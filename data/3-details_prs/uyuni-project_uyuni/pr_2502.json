{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNzgyMjA2", "number": 2502, "title": "Uyuni configuration states (users/orgs/groups)", "bodyText": "What does this PR change?\nImplements: SUSE/spacewalk#9876\nCode based on other PR: #1621\nScope\nThis card is about producing:\n\nSalt execution and state modules to create/modify/delete:\n\nUsers (including setting their Roles)\n\nsetting permissions of Users on ServerGroups (by server group name)\nsetting permissions of Users on Channels (by channel label)\n\n\nOrgs (including Trusts)\n\nsetting channel permissions, including via Trusts\n\n\nServerGroups (including adding/removing clients to a group, ideally via compound targeting)\n\n\nan example SLS file using those states (with hardcoded usernames/passwords)\nan additional example SLS file leveraging pillar_ldap to sync LDAP users to an Uyuni Server\na Salt Formula that does the same as the example file\na Form definition for that Formula\ndocumentation, tests, Review meeting session with demo\n\nTo Do List\n\n open WIP PR\nEnteties\nUsers (with roles)\n\n Salt Execution Module\n Salt Sate Module\n Manual test\n Unit testing\nUser permission on System Groups (by server group name)\n\n Salt Execution Module\n Salt Sate Module\n Manual test\n Unit testing\n\n\nChannels permissions (by channel label)\n\n Salt Execution Module\n Salt Sate Module\n Manual test\n Unit testing\n\n\n\n\nOrganization\n\nCreate\n\n Salt Execution Module\n Salt Sate Module\n Manual test\n Unit testing\n\n\nTrust (by org name)\n\n Salt Execution Module\n Salt Sate Module\n Manual test\n Unit testing\n\n\n\n\nSystem Groups\n\n Salt Execution Module\n Salt Sate Module\n Manual test\n Unit testing\n\n\n\n\n\n write first example SLS file (input data to be hardcoded)\n\n test manually\n\n\n write pillar_ldap-based example SLS file (SUSE/spacewalk#11984)\n\n test manually with a proper LDAP environment\n\n\n write Formula (SUSE/spacewalk#11986)\n\n write sls base example\n test manually with a proper LDAP environment\n\n\n add Cucumber tests (no LDAP). Make sure new tests are green in our CI\n open documentation PR (all execution and state modules to be fully described with names, parameters, etc., pointers to examples to be added)\n change specfiles if needed\n deliver demo in Review meeting\n\nDefinition of Done: Uyuni PR is merged, documentation PR is open, all tests pass, demo is delivered.\nGUI diff\nNo difference.\nBefore:\nAfter:\n\n DONE\n\nDocumentation\n\n\nNo documentation needed: add explanation. This can't be used if there is a GUI diff\n\n\nDocumentation issue was created: Link for SUSE Manager contributors, Link for community contributors.\n\n\n(OPTIONAL) Documentation PR\n\n\n DONE\n\n\nTest coverage\n\n\nNo tests: add explanation\n\n\nUnit tests were added\n\n\nCucumber tests were added\n\n\n DONE\n\n\nLinks\nFixes #\nTracks # add downstream PR, if any\n\n DONE\n\nChangelogs\nIf you don't need a changelog check, please mark this checkbox:\n\n No changelog needed\n\nIf you uncheck the checkbox after the PR is created, you will need to re-run changelog_test (see below)\nRe-run a test\nIf you need to re-run a test, please mark the related checkbox, it will be unchecked automatically once it has re-run:\n\n Re-run test \"changelog_test\"\n Re-run test \"backend_unittests_pgsql\"\n Re-run test \"java_lint_checkstyle\"\n Re-run test \"java_pgsql_tests\"\n Re-run test \"ruby_rubocop\"\n Re-run test \"schema_migration_test_oracle\"\n Re-run test \"schema_migration_test_pgsql\"\n Re-run test \"susemanager_unittests\"\n Re-run test \"javascript_lint\"\n Re-run test \"spacecmd_unittests\"", "createdAt": "2020-08-20T09:24:19Z", "url": "https://github.com/uyuni-project/uyuni/pull/2502", "merged": true, "mergeCommit": {"oid": "feab5a1d9861b43cdc2d9767fe56fe2ce63e9901"}, "closed": true, "closedAt": "2020-09-09T11:43:55Z", "author": {"login": "moio"}, "timelineItems": {"totalCount": 123, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHKhr6gH2gAyNDcwNzgyMjA2OmU3OGU4MGZjNjMzZGU2MGI2ZDQ2NTAwNTllZmMzOWE1ZmNiMDRkM2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHKiHQgBqjM3NDUzNjE0MzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e78e80fc633de60b6d4650059efc39a5fcb04d3e", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e78e80fc633de60b6d4650059efc39a5fcb04d3e", "committedDate": "2020-09-09T11:30:33Z", "message": "rename state and modules files to uyuni_config.py\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8422e73b5a9d7cd44ea2a40b84e1afcf8ee2725", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e8422e73b5a9d7cd44ea2a40b84e1afcf8ee2725", "committedDate": "2020-09-09T11:30:33Z", "message": "rename example file to match state name\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e29b4f176d6a3b50d6b5b594479bf8bf74e4b409", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e29b4f176d6a3b50d6b5b594479bf8bf74e4b409", "committedDate": "2020-09-09T11:30:33Z", "message": "code review #1\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea4d57ccb7cf48ae8d17f9d927eadceca315089c", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ea4d57ccb7cf48ae8d17f9d927eadceca315089c", "committedDate": "2020-09-09T11:30:34Z", "message": "code review #3\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea273dd02f95e6864ba4d41dd03c521aa8bcf9a9", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ea273dd02f95e6864ba4d41dd03c521aa8bcf9a9", "committedDate": "2020-09-09T11:30:34Z", "message": "rename expression to target and remove dead code\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a38082e7760c7c3b5e59eeba34077b800993bb1a", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a38082e7760c7c3b5e59eeba34077b800993bb1a", "committedDate": "2020-09-09T11:30:34Z", "message": "remove unnecessary log lines\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4bd1506ee43b4680c4bbce135995a324e89db1b", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f4bd1506ee43b4680c4bbce135995a324e89db1b", "committedDate": "2020-09-09T11:30:34Z", "message": "rename org to organizations\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89fdff4b25b64b7c5bc97a9900b81f011baa3c38", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/89fdff4b25b64b7c5bc97a9900b81f011baa3c38", "committedDate": "2020-09-09T11:30:34Z", "message": "rename uid to login\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c992d84c3e6fd3eb7d0375062d3fea698ec31bbd", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/c992d84c3e6fd3eb7d0375062d3fea698ec31bbd", "committedDate": "2020-09-09T11:30:34Z", "message": "covert to bool response helper method\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "197595cbba4dc4ee9e00c1a3f66a57a001b714f9", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/197595cbba4dc4ee9e00c1a3f66a57a001b714f9", "committedDate": "2020-09-09T11:30:34Z", "message": "new review round\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f74682e1cb5eb2ff1d2e4f55d1c0d7241bfe455", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4f74682e1cb5eb2ff1d2e4f55d1c0d7241bfe455", "committedDate": "2020-09-09T11:30:34Z", "message": "code review on methods documention\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "071e66d23f2cea1f0f99a6fd35f15967a63af5f0", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/071e66d23f2cea1f0f99a6fd35f15967a63af5f0", "committedDate": "2020-09-09T11:30:34Z", "message": "code review and format\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95f2cc2d4b5ee08a583aef50374016f077b0b71c", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/95f2cc2d4b5ee08a583aef50374016f077b0b71c", "committedDate": "2020-09-09T11:30:34Z", "message": "review cucumber tests\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06fde55cd97307997808a4e8611e646e7059f382", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/06fde55cd97307997808a4e8611e646e7059f382", "committedDate": "2020-09-09T11:30:34Z", "message": "review on cucumber test\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b528e3e8e8a9727922a867ef9b891b313fa9d892", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b528e3e8e8a9727922a867ef9b891b313fa9d892", "committedDate": "2020-09-09T11:30:34Z", "message": "remove new line 1\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96c9d7e410ab8f64b679bc4da64009e2ae31759f", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/96c9d7e410ab8f64b679bc4da64009e2ae31759f", "committedDate": "2020-09-09T11:30:34Z", "message": "add missing documentation\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2082f587a1626f93776e70fa3744135dfcfc2919", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2082f587a1626f93776e70fa3744135dfcfc2919", "committedDate": "2020-09-09T11:30:34Z", "message": "Allow connections to the FQDN, not just localhost"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beece77a709fe57927b2ff62be91c8a29656f067", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/beece77a709fe57927b2ff62be91c8a29656f067", "committedDate": "2020-09-09T11:30:34Z", "message": "rename example ldap file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01480e4ff40fd9bef8979c26faa46619413546e6", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/01480e4ff40fd9bef8979c26faa46619413546e6", "committedDate": "2020-09-09T11:30:34Z", "message": "general readme"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1943b8a7d4571c78a24a7c38870c429118807ee8", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1943b8a7d4571c78a24a7c38870c429118807ee8", "committedDate": "2020-09-09T11:30:34Z", "message": "remove module-specific instructions from general readme"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3acaf5d3bc3992b4f3d41581bd877bf73059d9f8", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3acaf5d3bc3992b4f3d41581bd877bf73059d9f8", "committedDate": "2020-09-09T11:30:34Z", "message": "spec: also install docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b88fc9616f9be2d23fb51af7998d534972f77afe", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b88fc9616f9be2d23fb51af7998d534972f77afe", "committedDate": "2020-09-09T11:30:34Z", "message": "newline fixed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15d65a3af7c6d260a11aa136305412068a2ca763", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/15d65a3af7c6d260a11aa136305412068a2ca763", "committedDate": "2020-09-09T11:30:34Z", "message": "tests: expect updated strings"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "070b2a9bb213b83261e2ff23376ccc23394f9a7f", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/070b2a9bb213b83261e2ff23376ccc23394f9a7f", "committedDate": "2020-09-09T09:48:01Z", "message": "newline fixed"}, "afterCommit": {"oid": "15d65a3af7c6d260a11aa136305412068a2ca763", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/15d65a3af7c6d260a11aa136305412068a2ca763", "committedDate": "2020-09-09T11:30:34Z", "message": "tests: expect updated strings"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7208512dd8f94b69085aef5aa975926715298fab", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7208512dd8f94b69085aef5aa975926715298fab", "committedDate": "2020-08-20T09:21:00Z", "message": "WIP: deliver in subpackage"}, "afterCommit": {"oid": "eaf6ae19fc34d2f589b9c7df006a86797fd3c1f1", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/eaf6ae19fc34d2f589b9c7df006a86797fd3c1f1", "committedDate": "2020-08-20T13:33:12Z", "message": "Deliver module in subpackage\n\nTest code also had to be adapted to run inside of the RPM build as well."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eaf6ae19fc34d2f589b9c7df006a86797fd3c1f1", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/eaf6ae19fc34d2f589b9c7df006a86797fd3c1f1", "committedDate": "2020-08-20T13:33:12Z", "message": "Deliver module in subpackage\n\nTest code also had to be adapted to run inside of the RPM build as well."}, "afterCommit": {"oid": "b5f883e8e19e03abdc8198428f269951b45d2056", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b5f883e8e19e03abdc8198428f269951b45d2056", "committedDate": "2020-08-20T13:38:23Z", "message": "Deliver module in subpackage\n\nTest code also had to be adapted to run inside of the RPM build as well."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e18b554fc7c6c467afef8db6a1ae2f81783e144f", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e18b554fc7c6c467afef8db6a1ae2f81783e144f", "committedDate": "2020-08-21T16:34:38Z", "message": "rename state and modules files to uyuni_config.py\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}, "afterCommit": {"oid": "4a186d1a535b6546f36a0ba9f9c3013baedaf553", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4a186d1a535b6546f36a0ba9f9c3013baedaf553", "committedDate": "2020-08-21T16:44:09Z", "message": "rename state and modules files to uyuni_config.py\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNDI3NDcw", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-473427470", "createdAt": "2020-08-24T12:45:43Z", "commit": {"oid": "4a186d1a535b6546f36a0ba9f9c3013baedaf553"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0NTo0M1rOHFinJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0NTo0M1rOHFinJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3MjAwNQ==", "bodyText": "@juliogonzalez is there any plan to rename susemanager-sls to uyuni-sls or anything else more \"neutral\"?\nHere we are creating a subpackage with \"susemanager\" in the name - but we could as well use a different name if you think it'd be more appropriate", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r475572005", "createdAt": "2020-08-24T12:45:43Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/susemanager-sls.spec", "diffHunk": "@@ -47,6 +47,14 @@ BuildArch:      noarch\n Static Salt state files for SUSE Manager, where generic operations are\n provided for the integration between infrastructure components.\n \n+%package -n susemanager-config-modules", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a186d1a535b6546f36a0ba9f9c3013baedaf553"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ecd1be7ba0e31dc8400de127f546419d4309d232", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ecd1be7ba0e31dc8400de127f546419d4309d232", "committedDate": "2020-08-25T10:43:32Z", "message": "review at cucumber test\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}, "afterCommit": {"oid": "2bd9e626480e6cff9f54c28b553af37f57889df4", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2bd9e626480e6cff9f54c28b553af37f57889df4", "committedDate": "2020-08-25T11:34:31Z", "message": "review at cucumber test\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NjE3MjY1", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-474617265", "createdAt": "2020-08-25T15:49:31Z", "commit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo0OTozMVrOHGefbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDozOTo1NVrOHGo5ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MzA2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  email: admin@org.com\n          \n          \n            \n                  email: admin@org.com", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476553069", "createdAt": "2020-08-25T15:49:31Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/examples/ldap/orgs.sls", "diffHunk": "@@ -0,0 +1,8 @@\n+uyuni:\n+  orgs:\n+    - org_id: MY-ORG\n+      org_admin_user: org_admin_user\n+      org_admin_password: org_admin_pass\n+      first_name: admin\n+      last_name: admin\n+      email: admin@org.com", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4MzE0Mg==", "bodyText": "I am not completely convinced of the parameter name choice here (expression and target) - I was reviewing SUSE/salt-formulas#69 and the principle-of-least-surprise hit me.\nAccording to the closest user-runnable module I could find, the match module, what we call expression here is called target, tgt or lookup - the name used in verbose documentation is target and that's also true for the commandline interface:\nUsage: salt [options] '<target>' <function> [arguments]\n\nI would thus recommend replacing expression with target here, in all callees and callers (including SUSE/salt-formulas#69).\nThat opens up another problem, which is how to rename the current parameter called target. Browsing upstream code the name I could see more often is tgt_type, so I'd recommend target_type here to be consistent with the former parameter.\nAlternatively we could use the compact names (tgt/tgt_type) which are overall more common in internal code but perhaps a bit less readable.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476583142", "createdAt": "2020-08-25T16:33:53Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(matching: str, target: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](matching, target)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, expression: str, target: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param expression: expression used to filter which minions should be part of the group\n+        :param target: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2201:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+            pass\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(expression, target,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == 2201:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2850:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == 2850:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Insure user is present with all his characteristics\n+\n+    :param name: user ID\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Insure user is present with all his characteristics\n+\n+    :param name: user ID\n+    :param password: user password\n+    :param manageable_channels: channels user can manage\n+    :param subscribable_channels: channels user can subscribe\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUserChannels().manage(name, password,\n+                                      manageable_channels, subscribable_channels,\n+                                      org_admin_user, org_admin_password)\n+\n+\n+def user_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+\n+    :param name: user id\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return:\n+    \"\"\"\n+    return UyuniUsers().delete(name, org_admin_user, org_admin_password)\n+\n+\n+def org_present(name, org_admin_user, org_admin_password,\n+                first_name, last_name, email, pam=False,\n+                admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create or update uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param pam: organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().manage(name, org_admin_user, org_admin_password, first_name,\n+                              last_name, email, pam,\n+                              admin_user, admin_password)\n+\n+\n+def org_absent(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().delete(name, admin_user, admin_password)\n+\n+\n+def org_trust(name, org_name, trusts, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add trusted organisations from a organization.\n+    :param name: state name\n+    :param org_name: Organization name\n+    :param trusts: list of organization names to trust\n+    :param admin_user: administrator username\n+    :param admin_password: administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgsTrust().trust(name, org_name, trusts, admin_user, admin_password)\n+\n+\n+def group_present(name, description, expression=None, target=\"glob\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 729}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4ODU2MA==", "bodyText": "I'd suggest moving this section in documentation lines of both the state and the execution modules, so that it becomes a \"preamble\" such as the notices here:\nhttps://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.yumpkg.html#salt.modules.yumpkg.clean_metadata\n(rationale: this README file will not be packaged so it will not be visible by end users)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476588560", "createdAt": "2020-08-25T16:42:43Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/README.md", "diffHunk": "@@ -18,3 +18,60 @@ Don't mind `.cache` and `__pycache__` directories,\n they are ignored in an explicit `.gitignore`.\n \n Have fun. :)\n+\n+## Run Unit tests \n+\n+Use the following command to run unit test \n+`make -f Makefile.python docker_pytest`\n+\n+## Uyuni users state modules\n+\n+### Pillar data structure global Admin User\n+\n+Pillar data to configure suse manager admin user and password:\n+```\n+uyuni:\n+  xmlrpc:\n+    user: admin\n+    password: admin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwNDk3Nw==", "bodyText": "I would suggest adding a comment to explain what this particular fault is about (or extract the constant with an intelligible name)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476704977", "createdAt": "2020-08-25T20:03:19Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(matching: str, target: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](matching, target)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, expression: str, target: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param expression: expression used to filter which minions should be part of the group\n+        :param target: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2201:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+            pass\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(expression, target,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == 2201:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2850:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwOTg2Mw==", "bodyText": "Is it correct to say that this mechanism to provide username and password via pillar instead of parameters is a convenience option not to have to repeat them at many places in one's SLS file?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476709863", "createdAt": "2020-08-25T20:13:08Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxMTY4OQ==", "bodyText": "I would suggest adding a comment to explain what this particular fault is about (or extract the constant with an intelligible name)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476711689", "createdAt": "2020-08-25T20:16:42Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxMjIwMg==", "bodyText": "I would suggest adding a comment to explain what this particular fault is about (or extract the constant with an intelligible name)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476712202", "createdAt": "2020-08-25T20:17:47Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(matching: str, target: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](matching, target)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, expression: str, target: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param expression: expression used to filter which minions should be part of the group\n+        :param target: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2201:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxMjQwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pass\n          \n      \n    \n    \n  \n\nI guess this statement is superfluous now", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476712407", "createdAt": "2020-08-25T20:18:15Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(matching: str, target: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](matching, target)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, expression: str, target: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param expression: expression used to filter which minions should be part of the group\n+        :param target: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2201:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+            pass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxMjcxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pass\n          \n      \n    \n    \n  \n\nI guess this statement is superfluous now", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476712717", "createdAt": "2020-08-25T20:18:56Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxNDM5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Insure user is present with all his characteristics\n          \n          \n            \n                Ensure a user is present with all specified properties", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476714398", "createdAt": "2020-08-25T20:22:13Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(matching: str, target: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](matching, target)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, expression: str, target: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param expression: expression used to filter which minions should be part of the group\n+        :param target: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2201:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+            pass\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(expression, target,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == 2201:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2850:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == 2850:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Insure user is present with all his characteristics", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 631}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxNTUxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Insure user is present with all his characteristics\n          \n          \n            \n                Ensure a user has access to the specified channels", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476715515", "createdAt": "2020-08-25T20:24:25Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(matching: str, target: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](matching, target)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, expression: str, target: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param expression: expression used to filter which minions should be part of the group\n+        :param target: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2201:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+            pass\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(expression, target,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == 2201:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != 2850:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == 2850:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Insure user is present with all his characteristics\n+\n+    :param name: user ID\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Insure user is present with all his characteristics", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 654}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxOTQ1OA==", "bodyText": "I think these lines can be removed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Available states \n          \n          \n            \n            \n          \n          \n            \n            Check methods in file `states/uyuni_config.py`", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476719458", "createdAt": "2020-08-25T20:31:52Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/README.md", "diffHunk": "@@ -18,3 +18,60 @@ Don't mind `.cache` and `__pycache__` directories,\n they are ignored in an explicit `.gitignore`.\n \n Have fun. :)\n+\n+## Run Unit tests \n+\n+Use the following command to run unit test \n+`make -f Makefile.python docker_pytest`\n+\n+## Uyuni users state modules\n+\n+### Pillar data structure global Admin User\n+\n+Pillar data to configure suse manager admin user and password:\n+```\n+uyuni:\n+  xmlrpc:\n+    user: admin\n+    password: admin\n+```\n+\n+### Available states \n+\n+Check methods in file `states/uyuni_config.py` \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcyMzU5NA==", "bodyText": "My problem with the -sls part is that SLS is the (typical) filename extension to Salt states, which is not really the content of this package (which is about modules, written in Python top to bottom).\nSo really this is a misnomer for the whole susemanager-sls package - it used to contain SLS files alone, but has modules since more than a while. And the subpackage under discussion ships modules exclusively and no SLS files (if we exclude examples for documentation purposes).\nSo I'd suggest going with the currently proposed name unless there are reasons I am not taking into account...", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476723594", "createdAt": "2020-08-25T20:39:55Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/susemanager-sls.spec", "diffHunk": "@@ -47,6 +47,14 @@ BuildArch:      noarch\n Static Salt state files for SUSE Manager, where generic operations are\n provided for the integration between infrastructure components.\n \n+%package -n susemanager-config-modules", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3MjAwNQ=="}, "originalCommit": {"oid": "4a186d1a535b6546f36a0ba9f9c3013baedaf553"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTI3MTg4", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-474927188", "createdAt": "2020-08-25T21:30:14Z", "commit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMTozMDoxNVrOHGqvrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMTozMDoxNVrOHGqvrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc1MzgzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              - ldap-users\n          \n          \n            \n              - ldap-users", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r476753839", "createdAt": "2020-08-25T21:30:15Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/examples/ldap/pillar_ldap.yaml", "diffHunk": "@@ -0,0 +1,31 @@\n+ldap-roles:\n+  server:    ldap.example.com\n+  port:      389\n+  anonymous: true\n+  mode:      map\n+  dn:        ou=permissions,dc=example,dc=com\n+  filter:    '(objectclass=groupOfNames)'\n+  attrs:\n+    - cn\n+    - dn\n+\n+ldap-users:\n+  server:    ldap.example.com\n+  port:      389\n+  anonymous: true\n+  mode:      map\n+  dn:        ou=people,dc=example,dc=com\n+  filter:    '(objectclass=person)'\n+  attrs:\n+    - givenName\n+    - sn\n+    - mail\n+    - uid\n+    - ou\n+    - dn\n+  lists:\n+    - memberOf\n+\n+search_order:\n+  - ldap-roles\n+  - ldap-users", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138376e6ca66909f86691d9f07f3937703b6373"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MjMzMjc5", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-475233279", "createdAt": "2020-08-26T07:45:53Z", "commit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNzo0NTo1NFrOHG_59A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDowMjoxMlrOHHFE5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwMDUzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                - org_admin_password: admin\n          \n          \n            \n                - org_admin_password: admin", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477100532", "createdAt": "2020-08-26T07:45:54Z", "author": {"login": "moio"}, "path": "testsuite/features/upload_files/salt/teardown_users_configuration.sls", "diffHunk": "@@ -0,0 +1,23 @@\n+my_org_remove:\n+  uyuni.org_absent:\n+    - name: my_org\n+    - admin_user: admin\n+    - admin_password: admin\n+\n+my_org2_remove:\n+  uyuni.org_absent:\n+    - name: my_org2\n+    - admin_user: admin\n+    - admin_password: admin\n+\n+minions_group_absent:\n+  uyuni.group_absent:\n+    - name: minions_group\n+    - org_admin_user: admin\n+    - org_admin_password: admin\n+\n+user2_absent:\n+  uyuni.user_absent:\n+    - name: user2\n+    - org_admin_user: admin\n+    - org_admin_password: admin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNjIxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            end\n          \n          \n            \n            end", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477106214", "createdAt": "2020-08-26T07:55:32Z", "author": {"login": "moio"}, "path": "testsuite/features/step_definitions/command_steps.rb", "diffHunk": "@@ -1313,3 +1313,12 @@\n   end\n   step %(I #{action} repository \"#{repo_name}\" on this \"#{host}\"#{error_control})\n end\n+\n+When(/^I apply \"([^\"]*)\" local salt state on \"([^\"]*)\"$/) do |state, host|\n+  node = get_target(host)\n+  source = File.dirname(__FILE__) + '/../upload_files/salt/' + state + '.sls'\n+  remote_file = '/usr/share/susemanager/salt/' + state + '.sls'\n+  return_code = file_inject(node, source, remote_file)\n+  raise 'File injection failed' unless return_code.zero?\n+  node.run('salt-call --local --file-root=/usr/share/susemanager/salt --module-dirs=/usr/share/susemanager/salt/ --log-level=info --retcode-passthrough --force-color state.apply ' + state)\n+end", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExNDMxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #    When I copy \"../upload_files/salt/teardown_configuration_states.sls\" to \"/usr/share/susemanager/salt/teardown_configuration_states.sls\" on \"server\"\n          \n          \n            \n            #    And I run \"salt-call --local --module-dirs=/usr/share/susemanager/salt --log-level=info --retcode-passthrough --force-color state.apply teardown_configuration_states\" on \"server\"\n          \n      \n    \n    \n  \n\nI guess those lines should be removed now?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477114310", "createdAt": "2020-08-26T08:09:13Z", "author": {"login": "moio"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organization, user and group using salt states\n+\n+  Scenario: Apply setup configure salt state to server\n+    When I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correct created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And  I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Apply teardown configure salt state to server\n+#    When I copy \"../upload_files/salt/teardown_configuration_states.sls\" to \"/usr/share/susemanager/salt/teardown_configuration_states.sls\" on \"server\"\n+#    And I run \"salt-call --local --module-dirs=/usr/share/susemanager/salt --log-level=info --retcode-passthrough --force-color state.apply teardown_configuration_states\" on \"server\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExOTM5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Feature: Create organization, user and group using salt states\n          \n          \n            \n            Feature: Create organizations, users and groups using salt states", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477119393", "createdAt": "2020-08-26T08:17:28Z", "author": {"login": "moio"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organization, user and group using salt states", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExOTczOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Scenario: Apply setup configure salt state to server\n          \n          \n            \n              Scenario: Apply configuration salt state to server", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477119739", "createdAt": "2020-08-26T08:18:05Z", "author": {"login": "moio"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organization, user and group using salt states\n+\n+  Scenario: Apply setup configure salt state to server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExOTk4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Scenario: Group was correct created\n          \n          \n            \n              Scenario: Group was correctly created", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477119985", "createdAt": "2020-08-26T08:18:29Z", "author": {"login": "moio"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organization, user and group using salt states\n+\n+  Scenario: Apply setup configure salt state to server\n+    When I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correct created", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEyMDQ0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Scenario: Apply teardown configure salt state to server\n          \n          \n            \n              Scenario: Apply configuration teardown salt state to server", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477120447", "createdAt": "2020-08-26T08:19:09Z", "author": {"login": "moio"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organization, user and group using salt states\n+\n+  Scenario: Apply setup configure salt state to server\n+    When I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correct created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And  I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Apply teardown configure salt state to server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c1f7afd04de9457824fba80f91a6e2b08a0b48d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE2MjM2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import pdb", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477162368", "createdAt": "2020-08-26T09:23:25Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdfed0fb6081b279676f7f60428802f44087a7fc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE2OTY2MA==", "bodyText": "I guess current_subscribed_channels could be a better name here?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477169660", "createdAt": "2020-08-26T09:35:29Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3MDQ0Nw==", "bodyText": "I guess a better name could be channel_software_is_globally_subscribable here?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477170447", "createdAt": "2020-08-26T09:36:47Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: list of user roles\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 966}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3MTEzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Returns whether the channel is globally subscribed on the organization\n          \n          \n            \n                Returns whether the channel is globally subscribable on the organization", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477171137", "createdAt": "2020-08-26T09:37:55Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: list of user roles\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 968}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3Mzk1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                            \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n          \n          \n            \n                                                            \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477173951", "createdAt": "2020-08-26T09:42:45Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3NDU2Mg==", "bodyText": "Do you mean \"channels are already in the desired state\" here?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477174562", "createdAt": "2020-08-26T09:43:47Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3NDg0MA==", "bodyText": "See above, I feel that \"installed\" is not the word we want here.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477174840", "createdAt": "2020-08-26T09:44:16Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4NDg5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n          \n          \n            \n                        return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477184890", "createdAt": "2020-08-26T10:01:34Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4NTI1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)\n          \n          \n            \n                    return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477185252", "createdAt": "2020-08-26T10:02:12Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == 2950:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            pass\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == -213:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == 2950:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_global_subscribable'](curr_channel,\n+                                                                                 org_admin_user,\n+                                                                                 org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"org channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels is already installed\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be installed\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing Channel management '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel management successful managed\", changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 309}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MzU2NTQ4", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-475356548", "createdAt": "2020-08-26T10:26:42Z", "commit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDoyNjo0MlrOHHF3eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTo0MzozM1rOHHINyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5ODIwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    # user fields changes\n          \n          \n            \n                    # user field changes", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477198202", "createdAt": "2020-08-26T10:26:42Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5ODM1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    # roles changes\n          \n          \n            \n                    # role changes", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477198357", "createdAt": "2020-08-26T10:26:58Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzNjY4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Manage user, insuring it is present with all his characteristics\n          \n          \n            \n                    Ensure a user is present with all specified properties", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477236683", "createdAt": "2020-08-26T11:43:33Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDExNTU4", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-475411558", "createdAt": "2020-08-26T11:51:55Z", "commit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "state": "COMMENTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTo1MTo1NVrOHHIeXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxMDo1MFrOHHLU0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0MDkyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Otherwise get an ew authentication token from xml rpc.\n          \n          \n            \n                    Otherwise get a new authentication token.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477240927", "createdAt": "2020-08-26T11:51:55Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0MTMyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    If refresh parameter where set to True, it will get a new token from the API\n          \n          \n            \n                    If refresh is True, get a new token from the API regardless of prior status.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477241324", "createdAt": "2020-08-26T11:52:41Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0MTU2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param refresh: force token to the refreshed, cached values\n          \n          \n            \n                    :param refresh: force token refresh, discarding any cached value", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477241562", "createdAt": "2020-08-26T11:53:11Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0NjMyMw==", "bodyText": "How likely is this to happen? Tokens by default take 1 hour to expire (it's configurable). Can we envision cases in which the application of the Salt state takes longer than that?\nDo we reuse tokens across salt or salt-call calls?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477246323", "createdAt": "2020-08-26T12:02:14Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0OTAzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Delete system group.\n          \n          \n            \n                Lists systems in a system group.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477249034", "createdAt": "2020-08-26T12:07:21Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: list of user roles\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).update(name=name, description=descr)\n+\n+\n+def systemgroup_delete(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).delete(name=name)\n+\n+\n+def systemgroup_list_systems(name, minimal=True, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 1181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1MTI1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Retrieve details of a ServerGroup.\n          \n          \n            \n                    Retrieve details of a system group.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477251250", "createdAt": "2020-08-26T12:11:18Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 514}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1MTc2MQ==", "bodyText": "What would break if we do not convert datetime objects into strings?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477251761", "createdAt": "2020-08-26T12:12:14Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 562}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1Mzc0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Get existing user data from the Uyuni.\n          \n          \n            \n                    Retrieve details of an Uyuni user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477253741", "createdAt": "2020-08-26T12:15:40Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1NDMwMw==", "bodyText": "I'd suggest renaming uid to login to make it apparent we are not talking about an ID but a name here.\nNote that there is many other places where this suggestion applies as well - they should probably be mass-renamed.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477254303", "createdAt": "2020-08-26T12:16:42Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1NDgwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Return all Uyuni users.\n          \n          \n            \n                    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n          \n          \n            \n                    This could be a sub-set of all existing users.\n          \n          \n            \n                    Return all Uyuni users visible to the authenticated user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477254800", "createdAt": "2020-08-26T12:17:34Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1NTgzMQ==", "bodyText": "I noticed that we have these log.debug lines immediately before self.client calls. Would it make more sense to just put a generic log.debug line inside of the client code, to log we are about to call an XMLRPC method, and remove those lines?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477255831", "createdAt": "2020-08-26T12:19:26Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1NjE2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Create user in Uyuni.\n          \n          \n            \n                    Create an Uyuni user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477256163", "createdAt": "2020-08-26T12:19:58Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1NjYyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param last_name: Second name\n          \n          \n            \n                    :param last_name: Last name", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477256625", "createdAt": "2020-08-26T12:20:45Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2MzE0NA==", "bodyText": "AFAIU wrapping responses with bool() like this is not what we want. XMLRPC calls typically return an integer to signal success with 1 as a value, so anything else is probably an error.\nbool() treats 0 as False and any other integer as True.\nWe should probably have a little helper method that explicitly checks for equality to 1, and check all bool() call sites in the PR.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477263144", "createdAt": "2020-08-26T12:31:54Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2NDkzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Update user information on Uyuni.\n          \n          \n            \n                    Update an Uyuni user information.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477264931", "createdAt": "2020-08-26T12:35:03Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2NTMzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param last_name: Second name\n          \n          \n            \n                    :param last_name: Last name", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477265339", "createdAt": "2020-08-26T12:35:47Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2NTUwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Remove user from the Uyuni.\n          \n          \n            \n                    Remove an Uyuni user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477265504", "createdAt": "2020-08-26T12:36:06Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NjcwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Get existing user data from the Uyuni.\n          \n          \n            \n                    Return the list of roles of a user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477276707", "createdAt": "2020-08-26T12:53:55Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NjkyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Add role to user\n          \n          \n            \n                    Add a role to a user", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477276929", "createdAt": "2020-08-26T12:54:14Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NzA4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param role: one of uyuni user roles\n          \n          \n            \n                    :param role: a new role", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477277080", "createdAt": "2020-08-26T12:54:31Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NzY1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Add system groups to user's list of assigned system groups.\n          \n          \n            \n                    Add system groups to a user's list of assigned system groups.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477277651", "createdAt": "2020-08-26T12:55:19Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3Nzg2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param server_group_names: systems groups to add to list of assigned system groups\n          \n          \n            \n                    :param server_group_names: system groups to add", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477277860", "createdAt": "2020-08-26T12:55:41Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3ODIzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param set_default: Should system groups also be added to user's list of default system groups.\n          \n          \n            \n                    :param set_default: True if the sytem groups should also be added to user's default list.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477278233", "createdAt": "2020-08-26T12:56:16Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3ODU3NA==", "bodyText": "I think we want to be consistent with the rest of Salt here and return True if execution is successful.\nThis also happens in several other places we might want to change as well.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477278574", "createdAt": "2020-08-26T12:56:48Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4MTM1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param set_default: Should system groups also be added to user's list of default system groups.\n          \n          \n            \n                    :param set_default: True if the system groups should also be removed to user's default list.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477281357", "createdAt": "2020-08-26T13:01:08Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4MjQ0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param access: Flag which if user should have management access to channel or not\n          \n          \n            \n                    :param access: True if the user should have management access to channel", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477282448", "createdAt": "2020-08-26T13:02:49Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4Mjc1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param access: Flag which if user should subscribe a channel or not\n          \n          \n            \n                    :param access: True if the user should have subscribe permission to the channel", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477282750", "createdAt": "2020-08-26T13:03:19Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NDc1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Returns whether the channel is globally subscribed on the organization\n          \n          \n            \n                    Returns whether the channel is globally subscribable on the organization", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477284758", "createdAt": "2020-08-26T13:06:25Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NjcyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :return: boolean which indicates if channel is globally subscribe\n          \n          \n            \n                    :return: boolean which indicates if channel is globally subscribable", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477286728", "createdAt": "2020-08-26T13:09:36Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NzYzMg==", "bodyText": "I'd suggest always using \"organizations\" in any user-facing material such as docs.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477287632", "createdAt": "2020-08-26T13:10:50Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 370}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDk1ODM2", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-475495836", "createdAt": "2020-08-26T13:37:14Z", "commit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzozNzoxNVrOHHMdHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzozNzoxNVrOHHMdHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMwNjE0MA==", "bodyText": "I would suggest\n    Note: the configured admin user must have the SUSE Manager/Uyuni Administrator role to perform this action\n\nThis line is also present with minor variants in many other places.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477306140", "createdAt": "2020-08-26T13:37:15Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 376}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDk4ODY4", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-475498868", "createdAt": "2020-08-26T13:40:25Z", "commit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "state": "COMMENTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzo0MDoyNlrOHHMmJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDoxNDo0N1rOHHONcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMwODQ1NA==", "bodyText": "Seems like parameters lack descriptions here", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477308454", "createdAt": "2020-08-26T13:40:26Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMwODcwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Delete Uyuni org.\n          \n          \n            \n                    Delete an Uyuni org.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477308708", "createdAt": "2020-08-26T13:40:43Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 413}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMwOTI1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Update Uyuni org name.\n          \n          \n            \n                    Update an Uyuni org name.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477309255", "createdAt": "2020-08-26T13:41:29Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMwOTc3Nw==", "bodyText": "Would it make sense to rename this method list_trusted_orgs?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477309777", "createdAt": "2020-08-26T13:42:09Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxMDMwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :return: list with all organization and if is trusted or not\n          \n          \n            \n                    :return: list with all organizations and their trust status", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477310304", "createdAt": "2020-08-26T13:42:53Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 453}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxMDU0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set organisation trusted\n          \n          \n            \n                    Set an organisation as trusted by another", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477310544", "createdAt": "2020-08-26T13:43:14Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 460}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxMDczOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param org_trust: organization to trust\n          \n          \n            \n                    :param org_trust: name of organization to trust", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477310738", "createdAt": "2020-08-26T13:43:30Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 464}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxMzk4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set organisation trusted.\n          \n          \n            \n                    Set an organisation as trusted by another", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477313988", "createdAt": "2020-08-26T13:47:41Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxNDMwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Remove organisation trusted.\n          \n          \n            \n                    Set an organisation as not trusted by another", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477314301", "createdAt": "2020-08-26T13:48:07Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 484}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxNDM4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Remove organisation trusted.\n          \n          \n            \n                    Set an organisation as not trusted by another", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477314387", "createdAt": "2020-08-26T13:48:13Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 497}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxNjE3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Get information from the system in the group.\n          \n          \n            \n                    Get information about systems in a group.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477316173", "createdAt": "2020-08-26T13:50:29Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 556}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxNjU3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param minimal: default True. Minimal information or more detailed one about systems\n          \n          \n            \n                    :param minimal: default True. Only return minimal information about systems, use False to get more details", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477316571", "createdAt": "2020-08-26T13:51:02Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 559}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxNzY0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Add or remove list of systems from the group\n          \n          \n            \n                    Add or remove systems from a system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477317645", "createdAt": "2020-08-26T13:52:20Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 567}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxODkxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Context cache can be used, to avoid multiple call to the server.\n          \n          \n            \n                    This method caches results, in order to avoid multiple XMLRPC calls.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477318915", "createdAt": "2020-08-26T13:53:56Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 582}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyMjYyMw==", "bodyText": "fp seems to never be used. If there is no good reason to keep it, I would suggest dropping it", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477322623", "createdAt": "2020-08-26T13:58:25Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: list of user roles\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).update(name=name, description=descr)\n+\n+\n+def systemgroup_delete(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).delete(name=name)\n+\n+\n+def systemgroup_list_systems(name, minimal=True, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+\n+    :return: List of system information\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).list_systems(name=name, minimal=minimal)\n+\n+\n+def systemgroup_add_remove_systems(name, add_remove, system_ids=[],\n+                                   org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param add_remove: True to add to the group, False to remove.\n+    :param system_ids: list of system ids to add/remove from group\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).add_remove_systems(name=name, add_remove=add_remove,\n+                                                                                   system_ids=system_ids)\n+\n+\n+def master_select_minions(expr=None, tgt=\"glob\", fp=False):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 1207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyNDU5OA==", "bodyText": "This method also seems only to be used by master_select_minions under the circumstance fp is True, but that's never the case. So this method seems to be dead code as well.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477324598", "createdAt": "2020-08-26T14:00:53Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 675}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyNTAyNA==", "bodyText": "This method seems never to be used, I would suggest to remove it.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477325024", "createdAt": "2020-08-26T14:01:27Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 654}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyNTQ0OA==", "bodyText": "This method only seems to be called by methods never used or dead code anyway.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477325448", "createdAt": "2020-08-26T14:02:04Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 615}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyNjAwOQ==", "bodyText": "This method only seems to be called by _get_fingerprints, which seems to be dead code.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477326009", "createdAt": "2020-08-26T14:02:51Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 605}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyNzAzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Return list of currently registered minions.\n          \n          \n            \n                    Returns currently registered minions.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477327039", "createdAt": "2020-08-26T14:04:20Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMzMzY0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param active: Return only active minions.\n          \n          \n            \n                    :param active: Return only active minions. Default False.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477333648", "createdAt": "2020-08-26T14:13:06Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 649}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMzNDg5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Provide Uyuni Users state module.\n          \n          \n            \n                Provide Uyuni configuration state module.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477334898", "createdAt": "2020-08-26T14:14:47Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1247 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a704c4bd768830e69618c41dada9c5279af48de0"}, "originalPosition": 697}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NTM1Nzg4", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-475535788", "createdAt": "2020-08-26T14:17:29Z", "commit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "state": "COMMENTED", "comments": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDoxNzoyOVrOHHOV3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDo0Nzo0MFrOHHPvcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMzNzA1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Get user in Uyuni.\n          \n          \n            \n                Get details of an Uyuni user", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477337053", "createdAt": "2020-08-26T14:17:29Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 707}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMzNzY1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                If user password is provided name and password fields are use to authenticate\n          \n          \n            \n                If password is provided as a parameter, then it will be used to authenticate", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477337656", "createdAt": "2020-08-26T14:18:17Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 708}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0MTA3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Return all Uyuni users.\n          \n          \n            \n                Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n          \n          \n            \n                This could be a sub-set of all existing users.\n          \n          \n            \n                Return all Uyuni users visible to the authenticated user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477341075", "createdAt": "2020-08-26T14:22:51Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 726}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0MTI3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Create user in Uyuni.\n          \n          \n            \n                Create an Uyuni user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477341271", "createdAt": "2020-08-26T14:23:10Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 738}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0Mzg3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Update user in Uyuni.\n          \n          \n            \n                Update an Uyuni user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477343877", "createdAt": "2020-08-26T14:26:27Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 760}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NDczNg==", "bodyText": "I would suggest:\n    :return: boolean, True indicates success\n\nNote that there are other occurrences as well.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477344736", "createdAt": "2020-08-26T14:27:33Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 750}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NTQ4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Create user in Uyuni.\n          \n          \n            \n                Deletes an Uyuni user", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477345485", "createdAt": "2020-08-26T14:28:32Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 778}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NTc4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Get user roles in Uyuni.\n          \n          \n            \n                Returns an Uyuni user roles.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477345783", "createdAt": "2020-08-26T14:28:56Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 791}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NjIyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                If user password is provided name and password fields are use to authenticate\n          \n          \n            \n                If password is provided as a parameter, then it will be used to authenticate", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477346222", "createdAt": "2020-08-26T14:29:31Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 792}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NjU2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Add role to user in Uyuni.\n          \n          \n            \n                Adds a role to an Uyuni user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477346561", "createdAt": "2020-08-26T14:29:57Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 808}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NjkxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Remove role to user in Uyuni.\n          \n          \n            \n                Remove a role from an Uyuni user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477346919", "createdAt": "2020-08-26T14:30:21Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 822}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NzU0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                List with all of manageable channels for the authenticated user\n          \n          \n            \n                List all of manageable channels for the authenticated user", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477347544", "createdAt": "2020-08-26T14:31:09Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 889}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NzY4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                List with all of subscribed channels for the authenticated user\n          \n          \n            \n                List all of subscribed channels for the authenticated user", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477347685", "createdAt": "2020-08-26T14:31:21Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 899}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0ODI3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :param access: Flag which if user should have access to channel or not\n          \n          \n            \n                :param access: True if the user should have management access to channel", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477348279", "createdAt": "2020-08-26T14:32:09Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 916}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0ODUzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :param access: Flag which if user should subscribe a channel or not\n          \n          \n            \n                :param access: True if the user should have subscribe access to channel", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477348536", "createdAt": "2020-08-26T14:32:31Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 933}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0OTA3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Returns whether the channel may be managed by the given user.\n          \n          \n            \n                Returns whether the channel may be subscribed by the given user.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477349075", "createdAt": "2020-08-26T14:33:15Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 956}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0OTcxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                List all existing org.\n          \n          \n            \n                List all organizations.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477349716", "createdAt": "2020-08-26T14:34:07Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 981}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0OTk4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Get org details\n          \n          \n            \n                Get details of an organization.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477349989", "createdAt": "2020-08-26T14:34:29Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 990}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MDA5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Delete org\n          \n          \n            \n                Delete an organization", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477350095", "createdAt": "2020-08-26T14:34:41Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1002}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MDI4Nw==", "bodyText": "Seems like parameter descriptions are missing here", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477350287", "createdAt": "2020-08-26T14:34:56Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1007}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MDU3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Create org in Uyuni.\n          \n          \n            \n                Create an Uyuni organization", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477350570", "createdAt": "2020-08-26T14:35:15Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1015}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MTYyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                update Uyuni organization name\n          \n          \n            \n                Update an Uyuni organization name", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477351629", "createdAt": "2020-08-26T14:36:41Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1037}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MTgwOA==", "bodyText": "Parameters lack descriptions here", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477351808", "createdAt": "2020-08-26T14:36:55Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1042}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MjU3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :return: list of all organizations with the trust flag value\n          \n          \n            \n                :return: list with all organizations and their trust status", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477352576", "createdAt": "2020-08-26T14:37:54Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1064}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1Mjk0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Remove an organization to the list of trusted organizations.\n          \n          \n            \n                Remove an organization from the list of trusted organizations.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477352948", "createdAt": "2020-08-26T14:38:24Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1097}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MzExNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Remove an organization to the list of trusted organizations.\n          \n          \n            \n                Remove an organization from the list of trusted organizations.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477353115", "createdAt": "2020-08-26T14:38:38Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MzM3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Server groups management\n          \n          \n            \n            System group management", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477353372", "createdAt": "2020-08-26T14:38:58Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MzQ4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Create system group.\n          \n          \n            \n                Create a system group.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477353481", "createdAt": "2020-08-26T14:39:06Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MzcyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :return: server group structure.\n          \n          \n            \n                :return: details of the system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477353726", "createdAt": "2020-08-26T14:39:28Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1Mzg1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Get system group details.\n          \n          \n            \n                Return system group details.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477353850", "createdAt": "2020-08-26T14:39:37Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NDAwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :return: server group structure.\n          \n          \n            \n                :return: details of the system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477354007", "createdAt": "2020-08-26T14:39:52Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NDA3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :return: server group structure.\n          \n          \n            \n                :return: details of the system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477354072", "createdAt": "2020-08-26T14:39:56Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NDQ5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Update system group.\n          \n          \n            \n                Update a system group.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477354491", "createdAt": "2020-08-26T14:40:27Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NDYyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Delete system group.\n          \n          \n            \n                Delete a system group.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477354627", "createdAt": "2020-08-26T14:40:37Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).update(name=name, description=descr)\n+\n+\n+def systemgroup_delete(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NDg1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                List system on system group\n          \n          \n            \n                List systems in a system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477354855", "createdAt": "2020-08-26T14:40:57Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).update(name=name, description=descr)\n+\n+\n+def systemgroup_delete(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).delete(name=name)\n+\n+\n+def systemgroup_list_systems(name, minimal=True, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    List system on system group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NTIzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :param minimal: default True. Minimal information or more detailed one about systems\n          \n          \n            \n                :param minimal: default True. Only return minimal information about systems, use False to get more details", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477355236", "createdAt": "2020-08-26T14:41:28Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).update(name=name, description=descr)\n+\n+\n+def systemgroup_delete(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).delete(name=name)\n+\n+\n+def systemgroup_list_systems(name, minimal=True, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    List system on system group\n+\n+    :param name: Name of the system group.\n+    :param minimal: default True. Minimal information or more detailed one about systems", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NTUzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Delete system group.\n          \n          \n            \n                Delete a system group.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477355534", "createdAt": "2020-08-26T14:41:53Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).update(name=name, description=descr)\n+\n+\n+def systemgroup_delete(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).delete(name=name)\n+\n+\n+def systemgroup_list_systems(name, minimal=True, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    List system on system group\n+\n+    :param name: Name of the system group.\n+    :param minimal: default True. Minimal information or more detailed one about systems\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: List of system information\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).list_systems(name=name, minimal=minimal)\n+\n+\n+def systemgroup_add_remove_systems(name, add_remove, system_ids=[],\n+                                   org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1NzE0NQ==", "bodyText": "It seems like the active parameter is never actually used, I'd propose to drop it.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477357145", "createdAt": "2020-08-26T14:43:58Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 645}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1OTEzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Map between minion ID and system internal ID of all system user have access to\n          \n          \n            \n                Returns a map from minion ID to Uyuni system ID for all systems a user has access to", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477359133", "createdAt": "2020-08-26T14:46:35Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.\n+        Context cache can be used, to avoid multiple call to the server.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    class FCkMinions(CkMinions):\n+        \"\"\"\n+        Minion data matcher.\n+        \"\"\"\n+\n+        def _get_key_fingerprint(self, minion_id: str) -> str:\n+            \"\"\"\n+            Get minion key fingerprint.\n+\n+            :param minion_id:\n+            :return: fingerprint or an empty string if not found\n+            \"\"\"\n+            keypath = os.path.join(self.opts['pki_dir'], self.acc, minion_id)\n+            return salt.utils.crypt.pem_finger(path=keypath, sum_type=self.opts[\"hash_type\"])\n+\n+        def _get_fingerprints(self, minion_ids: List[str]) -> Dict[str, str]:\n+            \"\"\"\n+            Resolve all fingerprints.\n+\n+            :param minion_ids:\n+            :return:\n+            \"\"\"\n+            minions = {}\n+            for mid in minion_ids:\n+                minions[mid] = self._get_key_fingerprint(minion_id=mid)\n+\n+            return minions\n+\n+    def __init__(self):\n+        self._minions = UyuniChildMasterIntegration.FCkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def list_minions(self, active: bool = False) -> List[str]:\n+        \"\"\"\n+        Return list of currently registered minions.\n+\n+        :param active: Return only active minions.\n+        :return: list of minion ids\n+        \"\"\"\n+        return self._minions.connected_ids() if active else self._minions._pki_minions()\n+\n+    def list_minions_fp(self, active: bool = False) -> Dict[str, str]:\n+        \"\"\"\n+        Return list of currently registered minions, including their key fingerprints.\n+\n+        :param active: Return only active minions.\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        return self._minions._get_fingerprints(self.list_minions(active=active))\n+\n+    def select_minions(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=expr, tgt_type=tgt)\n+\n+    def select_minions_fp(self, expr: str, tgt: str = \"glob\") -> Dict[str, Union[str, bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the expression.\n+\n+        :param expr: expression\n+        :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: mapping of minion ids to the fingerprints\n+        \"\"\"\n+        selected = self.select_minions(expr=expr, tgt=tgt)\n+        ret = {\n+            \"minions\": self._minions._get_fingerprints(selected[\"minions\"]),\n+            \"missing\": self._minions._get_fingerprints(selected[\"missing\"]),\n+            \"ssh_minions\": selected.get(\"ssh_minions\", False)\n+        }\n+\n+        return ret\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni Users state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users.\n+    Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+    This could be a sub-set of all existing users.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get user roles in Uyuni.\n+    If user password is provided name and password fields are use to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove role to user in Uyuni.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List with all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List with all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should have access to channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: Flag which if user should subscribe a channel or not\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_global_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribed on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_globally_subscribable(channel_label)\n+\n+\n+def org_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all existing org.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :return: list of all available orgs.\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).list_orgs()\n+\n+\n+def org_get_details(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Get org details\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).get_details(name)\n+\n+\n+def org_delete(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete org\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).delete(name)\n+\n+\n+def org_create(name, org_admin_user, org_admin_password, first_name, last_name, email,\n+               admin_prefix=\"Mr.\", pam=False, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create org in Uyuni.\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param admin_prefix: organization admin prefix\n+    :param pam:organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dictionary with org information\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).create(name=name, org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password,\n+                                                       first_name=first_name, last_name=last_name, email=email,\n+                                                       admin_prefix=admin_prefix, pam=pam)\n+\n+\n+def org_update_name(org_id, name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    update Uyuni organization name\n+    :param org_id:\n+    :param name:\n+    :param admin_user:\n+    :param admin_password:\n+    :return:\n+    \"\"\"\n+    return UyuniOrg(admin_user, admin_password).update_name(org_id, name)\n+\n+\n+def org_trust_list_orgs(admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all organanizations trusted by the authenticated user organization\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_orgs()\n+\n+\n+def org_trust_list_trusts(org_name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    List all trusts for one organization\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: Name of the organization to get the trusts\n+    :param admin_user: authentication user\n+    :param admin_password: authentication user password\n+    :return: list of all organizations with the trust flag value\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).list_trusts(org_name)\n+\n+\n+def org_trust_add_trust_by_name(org_name, org_trust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_trust: Trust organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust_by_name(org_name, org_trust)\n+\n+\n+def org_trust_add_trust(org_id, org_trust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: Organization id\n+    :param org_trust_id: Trust organization id\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).add_trust(org_id, org_trust_id)\n+\n+\n+def org_trust_remove_trust_by_name(org_name, org_untrust, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_name: organization name\n+    :param org_untrust: organization name to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust_by_name(org_name, org_untrust)\n+\n+\n+def org_trust_remove_trust(org_id, org_untrust_id, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Remove an organization to the list of trusted organizations.\n+    admin_user needs to have SUSE Manager Administrator role to perform this action\n+    :param org_id: orgnization id\n+    :param org_untrust_id: organizaton id to untrust\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return:\n+    \"\"\"\n+    return UyuniOrgTrust(admin_user, admin_password).remove_trust(org_id, org_untrust_id)\n+\n+\n+\"\"\"\n+Server groups management\n+\"\"\"\n+\n+\n+def systemgroup_create(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).create(name=name, description=descr)\n+\n+\n+def systemgroup_get_details(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get system group details.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).get_details(name=name)\n+\n+\n+def systemgroup_update(name, descr, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update system group.\n+\n+    :param name: Name of the system group.\n+    :param descr: Description of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: server group structure.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).update(name=name, description=descr)\n+\n+\n+def systemgroup_delete(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).delete(name=name)\n+\n+\n+def systemgroup_list_systems(name, minimal=True, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    List system on system group\n+\n+    :param name: Name of the system group.\n+    :param minimal: default True. Minimal information or more detailed one about systems\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: List of system information\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).list_systems(name=name, minimal=minimal)\n+\n+\n+def systemgroup_add_remove_systems(name, add_remove, system_ids=[],\n+                                   org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Delete system group.\n+\n+    :param name: Name of the system group.\n+    :param add_remove: True to add to the group, False to remove.\n+    :param system_ids: list of system ids to add/remove from group\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+\n+    :return: 1 on success, exception thrown otherwise.\n+    \"\"\"\n+    return UyuniSystemgroup(org_admin_user, org_admin_password).add_remove_systems(name=name, add_remove=add_remove,\n+                                                                                   system_ids=system_ids)\n+\n+\n+def master_select_minions(expr=None, tgt=\"glob\", fp=False):\n+    \"\"\"\n+    Return list minions from the configured Salt Master on the same host\n+    which match the expression on the defined target\n+\n+    :param expr: expression to filter minions\n+    :param tgt: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+    :param fp: Include fingerprints\n+\n+    :return: list of minion IDs\n+    \"\"\"\n+    cmi = UyuniChildMasterIntegration()\n+\n+    return (cmi.select_minions_fp if fp else cmi.select_minions)(expr=expr, tgt=tgt)\n+\n+\n+def master_list_minions(active=False):\n+    \"\"\"\n+    Return list of all available minions from the configured\n+        Salt Master on the same host.\n+\n+    :param active: Return only active minions.\n+\n+    :return: list of minion IDs\n+    \"\"\"\n+    cmi = UyuniChildMasterIntegration()\n+\n+    return cmi.list_minions(active=active)\n+\n+\n+def systems_get_minion_id_map(username=None, password=None, refresh=False):\n+    \"\"\"\n+    Map between minion ID and system internal ID of all system user have access to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 1244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1OTk4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map between minion ID and system internal ID of all system user have access to.\n          \n          \n            \n                    Returns a map from minion ID to Uyuni system ID for all systems a user has access to", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477359985", "createdAt": "2020-08-26T14:47:40Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1251 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get an ew authentication token from xml rpc.\n+        If refresh parameter where set to True, it will get a new token from the API\n+\n+        :param refresh: force token to the refreshed, cached values\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != 2950:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        log.debug(\"get user details: %s\", uid)\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users.\n+        Uyuni XML-RPC listUsers return all users that are visible for the authenticated user.\n+        This could be a sub-set of all existing users.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        log.debug(\"list existing users\")\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create user in Uyuni.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Adding user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update user information on Uyuni.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        log.debug(\"Updating user to Uyuni: %s\", uid)\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        log.debug(\"delete user: %s\", uid)\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Get existing user data from the Uyuni.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        log.debug(\"get user roles: %s\", uid)\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add role to user\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        log.debug(\"add role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        log.debug(\"remove role '%s' to user %s\", role, uid)\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        log.debug(\"list assigned system groups for user %s\", uid)\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to add to list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"add assigned system groups to user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: Should system groups also be added to user's list of default system groups.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"remove assign groups from user %s: %s\", uid, server_group_names)\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should have management access to channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change managing access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: Flag which if user should subscribe a channel or not\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"change subscription access to %s for user %s in channel %s\", access, uid, channel_label)\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can manage channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        log.debug(\"check if user %s can subscribe channel %s\", uid, channel_label)\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribed on the organization\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribe\n+        \"\"\"\n+        log.debug(\"check if channel globally Subscribable %s\", channel_label)\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+        :param name:\n+        :param org_admin_user:\n+        :param org_admin_password:\n+        :param first_name:\n+        :param last_name:\n+        :param email:\n+        :param admin_prefix:\n+        :param pam:\n+        :return: tuple of data and error/log message\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name:\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organization and if is trusted or not\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set organisation trusted\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Remove organisation trusted.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a ServerGroup.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Get details for group: %s\", name)\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"Create group: %s\", name)\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        log.debug(\"delete group: %s\", name)\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        log.debug(\"update group: %s\", name)\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information from the system in the group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Minimal information or more detailed one about systems\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove list of systems from the group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Map between minion ID and system internal ID of all system user have access to.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 581}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NTY4MjY2", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-475568266", "createdAt": "2020-08-26T14:49:24Z", "commit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDo0OToyNVrOHHP07g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDo0OToyNVrOHHP07g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM2MTM5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    :param last_name: Second name\n          \n          \n            \n                    :param last_name: Last name", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r477361390", "createdAt": "2020-08-26T14:49:25Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,757 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+import pdb\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user fields changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # roles changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == 2950:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage user, insuring it is present with all his characteristics\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49348a44f73d4acfda9d5c10c7326a9ad1abc71"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NzczNjk2", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476773696", "createdAt": "2020-08-27T14:24:31Z", "commit": {"oid": "d3d25ca2dcc6a1ec752b3f330a74769558a5fb2d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyNDozMVrOHIS0fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDoyNDozMVrOHIS0fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ1OTAwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pass", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478459006", "createdAt": "2020-08-27T14:24:31Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Second name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3d25ca2dcc6a1ec752b3f330a74769558a5fb2d"}, "originalPosition": 282}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2Nzg0NjMy", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476784632", "createdAt": "2020-08-27T14:35:29Z", "commit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozNToyOVrOHITU-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDozNToyOVrOHITU-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NzMyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :return: boolean which indicates if channel is globally subscribe\n          \n          \n            \n                :return: boolean which indicates if channel is globally subscribable", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478467323", "createdAt": "2020-08-27T14:35:29Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/modules/uyuni_config.py", "diffHunk": "@@ -0,0 +1,1156 @@\n+# coding: utf-8\n+from typing import Any, Dict, List, Optional, Union, Tuple\n+import ssl\n+import xmlrpc.client  # type: ignore\n+import logging\n+\n+import os\n+import salt.config\n+from salt.utils.minions import CkMinions\n+import datetime\n+\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__pillar__: Dict[str, Any] = {}\n+__context__: Dict[str, Any] = {}\n+__virtualname__: str = \"uyuni\"\n+\n+\n+class UyuniUsersException(Exception):\n+    \"\"\"\n+    Uyuni users Exception\n+    \"\"\"\n+\n+\n+class UyuniChannelsException(Exception):\n+    \"\"\"\n+    Uyuni channels Exception\n+    \"\"\"\n+\n+\n+class RPCClient:\n+    \"\"\"\n+    RPC Client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None, url: str = \"https://localhost/rpc/api\"):\n+        \"\"\"\n+        XML-RPC client interface.\n+\n+        :param user: username for the XML-RPC API endpoints\n+        :param password: password credentials for the XML-RPC API endpoints\n+        :param url: URL of the remote host\n+        \"\"\"\n+\n+        ctx: ssl.SSLContext = ssl.create_default_context()\n+        ctx.check_hostname = False\n+        ctx.verify_mode = ssl.CERT_NONE\n+        self.conn = xmlrpc.client.ServerProxy(url, context=ctx, use_datetime=True, use_builtin_types=True)\n+        if user is None or password is None:\n+            # if user or password not set, fallback to default user defined on pillar data\n+            if \"xmlrpc\" in (__pillar__ or {}).get(\"uyuni\", {}):\n+                rpc_conf = (__pillar__ or {})[\"uyuni\"][\"xmlrpc\"] or {}\n+                self._user: str = rpc_conf.get(\"user\", \"\")\n+                self._password: str = rpc_conf.get(\"password\", \"\")\n+            else:\n+                raise UyuniUsersException(\"Unable to find Pillar configuration for Uyuni XML-RPC API\")\n+        else:\n+            self._user: str = user\n+            self._password: str = password\n+\n+        self.token: Optional[str] = None\n+\n+    def get_user(self):\n+        return self._user\n+\n+    def get_token(self, refresh: bool = False) -> Optional[str]:\n+        \"\"\"\n+        Authenticate.\n+        If a authentication token is present on __context__ it will be returned\n+        Otherwise get a new authentication token from xml rpc.\n+        If refresh is True, get a new token from the API regardless of prior status.\n+\n+        :param refresh: force token refresh, discarding any cached value\n+        :return: authentication token\n+        \"\"\"\n+        if self.token is None or refresh:\n+            try:\n+                auth_token_key = \"uyuni.auth_token_\" + self._user\n+                if (not auth_token_key in __context__) or refresh:\n+                    __context__[auth_token_key] = self.conn.auth.login(self._user, self._password)\n+            except Exception as exc:\n+                log.error(\"Unable to login to the Uyuni server: %s\", exc)\n+                raise exc\n+            self.token = __context__[auth_token_key]\n+        return self.token\n+\n+    def __call__(self, method: str, *args, **kwargs) -> Any:\n+        self.get_token()\n+        if self.token is not None:\n+            try:\n+                log.debug(\"Calling RPC method %s\", method)\n+                return getattr(self.conn, method)(*((self.token,) + args))\n+            except Exception as exc:\n+                if exc.faultCode != AUTHENTICATION_ERROR:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+                \"\"\"\n+                Authentication error when using Token, it can have expired.\n+                Call a second time with a new session token\n+                \"\"\"\n+                log.warning(\"Fall back to the second try due to %s\", str(exc))\n+                try:\n+                    return getattr(self.conn, method)(*((self.get_token(refresh=True),) + args))\n+                except Exception as exc:\n+                    log.error(\"Unable to call RPC function: %s\", str(exc))\n+                    raise exc\n+\n+        raise UyuniUsersException(\"XML-RPC backend authentication error.\")\n+\n+\n+class UyuniRemoteObject:\n+    \"\"\"\n+    RPC client\n+    \"\"\"\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        self.client: RPCClient = RPCClient(user=user, password=password)\n+\n+    @staticmethod\n+    def _convert_datetime_str(response: Dict[str, Any]) -> Dict[str, Any]:\n+        \"\"\"\n+        modify any key-value pair where value is a datetime object to a string.\n+\n+        :param response: response dictionary to be processed\n+        :return: new dictionary with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return dict(\n+                [\n+                    (k, \"{0}\".format(v)) if isinstance(v, datetime.datetime) else (k, v)\n+                    for k, v in response.items()\n+                ]\n+            )\n+        return None\n+\n+    @staticmethod\n+    def _convert_datetime_list(response: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        modify any list of key-value pair where value is a datetime object to a string.\n+        :param response: list of dictionaries to be processed\n+        :return: List of new dictionaries with datetime objects converted to sting\n+        \"\"\"\n+        if response:\n+            return [UyuniRemoteObject._convert_datetime_str(value) for value in response]\n+        return None\n+\n+\n+class UyuniUser(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operation on users.\n+    \"\"\"\n+\n+    def get_details(self, uid: str) -> Dict[str, Any]:\n+        \"\"\"\n+        Retrieve details of an Uyuni user.\n+\n+        :param: uid: user name to lookup\n+        :return: Dictionary with user details\n+        \"\"\"\n+        return self.client(\"user.getDetails\", uid)\n+\n+    def list_users(self) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Return all Uyuni users visible to the authenticated user.\n+\n+        :return: all users visible to the authenticated user\n+        \"\"\"\n+        return self.client(\"user.listUsers\")\n+\n+    def create(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\",\n+               use_pam_auth: bool = False) -> bool:\n+        \"\"\"\n+        Create an Uyuni user.\n+        User will be created in the same organization as the authenticated user.\n+\n+        :param uid: desired login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        return bool(self.client(\"user.create\", uid, password, first_name, last_name, email, int(use_pam_auth)))\n+\n+    def set_details(self, uid: str, password: str, email: str, first_name: str = \"\", last_name: str = \"\") -> bool:\n+        \"\"\"\n+        Update an Uyuni user information.\n+\n+        :param uid: login name\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+\n+        :return: True on success, raise exception otherwise\n+        \"\"\"\n+        return bool(self.client(\"user.setDetails\", uid, {\n+            \"password\": password,\n+            \"first_name\": first_name,\n+            \"last_name\": last_name,\n+            \"email\": email\n+        }))\n+\n+    def delete(self, uid: str) -> bool:\n+        \"\"\"\n+        Remove an Uyuni user.\n+\n+        :param uid: UID of the user\n+        :return: boolean, True if user has been deleted successfully.\n+        \"\"\"\n+        return bool(self.client(\"user.delete\", uid))\n+\n+    def list_roles(self, uid: str) -> List[str]:\n+        \"\"\"\n+        Return the list of roles of a user.\n+\n+        :param: uid: user name to use on lookup\n+        :return: list of user roles\n+        \"\"\"\n+        return self.client(\"user.listRoles\", uid)\n+\n+    def add_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Add a role to a user\n+\n+        :param uid: UID of the user\n+        :param role: a new role\n+\n+        :return: boolean, True if role has been added successfully.\n+        \"\"\"\n+        return bool(self.client(\"user.addRole\", uid, role))\n+\n+    def remove_role(self, uid: str, role: str) -> bool:\n+        \"\"\"\n+        Remove user from the Uyuni org.\n+\n+        :param uid: UID of the user\n+        :param role: one of uyuni user roles\n+\n+        :return: boolean, True if role has been removed successfully.\n+        \"\"\"\n+        return bool(self.client(\"user.removeRole\", uid, role))\n+\n+    def list_assigned_system_groups(self, uid: str) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        Returns the system groups that a user can administer.\n+\n+        :param uid: UID of the user\n+        :return: List of system groups that a user can administer\n+        \"\"\"\n+        return self.client(\"user.listAssignedSystemGroups\", uid)\n+\n+    def add_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Add system groups to a user's list of assigned system groups.\n+\n+        :param uid: user id to look for\n+        :param server_group_names: system groups to add\n+        :param set_default: True if the system groups should also be added to user's default list.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"user.addAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+    def remove_assigned_system_groups(self, uid: str, server_group_names: List[str], set_default: bool = False) -> int:\n+        \"\"\"\n+        Remove system groups from a user's list of assigned system groups\n+\n+        :param uid: user id to look for\n+        :param server_group_names: systems groups to remove from list of assigned system groups\n+        :param set_default: True if the system groups should also be removed to user's default list.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"user.removeAssignedSystemGroups\", uid, server_group_names, set_default)\n+\n+\n+class UyuniChannel(UyuniRemoteObject):\n+    def list_manageable_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listManageableChannels\")\n+\n+    def list_my_channels(self) -> List[Dict[str, Union[int, str]]]:\n+        \"\"\"\n+        List all software channels that the user is entitled to manage.\n+        :return: list of manageable channels\n+        \"\"\"\n+        return self.client(\"channel.listMyChannels\")\n+\n+\n+class UyuniChannelSoftware(UyuniRemoteObject):\n+    def set_user_manageable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the manageable flag for a given channel and user.\n+        If access is set to 'true', this method will give the user manage permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: True if the user should have management access to channel\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"channel.software.setUserManageable\", channel_label, uid, access)\n+\n+    def set_user_subscribable(self, channel_label: str, uid: str, access: bool) -> int:\n+        \"\"\"\n+        Set the subscribable flag for a given channel and user.\n+        If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+        Otherwise, that privilege is revoked.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :param access: True if the user should have subscribe permission to the channel\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"channel.software.setUserSubscribable\", channel_label, uid, access)\n+\n+    def is_user_manageable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be managed by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user can manage channel or not\n+        \"\"\"\n+        return bool(self.client(\"channel.software.isUserManageable\", channel_label, uid))\n+\n+    def is_user_subscribable(self, channel_label: str, uid: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel may be subscribed to by the given user.\n+\n+        :param channel_label: label of the channel\n+        :param uid: user login id\n+        :return: boolean which indicates if user subscribe the channel or not\n+        \"\"\"\n+        return bool(self.client(\"channel.software.isUserSubscribable\", channel_label, uid))\n+\n+    def is_globally_subscribable(self, channel_label: str) -> bool:\n+        \"\"\"\n+        Returns whether the channel is globally subscribable on the organization\n+\n+        :param channel_label: label of the channel\n+        :return: boolean which indicates if channel is globally subscribable\n+        \"\"\"\n+        return bool(self.client(\"channel.software.isGloballySubscribable\", channel_label))\n+\n+\n+class UyuniOrg(UyuniRemoteObject):\n+    \"\"\"\n+    CRUD operations on orgs\n+    \"\"\"\n+\n+    def list_orgs(self) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        List all orgs.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list of all existing organizations\n+        \"\"\"\n+        return self.client(\"org.listOrgs\")\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str, bool]]:\n+        \"\"\"\n+        Get org data by name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organisation name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.getDetails\", name)\n+\n+    def create(self, name: str, org_admin_user: str, org_admin_password: str,\n+               first_name: str, last_name: str, email: str,\n+               admin_prefix: str = \"Mr.\", pam: bool = False) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Create a new Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param admin_prefix: organization admin prefix\n+        :param pam:organization admin pam authentication\n+        :return: dictionary with org information\n+        \"\"\"\n+        return self.client(\"org.create\", name, org_admin_user, org_admin_password, admin_prefix,\n+                           first_name, last_name, email, pam)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete an Uyuni org.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        org_id = int(self.get_details(name=name).get(\"id\", -1))\n+        return self.client(\"org.delete\", org_id)\n+\n+    def update_name(self, org_id: int, name: str) -> Dict[str, Union[str, int, bool]]:\n+        \"\"\"\n+        Update an Uyuni org name.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization internal id\n+        :param name: new organization name\n+        :return: organization details\n+        \"\"\"\n+        return self.client(\"org.updateName\", org_id, name)\n+\n+\n+class UyuniOrgTrust(UyuniRemoteObject):\n+\n+    def __init__(self, user: str = None, password: str = None):\n+        UyuniRemoteObject.__init__(self, user, password)\n+        self._org_manager = UyuniOrg(user, password)\n+\n+    def list_orgs(self) -> List[Dict[str, Union[str, int]]]:\n+        \"\"\"\n+        List all organizations trusted by the authenticated user organization\n+\n+        :return: List of organization details\n+        \"\"\"\n+        return self.client(\"org.trusts.listOrgs\")\n+\n+    def list_trusts(self, org_name: str) -> List[Dict[str, Union[str, int, bool]]]:\n+        \"\"\"\n+        List all trusts for the organization\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :return: list with all organizations and their trust status\n+        \"\"\"\n+        org = self._org_manager.get_details(org_name)\n+        return self.client(\"org.trusts.listTrusts\", org[\"id\"])\n+\n+    def add_trust_by_name(self, org_name: str, org_trust: str) -> int:\n+        \"\"\"\n+        Set an organisation as trusted by another\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_trust: name of organization to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_trust)\n+        return self.add_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def add_trust(self, org_id: str, org_trust_id: str) -> int:\n+        \"\"\"\n+        Set an organisation as trusted by another\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_trust_id: organization id to trust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.addTrust\", org_id, org_trust_id)\n+\n+    def remove_trust_by_name(self, org_name: str, org_untrust: str) -> int:\n+        \"\"\"\n+        Set an organisation as not trusted by another\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_name: organization name\n+        :param org_untrust: organization name to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        this_org = self._org_manager.get_details(org_name)\n+        trust_org = self._org_manager.get_details(org_untrust)\n+        return self.remove_trust(this_org[\"id\"], trust_org[\"id\"])\n+\n+    def remove_trust(self, org_id: str, org_untrust_id: str) -> int:\n+        \"\"\"\n+        Set an organisation as not trusted by another\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param org_id: organization id\n+        :param org_untrust_id: organization id to untrust\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"org.trusts.removeTrust\", org_id, org_untrust_id)\n+\n+\n+class UyuniSystemgroup(UyuniRemoteObject):\n+    \"\"\"\n+    Provides methods to access and modify system groups.\n+    \"\"\"\n+\n+    def get_details(self, name: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Retrieve details of a system group.\n+\n+        :param name: Name of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        return self.client(\"systemgroup.getDetails\", name)\n+\n+    def create(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Create a new system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        return self.client(\"systemgroup.create\", name, description)\n+\n+    def delete(self, name: str) -> int:\n+        \"\"\"\n+        Delete a system group.\n+\n+        :param name: Name of the system group.\n+        :return: 1 on success, exception thrown otherwise.\n+        \"\"\"\n+        return self.client(\"systemgroup.delete\", name)\n+\n+    def update(self, name: str, description: str) -> Dict[str, Union[int, str]]:\n+        \"\"\"\n+        Update an existing system group.\n+\n+        :param name: Name of the system group.\n+        :param description: Description of the system group.\n+        :return: data of the system group.\n+        \"\"\"\n+        return self.client(\"systemgroup.update\", name, description)\n+\n+    def list_systems(self, name: str, minimal: bool = True) -> List[Dict[str, Any]]:\n+        \"\"\"\n+        Get information about systems in a group.\n+\n+        :param name: Group name\n+        :param minimal: default True. Only return minimal information about systems, use False to get more details\n+        :return: List of system information\n+        \"\"\"\n+        return self._convert_datetime_list(\n+            self.client(\"systemgroup.listSystemsMinimal\" if minimal else \"systemgroup.listSystems\", name))\n+\n+    def add_remove_systems(self, name: str, add_remove: bool, system_ids: List[int] = []) -> int:\n+        \"\"\"\n+        Add or remove systems from a system group\n+\n+        :param name: Group name\n+        :param add_remove: True to add to the group, False to remove\n+        :param system_ids: List of system ids to add or remove\n+        :return: 1 on success, exception thrown otherwise\n+        \"\"\"\n+        return self.client(\"systemgroup.addOrRemoveSystems\", name, system_ids, add_remove)\n+\n+\n+class UyuniSystems(UyuniRemoteObject):\n+\n+    def get_minion_id_map(self, refresh: bool = False) -> Dict[str, int]:\n+        \"\"\"\n+        Returns a map from minion ID to Uyuni system ID for all systems a user has access to\n+        This method caches results, in order to avoid multiple XMLRPC calls.\n+\n+        :param refresh: Get new data from server, ignoring values in local context cache\n+        :return: Map between minion ID and system ID of all system accessible by authenticated user\n+        \"\"\"\n+        minions_token_key = \"uyuni.minions_id_map_\" + self.client.get_user()\n+        if (not minions_token_key in __context__) or refresh:\n+            __context__[minions_token_key] = self.client(\"system.getMinionIdMap\")\n+        return __context__[minions_token_key]\n+\n+\n+class UyuniChildMasterIntegration:\n+    \"\"\"\n+    Integration with the Salt Master which is running\n+    on the same host as this current Minion.\n+    \"\"\"\n+    DEFAULT_MASTER_CONFIG_PATH = \"/etc/salt/master\"\n+\n+    def __init__(self):\n+        self._minions = CkMinions(salt.config.client_config(self._get_master_config()))\n+\n+    @staticmethod\n+    def _get_master_config() -> str:\n+        \"\"\"\n+        Return master config.\n+        :return: path to salt master configuration file\n+        \"\"\"\n+        cfg_path = UyuniChildMasterIntegration.DEFAULT_MASTER_CONFIG_PATH\n+        for path in __pillar__.get(\"uyuni\", {}).get(\"masters\", {}).get(\"configs\", [cfg_path]):\n+            if os.path.exists(path):\n+                cfg_path = path\n+                break\n+\n+        return cfg_path\n+\n+    def select_minions(self, target: str, target_type: str = \"glob\") -> Dict[str, Union[List[str], bool]]:\n+        \"\"\"\n+        Select minion IDs that matches the target expression.\n+\n+        :param target: target expression to be applied\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                    pillar_exact, compound, compound_pillar_exact. Default: glob.\n+\n+        :return: list of minions\n+        \"\"\"\n+        return self._minions.check_minions(expr=target, tgt_type=target_type)\n+\n+\n+def __virtual__():\n+    \"\"\"\n+    Provide Uyuni configuration state module.\n+\n+    :return:\n+    \"\"\"\n+\n+    return __virtualname__\n+\n+\n+def user_get_details(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Get details of an Uyuni user\n+    If password is provided as a parameter, then it will be used to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar will be used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: The user information\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).get_details(uid=uid)\n+\n+\n+def user_list_users(org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Return all Uyuni users visible to the authenticated user.\n+\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: all users visible to the authenticated user\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).list_users()\n+\n+\n+def user_create(uid, password, email, first_name, last_name, use_pam_auth=False,\n+                org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create an Uyuni user.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).create(uid=uid, password=password, email=email,\n+                                                                first_name=first_name, last_name=last_name,\n+                                                                use_pam_auth=use_pam_auth)\n+\n+\n+def user_set_details(uid, password, email, first_name=None, last_name=None,\n+                     org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Update an Uyuni user.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param email: user email address\n+    :param first_name: user first name\n+    :param last_name: user last name\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).set_details(uid=uid, password=password, email=email,\n+                                                                     first_name=first_name, last_name=last_name)\n+\n+\n+def user_delete(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Deletes an Uyuni user\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).delete(uid=uid)\n+\n+\n+def user_list_roles(uid, password=None, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns an Uyuni user roles.\n+    If password is provided as a parameter, then it will be used to authenticate\n+    If no user credentials are provided, organization administrator credentials will be used\n+    If no user credentials neither organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param password: password for the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of user roles assigned\n+    \"\"\"\n+    return UyuniUser(org_admin_user if password is None else uid,\n+                     org_admin_password if password is None else password).list_roles(uid=uid)\n+\n+\n+def user_add_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Adds a role to an Uyuni user.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be added to the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).add_role(uid=uid, role=role)\n+\n+\n+def user_remove_role(uid, role, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove a role from an Uyuni user.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param role: role to be removed from the user\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user, org_admin_password).remove_role(uid=uid, role=role)\n+\n+\n+def user_list_assigned_system_groups(uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns the system groups that a user can administer.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: List of system groups that a user can administer\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).list_assigned_system_groups(uid=uid)\n+\n+\n+def user_add_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                    org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Add system groups to user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to add to list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).add_assigned_system_groups(uid=uid,\n+                                                                    server_group_names=server_group_names,\n+                                                                    set_default=set_default)\n+\n+\n+def user_remove_assigned_system_groups(uid, server_group_names, set_default=False,\n+                                       org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove system groups from a user's list of assigned system groups.\n+    If no organization admin credentials are provided, credentials from pillar are used\n+\n+    :param uid: user id to look for\n+    :param server_group_names: systems groups to remove from list of assigned system groups\n+    :param set_default: Should system groups also be added to user's list of default system groups.\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniUser(org_admin_user,\n+                     org_admin_password).remove_assigned_system_groups(uid=uid,\n+                                                                       server_group_names=server_group_names,\n+                                                                       set_default=set_default)\n+\n+\n+## channel.software\n+def channel_list_manageable_channels(uid, password):\n+    \"\"\"\n+    List all of manageable channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of manageable channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_manageable_channels()\n+\n+\n+def channel_list_my_channels(uid, password):\n+    \"\"\"\n+    List all of subscribed channels for the authenticated user\n+    :param uid: user login id\n+    :param password: user password\n+    :return: list of subscribed channels for the user\n+    \"\"\"\n+    return UyuniChannel(uid, password).list_my_channels()\n+\n+\n+def channel_software_set_user_manageable(channel_label, uid, access,\n+                                         admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the manageable flag for a given channel and user.\n+    If access is set to 'true', this method will give the user manage permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: True if the user should have management access to channel\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_manageable(channel_label, uid, access)\n+\n+\n+def channel_software_set_user_subscribable(channel_label, uid, access,\n+                                           admin_user=None, admin_password=None):\n+    \"\"\"\n+    Set the subscribable flag for a given channel and user.\n+    If value is set to 'true', this method will give the user subscribe permissions to the channel.\n+    Otherwise, that privilege is revoked.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param access: True if the user should have subscribe access to channel\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean indication success in operation\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).set_user_subscribable(channel_label, uid, access)\n+\n+\n+def channel_software_is_user_manageable(channel_label, uid, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be managed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param admin_user: organization admin username\n+    :param admin_password: organization admin password\n+    :return: boolean which indicates if user can manage channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(admin_user, admin_password).is_user_manageable(channel_label, uid)\n+\n+\n+def channel_software_is_user_subscribable(channel_label, uid, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel may be subscribed by the given user.\n+\n+    :param channel_label: label of the channel\n+    :param uid: user login id\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if user subscribe the channel or not\n+    \"\"\"\n+    return UyuniChannelSoftware(org_admin_user, org_admin_password).is_user_subscribable(channel_label, uid)\n+\n+\n+def channel_software_is_globally_subscribable(channel_label, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Returns whether the channel is globally subscribable on the organization\n+\n+    :param channel_label: label of the channel\n+    :param org_admin_user: organization admin username\n+    :param org_admin_password: organization admin password\n+    :return: boolean which indicates if channel is globally subscribe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 889}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODAyNDcy", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476802472", "createdAt": "2020-08-27T14:52:59Z", "commit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDo1Mjo1OVrOHIUIFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNDo1Mjo1OVrOHIUIFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ4MDQwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                :param last_name: Second name\n          \n          \n            \n                :param last_name: Last name", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478480406", "createdAt": "2020-08-27T14:52:59Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties\n+\n+    :param name: user ID\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 639}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODE3ODIw", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476817820", "createdAt": "2020-08-27T15:08:32Z", "commit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTowODozMlrOHIU1Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToxNzo1NFrOHIVPSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MTkwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n          \n          \n            \n                        return StateResult.state_error(uid, \"Error modifying user '{}': {}\".format(uid, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478491906", "createdAt": "2020-08-27T15:08:32Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5Mjc0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n          \n          \n            \n                            log.warning(\"Error while retrieving user information (admin credentials error) '{}': {}\".format(uid, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478492744", "createdAt": "2020-08-27T15:09:40Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MzE0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                           comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n          \n          \n            \n                                                           comment=\"Error while retrieving user information (admin credentials error) '{}': {}\".format(", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478493146", "createdAt": "2020-08-27T15:10:12Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MzQxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n          \n          \n            \n                        return StateResult.prepare_result(uid, True, \"{0} is already in the desired state\".format(uid))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478493410", "createdAt": "2020-08-27T15:10:34Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MzYzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n          \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} is already in the desired state\".format(name))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478493635", "createdAt": "2020-08-27T15:10:51Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MzgyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n          \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} is already in the desired state\".format(name))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478493828", "createdAt": "2020-08-27T15:11:09Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5Mzk4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n          \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} is already in the desired state\".format(org_name))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478493986", "createdAt": "2020-08-27T15:11:23Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 597}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5NDg3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n          \n          \n            \n                        return StateResult.prepare_result(uid, True, \"{0} user successfully modified\".format(uid), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478494871", "createdAt": "2020-08-27T15:12:34Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5NTA3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n          \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} org successfully modified\".format(name), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478495070", "createdAt": "2020-08-27T15:12:51Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5NTE4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n          \n          \n            \n                    return StateResult.prepare_result(name, True, \"Org '{}' trusts successfully modified\".format(org_name), processed_changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478495185", "createdAt": "2020-08-27T15:13:01Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 619}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5NzM0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n          \n          \n            \n                        return StateResult.prepare_result(uid, None, \"{0} would be created\".format(uid), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478497344", "createdAt": "2020-08-27T15:16:03Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5NzQ4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n          \n          \n            \n                        return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478497480", "createdAt": "2020-08-27T15:16:15Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 514}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5NzU3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n          \n          \n            \n                        return StateResult.prepare_result(name, None, \"{0} would be created\".format(org_name), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478497577", "createdAt": "2020-08-27T15:16:24Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param uid: UID of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(uid, True, \"{0} is already absent\".format(uid))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(uid,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'uid': {'old': uid},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(uid, None, \"{0} would be removed\".format(uid), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](uid,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(uid, True, \"User {} has been deleted\".format(uid), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(uid, \"Error deleting user '{}': {}\".format(uid, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, uid: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param uid: user ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](uid, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](uid, password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid,\n+                                           comment=\"Error managing user channels '{}': {}\".format(uid, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(uid, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} channels are already in the desired state\".format(uid))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} channels would be configured\".format(uid), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, uid, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, uid, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing channel '{}': {}\".format(uid, exc))\n+        return StateResult.prepare_result(uid, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"uid\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5ODYzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Remove user from the Uyuni Server\n          \n          \n            \n                    Remove an Uyuni user", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478498633", "createdAt": "2020-08-27T15:17:54Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](uid=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](uid=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('uid'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, uid: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param uid: user ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](uid, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](uid,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(uid, exc))\n+                return StateResult.state_error(uid,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   uid, exc))\n+\n+        user_paramters = {\"uid\": uid, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, error))\n+        if not changes:\n+            return StateResult.prepare_result(uid, True, \"{0} is already installed\".format(uid))\n+        if not current_user:\n+            changes['uid'] = {\"new\": uid}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(uid, None, \"{0} would be installed\".format(uid), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(uid, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(uid, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(uid, \"Error managing user '{}': {}\".format(uid, exc))\n+        else:\n+            return StateResult.prepare_result(uid, True, \"{0} user successful managed\".format(uid), changes)\n+\n+    def delete(self, uid: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e889b3b9d7b15bc20d8a2f9334020a0df7f7ff1a"}, "originalPosition": 189}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ1MDI3", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476845027", "createdAt": "2020-08-27T15:35:54Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNTo1NFrOHIWDmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNTo1NFrOHIWDmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxMjAyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n          \n          \n            \n                            log.warning(\"Error while retrieving user information (admin credentials error) '{}': {}\".format(login, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478512025", "createdAt": "2020-08-27T15:35:54Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ1Njg1", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476845685", "createdAt": "2020-08-27T15:36:37Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNjozN1rOHIWFng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNjozN1rOHIWFng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxMjU0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n          \n          \n            \n                        return StateResult.state_error(login, \"Error computing changes for user '{}': {}\".format(login, error))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478512542", "createdAt": "2020-08-27T15:36:37Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ1ODU0", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476845854", "createdAt": "2020-08-27T15:36:49Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNjo0OVrOHIWGHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNjo0OVrOHIWGHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxMjY2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n          \n          \n            \n                        return StateResult.prepare_result(login, True, \"{0} is already in the desired state\".format(login))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478512669", "createdAt": "2020-08-27T15:36:49Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ2MTk5", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476846199", "createdAt": "2020-08-27T15:37:12Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNzoxMlrOHIWHHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozNzoxMlrOHIWHHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxMjkyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n          \n          \n            \n                        return StateResult.prepare_result(login, None, \"{0} would be modified\".format(login), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478512925", "createdAt": "2020-08-27T15:37:12Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ3MDIx", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476847021", "createdAt": "2020-08-27T15:38:05Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozODowNVrOHIWJZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozODowNVrOHIWJZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxMzUwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n          \n          \n            \n                        return StateResult.state_error(login, \"Error modifying user '{}': {}\".format(login, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478513508", "createdAt": "2020-08-27T15:38:05Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ3MjQ2", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476847246", "createdAt": "2020-08-27T15:38:20Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozODoyMFrOHIWKJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozODoyMFrOHIWKJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxMzcwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n          \n          \n            \n                        return StateResult.prepare_result(login, True, \"{0} user successfully modified\".format(login), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478513700", "createdAt": "2020-08-27T15:38:20Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ3NTc1", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476847575", "createdAt": "2020-08-27T15:38:41Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozODo0MVrOHIWLLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozODo0MVrOHIWLLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxMzk2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n          \n          \n            \n                            return StateResult.prepare_result(login, None, \"{0} would be deleted\".format(login), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478513965", "createdAt": "2020-08-27T15:38:41Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ4MzY3", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476848367", "createdAt": "2020-08-27T15:39:35Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozOTozNVrOHIWNfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozOTozNVrOHIWNfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxNDU1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    User channels management present implementation\n          \n          \n            \n                    Modifies user-channel associations", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478514557", "createdAt": "2020-08-27T15:39:35Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 265}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODQ4NjQ1", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476848645", "createdAt": "2020-08-27T15:39:56Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozOTo1N1rOHIWOVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTozOTo1N1rOHIWOVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxNDc3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                       comment=\"Error managing user channels '{}': {}\".format(login, exc))\n          \n          \n            \n                                                       comment=\"Error retrieving information about user channels '{}': {}\".format(login, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478514775", "createdAt": "2020-08-27T15:39:57Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 281}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODUxODQ5", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476851849", "createdAt": "2020-08-27T15:43:39Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0MzozOVrOHIWX-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0MzozOVrOHIWX-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxNzI0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n          \n          \n            \n                        return StateResult.state_error(login, \"Error changing channel assignments '{}': {}\".format(login, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478517242", "createdAt": "2020-08-27T15:43:39Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 311}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODUyOTE3", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476852917", "createdAt": "2020-08-27T15:44:56Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NDo1N1rOHIWbDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NDo1N1rOHIWbDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxODAzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Create or update group\n          \n          \n            \n                    Create or update a system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478518030", "createdAt": "2020-08-27T15:44:57Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 348}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODUzNDkx", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476853491", "createdAt": "2020-08-27T15:45:36Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NTozNlrOHIWdLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NTozNlrOHIWdLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxODU3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n          \n          \n            \n                            return StateResult.state_error(name, \"Error retrieving information about system group '{}': {}\".format(name, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478518573", "createdAt": "2020-08-27T15:45:36Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 369}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODUzOTQz", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476853943", "createdAt": "2020-08-27T15:46:04Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NjowNFrOHIWekg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NjowNFrOHIWekg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxODkzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n          \n          \n            \n                        return StateResult.state_error(name, \"Error updating group. '{}': {}\".format(name, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478518930", "createdAt": "2020-08-27T15:46:04Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 417}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODU0MTQ2", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476854146", "createdAt": "2020-08-27T15:46:17Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NjoxOFrOHIWfLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0NjoxOFrOHIWfLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxOTA4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n          \n          \n            \n                        return StateResult.prepare_result(name, True, \"{0} successfully updated\".format(name), changes)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478519086", "createdAt": "2020-08-27T15:46:18Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 419}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODU0NjMx", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476854631", "createdAt": "2020-08-27T15:46:50Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0Njo1MFrOHIWgmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0Njo1MFrOHIWgmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUxOTQ1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Remove group from the Uyuni\n          \n          \n            \n                    Remove an Uyuni system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478519451", "createdAt": "2020-08-27T15:46:50Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 423}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODU3MzM5", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476857339", "createdAt": "2020-08-27T15:49:58Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0OTo1OFrOHIWopg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo0OTo1OFrOHIWopg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyMTUxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Manage organization.\n          \n          \n            \n                    Create or update an Uyuni organization.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478521510", "createdAt": "2020-08-27T15:49:58Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 474}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODU3NzQ4", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476857748", "createdAt": "2020-08-27T15:50:25Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1MDoyNVrOHIWpyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1MDoyNVrOHIWpyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyMTgwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n          \n          \n            \n                            return StateResult.state_error(name, \"Error retrieving information about organization '{}': {}\".format(name, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478521801", "createdAt": "2020-08-27T15:50:25Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 499}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODU4Mzk0", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476858394", "createdAt": "2020-08-27T15:51:11Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1MToxMVrOHIWrsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1MToxMVrOHIWrsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyMjI4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n          \n          \n            \n                        return StateResult.state_error(name, \"Error updating organization '{}': {}\".format(name, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478522288", "createdAt": "2020-08-27T15:51:11Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 526}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODU5NDA5", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476859409", "createdAt": "2020-08-27T15:52:19Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1MjoxOVrOHIWupQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1MjoxOVrOHIWupQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyMzA0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Remove organization from the Uyuni\n          \n          \n            \n                    Remove an Uyuni organization", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478523045", "createdAt": "2020-08-27T15:52:19Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 532}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY1NDkz", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476865493", "createdAt": "2020-08-27T15:59:24Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1OToyNFrOHIXAww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTo1OToyNFrOHIXAww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyNzY4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n          \n          \n            \n                        return StateResult.state_error(login, \"Channels access cannot be managed, \"\n          \n          \n            \n                                                            \"User can manage all channel in the organization \"\n          \n          \n            \n                                                            \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n          \n          \n            \n                    if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n          \n          \n            \n                        return StateResult.state_error(login, \"Channels access cannot be changed, because\"\n          \n          \n            \n                                                            \"the target user can manage all channels in the organization \"\n          \n          \n            \n                                                            \"(having an \\\"org_admin\\\" or \\\"channel_admin\\\" role).\")", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478527683", "createdAt": "2020-08-27T15:59:24Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 287}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY2ODE1", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476866815", "createdAt": "2020-08-27T16:00:54Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMDo1NVrOHIXEtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMDo1NVrOHIXEtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyODY5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Add trusted organisations to the a org\n          \n          \n            \n                    Establish trust relationships between organizations", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478528694", "createdAt": "2020-08-27T16:00:55Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 571}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY3ODgy", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476867882", "createdAt": "2020-08-27T16:02:11Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMjoxMVrOHIXHuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMjoxMVrOHIXHuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyOTQ2NA==", "bodyText": "I would suggest replacing orgs_trust with trusted_orgs", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478529464", "createdAt": "2020-08-27T16:02:11Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 568}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY4MzM5", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476868339", "createdAt": "2020-08-27T16:02:43Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMjo0M1rOHIXJBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMjo0M1rOHIXJBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUyOTc5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n          \n          \n            \n                        return StateResult.state_error(name, \"Error retrieving information about an organization trust'{}': {}\".format(org_name, exc))", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478529797", "createdAt": "2020-08-27T16:02:43Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 586}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY4Njcx", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476868671", "createdAt": "2020-08-27T16:03:06Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMzowNlrOHIXKIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMzowNlrOHIXKIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMDA4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n          \n          \n            \n                        return StateResult.prepare_result(name, False, \"Error updating organization trusts '{}': {}\".format(org_name, exc),", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478530081", "createdAt": "2020-08-27T16:03:06Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 617}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY5MTAw", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476869100", "createdAt": "2020-08-27T16:03:37Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMzozN1rOHIXLUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowMzozN1rOHIXLUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMDM4Nw==", "bodyText": "Is this TODO still valid?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478530387", "createdAt": "2020-08-27T16:03:37Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 624}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY5NTQ2", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476869546", "createdAt": "2020-08-27T16:04:10Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNDoxMFrOHIXMhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNDoxMFrOHIXMhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMDY5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                Ensure an Uyuni user is not present.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478530692", "createdAt": "2020-08-27T16:04:10Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties\n+\n+    :param name: user login name\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user has access to the specified channels\n+\n+    :param name: user login name\n+    :param password: user password\n+    :param manageable_channels: channels user can manage\n+    :param subscribable_channels: channels user can subscribe\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUserChannels().manage(name, password,\n+                                      manageable_channels, subscribable_channels,\n+                                      org_admin_user, org_admin_password)\n+\n+\n+def user_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 673}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODY5NzYz", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476869763", "createdAt": "2020-08-27T16:04:25Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNDoyNlrOHIXNIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNDoyNlrOHIXNIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMDg1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Create or update uyuni organization\n          \n          \n            \n                Create or update an Uyuni organization", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478530850", "createdAt": "2020-08-27T16:04:26Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties\n+\n+    :param name: user login name\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user has access to the specified channels\n+\n+    :param name: user login name\n+    :param password: user password\n+    :param manageable_channels: channels user can manage\n+    :param subscribable_channels: channels user can subscribe\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUserChannels().manage(name, password,\n+                                      manageable_channels, subscribable_channels,\n+                                      org_admin_user, org_admin_password)\n+\n+\n+def user_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+\n+    :param name: user login name\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return:\n+    \"\"\"\n+    return UyuniUsers().delete(name, org_admin_user, org_admin_password)\n+\n+\n+def org_present(name, org_admin_user, org_admin_password,\n+                first_name, last_name, email, pam=False,\n+                admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create or update uyuni organization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 686}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODcwMjA3", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476870207", "createdAt": "2020-08-27T16:04:56Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNDo1N1rOHIXOcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNDo1N1rOHIXOcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMTE4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Ensure a user is present with all specified properties\n          \n          \n            \n                Create or update an Uyuni user", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478531185", "createdAt": "2020-08-27T16:04:57Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 633}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODcwNjQ3", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476870647", "createdAt": "2020-08-27T16:05:26Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNToyNlrOHIXPwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNToyNlrOHIXPwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMTUyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Delete uyuni organization\n          \n          \n            \n                Ensure an Uyuni organization is not present", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478531522", "createdAt": "2020-08-27T16:05:26Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties\n+\n+    :param name: user login name\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user has access to the specified channels\n+\n+    :param name: user login name\n+    :param password: user password\n+    :param manageable_channels: channels user can manage\n+    :param subscribable_channels: channels user can subscribe\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUserChannels().manage(name, password,\n+                                      manageable_channels, subscribable_channels,\n+                                      org_admin_user, org_admin_password)\n+\n+\n+def user_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+\n+    :param name: user login name\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return:\n+    \"\"\"\n+    return UyuniUsers().delete(name, org_admin_user, org_admin_password)\n+\n+\n+def org_present(name, org_admin_user, org_admin_password,\n+                first_name, last_name, email, pam=False,\n+                admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create or update uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param pam: organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().manage(name, org_admin_user, org_admin_password, first_name,\n+                              last_name, email, pam,\n+                              admin_user, admin_password)\n+\n+\n+def org_absent(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete uyuni organization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 707}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODcxMzY1", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476871365", "createdAt": "2020-08-27T16:06:17Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNjoxN1rOHIXSAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNjoxN1rOHIXSAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMjA5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Add trusted organisations from a organization.\n          \n          \n            \n                Establish trust relationships between Uyuni organizations.", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478532098", "createdAt": "2020-08-27T16:06:17Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties\n+\n+    :param name: user login name\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user has access to the specified channels\n+\n+    :param name: user login name\n+    :param password: user password\n+    :param manageable_channels: channels user can manage\n+    :param subscribable_channels: channels user can subscribe\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUserChannels().manage(name, password,\n+                                      manageable_channels, subscribable_channels,\n+                                      org_admin_user, org_admin_password)\n+\n+\n+def user_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+\n+    :param name: user login name\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return:\n+    \"\"\"\n+    return UyuniUsers().delete(name, org_admin_user, org_admin_password)\n+\n+\n+def org_present(name, org_admin_user, org_admin_password,\n+                first_name, last_name, email, pam=False,\n+                admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create or update uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param pam: organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().manage(name, org_admin_user, org_admin_password, first_name,\n+                              last_name, email, pam,\n+                              admin_user, admin_password)\n+\n+\n+def org_absent(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().delete(name, admin_user, admin_password)\n+\n+\n+def org_trust(name, org_name, trusts, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add trusted organisations from a organization.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 720}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODcxNTUw", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476871550", "createdAt": "2020-08-27T16:06:30Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNjozMFrOHIXSiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNjozMFrOHIXSiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMjIzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Create or update group\n          \n          \n            \n                Create or update an Uyuni system group", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478532232", "createdAt": "2020-08-27T16:06:30Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties\n+\n+    :param name: user login name\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user has access to the specified channels\n+\n+    :param name: user login name\n+    :param password: user password\n+    :param manageable_channels: channels user can manage\n+    :param subscribable_channels: channels user can subscribe\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUserChannels().manage(name, password,\n+                                      manageable_channels, subscribable_channels,\n+                                      org_admin_user, org_admin_password)\n+\n+\n+def user_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+\n+    :param name: user login name\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return:\n+    \"\"\"\n+    return UyuniUsers().delete(name, org_admin_user, org_admin_password)\n+\n+\n+def org_present(name, org_admin_user, org_admin_password,\n+                first_name, last_name, email, pam=False,\n+                admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create or update uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param pam: organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().manage(name, org_admin_user, org_admin_password, first_name,\n+                              last_name, email, pam,\n+                              admin_user, admin_password)\n+\n+\n+def org_absent(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().delete(name, admin_user, admin_password)\n+\n+\n+def org_trust(name, org_name, trusts, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add trusted organisations from a organization.\n+    :param name: state name\n+    :param org_name: Organization name\n+    :param trusts: list of organization names to trust\n+    :param admin_user: administrator username\n+    :param admin_password: administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgsTrust().trust(name, org_name, trusts, admin_user, admin_password)\n+\n+\n+def group_present(name, description, target=None, target_type=\"glob\",\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create or update group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 734}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2ODcxOTc0", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-476871974", "createdAt": "2020-08-27T16:07:02Z", "commit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNzowMlrOHIXTxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNzowMlrOHIXTxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMjU1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Remove group from the Uyuni\n          \n          \n            \n                Ensure an Uyuni system group is not present", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r478532550", "createdAt": "2020-08-27T16:07:02Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/src/states/uyuni_config.py", "diffHunk": "@@ -0,0 +1,759 @@\n+import logging\n+from typing import Optional, Dict, Any, List, Tuple\n+from collections import Counter\n+\n+SERVER_GROUP_NOT_FOUND_ERROR = 2201\n+NO_SUCH_USER_ERROR = -213\n+ORG_NOT_FOUND_ERROR = 2850\n+AUTHENTICATION_ERROR = 2950\n+\n+log = logging.getLogger(__name__)\n+\n+__salt__: Dict[str, Any] = {}\n+__opts__: Dict[str, Any] = {}\n+__virtualname__ = 'uyuni'\n+\n+\n+class StateResult:\n+\n+    @staticmethod\n+    def state_error(name: str, comment: str = None):\n+        return StateResult.prepare_result(name, False, comment)\n+\n+    @staticmethod\n+    def prepare_result(name: str, result: Optional[bool], comment: str = None, changes: Dict = {}):\n+        return {\n+            'name': name,\n+            'changes': changes,\n+            'result': result,\n+            'comment': comment,\n+        }\n+\n+\n+class UyuniUsers:\n+\n+    @staticmethod\n+    def _update_user_roles(name: str,\n+                           current_roles: List[str] = [],\n+                           new_roles: List[str] = [],\n+                           org_admin_user: str = None,\n+                           org_admin_password: str = None):\n+\n+        for role_to_remove in (current_roles or []):\n+            if role_to_remove not in (new_roles or []):\n+                __salt__['uyuni.user_remove_role'](name, role=role_to_remove,\n+                                                   org_admin_user=org_admin_user,\n+                                                   org_admin_password=org_admin_password)\n+\n+        for role_to_add in (new_roles or []):\n+            if role_to_add not in (current_roles or []):\n+                __salt__['uyuni.user_add_role'](name, role=role_to_add,\n+                                                org_admin_user=org_admin_user,\n+                                                org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _update_user_system_groups(name: str,\n+                                   current_system_groups: List[str] = [],\n+                                   system_groups: List[str] = [],\n+                                   org_admin_user: str = None,\n+                                   org_admin_password: str = None):\n+\n+        systems_groups_add = [sys for sys in (system_groups or []) if sys not in (current_system_groups or [])]\n+        if systems_groups_add:\n+            __salt__['uyuni.user_add_assigned_system_groups'](login=name, server_group_names=systems_groups_add,\n+                                                              org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+\n+        system_groups_remove = [sys for sys in (current_system_groups or []) if sys not in (system_groups or [])]\n+        if system_groups_remove:\n+            __salt__['uyuni.user_remove_assigned_system_groups'](login=name, server_group_names=system_groups_remove,\n+                                                                 org_admin_user=org_admin_user,\n+                                                                 org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any],\n+                         roles: List[str],\n+                         current_roles: List[str],\n+                         system_groups: List[str],\n+                         current_system_groups: List[str],\n+                         use_pam_auth: bool = False):\n+        changes = {}\n+        error = None\n+        # user field changes\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+\n+        # role changes\n+        if Counter(roles or []) != Counter(current_roles or []):\n+            changes['roles'] = {'new': roles}\n+            if current_roles:\n+                changes['roles']['old'] = current_roles\n+\n+        # system group changes\n+        if Counter(system_groups or []) != Counter(current_system_groups or []):\n+            changes['system_groups'] = {'new': system_groups}\n+            if current_system_groups:\n+                changes['system_groups']['old'] = current_system_groups\n+\n+        # check if password have changed\n+        if current_user and not use_pam_auth:\n+            try:\n+                __salt__['uyuni.user_get_details'](user_changes.get('login'),\n+                                                   user_changes.get('password'))\n+            except Exception as exc:\n+                # check if it's an authentication error. If yes, password have changed\n+                if exc.faultCode == AUTHENTICATION_ERROR:\n+                    changes[\"password\"] = {\"new\": \"(hidden)\", \"old\": \"(hidden)\"}\n+                else:\n+                    error = exc\n+        return changes, error\n+\n+    def manage(self, login: str, password: str, email: str, first_name: str, last_name: str, use_pam_auth: bool = False,\n+               roles: Optional[List[str]] = [], system_groups: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Ensure a user is present with all specified properties\n+\n+        :param login: user login ID\n+        :param password: desired password for the user\n+        :param email: valid email address\n+        :param first_name: First name\n+        :param last_name: Last name\n+        :param use_pam_auth: if you wish to use PAM authentication for this user\n+        :param roles: roles to assign to user\n+        :param system_groups: system groups to assign user to\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_user = None\n+        current_roles = None\n+        current_system_groups_names = None\n+        try:\n+            current_user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_roles = __salt__['uyuni.user_list_roles'](login, org_admin_user=org_admin_user,\n+                                                              org_admin_password=org_admin_password)\n+            current_system_groups = __salt__['uyuni.user_list_assigned_system_groups'](login,\n+                                                                                       org_admin_user=org_admin_user,\n+                                                                                       org_admin_password=org_admin_password)\n+            current_system_groups_names = [s[\"name\"] for s in (current_system_groups or [])]\n+        except Exception as exc:\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                log.warning(\"Error managing user (admin credentials error) '{}': {}\".format(login, exc))\n+                return StateResult.state_error(login,\n+                                               comment=\"Error managing user (admin credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+\n+        user_paramters = {\"login\": login, \"password\": password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes, error = self._compute_changes(user_paramters, current_user,\n+                                               roles, current_roles,\n+                                               system_groups, current_system_groups_names,\n+                                               use_pam_auth=use_pam_auth)\n+\n+        if error:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, error))\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} is already installed\".format(login))\n+        if not current_user:\n+            changes['login'] = {\"new\": login}\n+            changes['password'] = {\"new\": \"(hidden)\"}\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} would be installed\".format(login), changes)\n+\n+        try:\n+            if current_user:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                user_paramters[\"use_pam_auth\"] = use_pam_auth\n+                __salt__['uyuni.user_create'](**user_paramters)\n+\n+            self._update_user_roles(login, current_roles, roles,\n+                                    org_admin_user, org_admin_password)\n+            self._update_user_system_groups(login, current_system_groups_names, system_groups,\n+                                            org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing user '{}': {}\".format(login, exc))\n+        else:\n+            return StateResult.prepare_result(login, True, \"{0} user successful managed\".format(login), changes)\n+\n+    def delete(self, login: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove user from the Uyuni Server\n+\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :param login: login of the user\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            user = __salt__['uyuni.user_get_details'](login, org_admin_user=org_admin_user,\n+                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == NO_SUCH_USER_ERROR:\n+                return StateResult.prepare_result(login, True, \"{0} is already absent\".format(login))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(login,\n+                                               \"Error deleting user (organization credentials error) '{}': {}\".format(\n+                                                   login, exc))\n+            raise exc\n+        else:\n+            changes = {\n+                'login': {'old': login},\n+                'email': {'old': user.get('email')},\n+                'first_name': {'old': user.get('first_name')},\n+                'last_name': {'old': user.get('last_name')}\n+            }\n+            if __opts__['test']:\n+                return StateResult.prepare_result(login, None, \"{0} would be removed\".format(login), changes)\n+\n+            try:\n+                __salt__['uyuni.user_delete'](login,\n+                                              org_admin_user=org_admin_user,\n+                                              org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(login, True, \"User {} has been deleted\".format(login), changes)\n+            except Exception as exc:\n+                return StateResult.state_error(login, \"Error deleting user '{}': {}\".format(login, exc))\n+\n+\n+class UyuniUserChannels:\n+\n+    @staticmethod\n+    def process_changes(current_managed_channels: Optional[List[str]],\n+                        new_managed_channels: Optional[List[str]],\n+                        current_subscribe_channels: List[str],\n+                        new_subscribe_channels: List[str],\n+                        org_admin_user: str, org_admin_password: str) -> Dict[str, Dict[str, bool]]:\n+        managed_changes: Dict[str, bool] = {}\n+        managed_changes.update({new_ma: True for new_ma in (new_managed_channels or [])\n+                                if new_ma not in current_managed_channels})\n+\n+        managed_changes.update({old_ma: False for old_ma in (current_managed_channels or [])\n+                                if old_ma not in new_managed_channels})\n+\n+        subscribe_changes: Dict[str, bool] = {}\n+        for new_channel in (new_subscribe_channels or []):\n+            if new_channel not in (current_subscribe_channels or []) or not managed_changes.get(new_channel, True):\n+                subscribe_changes[new_channel] = True\n+\n+        for curr_channel in (current_subscribe_channels or []):\n+            if not (curr_channel in new_subscribe_channels or curr_channel in new_managed_channels):\n+                if not __salt__['uyuni.channel_software_is_globally_subscribable'](curr_channel,\n+                                                                                   org_admin_user,\n+                                                                                   org_admin_password):\n+                    subscribe_changes[curr_channel] = False\n+        changes = {}\n+        if managed_changes:\n+            changes['manageable_channels'] = managed_changes\n+        if subscribe_changes:\n+            changes['subscribable_channels'] = subscribe_changes\n+        return changes\n+\n+    def manage(self, login: str, password: str,\n+               manageable_channels: Optional[List[str]] = [],\n+               subscribable_channels: Optional[List[str]] = [],\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        User channels management present implementation\n+\n+        :param login: user login ID\n+        :param password: user password\n+        :param manageable_channels: channels user can manage\n+        :param subscribable_channels: channels user can subscribe\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_roles = __salt__['uyuni.user_list_roles'](login, password=password)\n+            current_manageable_channels = __salt__['uyuni.channel_list_manageable_channels'](login, password)\n+            current_subscribe_channels = __salt__['uyuni.channel_list_my_channels'](login, password)\n+        except Exception as exc:\n+            return StateResult.state_error(login,\n+                                           comment=\"Error managing user channels '{}': {}\".format(login, exc))\n+            pass\n+\n+        if \"org_admin\" in current_roles or \"channel_admin\" in current_roles:\n+            return StateResult.state_error(login, \"Channels access cannot be managed, \"\n+                                                \"User can manage all channel in the organization \"\n+                                                \"(\\\"org_admin\\\" or \\\"channel_admin\\\" role).\")\n+\n+        current_manageable_channels_list = [c.get(\"label\") for c in (current_manageable_channels or [])]\n+        current_subscribe_channels_list = [c.get(\"label\") for c in (current_subscribe_channels or [])]\n+\n+        changes = self.process_changes(current_manageable_channels_list,\n+                                       manageable_channels,\n+                                       current_subscribe_channels_list, subscribable_channels,\n+                                       org_admin_user, org_admin_password)\n+\n+        if not changes:\n+            return StateResult.prepare_result(login, True, \"{0} channels are already in the desired state\".format(login))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(login, None, \"{0} channels would be configured\".format(login), changes)\n+\n+        try:\n+            for channel, action in changes.get('manageable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_manageable'](channel, login, action,\n+                                                                       org_admin_user, org_admin_password)\n+\n+            for channel, action in changes.get('subscribable_channels', {}).items():\n+                __salt__['uyuni.channel_software_set_user_subscribable'](channel, login, action,\n+                                                                         org_admin_user, org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(login, \"Error managing channel '{}': {}\".format(login, exc))\n+        return StateResult.prepare_result(login, True, \"Channel set to the desired state\", changes)\n+\n+\n+class UyuniGroups:\n+\n+    @staticmethod\n+    def _update_systems(name: str, new_systems: List[int], current_systems: List[int],\n+                        org_admin_user: str = None, org_admin_password: str = None):\n+\n+        remove_systems = [sys for sys in current_systems if sys not in new_systems]\n+        if remove_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, False, remove_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+        add_systems = [sys for sys in new_systems if sys not in current_systems]\n+        if add_systems:\n+            __salt__['uyuni.systemgroup_add_remove_systems'](name, True, add_systems,\n+                                                             org_admin_user=org_admin_user,\n+                                                             org_admin_password=org_admin_password)\n+\n+    @staticmethod\n+    def _get_systems_for_group(target: str, target_type: str = \"glob\",\n+                               org_admin_user: str = None, org_admin_password: str = None):\n+\n+        selected_minions = __salt__['uyuni.master_select_minions'](target, target_type)\n+        available_system_ids = __salt__['uyuni.systems_get_minion_id_map'](org_admin_user, org_admin_password)\n+\n+        return [\n+            available_system_ids[minion_id] for minion_id in selected_minions.get('minions', [])\n+            if minion_id in available_system_ids\n+        ]\n+\n+    def manage(self, name: str, description: str, target: str, target_type: str = \"glob\",\n+               org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Create or update group\n+        :param name: group name\n+        :param description: group description\n+        :param target: target expression used to filter which minions should be part of the group\n+        :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+                pillar_exact, compound, compound_pillar_exact. Default: glob.\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_group = None\n+        current_systems = None\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+            current_systems = __salt__['uyuni.systemgroup_list_systems'](name,\n+                                                                         org_admin_user=org_admin_user,\n+                                                                         org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing group '{}': {}\".format(name, exc))\n+\n+        current_systems_ids = [sys['id'] for sys in (current_systems or [])]\n+        systems_to_group = self._get_systems_for_group(target, target_type,\n+                                                       org_admin_user=org_admin_user,\n+                                                       org_admin_password=org_admin_password)\n+\n+        changes = {}\n+        if description != (current_group or {}).get('description'):\n+            changes['description'] = {'new': description}\n+            if current_group:\n+                changes['description']['old'] = current_group[\"description\"]\n+\n+        if Counter(current_systems_ids or []) != Counter(systems_to_group or []):\n+            changes['systems'] = {'new': systems_to_group}\n+            if current_group:\n+                changes['systems']['old'] = current_systems_ids\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+\n+        if not current_group:\n+            changes[\"name\"] = {\"new\": name}\n+\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be updated\".format(name), changes)\n+\n+        try:\n+            if current_group:\n+                __salt__['uyuni.systemgroup_update'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+            else:\n+                __salt__['uyuni.systemgroup_create'](name, description,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                self._update_systems(name,\n+                                     systems_to_group,\n+                                     current_systems_ids,\n+                                     org_admin_user=org_admin_user,\n+                                     org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing group. '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} successfully managed\".format(name), changes)\n+\n+    def delete(self, name: str, org_admin_user: str = None, org_admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove group from the Uyuni\n+\n+        :param name: Group Name\n+        :param org_admin_user: organization administrator username\n+        :param org_admin_password: organization administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_group = __salt__['uyuni.systemgroup_get_details'](name,\n+                                                                      org_admin_user=org_admin_user,\n+                                                                      org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == SERVER_GROUP_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting group (organization admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.systemgroup_delete'](name,\n+                                                     org_admin_user=org_admin_user,\n+                                                     org_admin_password=org_admin_password)\n+                return StateResult.prepare_result(name, True, \"Group {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_group.get('name')},\n+                                                   'description': {'old': current_group.get('description')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting group '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgs:\n+\n+    @staticmethod\n+    def _compute_changes(user_changes: Dict[str, Any],\n+                         current_user: Dict[str, Any]) -> Dict[str, Any]:\n+        changes = {}\n+        for field in [\"email\", \"first_name\", \"last_name\"]:\n+            if (current_user or {}).get(field) != user_changes.get(field):\n+                changes[field] = {\"new\": user_changes[field]}\n+                if current_user:\n+                    changes[field][\"old\"] = (current_user or {}).get(field)\n+        return changes\n+\n+    def manage(self, name: str, org_admin_user: str, org_admin_password: str, first_name: str,\n+               last_name: str, email: str, pam: bool = False,\n+               admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Manage organization.\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: organization name\n+        :param org_admin_user: organization admin user\n+        :param org_admin_password: organization admin password\n+        :param first_name: organization admin first name\n+        :param last_name: organization admin last name\n+        :param email: organization admin email\n+        :param pam: organization admin pam authentication\n+        :param admin_user: uyuni admin user\n+        :param admin_password: uyuni admin password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        current_org = None\n+        current_org_admin = None\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+            current_org_admin = __salt__['uyuni.user_get_details'](org_admin_user,\n+                                                                   org_admin_user=org_admin_user,\n+                                                                   org_admin_password=org_admin_password)\n+        except Exception as exc:\n+            if exc.faultCode != ORG_NOT_FOUND_ERROR:\n+                return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+\n+        user_paramters = {\"login\": org_admin_user, \"password\": org_admin_password, \"email\": email,\n+                          \"first_name\": first_name, \"last_name\": last_name,\n+                          \"org_admin_user\": org_admin_user, \"org_admin_password\": org_admin_password}\n+\n+        changes = self._compute_changes(user_paramters, current_org_admin)\n+        if not current_org:\n+            changes[\"org_name\"] = {\"new\": name}\n+            changes[\"org_admin_user\"] = {\"new\": org_admin_user}\n+            changes[\"pam\"] = {\"new\": pam}\n+\n+        if not changes:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(name))\n+        if __opts__['test']:\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(name), changes)\n+\n+        try:\n+            if current_org:\n+                __salt__['uyuni.user_set_details'](**user_paramters)\n+            else:\n+                __salt__['uyuni.org_create'](name=name,\n+                                             org_admin_user=org_admin_user, org_admin_password=org_admin_password,\n+                                             first_name=first_name, last_name=last_name, email=email,\n+                                             admin_user=admin_user, admin_password=admin_password, pam=pam)\n+\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org '{}': {}\".format(name, exc))\n+        else:\n+            return StateResult.prepare_result(name, True, \"{0} org successful managed\".format(name), changes)\n+\n+    def delete(self, name: str, admin_user=None, admin_password=None) -> Dict[str, Any]:\n+        \"\"\"\n+        Remove organization from the Uyuni\n+        Admin user must have SUSE Manager Administrator role to perform this action\n+\n+        :param name: Organization Name\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            current_org = __salt__['uyuni.org_get_details'](name,\n+                                                            admin_user=admin_user,\n+                                                            admin_password=admin_password)\n+        except Exception as exc:\n+            if exc.faultCode == ORG_NOT_FOUND_ERROR:\n+                return StateResult.prepare_result(name, True, \"{0} is already absent\".format(name))\n+            if exc.faultCode == AUTHENTICATION_ERROR:\n+                return StateResult.state_error(name,\n+                                               \"Error deleting organization (admin credentials error) '{}': {}\"\n+                                               .format(name, exc))\n+            raise exc\n+        else:\n+            if __opts__['test']:\n+                return StateResult.prepare_result(name, None, \"{0} would be removed\".format(name))\n+            try:\n+                __salt__['uyuni.org_delete'](name,\n+                                             admin_user=admin_user,\n+                                             admin_password=admin_password)\n+                return StateResult.prepare_result(name, True, \"Org {} has been deleted\".format(name),\n+                                                  {'name': {'old': current_org.get('name')}})\n+            except Exception as exc:\n+                return StateResult.state_error(name, \"Error deleting Org '{}': {}\".format(name, exc))\n+\n+\n+class UyuniOrgsTrust:\n+\n+    def trust(self, name: str, org_name: str, orgs_trust: List[str],\n+              admin_user: str = None, admin_password: str = None) -> Dict[str, Any]:\n+        \"\"\"\n+        Add trusted organisations to the a org\n+\n+        :param name: state name\n+        :param org_name: organization name\n+        :param orgs_trust: list of organization names to trust\n+        :param admin_user: administrator username\n+        :param admin_password: administrator password\n+        :return: dict for Salt communication\n+        \"\"\"\n+        try:\n+            org_trusts = __salt__['uyuni.org_trust_list_trusts'](org_name,\n+                                                                 admin_user=admin_user, admin_password=admin_password)\n+            current_org = __salt__['uyuni.org_get_details'](org_name,\n+                                                            admin_user=admin_user, admin_password=admin_password)\n+        except Exception as exc:\n+            return StateResult.state_error(name, \"Error managing org Trust'{}': {}\".format(org_name, exc))\n+\n+        trusts_to_add = []\n+        trusts_to_remove = []\n+        for org_trust in org_trusts:\n+            if org_trust.get(\"orgName\") in (orgs_trust or []) and not org_trust.get(\"trustEnabled\"):\n+                trusts_to_add.append(org_trust)\n+            elif org_trust.get(\"orgName\") not in (orgs_trust or []) and org_trust.get(\"trustEnabled\"):\n+                trusts_to_remove.append(org_trust)\n+\n+        if not trusts_to_add and not trusts_to_remove:\n+            return StateResult.prepare_result(name, True, \"{0} is already installed\".format(org_name))\n+        if __opts__['test']:\n+            changes = {}\n+            for org_add in trusts_to_add:\n+                changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+            return StateResult.prepare_result(name, None, \"{0} would be installed\".format(org_name), changes)\n+\n+        processed_changes = {}\n+        try:\n+            for org_add in trusts_to_add:\n+                __salt__['uyuni.org_trust_add_trust'](current_org.get(\"id\"), org_add.get(\"orgId\"),\n+                                                      admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_add.get(\"orgName\")] = {'old': None, 'new': True}\n+            for org_remove in trusts_to_remove:\n+                __salt__['uyuni.org_trust_remove_trust'](current_org.get(\"id\"), org_remove.get(\"orgId\"),\n+                                                         admin_user=admin_user, admin_password=admin_password)\n+                processed_changes[org_remove.get(\"orgName\")] = {'old': True, 'new': None}\n+        except Exception as exc:\n+            return StateResult.prepare_result(name, False, \"Error managing Org Trust '{}': {}\".format(org_name, exc),\n+                                              processed_changes)\n+        return StateResult.prepare_result(name, True, \"Org '{}' Trust successful managed\".format(org_name), processed_changes)\n+\n+\n+def __virtual__():\n+    '''\n+    TODO add a check to Only Runs in Uyuni server\n+    '''\n+    return __virtualname__\n+\n+\n+def user_present(name, password, email, first_name, last_name, use_pam_auth=False,\n+                 roles=None, system_groups=None,\n+                 org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user is present with all specified properties\n+\n+    :param name: user login name\n+    :param password: desired password for the user\n+    :param email: valid email address\n+    :param first_name: First name\n+    :param last_name: Second name\n+    :param use_pam_auth: if you wish to use PAM authentication for this user\n+    :param roles: roles to assign to user\n+    :param system_groups: system_groups to assign to user\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUsers().manage(name, password, email, first_name, last_name, use_pam_auth,\n+                               roles, system_groups,\n+                               org_admin_user, org_admin_password)\n+\n+\n+def user_channels(name, password,\n+                  manageable_channels=[], subscribable_channels=[],\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Ensure a user has access to the specified channels\n+\n+    :param name: user login name\n+    :param password: user password\n+    :param manageable_channels: channels user can manage\n+    :param subscribable_channels: channels user can subscribe\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniUserChannels().manage(name, password,\n+                                      manageable_channels, subscribable_channels,\n+                                      org_admin_user, org_admin_password)\n+\n+\n+def user_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+\n+    :param name: user login name\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return:\n+    \"\"\"\n+    return UyuniUsers().delete(name, org_admin_user, org_admin_password)\n+\n+\n+def org_present(name, org_admin_user, org_admin_password,\n+                first_name, last_name, email, pam=False,\n+                admin_user=None, admin_password=None):\n+    \"\"\"\n+    Create or update uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param org_admin_user: organization admin user\n+    :param org_admin_password: organization admin password\n+    :param first_name: organization admin first name\n+    :param last_name: organization admin last name\n+    :param email: organization admin email\n+    :param pam: organization admin pam authentication\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().manage(name, org_admin_user, org_admin_password, first_name,\n+                              last_name, email, pam,\n+                              admin_user, admin_password)\n+\n+\n+def org_absent(name, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Delete uyuni organization\n+    Admin user must have SUSE Manager Administrator role to perform this action\n+\n+    :param name: organization name\n+    :param admin_user: uyuni admin user\n+    :param admin_password: uyuni admin password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgs().delete(name, admin_user, admin_password)\n+\n+\n+def org_trust(name, org_name, trusts, admin_user=None, admin_password=None):\n+    \"\"\"\n+    Add trusted organisations from a organization.\n+    :param name: state name\n+    :param org_name: Organization name\n+    :param trusts: list of organization names to trust\n+    :param admin_user: administrator username\n+    :param admin_password: administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniOrgsTrust().trust(name, org_name, trusts, admin_user, admin_password)\n+\n+\n+def group_present(name, description, target=None, target_type=\"glob\",\n+                  org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Create or update group\n+\n+    :param name: group name\n+    :param description: group description\n+    :param target: target expression used to filter which minions should be part of the group\n+    :param target_type: target type, one of the following: glob, grain, grain_pcre, pillar, pillar_pcre,\n+            pillar_exact, compound, compound_pillar_exact. Default: glob.\n+    :param org_admin_user: organization administrator username\n+    :param org_admin_password: organization administrator password\n+    :return: dict for Salt communication\n+    \"\"\"\n+    return UyuniGroups().manage(name, description, target, target_type,\n+                                org_admin_user, org_admin_password)\n+\n+\n+def group_absent(name, org_admin_user=None, org_admin_password=None):\n+    \"\"\"\n+    Remove group from the Uyuni", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf91928c01581b92a6b3e5032b98d2f12beaf3d"}, "originalPosition": 751}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Njg2Mzkx", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-477686391", "createdAt": "2020-08-28T12:28:45Z", "commit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoyODo0NlrOHJCAsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjozMjozMlrOHJCSZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMjE3Nw==", "bodyText": "\"User\"", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479232177", "createdAt": "2020-08-28T12:28:46Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMjU3Mw==", "bodyText": "Remove 1 space", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479232573", "createdAt": "2020-08-28T12:29:06Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And  I follow \"Test-Channel-x86_64\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMzY1MA==", "bodyText": "i don't understand this title. Why is \"teardown\" repeated?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479233650", "createdAt": "2020-08-28T12:29:58Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And  I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Apply teardown configuration teardown salt state to server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzNTAyNw==", "bodyText": "Change to \"Cleanup: apply (etc)\" ?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479235027", "createdAt": "2020-08-28T12:31:05Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And  I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Apply teardown configuration teardown salt state to server", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMzY1MA=="}, "originalCommit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzNTI1Mg==", "bodyText": "Change to \"Cleanup: all (etc)\" ?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479235252", "createdAt": "2020-08-28T12:31:18Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And  I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Apply teardown configuration teardown salt state to server\n+    When I apply \"teardown_users_configuration\" local salt state on \"server\"\n+    And I manually uninstall the \"uyuni-config\" formula from the server\n+\n+  Scenario: All organizations were successfully removed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzNTU4Nw==", "bodyText": "Change to \"Cleanup: user (etc)\" ?", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479235587", "createdAt": "2020-08-28T12:31:36Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: user was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And  I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Apply teardown configuration teardown salt state to server\n+    When I apply \"teardown_users_configuration\" local salt state on \"server\"\n+    And I manually uninstall the \"uyuni-config\" formula from the server\n+\n+  Scenario: All organizations were successfully removed\n+    Given I am on the Organizations page\n+    Then I should not see a \"my_org\" text\n+    And I should not see a \"my_org2\" text\n+\n+  Scenario: User was successfully removed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzNjcxMA==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479236710", "createdAt": "2020-08-28T12:32:32Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/step_definitions/command_steps.rb", "diffHunk": "@@ -1313,3 +1313,12 @@\n   end\n   step %(I #{action} repository \"#{repo_name}\" on this \"#{host}\"#{error_control})\n end\n+\n+When(/^I apply \"([^\"]*)\" local salt state on \"([^\"]*)\"$/) do |state, host|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d09e962495e652c770a9b5b8b2d0c3bb9de4c8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Nzc0NTgz", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-477774583", "createdAt": "2020-08-28T14:27:09Z", "commit": {"oid": "bf900f37b5c8230842a5c665e7989a2342ac3887"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNDoyNzowOVrOHJIreA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNDoyODozMVrOHJIuww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM0MTQzMg==", "bodyText": "\"Salt\" big \"S\" (see Salt web site)\nSame below (several occurrences)", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479341432", "createdAt": "2020-08-28T14:27:09Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,66 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf900f37b5c8230842a5c665e7989a2342ac3887"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM0MjI3NQ==", "bodyText": "remove final blank line", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r479342275", "createdAt": "2020-08-28T14:28:31Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,66 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Cleanup: apply configuration teardown salt state to server\n+    When I apply \"teardown_users_configuration\" local salt state on \"server\"\n+    And I manually uninstall the \"uyuni-config\" formula from the server\n+\n+  Scenario: Cleanup: all organizations were successfully removed\n+    Given I am on the Organizations page\n+    Then I should not see a \"my_org\" text\n+    And I should not see a \"my_org2\" text\n+\n+  Scenario: Cleanup: user was successfully removed\n+    Given I am on the active Users page\n+    Then I should not see a \"user2\" text\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf900f37b5c8230842a5c665e7989a2342ac3887"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NzkwNzA0", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-477790704", "createdAt": "2020-08-28T14:47:02Z", "commit": {"oid": "4dc9b1bd3b3260708e5b861da802c9631c83e6f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7dd4e38df5303d0bc522833ac496b0942f1fcafa", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7dd4e38df5303d0bc522833ac496b0942f1fcafa", "committedDate": "2020-08-31T11:54:05Z", "message": "Allow connections to the FQDN, not just localhost"}, "afterCommit": {"oid": "6f44911d5056e481749c0031d3e8da10cd8adc34", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/6f44911d5056e481749c0031d3e8da10cd8adc34", "committedDate": "2020-08-31T13:33:22Z", "message": "general readme"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f84d6cf971cff1cf9fb231bccf05b4a6a7af184", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2f84d6cf971cff1cf9fb231bccf05b4a6a7af184", "committedDate": "2020-08-31T14:12:31Z", "message": "Changelogs updated"}, "afterCommit": {"oid": "b5fef8966912ed6956d83a80547026b7bce03a81", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b5fef8966912ed6956d83a80547026b7bce03a81", "committedDate": "2020-08-31T13:37:31Z", "message": "remove module-specific instructions from general readme"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjkyMTYy", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-481692162", "createdAt": "2020-09-03T10:07:46Z", "commit": {"oid": "b5fef8966912ed6956d83a80547026b7bce03a81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDowNzo0NlrOHMfr5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDowNzo0NlrOHMfr5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2NDEwMA==", "bodyText": "New line", "url": "https://github.com/uyuni-project/uyuni/pull/2502#discussion_r482864100", "createdAt": "2020-09-03T10:07:46Z", "author": {"login": "srbarrios"}, "path": "testsuite/features/secondary/srv_user_configuration_salt_states.feature", "diffHunk": "@@ -0,0 +1,65 @@\n+# Copyright (c) 2020 SUSE LLC\n+# Licensed under the terms of the MIT license.\n+\n+Feature: Create organizations, users and groups using Salt states\n+\n+  Scenario: Apply configuration salt state to server\n+    When I manually install the \"uyuni-config\" formula on the server\n+    And I apply \"setup_users_configuration\" local salt state on \"server\"\n+\n+  Scenario: Organization my_org was correctly created\n+    Given I am authorized as \"my_org_user\" with password \"my_org_user\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org2\" text in the content area\n+\n+  Scenario: Organization my_org2 was correctly created\n+    Given I am authorized as \"my_org_user2\" with password \"my_org_user2\"\n+    When I follow the left menu \"Home > My Organization\"\n+    Then I should see a \"my_org2\" text in the content area\n+    When I follow the left menu \"Home > My Organization > Organization Trusts\"\n+    Then I should see a \"my_org\" text in the content area\n+\n+  Scenario: Group was correctly created\n+    Given I am on the groups page\n+    When I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User was correctly created\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Systems > System Groups\"\n+    And I follow \"minions_group\"\n+    Then I should see a \"minions_group\" text\n+    And I should see a \"System Group Status\" text\n+\n+  Scenario: User channels permissions were assigned\n+    Given I am authorized as \"user2\" with password \"user2\"\n+    When I follow the left menu \"Software > Channel List > All\"\n+    And I follow \"Test-Channel-x86_64\"\n+    And I follow \"Managers\"\n+\n+  Scenario: User Roles were assigned\n+    Given I am on the active Users page\n+    And I follow \"user2\"\n+    Then I should see a \"User Details\" text\n+    And I should see \"role_activation_key_admin\" as checked\n+    And I should see \"role_image_admin\" as unchecked\n+    And I should see \"role_config_admin\" as checked\n+    And I should see \"role_cluster_admin\" as unchecked\n+    And I should see \"role_channel_admin\" as unchecked\n+    And I should see \"role_system_group_admin\" as unchecked\n+\n+  Scenario: Cleanup: apply configuration teardown salt state to server\n+    When I apply \"teardown_users_configuration\" local salt state on \"server\"\n+    And I manually uninstall the \"uyuni-config\" formula from the server\n+\n+  Scenario: Cleanup: all organizations were successfully removed\n+    Given I am on the Organizations page\n+    Then I should not see a \"my_org\" text\n+    And I should not see a \"my_org2\" text\n+\n+  Scenario: Cleanup: user was successfully removed\n+    Given I am on the active Users page\n+    Then I should not see a \"user2\" text", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5fef8966912ed6956d83a80547026b7bce03a81"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjkyNjE5", "url": "https://github.com/uyuni-project/uyuni/pull/2502#pullrequestreview-481692619", "createdAt": "2020-09-03T10:08:24Z", "commit": {"oid": "b5fef8966912ed6956d83a80547026b7bce03a81"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50771f54dbc94abafa445d6df8e21bb9f2e02091", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/50771f54dbc94abafa445d6df8e21bb9f2e02091", "committedDate": "2020-09-09T11:30:31Z", "message": "original code from isbm\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c8b437715cb7b515f9acb185f29756cc9e2d5d2", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/0c8b437715cb7b515f9acb185f29756cc9e2d5d2", "committedDate": "2020-09-09T11:30:31Z", "message": "support classes for RPC comunication\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc668d2324d756232d58a9bf68c45cbc050c44b4", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/cc668d2324d756232d58a9bf68c45cbc050c44b4", "committedDate": "2020-09-09T11:30:31Z", "message": "Module: user management\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34c6df58fabc5502825243a0083bee410b7cdea9", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/34c6df58fabc5502825243a0083bee410b7cdea9", "committedDate": "2020-09-09T11:30:31Z", "message": "Module: system groups\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fde6972aa51549f3a5e2443fc3de4fae7a56d50", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8fde6972aa51549f3a5e2443fc3de4fae7a56d50", "committedDate": "2020-09-09T11:30:32Z", "message": "Module: organizations\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d94964222ca825dfd7cc04a4169e1c7499ad8e5", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3d94964222ca825dfd7cc04a4169e1c7499ad8e5", "committedDate": "2020-09-09T11:30:32Z", "message": "WIP: states: user and system groups\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aa849ab8973eba3454d09688c1f91c413b11e0d", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1aa849ab8973eba3454d09688c1f91c413b11e0d", "committedDate": "2020-09-09T11:30:32Z", "message": "fixup! Module: organizations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1cda32b5829d974efa8ccea8aa4810904e124c4", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b1cda32b5829d974efa8ccea8aa4810904e124c4", "committedDate": "2020-09-09T11:30:32Z", "message": "wip: support to create orgs\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1076c8c9b7e514c047e2b23db2b4291eff1f2dfe", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1076c8c9b7e514c047e2b23db2b4291eff1f2dfe", "committedDate": "2020-09-09T11:30:32Z", "message": "Org Trust: execution modules\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "844cb494a8207c3bf6bc76ac027aa402db94d53b", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/844cb494a8207c3bf6bc76ac027aa402db94d53b", "committedDate": "2020-09-09T11:30:32Z", "message": "Org State: absent\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e38000133e15af2aa2b4d100da6be3e92ad1b032", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e38000133e15af2aa2b4d100da6be3e92ad1b032", "committedDate": "2020-09-09T11:30:32Z", "message": "update documentation\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baea718014a5328fbbfb459b16060f0e31d2415a", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/baea718014a5328fbbfb459b16060f0e31d2415a", "committedDate": "2020-09-09T11:30:32Z", "message": "state and module: organization trust\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f913df1e622c977753d568d412c48d228a0a732", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2f913df1e622c977753d568d412c48d228a0a732", "committedDate": "2020-09-09T11:30:32Z", "message": "Users: assign permissoin to groups\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58cc164a3a5ffee76d60ecf707c94b21f7c53ea6", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/58cc164a3a5ffee76d60ecf707c94b21f7c53ea6", "committedDate": "2020-09-09T11:30:32Z", "message": "User channel manager module and state\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7313211e82401aca09dbd7889dc84ebff495a36e", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7313211e82401aca09dbd7889dc84ebff495a36e", "committedDate": "2020-09-09T11:30:32Z", "message": "unit tests for RPCClient\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01e3c75737e0d6f76a398ca4788f6f5ff9f0800e", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/01e3c75737e0d6f76a398ca4788f6f5ff9f0800e", "committedDate": "2020-09-09T11:30:32Z", "message": "increase log in RPCClient class\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1285bb3d254a370bfd78c2af6d52737653c8375", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/d1285bb3d254a370bfd78c2af6d52737653c8375", "committedDate": "2020-09-09T11:30:32Z", "message": "code refactory\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cb0dc67fd0b4d1494cc66047b957e3fa3d332e7", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4cb0dc67fd0b4d1494cc66047b957e3fa3d332e7", "committedDate": "2020-09-09T11:30:32Z", "message": "user channels Subscribable support\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d48ec82b5e080fa5fba19adda79dc745c5ef044", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/6d48ec82b5e080fa5fba19adda79dc745c5ef044", "committedDate": "2020-09-09T11:30:32Z", "message": "user first and last name mandatory\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eb5f6add1a4dacfa895e9e4837fac37b91f10b5", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8eb5f6add1a4dacfa895e9e4837fac37b91f10b5", "committedDate": "2020-09-09T11:30:32Z", "message": "unit test: user present state\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56c440a59bc0e1f78edab8fc803bb42028bcff07", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/56c440a59bc0e1f78edab8fc803bb42028bcff07", "committedDate": "2020-09-09T11:30:32Z", "message": "correct bug on user.absent state\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e03ea793a23617fdf81623bb48cab69ba8dd32c4", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e03ea793a23617fdf81623bb48cab69ba8dd32c4", "committedDate": "2020-09-09T11:30:32Z", "message": "unit test: add tests for user_absent state\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1470394d2691ff04124b2f9cd4bf104462e1e0a3", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1470394d2691ff04124b2f9cd4bf104462e1e0a3", "committedDate": "2020-09-09T11:30:32Z", "message": "code cleanup: remove older state and module files\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0943c086eb8eab4a775d657eb544413e380698c", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b0943c086eb8eab4a775d657eb544413e380698c", "committedDate": "2020-09-09T11:30:33Z", "message": "add tests for user channels\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f58744cc65e744aff18c5a8437651698cdb58cc", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7f58744cc65e744aff18c5a8437651698cdb58cc", "committedDate": "2020-09-09T11:30:33Z", "message": "unit test for system groups\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a18d4d8aca9b350c73c5df9f0984ae87cbe5c77b", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a18d4d8aca9b350c73c5df9f0984ae87cbe5c77b", "committedDate": "2020-09-09T11:30:33Z", "message": "unit test for organizations\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9da8b0a2d1dcf0ecb1ed8dbd6c4817c2f737d24", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a9da8b0a2d1dcf0ecb1ed8dbd6c4817c2f737d24", "committedDate": "2020-09-09T11:30:33Z", "message": "unit test for org trust\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c6e6e9c9b1f963de7de1cbf4758d0023518f0e7", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4c6e6e9c9b1f963de7de1cbf4758d0023518f0e7", "committedDate": "2020-09-09T11:30:33Z", "message": "org trust remane parameter\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13b03c19203438a169728e2336bdfee7b575b09f", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/13b03c19203438a169728e2336bdfee7b575b09f", "committedDate": "2020-09-09T11:30:33Z", "message": "add state module hardcode example\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17ac89bbc6ef4671d0052c49f27ca0cb8c0f0c1c", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/17ac89bbc6ef4671d0052c49f27ca0cb8c0f0c1c", "committedDate": "2020-09-09T11:30:33Z", "message": "add support for users pam authentication\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60baf17693032f159a3165370da21a44b5a7b56e", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/60baf17693032f159a3165370da21a44b5a7b56e", "committedDate": "2020-09-09T11:30:33Z", "message": "add documentation for pillar ldap create users\n\nUse pillar ldap extention to extract users information\nand state file to create those users on uyuni server\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98d5a549e151ce6d31bbbe62ac1837b3fcb527d9", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/98d5a549e151ce6d31bbbe62ac1837b3fcb527d9", "committedDate": "2020-09-09T11:30:33Z", "message": "Deliver module in subpackage\n\nTest code also had to be adapted to run inside of the RPM build as well."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "919a763e9a5d014961a4b0b1dc448e9e0b4edc48", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/919a763e9a5d014961a4b0b1dc448e9e0b4edc48", "committedDate": "2020-09-09T11:30:33Z", "message": "bug solved in org trust\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04b568ac84a91188f33bebe8dd81ddfcf888d841", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/04b568ac84a91188f33bebe8dd81ddfcf888d841", "committedDate": "2020-09-09T11:30:33Z", "message": "cucumber test for configuration salt states\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e78e80fc633de60b6d4650059efc39a5fcb04d3e", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e78e80fc633de60b6d4650059efc39a5fcb04d3e", "committedDate": "2020-09-09T11:30:33Z", "message": "rename state and modules files to uyuni_config.py\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b5a183315d1b2f1eeeffbdcbd73265526ec582d", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2b5a183315d1b2f1eeeffbdcbd73265526ec582d", "committedDate": "2020-09-09T11:30:33Z", "message": "review at cucumber test\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8422e73b5a9d7cd44ea2a40b84e1afcf8ee2725", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e8422e73b5a9d7cd44ea2a40b84e1afcf8ee2725", "committedDate": "2020-09-09T11:30:33Z", "message": "rename example file to match state name\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48d2e97b653bc12639c112c54090314dfe93385e", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/48d2e97b653bc12639c112c54090314dfe93385e", "committedDate": "2020-09-09T11:30:33Z", "message": "spec: include examples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd8a57b392abde83ea67c3a79e053ab99177a722", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/bd8a57b392abde83ea67c3a79e053ab99177a722", "committedDate": "2020-09-09T11:30:33Z", "message": "Rename package to Uyuni neutral name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3cc1ec4e33fe44120dcbd0bbce4b52e0902670b", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a3cc1ec4e33fe44120dcbd0bbce4b52e0902670b", "committedDate": "2020-09-09T11:30:33Z", "message": "testsuite: install/uninstall module packages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "830dabebf411b12c5bdc5a1caafdd9a13d094e92", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/830dabebf411b12c5bdc5a1caafdd9a13d094e92", "committedDate": "2020-09-09T11:30:33Z", "message": "Add missing newline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d780c07fa18a4f3bc2c0a65f2caf5a173bf92f22", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/d780c07fa18a4f3bc2c0a65f2caf5a173bf92f22", "committedDate": "2020-09-09T11:30:33Z", "message": "update execution module dcumentation\n\nSigned-off-by: Ricardo Mateus <rmateus@suse.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de8b033ec4b3f36d79becf578150dc8658a08297", "author": {"user": {"login": "rjmateus", "name": "Ricardo Mateus"}}, "url": "https://github.com/uyuni-project/uyuni/commit/de8b033ec4b3f36d79becf578150dc8658a08297", "committedDate": "2020-09-09T11:30:33Z", "message": "Update susemanager-utils/susemanager-sls/src/examples/ldap/orgs.sls\n\nCo-authored-by: Silvio Moioli <smoioli@suse.de>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1067, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}