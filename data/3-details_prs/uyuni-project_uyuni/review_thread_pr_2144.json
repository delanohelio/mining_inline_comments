{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2NzQwODU0", "number": 2144, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOToxMzozNlrOD39bBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyNToyOVrOETOtaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDA0NjE0OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/postgres/triggers/suseMaintenanceCalendar.sql", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOToxMzozNlrOGOgt5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOToxMzozNlrOGOgt5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTI4NQ==", "bodyText": "I wonderif the triggers for this and the other table are not necessarily needed. We always modify the entities using hibernate, the @UpdateTimestamp in BaseDomainHelper should do the trick.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r417869285", "createdAt": "2020-04-30T09:13:36Z", "author": {"login": "hustodemon"}, "path": "schema/spacewalk/postgres/triggers/suseMaintenanceCalendar.sql", "diffHunk": "@@ -0,0 +1,25 @@\n+--\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- triggers for suseMaintenanceCalendar\n+\n+create or replace function suse_mtcal_mod_trig_fun() returns trigger as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6893cea05627b65168e9b59e9de43e97bbbda58"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDA1MjcxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/action/ActionType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOToxNToyNFrOGOgyDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozODoyM1rOGR2mPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg3MDM0OQ==", "bodyText": "I'd suggest using camelCase (even though that the other attributes don't use it (which is ugly :) )).", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r417870349", "createdAt": "2020-04-30T09:15:24Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/domain/action/ActionType.java", "diffHunk": "@@ -30,6 +30,7 @@\n     private String name;\n     private Character triggersnapshot;\n     private Character unlockedonly;\n+    private boolean maintenancemodeonly;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6893cea05627b65168e9b59e9de43e97bbbda58"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzUwMw==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r421373503", "createdAt": "2020-05-07T09:38:23Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/redhat/rhn/domain/action/ActionType.java", "diffHunk": "@@ -30,6 +30,7 @@\n     private String name;\n     private Character triggersnapshot;\n     private Character unlockedonly;\n+    private boolean maintenancemodeonly;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg3MDM0OQ=="}, "originalCommit": {"oid": "c6893cea05627b65168e9b59e9de43e97bbbda58"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTQzMjQ4OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceCalendar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzoxMTowN1rOGRSNrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMToyNjo1M1rOGR6Log==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc3NzM4OQ==", "bodyText": "I'd be careful with the lazy fetching here. The org attribute is part of hashCode, equals and toString, meaning that any operation using these (like putting a MaintenanceCalendar into a set, or printing it to the log) can fire a SELECT. I'd stick to the default here (when you don't specify the fetch strategy on @ManyToOne, then \"eager\" strategy is used). Being eager here shouldn't really have big performance impact. It also shouldn't pollute the session with a lot of object, since mostly we will deal with a lot of maintenance schedules from the same org.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420777389", "createdAt": "2020-05-06T13:11:07Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceCalendar.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.domain.BaseDomainHelper;\n+import com.redhat.rhn.domain.org.Org;\n+\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+\n+import java.util.Optional;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+@Entity\n+@Table(name = \"suseMaintenanceCalendar\")\n+@NamedQueries\n+({\n+    @NamedQuery(name = \"MaintenanceCalendar.lookupByUserAndName\",\n+        query = \"from com.suse.manager.model.maintenance.MaintenanceCalendar c \" +\n+                \"where c.org.id = :orgId and c.label = :label\")\n+})\n+public class MaintenanceCalendar extends BaseDomainHelper {\n+    private Long id;\n+    private Org org;\n+    private String label;\n+    private String url;\n+    private String ical;\n+\n+    /**\n+     * @return the id\n+     */\n+    @Id\n+    @Column(name = \"id\")\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"mtcal_seq\")\n+    @SequenceGenerator(name = \"mtcal_seq\", sequenceName = \"suse_mtcal_id_seq\", allocationSize = 1)\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the organization\n+     */\n+    @ManyToOne(fetch = FetchType.LAZY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10e17c10a6249dc794ae6367fcb537a1ccf5159"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQzMjIyNg==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r421432226", "createdAt": "2020-05-07T11:26:53Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceCalendar.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.domain.BaseDomainHelper;\n+import com.redhat.rhn.domain.org.Org;\n+\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+\n+import java.util.Optional;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+@Entity\n+@Table(name = \"suseMaintenanceCalendar\")\n+@NamedQueries\n+({\n+    @NamedQuery(name = \"MaintenanceCalendar.lookupByUserAndName\",\n+        query = \"from com.suse.manager.model.maintenance.MaintenanceCalendar c \" +\n+                \"where c.org.id = :orgId and c.label = :label\")\n+})\n+public class MaintenanceCalendar extends BaseDomainHelper {\n+    private Long id;\n+    private Org org;\n+    private String label;\n+    private String url;\n+    private String ical;\n+\n+    /**\n+     * @return the id\n+     */\n+    @Id\n+    @Column(name = \"id\")\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"mtcal_seq\")\n+    @SequenceGenerator(name = \"mtcal_seq\", sequenceName = \"suse_mtcal_id_seq\", allocationSize = 1)\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the organization\n+     */\n+    @ManyToOne(fetch = FetchType.LAZY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc3NzM4OQ=="}, "originalCommit": {"oid": "e10e17c10a6249dc794ae6367fcb537a1ccf5159"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTQ0OTkwOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceSchedule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzoxNTowNFrOGRSYZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMToyNjo1OFrOGR6L0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4MDEzMg==", "bodyText": "Same here.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420780132", "createdAt": "2020-05-06T13:15:04Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceSchedule.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.domain.BaseDomainHelper;\n+import com.redhat.rhn.domain.org.Org;\n+\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+\n+import java.util.Optional;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+/**\n+ * MaintenanceSchedule - store maintenance schedule objects\n+ */\n+@Entity\n+@Table(name = \"suseMaintenanceSchedule\")\n+@NamedQueries\n+({\n+    @NamedQuery(name = \"MaintenanceSchedule.lookupByUserAndName\",\n+        query = \"from com.suse.manager.model.maintenance.MaintenanceSchedule s \" +\n+                \"where s.org.id = :orgId and s.name = :name\")\n+})\n+public class MaintenanceSchedule extends BaseDomainHelper {\n+    private Long id;\n+    private Org org;\n+    private String name;\n+    private ScheduleType scheduleType;\n+    private MaintenanceCalendar calendar;\n+\n+    public enum ScheduleType {\n+        SINGLE(\"single\"),\n+        MULTI(\"multi\");\n+\n+        private String label;\n+\n+        ScheduleType(String labelIn) {\n+            this.label = labelIn;\n+        }\n+\n+        /**\n+         * Gets the label.\n+         *\n+         * @return label\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * Looks up ScheduleType by label\n+         *\n+         * @param label the label\n+         * @throws java.lang.IllegalArgumentException if no matching schedule type is found\n+         * @return the matching schedule type\n+         */\n+        public static ScheduleType lookupByLabel(String label) {\n+            for (ScheduleType value : values()) {\n+                if (value.label.equals(label)) {\n+                    return value;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Unsupported label: \" + label);\n+        }\n+    }\n+\n+    /**\n+     * @return the maintenance schedule id\n+     */\n+    @Id\n+    @Column(name = \"id\")\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"mtsched_seq\")\n+    @SequenceGenerator(name = \"mtsched_seq\", sequenceName = \"suse_mtsched_id_seq\", allocationSize = 1)\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the organization\n+     */\n+    @ManyToOne(fetch = FetchType.LAZY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10e17c10a6249dc794ae6367fcb537a1ccf5159"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQzMjI3NA==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r421432274", "createdAt": "2020-05-07T11:26:58Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceSchedule.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.domain.BaseDomainHelper;\n+import com.redhat.rhn.domain.org.Org;\n+\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+\n+import java.util.Optional;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+/**\n+ * MaintenanceSchedule - store maintenance schedule objects\n+ */\n+@Entity\n+@Table(name = \"suseMaintenanceSchedule\")\n+@NamedQueries\n+({\n+    @NamedQuery(name = \"MaintenanceSchedule.lookupByUserAndName\",\n+        query = \"from com.suse.manager.model.maintenance.MaintenanceSchedule s \" +\n+                \"where s.org.id = :orgId and s.name = :name\")\n+})\n+public class MaintenanceSchedule extends BaseDomainHelper {\n+    private Long id;\n+    private Org org;\n+    private String name;\n+    private ScheduleType scheduleType;\n+    private MaintenanceCalendar calendar;\n+\n+    public enum ScheduleType {\n+        SINGLE(\"single\"),\n+        MULTI(\"multi\");\n+\n+        private String label;\n+\n+        ScheduleType(String labelIn) {\n+            this.label = labelIn;\n+        }\n+\n+        /**\n+         * Gets the label.\n+         *\n+         * @return label\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * Looks up ScheduleType by label\n+         *\n+         * @param label the label\n+         * @throws java.lang.IllegalArgumentException if no matching schedule type is found\n+         * @return the matching schedule type\n+         */\n+        public static ScheduleType lookupByLabel(String label) {\n+            for (ScheduleType value : values()) {\n+                if (value.label.equals(label)) {\n+                    return value;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Unsupported label: \" + label);\n+        }\n+    }\n+\n+    /**\n+     * @return the maintenance schedule id\n+     */\n+    @Id\n+    @Column(name = \"id\")\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"mtsched_seq\")\n+    @SequenceGenerator(name = \"mtsched_seq\", sequenceName = \"suse_mtsched_id_seq\", allocationSize = 1)\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the organization\n+     */\n+    @ManyToOne(fetch = FetchType.LAZY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4MDEzMg=="}, "originalCommit": {"oid": "e10e17c10a6249dc794ae6367fcb537a1ccf5159"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTQ2MDUwOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceSchedule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzoxNzozN1rOGRSfFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMToyODowOVrOGR6OUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4MTg0Nw==", "bodyText": "Now I remember our discussion about optional attributes on hibernate entities. If you want to use getCalendar, that return optional, you can move the annotations from the getter to the calendar field. But that's a subtle detail, feel free to keep it this way!", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420781847", "createdAt": "2020-05-06T13:17:37Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceSchedule.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.domain.BaseDomainHelper;\n+import com.redhat.rhn.domain.org.Org;\n+\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+\n+import java.util.Optional;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+/**\n+ * MaintenanceSchedule - store maintenance schedule objects\n+ */\n+@Entity\n+@Table(name = \"suseMaintenanceSchedule\")\n+@NamedQueries\n+({\n+    @NamedQuery(name = \"MaintenanceSchedule.lookupByUserAndName\",\n+        query = \"from com.suse.manager.model.maintenance.MaintenanceSchedule s \" +\n+                \"where s.org.id = :orgId and s.name = :name\")\n+})\n+public class MaintenanceSchedule extends BaseDomainHelper {\n+    private Long id;\n+    private Org org;\n+    private String name;\n+    private ScheduleType scheduleType;\n+    private MaintenanceCalendar calendar;\n+\n+    public enum ScheduleType {\n+        SINGLE(\"single\"),\n+        MULTI(\"multi\");\n+\n+        private String label;\n+\n+        ScheduleType(String labelIn) {\n+            this.label = labelIn;\n+        }\n+\n+        /**\n+         * Gets the label.\n+         *\n+         * @return label\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * Looks up ScheduleType by label\n+         *\n+         * @param label the label\n+         * @throws java.lang.IllegalArgumentException if no matching schedule type is found\n+         * @return the matching schedule type\n+         */\n+        public static ScheduleType lookupByLabel(String label) {\n+            for (ScheduleType value : values()) {\n+                if (value.label.equals(label)) {\n+                    return value;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Unsupported label: \" + label);\n+        }\n+    }\n+\n+    /**\n+     * @return the maintenance schedule id\n+     */\n+    @Id\n+    @Column(name = \"id\")\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"mtsched_seq\")\n+    @SequenceGenerator(name = \"mtsched_seq\", sequenceName = \"suse_mtsched_id_seq\", allocationSize = 1)\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the organization\n+     */\n+    @ManyToOne(fetch = FetchType.LAZY)\n+    @JoinColumn(name = \"org_id\", nullable = false)\n+    public Org getOrg() {\n+        return org;\n+    }\n+\n+    /**\n+     * @return the schedule name\n+     */\n+    @Column(name = \"name\")\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * @return the schedule type\n+     */\n+    @Column(name = \"sched_type\")\n+    @Enumerated(EnumType.STRING)\n+    public ScheduleType getScheduleType() {\n+        return scheduleType;\n+    }\n+\n+    /**\n+     * @return the calendar\n+     */\n+    @ManyToOne()\n+    @JoinColumn(name = \"ical_id\", nullable = true)\n+    protected MaintenanceCalendar getCalendar() {\n+        return calendar;\n+    }\n+\n+    /**\n+     * @return the calendar as optional\n+     */\n+    @Transient\n+    public Optional<MaintenanceCalendar> getCalendarOpt() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10e17c10a6249dc794ae6367fcb537a1ccf5159"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQzMjkxNA==", "bodyText": "That had other downsides if I remember. The behavior of hibernate is different when you assign it to getter or to fields. I better keep it like it is", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r421432914", "createdAt": "2020-05-07T11:28:09Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/model/maintenance/MaintenanceSchedule.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.domain.BaseDomainHelper;\n+import com.redhat.rhn.domain.org.Org;\n+\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+\n+import java.util.Optional;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.NamedQueries;\n+import javax.persistence.NamedQuery;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n+\n+/**\n+ * MaintenanceSchedule - store maintenance schedule objects\n+ */\n+@Entity\n+@Table(name = \"suseMaintenanceSchedule\")\n+@NamedQueries\n+({\n+    @NamedQuery(name = \"MaintenanceSchedule.lookupByUserAndName\",\n+        query = \"from com.suse.manager.model.maintenance.MaintenanceSchedule s \" +\n+                \"where s.org.id = :orgId and s.name = :name\")\n+})\n+public class MaintenanceSchedule extends BaseDomainHelper {\n+    private Long id;\n+    private Org org;\n+    private String name;\n+    private ScheduleType scheduleType;\n+    private MaintenanceCalendar calendar;\n+\n+    public enum ScheduleType {\n+        SINGLE(\"single\"),\n+        MULTI(\"multi\");\n+\n+        private String label;\n+\n+        ScheduleType(String labelIn) {\n+            this.label = labelIn;\n+        }\n+\n+        /**\n+         * Gets the label.\n+         *\n+         * @return label\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * Looks up ScheduleType by label\n+         *\n+         * @param label the label\n+         * @throws java.lang.IllegalArgumentException if no matching schedule type is found\n+         * @return the matching schedule type\n+         */\n+        public static ScheduleType lookupByLabel(String label) {\n+            for (ScheduleType value : values()) {\n+                if (value.label.equals(label)) {\n+                    return value;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Unsupported label: \" + label);\n+        }\n+    }\n+\n+    /**\n+     * @return the maintenance schedule id\n+     */\n+    @Id\n+    @Column(name = \"id\")\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"mtsched_seq\")\n+    @SequenceGenerator(name = \"mtsched_seq\", sequenceName = \"suse_mtsched_id_seq\", allocationSize = 1)\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @return the organization\n+     */\n+    @ManyToOne(fetch = FetchType.LAZY)\n+    @JoinColumn(name = \"org_id\", nullable = false)\n+    public Org getOrg() {\n+        return org;\n+    }\n+\n+    /**\n+     * @return the schedule name\n+     */\n+    @Column(name = \"name\")\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * @return the schedule type\n+     */\n+    @Column(name = \"sched_type\")\n+    @Enumerated(EnumType.STRING)\n+    public ScheduleType getScheduleType() {\n+        return scheduleType;\n+    }\n+\n+    /**\n+     * @return the calendar\n+     */\n+    @ManyToOne()\n+    @JoinColumn(name = \"ical_id\", nullable = true)\n+    protected MaintenanceCalendar getCalendar() {\n+        return calendar;\n+    }\n+\n+    /**\n+     * @return the calendar as optional\n+     */\n+    @Transient\n+    public Optional<MaintenanceCalendar> getCalendarOpt() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4MTg0Nw=="}, "originalCommit": {"oid": "e10e17c10a6249dc794ae6367fcb537a1ccf5159"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTQ5MDU1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/common/util/http/HttpClientAdapter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzoyNDoyNVrOGRSx3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMToyOTo0MlrOGR6RRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4NjY1Mw==", "bodyText": "These values will be used also by existing code (SCC client, for instance). Are 5 seconds reasonable for it?", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420786653", "createdAt": "2020-05-06T13:24:25Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/common/util/http/HttpClientAdapter.java", "diffHunk": "@@ -113,6 +115,9 @@ public HttpClientAdapter() {\n \n         clientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n         Builder requestConfigBuilder = RequestConfig.custom()\n+                .setConnectionRequestTimeout(5000)\n+                .setConnectTimeout(Config.get().getInt(HTTP_CONNECTION_TIMEOUT, 5000))\n+                .setSocketTimeout(Config.get().getInt(HTTP_SOCKET_TIMEOUT, 5000))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3640b21fd7515c54756d7e5be8b99126d1fe466"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQzMzY2OQ==", "bodyText": "I think yes. Socket timeout means, 5 seconds without data going over the line.\nBut I think about changing the default to 10 seconds as this was a timeout used by salt-api for example.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r421433669", "createdAt": "2020-05-07T11:29:42Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/redhat/rhn/common/util/http/HttpClientAdapter.java", "diffHunk": "@@ -113,6 +115,9 @@ public HttpClientAdapter() {\n \n         clientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n         Builder requestConfigBuilder = RequestConfig.custom()\n+                .setConnectionRequestTimeout(5000)\n+                .setConnectTimeout(Config.get().getInt(HTTP_CONNECTION_TIMEOUT, 5000))\n+                .setSocketTimeout(Config.get().getInt(HTTP_SOCKET_TIMEOUT, 5000))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4NjY1Mw=="}, "originalCommit": {"oid": "a3640b21fd7515c54756d7e5be8b99126d1fe466"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTU0NDY3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzozNjowMFrOGRTS8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMTozNDozNVrOGR6anA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5NTEyMg==", "bodyText": "Nit: You can use directly  list() instead of stream().", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420795122", "createdAt": "2020-05-06T13:36:00Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.maintenance;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+import com.suse.manager.utils.HttpHelper;\n+\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.ParseException;\n+import org.apache.http.StatusLine;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * MaintenanceManager\n+ */\n+public class MaintenanceManager {\n+\n+    private static volatile MaintenanceManager instance = null;\n+\n+    /**\n+     * Instantiate Maintenance Manager object\n+     *\n+     * @return MaintenanceManager object\n+     */\n+    public static MaintenanceManager instance() {\n+        if (instance == null) {\n+            synchronized (MaintenanceManager.class) {\n+                if (instance == null) {\n+                    instance = new MaintenanceManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        getSession().save(schedule);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        getSession().remove(schedule);\n+    }\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        getSession().remove(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Schedule Names belong to the given User\n+     * @param user the user\n+     * @return a list of Schedule names\n+     */\n+    public List<String> listScheduleNamesByUser(User user) {\n+        @SuppressWarnings(\"unchecked\")\n+        Stream<String> names = getSession()\n+            .createQuery(\"SELECT name FROM MaintenanceSchedule WHERE org = :org\")\n+            .setParameter(\"org\", user.getOrg())\n+            .stream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32775b7518c9ddf2a0f9531fc4eed4a85b6df559"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQzNjA2MA==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r421436060", "createdAt": "2020-05-07T11:34:35Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.maintenance;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+import com.suse.manager.utils.HttpHelper;\n+\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.ParseException;\n+import org.apache.http.StatusLine;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * MaintenanceManager\n+ */\n+public class MaintenanceManager {\n+\n+    private static volatile MaintenanceManager instance = null;\n+\n+    /**\n+     * Instantiate Maintenance Manager object\n+     *\n+     * @return MaintenanceManager object\n+     */\n+    public static MaintenanceManager instance() {\n+        if (instance == null) {\n+            synchronized (MaintenanceManager.class) {\n+                if (instance == null) {\n+                    instance = new MaintenanceManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        getSession().save(schedule);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        getSession().remove(schedule);\n+    }\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        getSession().remove(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Schedule Names belong to the given User\n+     * @param user the user\n+     * @return a list of Schedule names\n+     */\n+    public List<String> listScheduleNamesByUser(User user) {\n+        @SuppressWarnings(\"unchecked\")\n+        Stream<String> names = getSession()\n+            .createQuery(\"SELECT name FROM MaintenanceSchedule WHERE org = :org\")\n+            .setParameter(\"org\", user.getOrg())\n+            .stream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5NTEyMg=="}, "originalCommit": {"oid": "32775b7518c9ddf2a0f9531fc4eed4a85b6df559"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTU0ODA3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzozNjo0NFrOGRTVJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzozNjo0NFrOGRTVJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5NTY4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Create a Maintenance Scheudle\n          \n          \n            \n                 * Create a Maintenance Schedule", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420795687", "createdAt": "2020-05-06T13:36:44Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.maintenance;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+import com.suse.manager.utils.HttpHelper;\n+\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.ParseException;\n+import org.apache.http.StatusLine;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * MaintenanceManager\n+ */\n+public class MaintenanceManager {\n+\n+    private static volatile MaintenanceManager instance = null;\n+\n+    /**\n+     * Instantiate Maintenance Manager object\n+     *\n+     * @return MaintenanceManager object\n+     */\n+    public static MaintenanceManager instance() {\n+        if (instance == null) {\n+            synchronized (MaintenanceManager.class) {\n+                if (instance == null) {\n+                    instance = new MaintenanceManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        getSession().save(schedule);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        getSession().remove(schedule);\n+    }\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        getSession().remove(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Schedule Names belong to the given User\n+     * @param user the user\n+     * @return a list of Schedule names\n+     */\n+    public List<String> listScheduleNamesByUser(User user) {\n+        @SuppressWarnings(\"unchecked\")\n+        Stream<String> names = getSession()\n+            .createQuery(\"SELECT name FROM MaintenanceSchedule WHERE org = :org\")\n+            .setParameter(\"org\", user.getOrg())\n+            .stream();\n+        return names.collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Lookup a MaintenanceSchedule by user and name\n+     * @param user the user\n+     * @param name the schedule name\n+     * @return Optional Maintenance Schedule\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Optional<MaintenanceSchedule> lookupMaintenanceScheduleByUserAndName(User user, String name) {\n+        return getSession().createNamedQuery(\"MaintenanceSchedule.lookupByUserAndName\")\n+            .setParameter(\"orgId\", user.getOrg().getId())\n+            .setParameter(\"name\", name)\n+            .uniqueResultOptional();\n+    }\n+\n+    /**\n+     * Create a Maintenance Scheudle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32775b7518c9ddf2a0f9531fc4eed4a85b6df559"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTU1NTEzOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzozODoyMFrOGRTZvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzozODoyMFrOGRTZvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5Njg2Mg==", "bodyText": "Same here: list can be used directly on that query.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420796862", "createdAt": "2020-05-06T13:38:20Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.maintenance;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+import com.suse.manager.utils.HttpHelper;\n+\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.ParseException;\n+import org.apache.http.StatusLine;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * MaintenanceManager\n+ */\n+public class MaintenanceManager {\n+\n+    private static volatile MaintenanceManager instance = null;\n+\n+    /**\n+     * Instantiate Maintenance Manager object\n+     *\n+     * @return MaintenanceManager object\n+     */\n+    public static MaintenanceManager instance() {\n+        if (instance == null) {\n+            synchronized (MaintenanceManager.class) {\n+                if (instance == null) {\n+                    instance = new MaintenanceManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        getSession().save(schedule);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        getSession().remove(schedule);\n+    }\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        getSession().remove(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Schedule Names belong to the given User\n+     * @param user the user\n+     * @return a list of Schedule names\n+     */\n+    public List<String> listScheduleNamesByUser(User user) {\n+        @SuppressWarnings(\"unchecked\")\n+        Stream<String> names = getSession()\n+            .createQuery(\"SELECT name FROM MaintenanceSchedule WHERE org = :org\")\n+            .setParameter(\"org\", user.getOrg())\n+            .stream();\n+        return names.collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Lookup a MaintenanceSchedule by user and name\n+     * @param user the user\n+     * @param name the schedule name\n+     * @return Optional Maintenance Schedule\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Optional<MaintenanceSchedule> lookupMaintenanceScheduleByUserAndName(User user, String name) {\n+        return getSession().createNamedQuery(\"MaintenanceSchedule.lookupByUserAndName\")\n+            .setParameter(\"orgId\", user.getOrg().getId())\n+            .setParameter(\"name\", name)\n+            .uniqueResultOptional();\n+    }\n+\n+    /**\n+     * Create a Maintenance Scheudle\n+     * @param user the creator\n+     * @param name the schedule name\n+     * @param type the schedule type\n+     * @param calendar and optional Maintenance Calendar\n+     * @return the created Maintenance Schedule\n+     */\n+    public MaintenanceSchedule createMaintenanceSchedule(User user, String name, ScheduleType type,\n+            Optional<MaintenanceCalendar> calendar) {\n+        MaintenanceSchedule ms = new MaintenanceSchedule();\n+        ms.setOrg(user.getOrg());\n+        ms.setName(name);\n+        ms.setScheduleType(type);\n+        calendar.ifPresent(ms::setCalendar);\n+        save(ms);\n+        return ms;\n+    }\n+\n+    /**\n+     * Update a MaintenanceSchedule\n+     * @param user the user\n+     * @param name the schedule name\n+     * @param details values which should be changed (name, type, calendar)\n+     * @return the updated MaintenanceSchedule\n+     */\n+    public MaintenanceSchedule updateMaintenanceSchedule(User user, String name, Map<String, String> details) {\n+        MaintenanceSchedule schedule = lookupMaintenanceScheduleByUserAndName(user, name)\n+                .orElseThrow(() -> new EntityNotExistsException(name));\n+        if (details.containsKey(\"name\")) {\n+            // TODO: should the identifier really be changeable?\n+            schedule.setName(details.get(\"name\"));\n+        }\n+        if (details.containsKey(\"type\")) {\n+            schedule.setScheduleType(ScheduleType.lookupByLabel(details.get(\"type\")));\n+        }\n+        if (details.containsKey(\"calendar\")) {\n+            MaintenanceCalendar calendar = lookupCalendarByUserAndLabel(user, details.get(\"calendar\"))\n+                .orElseThrow(() -> new EntityNotExistsException(details.get(\"calendar\")));\n+\n+            schedule.setCalendar(calendar);\n+        }\n+        save(schedule);\n+        manageAffectedScheduledActions(user, schedule, Collections.EMPTY_LIST);\n+        return schedule;\n+    }\n+\n+    /**\n+     * List Maintenance Calendar Labels belonging to the given User\n+     * @param user the user\n+     * @return a list of Calendar labels\n+     */\n+    public List<String> listCalendarLabelsByUser(User user) {\n+        Stream<String> labels = getSession()\n+                .createQuery(\"SELECT label FROM MaintenanceCalendar WHERE org = :org\")\n+                .setParameter(\"org\", user.getOrg())\n+                .stream();\n+        return labels.collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32775b7518c9ddf2a0f9531fc4eed4a85b6df559"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTYwMTQxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo0Nzo0M1rOGRT2YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzozNDoyMFrOGR-xNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNDE5Mg==", "bodyText": "We should also make sure that if the entity already exists, we throw a reasonable exception. A check could be added in MaintenanceManager.createMaintenanceSchedule() that throws EntityExistsException, that would be turned into a fault here.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420804192", "createdAt": "2020-05-06T13:47:43Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.maintenance;\n+\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Maintenance Schedule XMLRPC Handler\n+ *\n+ * @xmlrpc.namespace maintenance\n+ * @xmlrpc.doc Provides methods to access and modify Maintenance Schedules related entities\n+ */\n+public class MaintenanceHandler extends BaseHandler {\n+\n+    private final MaintenanceManager mm = MaintenanceManager.instance();\n+\n+    /**\n+     * List Schedule Names visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of schedule names\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance schedule names\")\n+     */\n+    public List<String> listScheduleNames(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listScheduleNamesByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return the Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule getScheduleDetails(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(name));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param type schedule type\n+     * @return the new Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param #param_desc(\"string\", \"type\", \"Schedule type: single, multi\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule createSchedule(User loggedInUser, String name, String type) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceSchedule(loggedInUser, name, ScheduleType.lookupByLabel(type),\n+                Optional.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNzM4Mw==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r421507383", "createdAt": "2020-05-07T13:34:20Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.maintenance;\n+\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Maintenance Schedule XMLRPC Handler\n+ *\n+ * @xmlrpc.namespace maintenance\n+ * @xmlrpc.doc Provides methods to access and modify Maintenance Schedules related entities\n+ */\n+public class MaintenanceHandler extends BaseHandler {\n+\n+    private final MaintenanceManager mm = MaintenanceManager.instance();\n+\n+    /**\n+     * List Schedule Names visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of schedule names\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance schedule names\")\n+     */\n+    public List<String> listScheduleNames(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listScheduleNamesByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return the Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule getScheduleDetails(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(name));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param type schedule type\n+     * @return the new Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param #param_desc(\"string\", \"type\", \"Schedule type: single, multi\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule createSchedule(User loggedInUser, String name, String type) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceSchedule(loggedInUser, name, ScheduleType.lookupByLabel(type),\n+                Optional.empty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNDE5Mg=="}, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTYwNjI1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo0ODo0M1rOGRT5eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo0ODo0M1rOGRT5eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNDk4Ng==", "bodyText": "Typo: a EntityNotExistsException instance should be caught.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420804986", "createdAt": "2020-05-06T13:48:43Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.maintenance;\n+\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Maintenance Schedule XMLRPC Handler\n+ *\n+ * @xmlrpc.namespace maintenance\n+ * @xmlrpc.doc Provides methods to access and modify Maintenance Schedules related entities\n+ */\n+public class MaintenanceHandler extends BaseHandler {\n+\n+    private final MaintenanceManager mm = MaintenanceManager.instance();\n+\n+    /**\n+     * List Schedule Names visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of schedule names\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance schedule names\")\n+     */\n+    public List<String> listScheduleNames(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listScheduleNamesByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return the Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule getScheduleDetails(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(name));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param type schedule type\n+     * @return the new Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param #param_desc(\"string\", \"type\", \"Schedule type: single, multi\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule createSchedule(User loggedInUser, String name, String type) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceSchedule(loggedInUser, name, ScheduleType.lookupByLabel(type),\n+                Optional.empty());\n+    }\n+\n+    /**\n+     * Update a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param details values to update\n+     * @return the changed Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Update a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param\n+     *     #struct_begin(\"Maintenance Schedule Details\")\n+     *         #prop_desc(\"string\", \"name\", \"new Schedule Name\")\n+     *         #prop_desc(\"string\", \"type\", \"new Schedule Type\")\n+     *           #options()\n+     *               #item(\"single\")\n+     *               #item(\"multi\"\")\n+     *           #options_end()\n+     *         #prop_desc(\"string\", \"calendar\", \"new calendar label\")\n+     *     #struct_end()\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule updateSchedule(User loggedInUser, String name, Map<String, String> details) {\n+        ensureOrgAdmin(loggedInUser);\n+\n+        // confirm that the user only provided valid keys in the map\n+        Set<String> validKeys = new HashSet<String>();\n+        validKeys.add(\"name\");\n+        validKeys.add(\"type\");\n+        validKeys.add(\"calendar\");\n+        validateMap(validKeys, details);\n+\n+        try {\n+            return mm.updateMaintenanceSchedule(loggedInUser, name, details);\n+        }\n+        catch (EntityNotExistsFaultException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTYxMzk0OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MDoxMVrOGRT-Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MDoxMVrOGRT-Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNjE5NQ==", "bodyText": "Same thing as with createSchedule - an existence check would be cool.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420806195", "createdAt": "2020-05-06T13:50:11Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.maintenance;\n+\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Maintenance Schedule XMLRPC Handler\n+ *\n+ * @xmlrpc.namespace maintenance\n+ * @xmlrpc.doc Provides methods to access and modify Maintenance Schedules related entities\n+ */\n+public class MaintenanceHandler extends BaseHandler {\n+\n+    private final MaintenanceManager mm = MaintenanceManager.instance();\n+\n+    /**\n+     * List Schedule Names visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of schedule names\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance schedule names\")\n+     */\n+    public List<String> listScheduleNames(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listScheduleNamesByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return the Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule getScheduleDetails(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(name));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param type schedule type\n+     * @return the new Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param #param_desc(\"string\", \"type\", \"Schedule type: single, multi\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule createSchedule(User loggedInUser, String name, String type) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceSchedule(loggedInUser, name, ScheduleType.lookupByLabel(type),\n+                Optional.empty());\n+    }\n+\n+    /**\n+     * Update a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param details values to update\n+     * @return the changed Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Update a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param\n+     *     #struct_begin(\"Maintenance Schedule Details\")\n+     *         #prop_desc(\"string\", \"name\", \"new Schedule Name\")\n+     *         #prop_desc(\"string\", \"type\", \"new Schedule Type\")\n+     *           #options()\n+     *               #item(\"single\")\n+     *               #item(\"multi\"\")\n+     *           #options_end()\n+     *         #prop_desc(\"string\", \"calendar\", \"new calendar label\")\n+     *     #struct_end()\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule updateSchedule(User loggedInUser, String name, Map<String, String> details) {\n+        ensureOrgAdmin(loggedInUser);\n+\n+        // confirm that the user only provided valid keys in the map\n+        Set<String> validKeys = new HashSet<String>();\n+        validKeys.add(\"name\");\n+        validKeys.add(\"type\");\n+        validKeys.add(\"calendar\");\n+        validateMap(validKeys, details);\n+\n+        try {\n+            return mm.updateMaintenanceSchedule(loggedInUser, name, details);\n+        }\n+        catch (EntityNotExistsFaultException e) {\n+            throw new EntityNotExistsFaultException(e);\n+        }\n+    }\n+\n+    /**\n+     * Delete a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return number of removed objects\n+     *\n+     * @xmlrpc.doc Remove a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype #return_int_success()\n+     */\n+    public int deleteSchedule(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        Optional<MaintenanceSchedule> schedule = mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name);\n+        mm.remove(schedule.orElseThrow(() -> new EntityNotExistsFaultException(name)));\n+        return 1;\n+    }\n+\n+\n+    /**\n+     * List Calendar Labels visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of calendar labels\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance calendar labels\")\n+     */\n+    public List<String> listCalendarLabels(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listCalendarLabelsByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @throws EntityNotExistsFaultException when Maintenance Calendar does not exist\n+     * @return the Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar getCalendarDetails(User loggedInUser, String label) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupCalendarByUserAndLabel(loggedInUser, label)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(label));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param ical calendar ical data\n+     * @return the new Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param #param_desc(\"string\", \"ical\", \"ICal Calendar Data\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar createCalendar(User loggedInUser, String label, String ical) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceCalendar(loggedInUser, label, ical);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTYxNTk5OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MDozOVrOGRT_hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MDozOVrOGRT_hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNjUzMw==", "bodyText": "Same as create*.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420806533", "createdAt": "2020-05-06T13:50:39Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.maintenance;\n+\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Maintenance Schedule XMLRPC Handler\n+ *\n+ * @xmlrpc.namespace maintenance\n+ * @xmlrpc.doc Provides methods to access and modify Maintenance Schedules related entities\n+ */\n+public class MaintenanceHandler extends BaseHandler {\n+\n+    private final MaintenanceManager mm = MaintenanceManager.instance();\n+\n+    /**\n+     * List Schedule Names visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of schedule names\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance schedule names\")\n+     */\n+    public List<String> listScheduleNames(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listScheduleNamesByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return the Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule getScheduleDetails(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(name));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param type schedule type\n+     * @return the new Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param #param_desc(\"string\", \"type\", \"Schedule type: single, multi\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule createSchedule(User loggedInUser, String name, String type) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceSchedule(loggedInUser, name, ScheduleType.lookupByLabel(type),\n+                Optional.empty());\n+    }\n+\n+    /**\n+     * Update a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param details values to update\n+     * @return the changed Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Update a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param\n+     *     #struct_begin(\"Maintenance Schedule Details\")\n+     *         #prop_desc(\"string\", \"name\", \"new Schedule Name\")\n+     *         #prop_desc(\"string\", \"type\", \"new Schedule Type\")\n+     *           #options()\n+     *               #item(\"single\")\n+     *               #item(\"multi\"\")\n+     *           #options_end()\n+     *         #prop_desc(\"string\", \"calendar\", \"new calendar label\")\n+     *     #struct_end()\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule updateSchedule(User loggedInUser, String name, Map<String, String> details) {\n+        ensureOrgAdmin(loggedInUser);\n+\n+        // confirm that the user only provided valid keys in the map\n+        Set<String> validKeys = new HashSet<String>();\n+        validKeys.add(\"name\");\n+        validKeys.add(\"type\");\n+        validKeys.add(\"calendar\");\n+        validateMap(validKeys, details);\n+\n+        try {\n+            return mm.updateMaintenanceSchedule(loggedInUser, name, details);\n+        }\n+        catch (EntityNotExistsFaultException e) {\n+            throw new EntityNotExistsFaultException(e);\n+        }\n+    }\n+\n+    /**\n+     * Delete a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return number of removed objects\n+     *\n+     * @xmlrpc.doc Remove a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype #return_int_success()\n+     */\n+    public int deleteSchedule(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        Optional<MaintenanceSchedule> schedule = mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name);\n+        mm.remove(schedule.orElseThrow(() -> new EntityNotExistsFaultException(name)));\n+        return 1;\n+    }\n+\n+\n+    /**\n+     * List Calendar Labels visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of calendar labels\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance calendar labels\")\n+     */\n+    public List<String> listCalendarLabels(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listCalendarLabelsByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @throws EntityNotExistsFaultException when Maintenance Calendar does not exist\n+     * @return the Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar getCalendarDetails(User loggedInUser, String label) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupCalendarByUserAndLabel(loggedInUser, label)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(label));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param ical calendar ical data\n+     * @return the new Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param #param_desc(\"string\", \"ical\", \"ICal Calendar Data\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar createCalendar(User loggedInUser, String label, String ical) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceCalendar(loggedInUser, label, ical);\n+    }\n+\n+    /**\n+     * Create a new Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param url calendar url\n+     * @return the new Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param #param_desc(\"string\", \"url\", \"download URL for ICal Calendar Data\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar createCalendarWithUrl(User loggedInUser, String label, String url) {\n+        ensureOrgAdmin(loggedInUser);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTYxODA3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MTowNFrOGRUAxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MTowNFrOGRUAxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNjg1Mw==", "bodyText": "Typo (should be EntityNotExistsException).", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420806853", "createdAt": "2020-05-06T13:51:04Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.maintenance;\n+\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Maintenance Schedule XMLRPC Handler\n+ *\n+ * @xmlrpc.namespace maintenance\n+ * @xmlrpc.doc Provides methods to access and modify Maintenance Schedules related entities\n+ */\n+public class MaintenanceHandler extends BaseHandler {\n+\n+    private final MaintenanceManager mm = MaintenanceManager.instance();\n+\n+    /**\n+     * List Schedule Names visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of schedule names\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance schedule names\")\n+     */\n+    public List<String> listScheduleNames(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listScheduleNamesByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return the Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule getScheduleDetails(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(name));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param type schedule type\n+     * @return the new Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param #param_desc(\"string\", \"type\", \"Schedule type: single, multi\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule createSchedule(User loggedInUser, String name, String type) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceSchedule(loggedInUser, name, ScheduleType.lookupByLabel(type),\n+                Optional.empty());\n+    }\n+\n+    /**\n+     * Update a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param details values to update\n+     * @return the changed Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Update a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param\n+     *     #struct_begin(\"Maintenance Schedule Details\")\n+     *         #prop_desc(\"string\", \"name\", \"new Schedule Name\")\n+     *         #prop_desc(\"string\", \"type\", \"new Schedule Type\")\n+     *           #options()\n+     *               #item(\"single\")\n+     *               #item(\"multi\"\")\n+     *           #options_end()\n+     *         #prop_desc(\"string\", \"calendar\", \"new calendar label\")\n+     *     #struct_end()\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule updateSchedule(User loggedInUser, String name, Map<String, String> details) {\n+        ensureOrgAdmin(loggedInUser);\n+\n+        // confirm that the user only provided valid keys in the map\n+        Set<String> validKeys = new HashSet<String>();\n+        validKeys.add(\"name\");\n+        validKeys.add(\"type\");\n+        validKeys.add(\"calendar\");\n+        validateMap(validKeys, details);\n+\n+        try {\n+            return mm.updateMaintenanceSchedule(loggedInUser, name, details);\n+        }\n+        catch (EntityNotExistsFaultException e) {\n+            throw new EntityNotExistsFaultException(e);\n+        }\n+    }\n+\n+    /**\n+     * Delete a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return number of removed objects\n+     *\n+     * @xmlrpc.doc Remove a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype #return_int_success()\n+     */\n+    public int deleteSchedule(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        Optional<MaintenanceSchedule> schedule = mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name);\n+        mm.remove(schedule.orElseThrow(() -> new EntityNotExistsFaultException(name)));\n+        return 1;\n+    }\n+\n+\n+    /**\n+     * List Calendar Labels visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of calendar labels\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance calendar labels\")\n+     */\n+    public List<String> listCalendarLabels(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listCalendarLabelsByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @throws EntityNotExistsFaultException when Maintenance Calendar does not exist\n+     * @return the Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar getCalendarDetails(User loggedInUser, String label) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupCalendarByUserAndLabel(loggedInUser, label)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(label));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param ical calendar ical data\n+     * @return the new Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param #param_desc(\"string\", \"ical\", \"ICal Calendar Data\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar createCalendar(User loggedInUser, String label, String ical) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceCalendar(loggedInUser, label, ical);\n+    }\n+\n+    /**\n+     * Create a new Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param url calendar url\n+     * @return the new Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param #param_desc(\"string\", \"url\", \"download URL for ICal Calendar Data\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar createCalendarWithUrl(User loggedInUser, String label, String url) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceCalendarWithUrl(loggedInUser, label, url);\n+    }\n+\n+    /**\n+     * Update a Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param details values which should be updated\n+     * @return the changed Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Update a Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param\n+     *     #struct_begin(\"Maintenance Calendar Details\")\n+     *         #prop_desc(\"string\", \"label\", \"new Calendar Label\")\n+     *         #prop_desc(\"string\", \"ical\", \"new ical Calendar data\")\n+     *     #struct_end()\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar updateCalendar(User loggedInUser, String label, Map<String, String> details) {\n+        ensureOrgAdmin(loggedInUser);\n+\n+        // confirm that the user only provided valid keys in the map\n+        Set<String> validKeys = new HashSet<String>();\n+        validKeys.add(\"label\");\n+        validKeys.add(\"ical\");\n+        validateMap(validKeys, details);\n+\n+        try {\n+            return mm.updateCalendar(loggedInUser, label, details);\n+        }\n+        catch (EntityNotExistsFaultException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTYyMTkxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MTo1MFrOGRUDJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MTo1MFrOGRUDJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNzQ2MA==", "bodyText": "Same.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420807460", "createdAt": "2020-05-06T13:51:50Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/xmlrpc/maintenance/MaintenanceHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.maintenance;\n+\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Maintenance Schedule XMLRPC Handler\n+ *\n+ * @xmlrpc.namespace maintenance\n+ * @xmlrpc.doc Provides methods to access and modify Maintenance Schedules related entities\n+ */\n+public class MaintenanceHandler extends BaseHandler {\n+\n+    private final MaintenanceManager mm = MaintenanceManager.instance();\n+\n+    /**\n+     * List Schedule Names visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of schedule names\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance schedule names\")\n+     */\n+    public List<String> listScheduleNames(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listScheduleNamesByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return the Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule getScheduleDetails(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(name));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param type schedule type\n+     * @return the new Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param #param_desc(\"string\", \"type\", \"Schedule type: single, multi\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule createSchedule(User loggedInUser, String name, String type) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceSchedule(loggedInUser, name, ScheduleType.lookupByLabel(type),\n+                Optional.empty());\n+    }\n+\n+    /**\n+     * Update a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @param details values to update\n+     * @return the changed Maintenance Schedule\n+     *\n+     * @xmlrpc.doc Update a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.param\n+     *     #struct_begin(\"Maintenance Schedule Details\")\n+     *         #prop_desc(\"string\", \"name\", \"new Schedule Name\")\n+     *         #prop_desc(\"string\", \"type\", \"new Schedule Type\")\n+     *           #options()\n+     *               #item(\"single\")\n+     *               #item(\"multi\"\")\n+     *           #options_end()\n+     *         #prop_desc(\"string\", \"calendar\", \"new calendar label\")\n+     *     #struct_end()\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceScheduleSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceSchedule updateSchedule(User loggedInUser, String name, Map<String, String> details) {\n+        ensureOrgAdmin(loggedInUser);\n+\n+        // confirm that the user only provided valid keys in the map\n+        Set<String> validKeys = new HashSet<String>();\n+        validKeys.add(\"name\");\n+        validKeys.add(\"type\");\n+        validKeys.add(\"calendar\");\n+        validateMap(validKeys, details);\n+\n+        try {\n+            return mm.updateMaintenanceSchedule(loggedInUser, name, details);\n+        }\n+        catch (EntityNotExistsFaultException e) {\n+            throw new EntityNotExistsFaultException(e);\n+        }\n+    }\n+\n+    /**\n+     * Delete a Maintenance Schedule\n+     *\n+     * @param loggedInUser the user\n+     * @param name schedule name\n+     * @throws EntityNotExistsFaultException when Maintenance Schedule does not exist\n+     * @return number of removed objects\n+     *\n+     * @xmlrpc.doc Remove a Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"name\", \"Maintenance Schedule Name\")\n+     * @xmlrpc.returntype #return_int_success()\n+     */\n+    public int deleteSchedule(User loggedInUser, String name) {\n+        ensureOrgAdmin(loggedInUser);\n+        Optional<MaintenanceSchedule> schedule = mm.lookupMaintenanceScheduleByUserAndName(loggedInUser, name);\n+        mm.remove(schedule.orElseThrow(() -> new EntityNotExistsFaultException(name)));\n+        return 1;\n+    }\n+\n+\n+    /**\n+     * List Calendar Labels visible to user\n+     *\n+     * @param loggedInUser the user\n+     * @return list of calendar labels\n+     *\n+     * @xmlrpc.doc List Schedule Names visible to user\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.returntype #array_single(\"string\", \"maintenance calendar labels\")\n+     */\n+    public List<String> listCalendarLabels(User loggedInUser) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.listCalendarLabelsByUser(loggedInUser);\n+    }\n+\n+    /**\n+     * Lookup a specific Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @throws EntityNotExistsFaultException when Maintenance Calendar does not exist\n+     * @return the Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Lookup a specific Maintenance Schedule\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar getCalendarDetails(User loggedInUser, String label) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.lookupCalendarByUserAndLabel(loggedInUser, label)\n+                .orElseThrow(() -> new EntityNotExistsFaultException(label));\n+    }\n+\n+    /**\n+     * Create a new Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param ical calendar ical data\n+     * @return the new Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param #param_desc(\"string\", \"ical\", \"ICal Calendar Data\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar createCalendar(User loggedInUser, String label, String ical) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceCalendar(loggedInUser, label, ical);\n+    }\n+\n+    /**\n+     * Create a new Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param url calendar url\n+     * @return the new Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Create a new Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param #param_desc(\"string\", \"url\", \"download URL for ICal Calendar Data\")\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar createCalendarWithUrl(User loggedInUser, String label, String url) {\n+        ensureOrgAdmin(loggedInUser);\n+        return mm.createMaintenanceCalendarWithUrl(loggedInUser, label, url);\n+    }\n+\n+    /**\n+     * Update a Maintenance Calendar\n+     *\n+     * @param loggedInUser the user\n+     * @param label calendar label\n+     * @param details values which should be updated\n+     * @return the changed Maintenance Calendar\n+     *\n+     * @xmlrpc.doc Update a Maintenance Calendar\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.param\n+     *     #struct_begin(\"Maintenance Calendar Details\")\n+     *         #prop_desc(\"string\", \"label\", \"new Calendar Label\")\n+     *         #prop_desc(\"string\", \"ical\", \"new ical Calendar data\")\n+     *     #struct_end()\n+     * @xmlrpc.returntype\n+     * #array_begin()\n+     * $MaintenanceCalendarSerializer\n+     * #array_end()\n+     */\n+    public MaintenanceCalendar updateCalendar(User loggedInUser, String label, Map<String, String> details) {\n+        ensureOrgAdmin(loggedInUser);\n+\n+        // confirm that the user only provided valid keys in the map\n+        Set<String> validKeys = new HashSet<String>();\n+        validKeys.add(\"label\");\n+        validKeys.add(\"ical\");\n+        validateMap(validKeys, details);\n+\n+        try {\n+            return mm.updateCalendar(loggedInUser, label, details);\n+        }\n+        catch (EntityNotExistsFaultException e) {\n+            throw new EntityNotExistsFaultException(e);\n+        }\n+    }\n+\n+    /**\n+     * Refresh the calendar data using the configured URL\n+     * @param loggedInUser user\n+     * @param label the calendar label\n+     *\n+     * @xmlrpc.doc Refresh Maintenance Calendar Data using the configured URL\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"label\", \"Maintenance Calendar Label\")\n+     * @xmlrpc.returntype #return_int_success()\n+     */\n+    public int refreshCalendar(User loggedInUser, String label) {\n+        ensureOrgAdmin(loggedInUser);\n+        try {\n+            mm.refreshCalendar(loggedInUser, label);\n+            return 1;\n+        }\n+        catch (EntityNotExistsFaultException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTYyNTY2OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/xmlrpc/serializer/MaintenanceCalendarSerializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MjozNFrOGRUFfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MjozNFrOGRUFfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwODA2Mg==", "bodyText": "I think this should be label.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420808062", "createdAt": "2020-05-06T13:52:34Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/xmlrpc/serializer/MaintenanceCalendarSerializer.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.xmlrpc.serializer;\n+\n+import com.redhat.rhn.frontend.xmlrpc.serializer.RhnXmlRpcCustomSerializer;\n+import com.redhat.rhn.frontend.xmlrpc.serializer.util.SerializerHelper;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import redstone.xmlrpc.XmlRpcException;\n+import redstone.xmlrpc.XmlRpcSerializer;\n+\n+/**\n+ * Serializer for {@link com.suse.manager.model.maintenance.MaintenanceCalendar}\n+ *\n+ * @xmlrpc.doc\n+ * #struct_begin(\"Maintenance Calendar information\")\n+ *   #prop(\"int\", \"id\")\n+ *   #prop(\"int\", \"orgId\")\n+ *   #prop(\"string\", \"name\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a66aac3640c669ef40f59a31827f51ee5673502"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTY2NzE1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/test/MaintenanceManagerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDowMDoyM1rOGRUfGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDowMDoyM1rOGRUfGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgxNDYxOA==", "bodyText": "General nitpick:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertNull(dbSchedule.getCalendarOpt().orElse(null));\n          \n          \n            \n                    assertTrue(dbSchedule.getCalendarOpt().isEmpty());", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r420814618", "createdAt": "2020-05-06T14:00:23Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/test/MaintenanceManagerTest.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.maintenance.test;\n+\n+import com.redhat.rhn.common.util.FileUtils;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.TestUtils;\n+\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule.ScheduleType;\n+\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+\n+public class MaintenanceManagerTest extends BaseTestCaseWithUser {\n+\n+    private static final String TESTDATAPATH = \"/com/suse/manager/maintenance/test/testdata\";\n+    private static final String KDE_ICS = \"maintenance-windows-kde.ics\";\n+    private static final String EXCHANGE_ICS = \"maintenance-windows-exchange.ics\";\n+\n+    public void testCreateSchedule() throws Exception {\n+        MaintenanceManager mm = MaintenanceManager.instance();\n+        mm.createMaintenanceSchedule(user, \"test server\", ScheduleType.SINGLE, Optional.empty());\n+\n+        List<String> names = mm.listScheduleNamesByUser(user);\n+        assertEquals(1, names.size());\n+        assertContains(names, \"test server\");\n+\n+        Optional<MaintenanceSchedule> dbScheduleOpt = mm.lookupMaintenanceScheduleByUserAndName(user, \"test server\");\n+        assertNotNull(dbScheduleOpt.orElse(null));\n+        MaintenanceSchedule dbSchedule = dbScheduleOpt.get();\n+\n+        assertEquals(user.getOrg(), dbSchedule.getOrg());\n+        assertEquals(\"test server\", dbSchedule.getName());\n+        assertEquals(ScheduleType.SINGLE, dbSchedule.getScheduleType());\n+        assertNull(dbSchedule.getCalendarOpt().orElse(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ed1ecb19bccddc3f500ed1453e72281dcd7d26"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzM3Mzk2OnYy", "diffSide": "RIGHT", "path": "testsuite/features/init_clients/centos_ssh_minion.feature", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwODozMDowN1rOGTSDYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMTo0NjoyNFrOGWzh4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg3MTkwNg==", "bodyText": "Please tag with # WORKAROUND fix CentOS random boot failures\nI suggest to move that commit to a separate PR if it works\nI asked Ricardo whether we should not do that at images level, rather\nPlease tell me when I need to re-enable CentOS reboots \ud83d\ude38", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r422871906", "createdAt": "2020-05-11T08:30:07Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/init_clients/centos_ssh_minion.feature", "diffHunk": "@@ -64,3 +64,7 @@ Feature: Bootstrap a SSH-managed CentOS minion and do some basic operations on i\n   Scenario: Check events history for failures on SSH-managed CentOS minion\n     Given I am on the Systems overview page of this \"ceos_ssh_minion\"\n     Then I check for failed events on history event page\n+\n+@centos_minion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebd20e60fe83cb7590fe16940743d13126582555"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE2NTk5Ng==", "bodyText": "It does not work, so I removed this commit.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r425165996", "createdAt": "2020-05-14T14:08:58Z", "author": {"login": "mcalmer"}, "path": "testsuite/features/init_clients/centos_ssh_minion.feature", "diffHunk": "@@ -64,3 +64,7 @@ Feature: Bootstrap a SSH-managed CentOS minion and do some basic operations on i\n   Scenario: Check events history for failures on SSH-managed CentOS minion\n     Given I am on the Systems overview page of this \"ceos_ssh_minion\"\n     Then I check for failed events on history event page\n+\n+@centos_minion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg3MTkwNg=="}, "originalCommit": {"oid": "ebd20e60fe83cb7590fe16940743d13126582555"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU2NjExNQ==", "bodyText": "OK!", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r426566115", "createdAt": "2020-05-18T11:46:24Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/init_clients/centos_ssh_minion.feature", "diffHunk": "@@ -64,3 +64,7 @@ Feature: Bootstrap a SSH-managed CentOS minion and do some basic operations on i\n   Scenario: Check events history for failures on SSH-managed CentOS minion\n     Given I am on the Systems overview page of this \"ceos_ssh_minion\"\n     Then I check for failed events on history event page\n+\n+@centos_minion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg3MTkwNg=="}, "originalCommit": {"oid": "ebd20e60fe83cb7590fe16940743d13126582555"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDgwNjI4OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOToyOTo0OFrOGV9fPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOToyOTo0OFrOGV9fPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4MDcwMQ==", "bodyText": "In this case, the permissions are done in the callers of this method. Would it be possible to move them here, as in the remove case?", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r425680701", "createdAt": "2020-05-15T09:29:48Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -74,31 +74,35 @@ public static MaintenanceManager instance() {\n      * Save a MaintenanceSchedule\n      * @param schedule the schedule\n      */\n-    public void save(MaintenanceSchedule schedule) {\n+    protected void save(MaintenanceSchedule schedule) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caeab8443513101a4c51dbcb823d7596921aed6d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDgwNjY1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOToyOTo1NFrOGV9feQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOToyOTo1NFrOGV9feQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4MDc2MQ==", "bodyText": "Same as above.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r425680761", "createdAt": "2020-05-15T09:29:54Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -74,31 +74,35 @@ public static MaintenanceManager instance() {\n      * Save a MaintenanceSchedule\n      * @param schedule the schedule\n      */\n-    public void save(MaintenanceSchedule schedule) {\n+    protected void save(MaintenanceSchedule schedule) {\n         getSession().save(schedule);\n     }\n \n     /**\n      * Remove a MaintenanceSchedule\n      * @param schedule the schedule\n      */\n-    public void remove(MaintenanceSchedule schedule) {\n+    public void remove(User user, MaintenanceSchedule schedule) {\n+        ensureOrgAdmin(user);\n+        ensureScheduleAccessible(user, schedule);\n         getSession().remove(schedule);\n     }\n \n     /**\n      * Save a MaintenanceCalendar\n      * @param calendar the calendar\n      */\n-    public void save(MaintenanceCalendar calendar) {\n+    protected void save(MaintenanceCalendar calendar) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caeab8443513101a4c51dbcb823d7596921aed6d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDgzNTg4OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTozODoyN1rOGV9xuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTozODoyN1rOGV9xuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NTQzMw==", "bodyText": "My IDE does not complain if I remove all of these suppressions (same for ActionFactory), do you have the compiler in the IDE set correctly (I have the code level set to Java 11)?", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r425685433", "createdAt": "2020-05-15T09:38:27Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -181,6 +187,7 @@ public MaintenanceSchedule updateMaintenanceSchedule(User user, String name, Map\n      * @param user the user\n      * @return a list of Calendar labels\n      */\n+    @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caeab8443513101a4c51dbcb823d7596921aed6d"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTIxMTcxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/CancelRescheduleStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTo0NjowN1rOGWBhaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTo0NjowN1rOGWBhaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0Njc5Mg==", "bodyText": "Franky question: tasko invoked per action? Maybe we need to invoke it in bulk (think of exception handling in that case... otoh: in which cases can taskomatic fail on unscheduling, except of being down?).", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r425746792", "createdAt": "2020-05-15T11:46:07Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/CancelRescheduleStrategy.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.maintenance;\n+\n+import com.redhat.rhn.domain.action.Action;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.action.ActionManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * CancelRescheduleStrategy - Cancel the action for the system\n+ */\n+public class CancelRescheduleStrategy implements RescheduleStrategy {\n+    private static final Logger LOG = Logger.getLogger(CancelRescheduleStrategy.class);\n+\n+    @Override\n+    public RescheduleResult reschedule(User user, Map<Action, List<Server>> actionsServers,\n+            MaintenanceSchedule schedule) throws RescheduleException {\n+        RescheduleResult result = new RescheduleResult(getType(), actionsServers);\n+        try {\n+            for (Action action: actionsServers.keySet()) {\n+                List<Long> serverIds = actionsServers.get(action).stream()\n+                        .map(s -> s.getId())\n+                        .collect(Collectors.toList());\n+                ActionManager.cancelActions(user, Collections.singletonList(action), Optional.of(serverIds));\n+                LOG.info(String.format(\"Cancel action '%s' for servers '%s'\",\n+                        action.toString(), serverIds.toString()));\n+            }\n+        }\n+        catch (TaskomaticApiException | RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b144ffac21af51737104f7305c39a8585828d744"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTMyNTYyOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjoyNDo0OVrOGWCpSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjoyNDo0OVrOGWCpSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc2NTE5Mw==", "bodyText": "Franky: as discussed on the mtg, maybe we don't need to specify a separate \"fail\" strategy, since it should be always the last step.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r425765193", "createdAt": "2020-05-15T12:24:49Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -382,20 +400,37 @@ protected boolean manageAffectedScheduledActions(User user, MaintenanceSchedule\n             .collect(Collectors.groupingBy(ServerAction::getParentAction,\n                     Collectors.mapping(ServerAction::getServer, Collectors.toList())));\n \n-        for (RescheduleStrategy s : scheduleStrategy) {\n-            if (s.reschedule(user, actionsForServerToReschedule, schedule)) {\n-                return true;\n+        try {\n+            for (RescheduleStrategy s : scheduleStrategy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f8a02a9ecfeacc67bdb7a58d457ae513f1928f"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTMzNzk3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjoyODozNlrOGWCxOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjoyODozNlrOGWCxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc2NzIyNA==", "bodyText": "Franky: when the tasko unscheduling doesn't work, then it's kind of fine and we could ignore: in the worst case the action will be executed by tasko, but no action will be found.\nWorse thing is the re-scheduling of actions. Maybe we need to have schedule all-or-nothing on taskomatic side.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r425767224", "createdAt": "2020-05-15T12:28:36Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -382,20 +400,37 @@ protected boolean manageAffectedScheduledActions(User user, MaintenanceSchedule\n             .collect(Collectors.groupingBy(ServerAction::getParentAction,\n                     Collectors.mapping(ServerAction::getServer, Collectors.toList())));\n \n-        for (RescheduleStrategy s : scheduleStrategy) {\n-            if (s.reschedule(user, actionsForServerToReschedule, schedule)) {\n-                return true;\n+        try {\n+            for (RescheduleStrategy s : scheduleStrategy) {\n+                RescheduleResult result = s.reschedule(user, actionsForServerToReschedule, schedule);\n+                if (result.isSuccess()) {\n+                    return true;\n+                }\n             }\n         }\n+        catch (RescheduleException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f8a02a9ecfeacc67bdb7a58d457ae513f1928f"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjA2MzI2OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/common/hibernate/HibernateFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODo1NToyOVrOGWtsUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODo1NToyOVrOGWtsUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ3MDQ4MA==", "bodyText": "Franky: would be nice to have some test description for the ics files.", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r426470480", "createdAt": "2020-05-18T08:55:29Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/redhat/rhn/common/hibernate/HibernateFactory.java", "diffHunk": "@@ -452,7 +453,7 @@ public static Object reload(Object obj) throws HibernateException {\n          * session.get is set to not return the proxy class, so that is what we'll use.\n          */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b1e59716228dcc091654e879e22c4c2a8e27937"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTk5NDAxOnYy", "diffSide": "RIGHT", "path": "testsuite/features/step_definitions/common_steps.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyNToyOVrOG42Aww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyNToyOVrOG42Aww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1ODM3MQ==", "bodyText": "And please (and also on previous line)", "url": "https://github.com/uyuni-project/uyuni/pull/2144#discussion_r462258371", "createdAt": "2020-07-29T12:25:29Z", "author": {"login": "Bischoff"}, "path": "testsuite/features/step_definitions/common_steps.rb", "diffHunk": "@@ -206,6 +206,7 @@\n   steps %(\n     When I am authorized as \"admin\" with password \"admin\"\n     When I follow the left menu \"Systems > Overview\"\n+    When I wait until I see \"System Overview\" text", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db097ca4618a4c06ce272ad1682f7c4fe259d2e"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4339, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}