{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMjQ0Mjgy", "number": 1900, "title": "Remove oracle", "bodyText": "What does this PR change?\nOur schema package is still based on oracle syntax and migrate it to postgresql using sed and other tricks.\nAs postgresql is currently the only supported DB in uyuni we should drop everything around oracle now.\nThis PR start with this:\n\nmigrate all scripts to postgresql syntax\nremove oracle specific files\nremove validators to check sha1 checksum of oracle equivalent file.\n\nThe schema upgrade still work with .postgresql suffix as the script requires this.\nGUI diff\nNo difference.\n\n DONE\n\nDocumentation\n\n\nNo documentation needed: internal\n\n\n DONE\n\n\nTest coverage\n\n\nNo tests: already covered\n\n\n DONE\n\n\nLinks\nFixes SUSE/spacewalk#8883\n\n DONE\n\nChangelogs\nIf you don't need a changelog check, please mark this checkbox:\n\n No changelog needed\n\nIf you uncheck the checkbox after the PR is created, you will need to re-run changelog_test (see below)\nRe-run a test\nIf you need to re-run a test, please mark the related checkbox, it will be unchecked automatically once it has re-run:\n\n Re-run test \"changelog_test\"\n Re-run test \"backend_unittests_pgsql\"\n Re-run test \"java_lint_checkstyle\"\n Re-run test \"java_pgsql_tests\"\n Re-run test \"ruby_rubocop\"\n Re-run test \"schema_migration_test_oracle\"\n Re-run test \"schema_migration_test_pgsql\"\n Re-run test \"susemanager_unittests\"\n Re-run test \"javascript_lint\"\n Re-run test \"spacecmd_unittests\"", "createdAt": "2020-02-10T16:54:25Z", "url": "https://github.com/uyuni-project/uyuni/pull/1900", "merged": true, "mergeCommit": {"oid": "191ec0fcca11b515d107effdfd9424068e045def"}, "closed": true, "closedAt": "2020-02-19T20:47:29Z", "author": {"login": "mcalmer"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDO8ejgBqjMwMjU5MTI4MzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcF5k5yABqjMwNTI1Mzg5Mzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce70ec7ba9dcdd5c95853742d7a140f32f911629", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ce70ec7ba9dcdd5c95853742d7a140f32f911629", "committedDate": "2020-02-11T06:48:09Z", "message": "Remove Oracle-only MessageQueueEventListener"}, "afterCommit": {"oid": "acc1362961ec17bdda9829d2be719cad0585b6a1", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/acc1362961ec17bdda9829d2be719cad0585b6a1", "committedDate": "2020-02-11T10:11:48Z", "message": "Remove Oracle-only MessageQueueEventListener"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acc1362961ec17bdda9829d2be719cad0585b6a1", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/acc1362961ec17bdda9829d2be719cad0585b6a1", "committedDate": "2020-02-11T10:11:48Z", "message": "Remove Oracle-only MessageQueueEventListener"}, "afterCommit": {"oid": "48b6d8717a02911f60db41a6f254dd9c10bcf61f", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/48b6d8717a02911f60db41a6f254dd9c10bcf61f", "committedDate": "2020-02-11T12:26:50Z", "message": "Remove Oracle-only MessageQueueEventListener"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20e8b1e879b14f2044626aa6fa02d2be2d7d0232", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/20e8b1e879b14f2044626aa6fa02d2be2d7d0232", "committedDate": "2020-02-11T16:30:23Z", "message": "comvert all sqlsyntax to postgres format for all versions > 1.2 which support postregs"}, "afterCommit": {"oid": "12e085cf42bce2fb24c2a47932d23f8c3e15309e", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/12e085cf42bce2fb24c2a47932d23f8c3e15309e", "committedDate": "2020-02-12T09:15:12Z", "message": "comvert all sqlsyntax to postgres format for all versions > 1.2 which support postregs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12e085cf42bce2fb24c2a47932d23f8c3e15309e", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/12e085cf42bce2fb24c2a47932d23f8c3e15309e", "committedDate": "2020-02-12T09:15:12Z", "message": "comvert all sqlsyntax to postgres format for all versions > 1.2 which support postregs"}, "afterCommit": {"oid": "b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e", "committedDate": "2020-02-14T10:13:39Z", "message": "update changelog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNDU5MjE0", "url": "https://github.com/uyuni-project/uyuni/pull/1900#pullrequestreview-360459214", "createdAt": "2020-02-18T15:57:54Z", "commit": {"oid": "b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNTo1Nzo1NFrOFrIG7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNTo1Nzo1NFrOFrIG7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2NTkzNA==", "bodyText": "Some comments like this now look a bit funny :-)\nNot sure if it's worth to fix them though.", "url": "https://github.com/uyuni-project/uyuni/pull/1900#discussion_r380765934", "createdAt": "2020-02-18T15:57:54Z", "author": {"login": "moio"}, "path": "schema/spacewalk/upgrade/spacewalk-schema-1.3-to-spacewalk-schema-1.4/022-rhn_entitlements.sql", "diffHunk": "@@ -0,0 +1,1750 @@\n+\n+-- Note: this file is not a full equivalent of the Oracle sources.\n+-- Neither the flex stuff nor the update_family_countsYN was fully migrated.\n+-- Migrated functions or code paths:\n+--\n+-- can_entitle_server\n+-- entitle_server\n+-- code path of simple rhn-satellite-activate\n+--\n+--\n+-- Copyright (c) 2008--2011 Red Hat, Inc.\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+-- create schema rhn_entitlements;\n+\n+-- setup search_path so that these functions are created in appropriate schema.\n+update pg_settings set setting = 'rhn_entitlements,' || setting where name = 'search_path';\n+\n+   create or replace function find_compatible_sg (\n+      server_id_in in numeric,\n+      type_label_in in varchar\n+   )\n+   returns numeric\n+as $$\n+    declare\n+      servergroups cursor for\n+         select sg.id\n+           from rhnServerGroupType             sgt,\n+                rhnServerGroup                 sg,\n+                rhnServer                     s,\n+                rhnServerServerGroupArchCompat ssgac\n+          where s.id = server_id_in\n+            and s.org_id = sg.org_id\n+            and sgt.label = type_label_in\n+            and sg.group_type = sgt.id\n+            and ssgac.server_group_type = sgt.id\n+            and ssgac.server_arch_id = s.server_arch_id\n+            and not exists (\n+                     select 1\n+                      from rhnServerGroupMembers sgm\n+                     where sgm.server_group_id = sg.id\n+                       and sgm.server_id = s.id);\n+\n+\n+   begin\n+      for servergroup in servergroups loop\n+         return servergroup.id;\n+      end loop;\n+\n+      --no servergroup found\n+      return NULL;\n+   end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: remove_org_entitlements\n+    --\n+    -- Removes both system entitlements and channel subscriptions\n+    -- that are currently assigned to an org and re-assigns to the\n+    -- master org (org_id = 1).\n+    --\n+    -- When we call this we expect everything to already be unentitled\n+    -- which shoul be handled by delete_org.\n+    --\n+    -- Called by: delete_org\n+    -- *******************************************************************\n+    create or replace function remove_org_entitlements (\n+        org_id_in numeric\n+    ) returns void\n+as $$\n+    declare\n+        system_ents cursor for\n+        select sg.id, sg.max_members, sg.group_type\n+        from rhnServerGroup sg\n+        where group_type is not null\n+          and org_id = org_id_in;\n+\n+        channel_subs cursor for\n+        select pcf.channel_family_id, pcf.max_members\n+        from rhnChannelFamily cf,\n+             rhnPrivateChannelFamily pcf\n+        where pcf.org_id = org_id_in\n+          and pcf.channel_family_id = cf.id\n+          and cf.org_id is null;\n+\n+    begin\n+\n+        for system_ent in system_ents loop\n+            update rhnServerGroup\n+            set max_members = max_members + system_ent.max_members\n+            where org_id = 1\n+              and group_type = system_ent.group_type;\n+        end loop;\n+\n+        update rhnServerGroup\n+        set max_members = 0\n+        where org_id = org_id_in;\n+\n+        for channel_sub in channel_subs loop\n+            update rhnPrivateChannelFamily\n+            set max_members = max_members + channel_sub.max_members\n+            where org_id = 1\n+              and channel_family_id = channel_sub.channel_family_id;\n+        end loop;\n+\n+        update rhnPrivateChannelFamily\n+        set max_members = 0\n+        where org_id = org_id_in;\n+\n+    end$$\n+language plpgsql;\n+\n+    create or replace function entitlement_grants_service (\n+        entitlement_in in varchar,\n+        service_level_in in varchar\n+    ) returns numeric\n+as $$\n+    begin\n+        if service_level_in = 'provisioning' then\n+            if entitlement_in = 'provisioning_entitled' then\n+                return 1;\n+            else\n+                return 0;\n+            end if;\n+        elsif service_level_in = 'management' then\n+            if entitlement_in = 'enterprise_entitled' then\n+                return 1;\n+            else\n+                return 0;\n+            end if;\n+        elsif service_level_in = 'monitoring' then\n+            if entitlement_in = 'monitoring_entitled' then\n+                return 1;\n+            end if;\n+        elsif service_level_in = 'updates' then\n+            return 1;\n+        else\n+            return 0;\n+        end if;\n+    end$$\n+language plpgsql;\n+\n+    create or replace function lookup_entitlement_group (\n+        org_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled'\n+    ) returns numeric\n+as $$\n+    declare\n+        server_groups cursor for\n+            select  sg.id               server_group_id\n+            from    rhnServerGroup      sg,\n+                    rhnServerGroupType  sgt\n+            where   sgt.label = type_label_in\n+                and sgt.id = sg.group_type\n+                and sg.org_id = org_id_in;\n+    begin\n+        for sg in server_groups loop\n+            return sg.server_group_id;\n+        end loop;\n+        return rhn_entitlements.create_entitlement_group(\n+                org_id_in,\n+                type_label_in\n+            );\n+    end$$\n+language plpgsql;\n+\n+    create or replace function create_entitlement_group (\n+        org_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled'\n+    ) returns numeric\n+as $$\n+    declare\n+        sg_id_val numeric;\n+    begin\n+        select  nextval('rhn_server_group_id_seq')\n+        into    sg_id_val;\n+\n+        insert into rhnServerGroup (\n+                id, name, description, max_members, current_members,\n+                group_type, org_id\n+            ) (\n+                select  sg_id_val, sgt.label, sgt.label,\n+                        0, 0, sgt.id, org_id_in\n+                from    rhnServerGroupType sgt\n+                where   sgt.label = type_label_in\n+            );\n+\n+        return sg_id_val;\n+    end$$\n+language plpgsql;\n+\n+   create or replace function can_entitle_server (\n+      server_id_in   in numeric,\n+      type_label_in  in varchar\n+   )\n+   returns numeric\n+as $$\n+    declare\n+      addon_servergroups cursor (base_label_in varchar,\n+                                 addon_label_in varchar) for\n+         select\n+            addon_id\n+         from\n+            rhnSGTypeBaseAddonCompat\n+         where base_id = lookup_sg_type (base_label_in)\n+           and addon_id = lookup_sg_type (addon_label_in);\n+\n+      previous_ent        varchar[];\n+      is_base_in          char   := 'N';\n+      is_base_current     char   := 'N';\n+      i                   numeric := 0;\n+      sgid                numeric := 0;\n+\n+   begin\n+\n+      previous_ent := rhn_entitlements.get_server_entitlement(server_id_in);\n+\n+      select distinct is_base\n+      into is_base_in\n+      from rhnServerGroupType\n+      where label = type_label_in;\n+\n+      if array_upper(previous_ent, 1) is null or array_upper(previous_ent, 1) = 0 then\n+         if is_base_in = 'Y' then\n+            sgid := rhn_entitlements.find_compatible_sg (server_id_in, type_label_in);\n+            if sgid is not null then\n+              -- rhn_server.insert_into_servergroup (server_id_in, sgid);\n+              return 1;\n+            else\n+              -- rhn_exception.raise_exception ('invalid_base_entitlement');\n+              return 0;\n+            end if;\n+         else\n+            -- rhn_exception.raise_exception ('invalid_base_entitlement');\n+            return 0;\n+         end if;\n+\n+      -- there are previous ents, first make sure we're not trying to entitle a base ent\n+      elsif is_base_in = 'Y' then\n+         -- rhn_exception.raise_exception ('invalid_addon_entitlement');\n+         return 0;\n+\n+      -- it must be an addon, so proceed with the entitlement\n+      else\n+\n+         -- find the servers base ent\n+         is_base_current := 'N';\n+         i := 0;\n+         while is_base_current = 'N' and i < array_upper(previous_ent, 1)\n+         loop\n+            i := i + 1;\n+            select is_base\n+            into is_base_current\n+            from rhnServerGroupType\n+            where label = previous_ent[i];\n+         end loop;\n+\n+         -- never found a base ent, that would be strange\n+         if is_base_current  = 'N' then\n+            -- rhn_exception.raise_exception ('invalid_base_entitlement');\n+            return 0;\n+         end if;\n+\n+         -- this for loop verifies the validity of the addon path\n+         for addon_servergroup in addon_servergroups  (previous_ent[i], type_label_in) loop\n+            -- find an appropriate sgid for the addon and entitle the server\n+            sgid := rhn_entitlements.find_compatible_sg (server_id_in, type_label_in);\n+            if sgid is not null then\n+               -- rhn_server.insert_into_servergroup (server_id_in, sgid);\n+               return 1;\n+            else\n+               -- rhn_exception.raise_exception ('invalid_addon_entitlement');\n+               return 0;\n+            end if;\n+         end loop;\n+\n+      end if;\n+\n+      return 0;\n+\n+   end$$\n+language plpgsql;\n+\n+   create or replace function can_switch_base (\n+      server_id_in   in    integer,\n+      type_label_in  in    varchar\n+   )\n+   returns numeric\n+as $$\n+   declare\n+      type_label_in_is_base   char(1);\n+      sgid                    numeric;\n+\n+   begin\n+\n+       select is_base into type_label_in_is_base\n+       from rhnServerGroupType\n+       where label = type_label_in;\n+\n+       if not found then\n+          perform rhn_exception.raise_exception ( 'invalid_entitlement' );\n+       end if;\n+\n+      if type_label_in_is_base = 'N' then\n+         perform rhn_exception.raise_exception ( 'invalid_entitlement' );\n+      else\n+         sgid := rhn_entitlements.find_compatible_sg ( server_id_in,\n+                                                       type_label_in );\n+         if sgid is not null then\n+           return 1;\n+         else\n+           return 0;\n+         end if;\n+      end if;\n+\n+   end$$\n+language plpgsql;\n+\n+    create or replace function entitle_server (\n+        server_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled'\n+    ) returns void\n+as $$\n+    declare\n+      sgid  numeric := 0;\n+      is_virt numeric := 0;\n+\n+    begin\n+\n+      select 1 into is_virt\n+        from rhnServerEntitlementView\n+        where server_id = server_id_in\n+          and label in ('virtualization_host', 'virtualization_host_platform');\n+\n+      if not found then\n+          is_virt := 0;\n+      end if;\n+\n+      if is_virt = 0 and (type_label_in = 'virtualization_host' or\n+                          type_label_in = 'virtualization_host_platform') then\n+\n+        is_virt := 1;\n+      end if;\n+\n+      if rhn_entitlements.can_entitle_server(server_id_in,\n+                                             type_label_in) = 1 then\n+         sgid := rhn_entitlements.find_compatible_sg (server_id_in,\n+                                                      type_label_in);\n+         if sgid is not null then\n+            insert into rhnServerHistory ( id, server_id, summary, details )\n+            values ( nextval('rhn_event_id_seq'), server_id_in,\n+                     'added system entitlement ',\n+                      case type_label_in\n+                       when 'enterprise_entitled' then 'Management'\n+                       when 'sw_mgr_entitled' then 'Update'\n+                       when 'provisioning_entitled' then 'Provisioning'\n+                       when 'monitoring_entitled' then 'Monitoring'\n+                       when 'virtualization_host' then 'Virtualization'\n+                       when 'virtualization_host_platform' then\n+                            'Virtualization Platform' end  );\n+\n+            perform rhn_server.insert_into_servergroup (server_id_in, sgid);\n+\n+            if is_virt = 1 then\n+              perform rhn_entitlements.repoll_virt_guest_entitlements(server_id_in);\n+            end if;\n+\n+         else\n+            perform rhn_exception.raise_exception ('no_available_server_group');\n+         end if;\n+      else\n+         perform rhn_exception.raise_exception ('invalid_entitlement');\n+      end if;\n+   end$$\n+language plpgsql;\n+\n+    create or replace function remove_server_entitlement (\n+        server_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled',\n+        repoll_virt_guests in numeric default 1\n+    ) returns void\n+as $$\n+    declare\n+      group_id numeric;\n+      type_is_base char;\n+      is_virt numeric := 0;\n+    begin\n+      -- would be nice if there were a virt attribute of entitlement types, not have to specify 2 different ones...\n+        select 1 into is_virt\n+          from rhnServerEntitlementView\n+          where server_id = server_id_in\n+            and label in ('virtualization_host', 'virtualization_host_platform');\n+        if not found then\n+            is_virt := 0;\n+        end if;\n+\n+        select  sg.id, sgt.is_base\n+        into group_id, type_is_base\n+        from    rhnServerGroupType sgt,\n+            rhnServerGroup sg,\n+                rhnServerGroupMembers sgm,\n+                rhnServer s\n+        where   s.id = server_id_in\n+            and s.id = sgm.server_id\n+            and sgm.server_group_id = sg.id\n+            and sg.org_id = s.org_id\n+            and sgt.label = type_label_in\n+            and sgt.id = sg.group_type;\n+\n+        if not found then\n+          perform rhn_exception.raise_exception('invalid_server_group_member');\n+        end if;\n+\n+      if ( type_is_base = 'Y' ) then\n+         -- unentitle_server should handle everything, don't really need to do anything else special here\n+         perform rhn_entitlements.unentitle_server ( server_id_in );\n+      else\n+\n+         insert into rhnServerHistory ( id, server_id, summary, details )\n+         values ( nextval('rhn_event_id_seq'), server_id_in,\n+                  'removed system entitlement ',\n+                   case type_label_in\n+                    when 'enterprise_entitled' then 'Management'\n+                    when 'sw_mgr_entitled' then 'Update'\n+                    when 'provisioning_entitled' then 'Provisioning'\n+                    when 'monitoring_entitled' then 'Monitoring'\n+                    when 'virtualization_host' then 'Virtualization'\n+                    when 'virtualization_host_platform' then\n+                         'Virtualization Platforrm' end  );\n+\n+         perform rhn_server.delete_from_servergroup(server_id_in, group_id);\n+\n+         -- special case: clean up related monitoring data\n+         if type_label_in = 'monitoring_entitled' then\n+           DELETE\n+             FROM state_change\n+            WHERE o_id IN (SELECT probe_id::varchar\n+                             FROM rhn_check_probe\n+                            WHERE host_id = server_id_in);\n+           DELETE\n+             FROM time_series\n+            WHERE substring(o_id FROM position('-' IN o_id) + 1\n+                            FOR position('-' IN substring(o_id FROM position('-' IN o_id) + 1)) - 1)\n+              IN (SELECT probe_id::text\n+                    FROM rhn_check_probe\n+                   WHERE host_id = server_id_in);\n+           DELETE\n+             FROM rhn_probe\n+            WHERE recid IN (SELECT probe_id\n+                              FROM rhn_check_probe\n+                             WHERE host_id = server_id_in);\n+         end if;\n+\n+         if is_virt = 1 and repoll_virt_guests = 1 then\n+           perform rhn_entitlements.repoll_virt_guest_entitlements(server_id_in);\n+         end if;\n+      end if;\n+\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unentitle_server (\n+        server_id_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+      servergroups cursor for\n+         select distinct sgt.label, sg.id server_group_id\n+         from  rhnServerGroupType sgt,\n+               rhnServerGroup sg,\n+               rhnServer s,\n+               rhnServerGroupMembers sgm\n+         where s.id = server_id_in\n+            and s.org_id = sg.org_id\n+            and sg.group_type = sgt.id\n+            and sgm.server_group_id = sg.id\n+            and sgm.server_id = s.id;\n+\n+     is_virt numeric := 0;\n+\n+   begin\n+\n+      select 1 into is_virt\n+        from rhnServerEntitlementView\n+        where server_id = server_id_in\n+         and label in ('virtualization_host', 'virtualization_host_platform');\n+\n+      if not found then\n+          is_virt := 0;\n+      end if;\n+\n+      for servergroup in servergroups loop\n+\n+         insert into rhnServerHistory ( id, server_id, summary, details )\n+         values ( nextval('rhn_event_id_seq'), server_id_in,\n+                  'removed system entitlement ',\n+                   case servergroup.label\n+                    when 'enterprise_entitled' then 'Management'\n+                    when 'sw_mgr_entitled' then 'Update'\n+                    when 'provisioning_entitled' then 'Provisioning'\n+                    when 'monitoring_entitled' then 'Monitoring'\n+                    when 'virtualization_host' then 'Virtualization'\n+                    when 'virtualization_host_platform' then\n+                         'Virtualization Platform' end  );\n+\n+         perform rhn_server.delete_from_servergroup(server_id_in,\n+                                            servergroup.server_group_id );\n+      end loop;\n+\n+      if is_virt = 1 then\n+        perform rhn_entitlements.repoll_virt_guest_entitlements(server_id_in);\n+      end if;\n+\n+   end$$\n+language plpgsql;\n+\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: repoll_virt_guest_entitlements\n+    --\n+    --   Whenever we add/remove a virtualization_host* entitlement from\n+    --   a host, we can call this procedure to update what type of slots\n+    --   the guests are consuming.\n+    --\n+    --   If you're removing the entitlement, it's\n+    --   possible the guests will become unentitled if you don't have enough\n+    --   physical slots to cover them.\n+    --\n+    --   If you're adding the entitlement, you end up freeing up physical\n+    --   slots for other systems.\n+    --\n+    -- *******************************************************************\n+    create or replace function repoll_virt_guest_entitlements(\n+        server_id_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+        -- All channel families associated with the guests of server_id_in\n+        families cursor for\n+            select distinct cfs.channel_family_id\n+            from\n+                rhnChannelFamilyServers cfs,\n+                rhnVirtualInstance vi\n+            where\n+                vi.host_system_id = server_id_in\n+                and vi.virtual_system_id = cfs.server_id;\n+\n+        -- All of server group types associated with the guests of\n+        -- server_id_in\n+        group_types cursor for\n+            select distinct sg.group_type, sgt.label\n+            from\n+                rhnServerGroupType sgt,\n+                rhnServerGroup sg,\n+                rhnServerGroupMembers sgm,\n+                rhnVirtualInstance vi\n+            where\n+                vi.host_system_id = server_id_in\n+                and vi.virtual_system_id = sgm.server_id\n+                and sgm.server_group_id = sg.id\n+                and sg.group_type = sgt.id;\n+\n+        -- Virtual servers from a certain family belonging to a specific\n+        -- host that are consuming physical channel slots over the limit.\n+        virt_servers_cfam cursor(family_id_in numeric, quantity_in numeric) for\n+                select vi.virtual_system_id\n+                from\n+                    rhnChannelFamilyMembers cfm,\n+                    rhnServerChannel sc,\n+                    rhnVirtualInstance vi\n+                where\n+                    vi.host_system_id = server_id_in\n+                    and vi.virtual_system_id = sc.server_id\n+                    and sc.channel_id = cfm.channel_id\n+                    and cfm.channel_family_id = family_id_in\n+                order by sc.modified desc\n+                limit quantity_in;\n+\n+        -- Virtual servers from a certain family belonging to a specific\n+        -- host that are consuming physical system slots over the limit.\n+        virt_servers_sgt cursor(group_type_in numeric, quantity_in numeric) for\n+                select vi.virtual_system_id\n+                from\n+                    rhnServerGroup sg,\n+                    rhnServerGroupMembers sgm,\n+                    rhnVirtualInstance vi\n+                where\n+                    vi.host_system_id = server_id_in\n+                    and vi.virtual_system_id = sgm.server_id\n+                    and sgm.server_group_id = sg.id\n+                    and sg.group_type = group_type_in\n+                order by sgm.modified desc\n+                limit quantity_in;\n+\n+        org_id_val numeric;\n+        max_members_val numeric;\n+        current_members_calc numeric;\n+        sg_id numeric;\n+\n+    begin\n+\n+        select org_id\n+        into org_id_val\n+        from rhnServer\n+        where id = server_id_in;\n+\n+        -- deal w/ channel entitlements first ...\n+        for family in families loop\n+            -- get the current (physical) members of the family\n+            current_members_calc :=\n+                rhn_channel.channel_family_current_members(family.channel_family_id,\n+                                                           org_id_val); -- fixed transposed args\n+\n+            -- get the max members of the family\n+            select max_members\n+            into max_members_val\n+            from rhnPrivateChannelFamily\n+            where channel_family_id = family.channel_family_id\n+            and org_id = org_id_val;\n+\n+            if current_members_calc > max_members_val then\n+                -- A virtualization_host* ent must have been removed, so we'll\n+                -- unsubscribe guests from the host first.\n+\n+                -- hm, i don't think max_members - current_members_calc yielding a negative NUMERIC\n+                -- will work w/ rownum, swaping 'em in the body of this if...\n+                for virt_server in virt_servers_cfam(family.channel_family_id,\n+                                current_members_calc - max_members_val) loop\n+\n+                    perform rhn_channel.unsubscribe_server_from_family(\n+                                virt_server.virtual_system_id,\n+                                family.channel_family_id);\n+                end loop;\n+\n+                -- if we're still over the limit, which would be odd,\n+                -- just prune the group to max_members\n+                --\n+                -- er... wouldn't we actually have to refresh the values of\n+                -- current_members_calc and max_members_val to actually ever\n+                -- *skip this??\n+                if current_members_calc > max_members_val then\n+                    -- argh, transposed again?!\n+                    perform rhn_entitlements.set_family_count(org_id_val,\n+                                     family.channel_family_id,\n+                                     max_members_val);\n+                end if;\n+\n+           end if;\n+\n+            -- update current_members for the family.  This will set the value\n+            -- to reflect adding/removing the entitlement.\n+            --\n+            -- what's the difference of doing this vs the unavoidable set_family_count above?\n+            perform rhn_channel.update_family_counts(family.channel_family_id,\n+                                             org_id_val);\n+        end loop;\n+\n+        for a_group_type in group_types loop\n+          -- get the current *physical* members of the system entitlement type for the org...\n+          --\n+          -- unlike channel families, it appears the standard rhnServerGroup.max_members represents\n+          -- *physical* slots, vs physical+virt ... boy that's confusing...\n+\n+          select max_members, id\n+            into max_members_val, sg_id\n+            from rhnServerGroup\n+            where group_type = a_group_type.group_type\n+            and org_id = org_id_val;\n+\n+\n+      select count(sep.server_id) into current_members_calc\n+            from rhnServerEntitlementPhysical sep\n+           where sep.server_group_id = sg_id\n+             and sep.server_group_type_id = a_group_type.group_type;\n+\n+          if current_members_calc > max_members_val then\n+            -- A virtualization_host* ent must have been removed, and we're over the limit, so unsubscribe guests\n+            for virt_server in virt_servers_sgt(a_group_type.group_type,\n+                                                current_members_calc - max_members_val) loop\n+              perform rhn_entitlements.remove_server_entitlement(virt_server.virtual_system_id, a_group_type.label);\n+\n+              -- decrement current_members_calc, we'll use it to reset current_members for the group at the end...\n+              current_members_calc := current_members_calc - 1;\n+            end loop;\n+\n+          end if;\n+\n+          update rhnServerGroup set current_members = current_members_calc\n+           where org_id = org_id_val\n+             and group_type = a_group_type.group_type;\n+\n+          -- I think that's all the house-keeping we have to do...\n+        end loop;\n+\n+    end$$\n+language plpgsql;\n+\n+    create or replace function get_server_entitlement (\n+        server_id_in in numeric\n+    ) returns varchar[]\n+as $$\n+    declare\n+        server_groups cursor for\n+            select  sgt.label\n+            from    rhnServerGroupType      sgt,\n+                    rhnServerGroup          sg,\n+                    rhnServerGroupMembers   sgm\n+            where   1=1\n+                and sgm.server_id = server_id_in\n+                and sg.id = sgm.server_group_id\n+                and sgt.id = sg.group_type\n+                and sgt.label in (\n+                    'sw_mgr_entitled','enterprise_entitled',\n+                    'provisioning_entitled', 'nonlinux_entitled',\n+                    'monitoring_entitled', 'virtualization_host',\n+                                        'virtualization_host_platform'\n+                    );\n+\n+         ent_array varchar[];\n+\n+    begin\n+\n+      ent_array := '{}';\n+\n+      for sg in server_groups loop\n+         ent_array := ent_array || sg.label;\n+      end loop;\n+\n+      return ent_array;\n+\n+    end$$\n+language plpgsql;\n+\n+    -- this desperately needs to be table driven.\n+    create or replace function modify_org_service (\n+        org_id_in in numeric,\n+        service_label_in in varchar,\n+        enable_in in char\n+    ) returns void\n+as $$\n+    declare\n+        roles_to_process varchar[];\n+        roles cursor(role_label_in varchar) for\n+            select  label, id\n+            from    rhnUserGroupType\n+            where   label = role_label_in;\n+        org_roles cursor(role_label_in varchar) for\n+            select  1\n+            from    rhnUserGroup ug,\n+                    rhnUserGroupType ugt\n+            where   ugt.label = role_label_in\n+                and ug.org_id = org_id_in\n+                and ugt.id = ug.group_type;\n+\n+        ents_to_process varchar[];\n+        ents cursor(ent_label_in varchar) for\n+            select  label, id\n+            from    rhnOrgEntitlementType\n+            where   label = ent_label_in;\n+        org_ents cursor(ent_label_in varchar) for\n+            select  1\n+            from    rhnOrgEntitlements oe,\n+                    rhnOrgEntitlementType oet\n+            where   oet.label = ent_label_in\n+                and oe.org_id = org_id_in\n+                and oet.id = oe.entitlement_id;\n+        create_row char(1);\n+    begin\n+        ents_to_process := '{}';\n+        roles_to_process := '{}';\n+        -- a bit kludgy, but only for 3.4 really.  Certainly no\n+        -- worse than the old code...\n+        if service_label_in = 'enterprise' or\n+           service_label_in = 'management' then\n+            ents_to_process := array_append(ents_to_process, 'sw_mgr_enterprise');\n+\n+            roles_to_process := array_append(roles_to_process, 'org_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'system_group_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'activation_key_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'org_applicant');\n+        elsif service_label_in = 'provisioning' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_provisioning');\n+\n+            roles_to_process := array_append(roles_to_process, 'system_group_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'activation_key_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+            -- another nasty special case...\n+            if enable_in = 'Y' then\n+                ents_to_process := array_append(ents_to_process, 'sw_mgr_enterprise');\n+            end if;\n+        elsif service_label_in = 'monitoring' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_monitor');\n+\n+            roles_to_process := array_append(roles_to_process, 'monitoring_admin');\n+        elsif service_label_in = 'virtualization' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_virtualization');\n+\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+        elsif service_label_in = 'virtualization_platform' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_virtualization_platform');\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+    elsif service_label_in = 'nonlinux' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_nonlinux');\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+        end if;\n+\n+        if enable_in = 'Y' then\n+            for i in 1..array_upper(ents_to_process, 1) loop\n+                for ent in ents(ents_to_process[i]) loop\n+                    create_row := 'Y';\n+                    for oe in org_ents(ent.label) loop\n+                        create_row := 'N';\n+                    end loop;\n+                    if create_row = 'Y' then\n+                        insert into rhnOrgEntitlements(org_id, entitlement_id)\n+                            values (org_id_in, ent.id);\n+                    end if;\n+                end loop;\n+            end loop;\n+            for i in 1..array_upper(roles_to_process, 1) loop\n+                for role in roles(roles_to_process[i]) loop\n+                    create_row := 'Y';\n+                    for o_r in org_roles(role.label) loop\n+                        create_row := 'N';\n+                    end loop;\n+                    if create_row = 'Y' then\n+                        insert into rhnUserGroup(\n+                                id, name, description, current_members,\n+                                group_type, org_id\n+                            ) (\n+                                select  nextval('rhn_user_group_id_seq'),\n+                                        ugt.name || 's',\n+                                        ugt.name || 's for Org ' ||\n+                                            o.name || ' ('|| o.id ||')',\n+                                        0, ugt.id, o.id\n+                                from    rhnUserGroupType ugt,\n+                                        web_customer o\n+                                where   o.id = org_id_in\n+                                    and ugt.id = role.id\n+                            );\n+                    end if;\n+                end loop;\n+            end loop;\n+        else\n+            for i in 1..coalesce(array_upper(ents_to_process, 1), 0) loop\n+                for ent in ents(ents_to_process[i]) loop\n+                    delete from rhnOrgEntitlements\n+                     where org_id = org_id_in\n+                       and entitlement_id = ent.id;\n+                end loop;\n+            end loop;\n+        end if;\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_enterprise (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'enterprise', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_provisioning (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'provisioning', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_monitoring (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'monitoring', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_nonlinux (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'nonlinux', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_enterprise (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'enterprise', 'N');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_provisioning (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'provisioning', 'N');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_monitoring (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'monitoring', 'N');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_nonlinux (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'nonlinux', 'N');\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: prune_group\n+    -- Unsubscribes servers consuming physical slots that over the org's\n+    --   limit.\n+    -- Called by: set_group_count, repoll_virt_guest_entitlements\n+    -- *******************************************************************\n+    create or replace function prune_group (\n+        group_id_in in numeric,\n+        type_in in char,\n+        quantity_in in numeric,\n+        update_family_countsYN in numeric default 1\n+    ) returns void\n+as $$\n+    declare\n+        ugrecord record;\n+        sgrecord record;\n+      type_is_base char;\n+    begin\n+        if type_in = 'U' then\n+            update      rhnUserGroup\n+                set     max_members = quantity_in\n+                where   id = group_id_in;\n+\n+            for ugrecord in (\n+\t\t    select  user_id, user_group_id, ugt.label\n+\t\t    from    rhnUserGroupType    ugt,\n+\t\t\t    rhnUserGroup        ug,\n+\t\t\t    rhnUserGroupMembers ugm\n+\t\t    where   1=1\n+\t\t\tand ugm.user_group_id = group_id_in\n+\t\t\tand ugm.user_id in (\n+\t\t\t\t    select  user_id\n+\t\t\t\t    from    rhnUserGroupMembers\n+\t\t\t\t    where   user_group_id = group_id_in\n+\t\t\t\t    order by modified asc\n+\t\t\t\t    offset quantity_in\n+\t\t\t\t)\n+\t\t\tand ugm.user_group_id = ug.id\n+\t\t\tand ug.group_type = ugt.id\n+\t    ) loop\n+                perform rhn_user.remove_from_usergroup(ugrecord.user_id, ugrecord.user_group_id);\n+            end loop;\n+        elsif type_in = 'S' then\n+            update      rhnServerGroup\n+                set     max_members = quantity_in\n+                where   id = group_id_in;\n+\n+            for sgrecord in (\n+\t\t   select  server_id, server_group_id, sgt.id as group_type_id, sgt.label\n+\t\t    from    rhnServerGroupType              sgt,\n+\t\t\t\t    rhnServerGroup                  sg,\n+\t\t\t\t    rhnServerGroupMembers   sgm\n+\t\t    where   1=1\n+\t\t\t    and sgm.server_group_id = group_id_in\n+\t\t\t    and sgm.server_id in (\n+\t\t\t\t    select  sep.server_id\n+\t\t\t\t    from\n+\t\t\t\t\trhnServerEntitlementPhysical sep\n+\t\t\t\t    where\n+\t\t\t\t\tsep.server_group_id = group_id_in\n+\t\t\t\t    order by sep.modified asc\n+\t\t\t\t    offset quantity_in\n+\t\t\t\t)\n+\t\t\t    and sgm.server_group_id = sg.id\n+\t\t\t    and sg.group_type = sgt.id\n+\t    ) loop\n+                perform rhn_entitlements.remove_server_entitlement(sgrecord.server_id, sgrecord.label);\n+\n+            select is_base\n+            into type_is_base\n+            from rhnServerGroupType sgt\n+            where sgt.id = sgrecord.group_type_id;\n+\n+            -- if we're removing a base ent, then be sure to\n+            -- remove the server's channel subscriptions.\n+            if ( type_is_base = 'Y' ) then\n+                   perform rhn_channel.clear_subscriptions(sgrecord.server_id, update_family_countsYN);\n+            end if;\n+\n+            end loop;\n+        end if;\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: assign_system_entitlement\n+    --\n+    -- Moves system entitlements from from_org_id_in to to_org_id_in.\n+    -- Can raise not_enough_entitlements_in_base_org if from_org_id_in\n+    -- does not have enough entitlements to cover the move.\n+    -- Takes care of unentitling systems if necessary by calling\n+    -- set_group_count\n+    -- *******************************************************************\n+    create or replace function assign_system_entitlement(\n+        group_label_in in varchar,\n+        from_org_id_in in numeric,\n+        to_org_id_in in numeric,\n+        quantity_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+        prev_ent_count numeric;\n+    to_org_prev_ent_count numeric;\n+        new_ent_count numeric;\n+    new_quantity numeric;\n+        group_type numeric;\n+    begin\n+\n+            select max_members\n+            into prev_ent_count\n+            from rhnServerGroupType sgt,\n+                 rhnServerGroup sg\n+            where sg.org_id = from_org_id_in\n+              and sg.group_type = sgt.id\n+              and sgt.label = group_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'not_enough_entitlements_in_base_org');\n+            end if;\n+\n+            select max_members\n+            into to_org_prev_ent_count\n+            from rhnServerGroupType sgt,\n+                 rhnServerGroup sg\n+            where sg.org_id = to_org_id_in\n+              and sg.group_type = sgt.id\n+              and sgt.label = group_label_in;\n+\n+            if not found then\n+                to_org_prev_ent_count := 0;\n+            end if;\n+\n+            select id\n+            into group_type\n+            from rhnServerGroupType\n+            where label = group_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'invalid_server_group');\n+            end if;\n+\n+        new_ent_count := prev_ent_count - quantity_in;\n+\n+        if prev_ent_count > new_ent_count then\n+            new_quantity := to_org_prev_ent_count + quantity_in;\n+        end if;\n+\n+        if new_ent_count < 0 then\n+            perform rhn_exception.raise_exception(\n+                          'not_enough_entitlements_in_base_org');\n+        end if;\n+\n+\n+        perform rhn_entitlements.set_group_count(from_org_id_in,\n+                                         'S',\n+                                         group_type,\n+                                         new_ent_count);\n+\n+        perform rhn_entitlements.set_group_count(to_org_id_in,\n+                                         'S',\n+                                         group_type,\n+                                         new_quantity);\n+\n+        -- Create or delete the entries in rhnOrgEntitlementType\n+        if group_label_in = 'enterprise_entitled' then\n+            if new_quantity > 0 then\n+                perform rhn_entitlements.set_customer_enterprise(to_org_id_in);\n+            else\n+                perform rhn_entitlements.unset_customer_enterprise(to_org_id_in);\n+            end if;\n+        end if;\n+\n+        if group_label_in = 'provisioning_entitled' then\n+            if new_quantity > 0 then\n+                perform rhn_entitlements.set_customer_provisioning(to_org_id_in);\n+            else\n+                perform rhn_entitlements.unset_customer_provisioning(to_org_id_in);\n+            end if;\n+        end if;\n+\n+        if group_label_in = 'monitoring_entitled' then\n+            if new_quantity > 0 then\n+                perform rhn_entitlements.set_customer_monitoring(to_org_id_in);\n+            else\n+                perform rhn_entitlements.unset_customer_monitoring(to_org_id_in);\n+            end if;\n+        end if;\n+\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: assign_channel_entitlement\n+    --\n+    -- Moves channel entitlements from from_org_id_in to to_org_id_in.\n+    -- Can raise not_enough_entitlements_in_base_org if from_org_id_in\n+    -- does not have enough entitlements to cover the move.\n+    -- Takes care of unentitling systems if necessary by calling\n+    -- set_family_count\n+    -- *******************************************************************\n+    create or replace function assign_channel_entitlement(\n+        channel_family_label_in in varchar,\n+        from_org_id_in in numeric,\n+        to_org_id_in in numeric,\n+        quantity_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+        prev_ent_count numeric;\n+        new_ent_count numeric;\n+    to_org_prev_ent_count numeric;\n+    new_quantity numeric;\n+        cfam_id       numeric;\n+    begin\n+\n+            select max_members\n+            into prev_ent_count\n+            from rhnChannelFamily cf,\n+                 rhnPrivateChannelFamily pcf\n+            where pcf.org_id = from_org_id_in\n+              and pcf.channel_family_id = cf.id\n+              and cf.label = channel_family_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'not_enough_entitlements_in_base_org');\n+            end if;\n+\n+            select max_members\n+            into to_org_prev_ent_count\n+            from rhnChannelFamily cf,\n+                 rhnPrivateChannelFamily pcf\n+            where pcf.org_id = to_org_id_in\n+              and pcf.channel_family_id = cf.id\n+              and cf.label = channel_family_label_in;\n+\n+            if not found then\n+                to_org_prev_ent_count := 0;\n+            end if;\n+\n+            select id\n+            into cfam_id\n+            from rhnChannelFamily\n+            where label = channel_family_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'invalid_channel_family');\n+            end if;\n+\n+        new_ent_count := prev_ent_count - quantity_in;\n+\n+    if prev_ent_count > new_ent_count then\n+            new_quantity := to_org_prev_ent_count + quantity_in;\n+    end if;\n+\n+\n+        if new_ent_count < 0 then\n+            perform rhn_exception.raise_exception(\n+                          'not_enough_entitlements_in_base_org');\n+        end if;\n+\n+        perform rhn_entitlements.set_family_count(from_org_id_in,\n+                                          cfam_id,\n+                                          new_ent_count);\n+\n+        perform rhn_entitlements.set_family_count(to_org_id_in,\n+                                          cfam_id,\n+                                          new_quantity);\n+\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: activate_system_entitlement\n+    --\n+    -- Sets the values in rhnServerGroup for a given rhnServerGroupType.\n+    --\n+    -- Calls: set_group_count to update, prune, or create the group.\n+    -- Called by: the code that activates a satellite cert.\n+    --\n+    -- Raises not_enough_entitlements_in_base_org if all entitlements\n+    -- in the org are used so the free entitlements would not cover\n+    -- the difference when descreasing the NUMERIC of entitlements.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e"}, "originalPosition": 1229}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e", "committedDate": "2020-02-14T10:13:39Z", "message": "update changelog"}, "afterCommit": {"oid": "01be1dd75ab246eb0918c2faa07221ff2b87c5bd", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/01be1dd75ab246eb0918c2faa07221ff2b87c5bd", "committedDate": "2020-02-19T09:24:09Z", "message": "fix comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a36e883e5ce84a0ed42a06917f06cee2d8ba74e2", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a36e883e5ce84a0ed42a06917f06cee2d8ba74e2", "committedDate": "2020-02-19T16:58:37Z", "message": "convert common/tables to postgresql syntax"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09bab0144f3a7cf3e8e3e0bbbcd38816fad256a9", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/09bab0144f3a7cf3e8e3e0bbbcd38816fad256a9", "committedDate": "2020-02-19T16:58:37Z", "message": "remove oracle subdir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f830347f70dc9c94afe637a45003a8046e73d5ce", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f830347f70dc9c94afe637a45003a8046e73d5ce", "committedDate": "2020-02-19T16:58:37Z", "message": "remove oracle schema migrations and copy postgresql to global migrations for spacewalk schema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6b6fea1946c798a2a8baad4ba3d836b167f18e7", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e6b6fea1946c798a2a8baad4ba3d836b167f18e7", "committedDate": "2020-02-19T16:58:37Z", "message": "remove oracle migrations and copy postgresql to global for susemanager schema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4ca2be5903e6c195f00247bd89ba58aae184482", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f4ca2be5903e6c195f00247bd89ba58aae184482", "committedDate": "2020-02-19T16:58:37Z", "message": "remove empty files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5be4fd2a1c4abfa9363785fdd90977eccfe5f80", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f5be4fd2a1c4abfa9363785fdd90977eccfe5f80", "committedDate": "2020-02-19T16:58:37Z", "message": "fix not empty files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6413c1ff717392caf54ccb121ecd460cd3de4f8e", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/6413c1ff717392caf54ccb121ecd460cd3de4f8e", "committedDate": "2020-02-19T16:58:37Z", "message": "remove \"oracle equivalent\" line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b33f3cd8c308d98406e3b956520567829fc28cf3", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b33f3cd8c308d98406e3b956520567829fc28cf3", "committedDate": "2020-02-19T16:58:38Z", "message": "remove \"oracle equivalent\" and \"retrieved from\" headers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3228a46874370a866e99f07995d481faf32f3f6e", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3228a46874370a866e99f07995d481faf32f3f6e", "committedDate": "2020-02-19T16:58:38Z", "message": "drop oracle from scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a912073fdb03d856af17921b2c341adef9949e9", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7a912073fdb03d856af17921b2c341adef9949e9", "committedDate": "2020-02-19T16:58:38Z", "message": "join dblink migrations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ff06173bb59e209b91c31c5c42d28f6dab2e85a", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8ff06173bb59e209b91c31c5c42d28f6dab2e85a", "committedDate": "2020-02-19T16:58:38Z", "message": "fix Makefiles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6966e8ffefc16f2a585f222e1c8ab97c6cfa867f", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/6966e8ffefc16f2a585f222e1c8ab97c6cfa867f", "committedDate": "2020-02-19T16:58:38Z", "message": "add DB backend suffix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "530999ff25811904725575a67e1d684080a89c0f", "author": {"user": {"login": "moio", "name": "Silvio Moioli"}}, "url": "https://github.com/uyuni-project/uyuni/commit/530999ff25811904725575a67e1d684080a89c0f", "committedDate": "2020-02-19T16:58:38Z", "message": "Remove Oracle-only MessageQueueEventListener"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9961ebbff7c27ad8ea21c48e62760a958d75eac8", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/9961ebbff7c27ad8ea21c48e62760a958d75eac8", "committedDate": "2020-02-19T16:58:38Z", "message": "drop oracle from spacewalk-backend"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "088007607a1b8b086f0be684c0f5fa65f4e08094", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/088007607a1b8b086f0be684c0f5fa65f4e08094", "committedDate": "2020-02-19T16:58:38Z", "message": "remove oracle from test tooling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4926f838be04841625ba32a7a28f6a0bf851ad16", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4926f838be04841625ba32a7a28f6a0bf851ad16", "committedDate": "2020-02-19T16:58:38Z", "message": "drop oracle from java code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bea44be2ef44ef8b9a38ebf54c43af8f3730607f", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/bea44be2ef44ef8b9a38ebf54c43af8f3730607f", "committedDate": "2020-02-19T16:58:38Z", "message": "remove oracle db backend from supportutils plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ad2112a07de6edf5f823a9d8e598f3ab828744a", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3ad2112a07de6edf5f823a9d8e598f3ab828744a", "committedDate": "2020-02-19T16:58:38Z", "message": "remove oracle from susmanager tooling\n\n- oracle2postgresql must be executed on a system which still has oracle\n  (3.2 or earlier)\n- no new setups supported anymore - remove the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d081c185bdb5783f4353246c500347266b10426", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1d081c185bdb5783f4353246c500347266b10426", "committedDate": "2020-02-19T16:58:38Z", "message": "more oracle removals from schema package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "910b64ee37d60a48e0115a7778b3e177d669f44b", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/910b64ee37d60a48e0115a7778b3e177d669f44b", "committedDate": "2020-02-19T16:58:38Z", "message": "remove oracle DB support from reporting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef8067996653b7f4efd6743e266dd8014ae3938", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/0ef8067996653b7f4efd6743e266dd8014ae3938", "committedDate": "2020-02-19T16:58:38Z", "message": "remove oracle subpackage from spacewalk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b476a5ba3aef8d504aa0ef0f52f6595133949e6", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/9b476a5ba3aef8d504aa0ef0f52f6595133949e6", "committedDate": "2020-02-19T16:58:38Z", "message": "comvert all sqlsyntax to postgres format for all versions > 1.2 which support postregs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1431c459c1976955af39c718e197ec054cb5c8ad", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1431c459c1976955af39c718e197ec054cb5c8ad", "committedDate": "2020-02-19T16:59:09Z", "message": "update changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6fe60bcefb6d6d8842403cadcc447cfac0af084", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f6fe60bcefb6d6d8842403cadcc447cfac0af084", "committedDate": "2020-02-19T16:59:09Z", "message": "fix comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01be1dd75ab246eb0918c2faa07221ff2b87c5bd", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/01be1dd75ab246eb0918c2faa07221ff2b87c5bd", "committedDate": "2020-02-19T09:24:09Z", "message": "fix comments"}, "afterCommit": {"oid": "f6fe60bcefb6d6d8842403cadcc447cfac0af084", "author": {"user": {"login": "mcalmer", "name": "Michael Calmer"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f6fe60bcefb6d6d8842403cadcc447cfac0af084", "committedDate": "2020-02-19T16:59:09Z", "message": "fix comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1653, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}