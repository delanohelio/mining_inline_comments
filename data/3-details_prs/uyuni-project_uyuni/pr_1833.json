{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NDA0MTQw", "number": 1833, "title": "Get the grains that we check on every startup from the start event", "bodyText": "What does this PR change?\nGet the grains (machine_id, saltboot_initrd, management_key) that we check on every startup from the start event instead of making a separate call.\nBackground\nWe faced performance issues during minions startup as machine_id grains is needed to lookup if minion already exists in the database. This is needed to differentiate between a startup and 1st-time registration.\nWe followed different approaches, each with some pros/cons. Those approaches are described herein this PR description SUSE/spacewalk#8892. The related research card is SUSE/spacewalk#8228 where one can see further discussion.\nIn the end, we introduced a patch in upstream which makes it possible to pass interesting grains in the payload of minion start-up event. Related PR saltstack/salt#54948.\nWe think this is better approach in a sense that, we don't need to make a separate call, of course, it has a downside that all the minions need to have this new parameter in their config so next time, when minion get started, we use grains from the start_up event instead of making a separate call.\nIt is also noticeable that I kept the old way as a fallback, the reason was the older minions might not get the new changes so we have to have a backup plan.\nWe save 1 salt call in case of already registered minions, even if startup grains are not configured.\nSo if start-up grains are supported, with this PR number of salt sync calls are following\n\n\n\nTest\nBefore\nAfter\n\n\n\n\nNew registration\n2\n1\n\n\nRegistered minion startup\n2\n0\n\n\n\nIf start-up grains are not supported, with this PR number of salt sync calls are following\n\n\n\nTest\nBefore\nAfter\n\n\n\n\nNew registration\n2\n2\n\n\nRegistered minion startup\n2\n1\n\n\n\nBenchmarks\nAccording to tests with 100 evil-minions at normal speed mode (--slowdown-factor 1) an ~1.32x speedup on the total time to handle all minion start events (29s on average versus 38.5s).\nNote that it is expected that the slower the simulated minions, the bigger the speedup.\nGUI diff\nNo difference.\n\n DONE\n\nDocumentation\n-Instead of a separate call, the grain is part of startup event, there is nothing to document here for the customer. I will add the documentation for using the helper `mgr_start_event_grains.sls state though\nuyuni-project/uyuni-docs#88\n\n DONE\n\nTest coverage\n\n\nNo tests: Existing tests are modified\n\n\n DONE\n\n\nLinks\nFixes # SUSE/spacewalk#9909\nTracks # add downstream PR, if any\n\n DONE", "createdAt": "2020-01-27T10:03:44Z", "url": "https://github.com/uyuni-project/uyuni/pull/1833", "merged": true, "mergeCommit": {"oid": "ee453d9cfe3ece7d6996a3efe2d3c00e06349859"}, "closed": true, "closedAt": "2020-02-25T08:01:17Z", "author": {"login": "admd"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-Z7EpgBqjI5ODExODQ1ODg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHtcTuABqjMwNjgzNDI4Nzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b5f219e638bcec8f8b9fd04307271d6a31098b35", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/b5f219e638bcec8f8b9fd04307271d6a31098b35", "committedDate": "2020-01-27T09:43:18Z", "message": "get the machine-id grain from the start up event"}, "afterCommit": {"oid": "d9b2fbf8704d6696a712ff7e36031a74ab559a0f", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/d9b2fbf8704d6696a712ff7e36031a74ab559a0f", "committedDate": "2020-01-27T10:10:07Z", "message": "get the machine-id grain from the start up event"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d9b2fbf8704d6696a712ff7e36031a74ab559a0f", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/d9b2fbf8704d6696a712ff7e36031a74ab559a0f", "committedDate": "2020-01-27T10:10:07Z", "message": "get the machine-id grain from the start up event"}, "afterCommit": {"oid": "7e1dc28f317807510325438ed1d501893b088cb8", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7e1dc28f317807510325438ed1d501893b088cb8", "committedDate": "2020-01-27T10:47:04Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e1dc28f317807510325438ed1d501893b088cb8", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7e1dc28f317807510325438ed1d501893b088cb8", "committedDate": "2020-01-27T10:47:04Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}, "afterCommit": {"oid": "4a8bbece5243c368e9466840e93d55206ffece72", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4a8bbece5243c368e9466840e93d55206ffece72", "committedDate": "2020-01-27T12:10:48Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a8bbece5243c368e9466840e93d55206ffece72", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4a8bbece5243c368e9466840e93d55206ffece72", "committedDate": "2020-01-27T12:10:48Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}, "afterCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3eeecaaeee83c6f158eeea1a5f9789945813abb3", "committedDate": "2020-01-27T12:46:23Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njc1MDg3", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-348675087", "createdAt": "2020-01-27T13:52:05Z", "commit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1MjowNVrOFiDTaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozOTowM1rOFiE7kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MDAyNQ==", "bodyText": "A nitpick, but as this is completely new file, I'm not sure it is possible to claim copyright since 2015.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371250025", "createdAt": "2020-01-27T13:52:05Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/reactor/messaging/MinionStartupGrains.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2015--2019 SUSE LLC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzUwNw==", "bodyText": "Another nitpick, but rMinEMessage variable name makes it difficult to read for me :D", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371253507", "createdAt": "2020-01-27T13:58:37Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -115,8 +115,9 @@ public RegisterMinionEventMessageAction(SaltService saltService) {\n      */\n     @Override\n     public void execute(EventMessage msg) {\n-        registerMinion(((RegisterMinionEventMessage) msg).getMinionId(), false,\n-                empty(), empty());\n+        RegisterMinionEventMessage rMinEMessage = ((RegisterMinionEventMessage) msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NzYzMg==", "bodyText": "The same as before. New file, but copyright retroactive to 2015", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371257632", "createdAt": "2020-01-27T14:06:34Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartEvent.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2015--2019 SUSE LLC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MTY4Ng==", "bodyText": "How does this behave if grain is added to this list, but is not set for that minion? Is the grain simply ignored?\nI'm asking because in the registration routine we also always check for saltboot_initrd grain and activation key grain as well (see https://github.com/uyuni-project/uyuni/blob/master/java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java#L362 ).", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371261686", "createdAt": "2020-01-27T14:14:01Z", "author": {"login": "aaannz"}, "path": "susemanager-utils/susemanager-sls/salt/util/mg_start_event_grains.sls", "diffHunk": "@@ -0,0 +1,6 @@\n+mgr_start_event_grains:\n+  file.append:\n+    - name: /etc/salt/minion.d/susemanager.conf\n+    - text: |\n+        start_event_grains:\n+          - machine_id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MDg5NA==", "bodyText": "I'm confused. Previously it was possible to reactive system with the same minionId. This line will now prevents it. Is this intentional?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371270894", "createdAt": "2020-01-27T14:29:37Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,69 +128,67 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        getMachineId(minionId, empty())\n+                .ifPresent(machineId-> registerMinion(minionId, true, proxyId, activationKeyOverride, machineId));\n     }\n \n+     /**\n+     * Return the machine Id, it looks up start_event_grains & if it doesn't exist then fall back to the salt call\n+     * @param minionId minion id\n+     * @param startupGrains start up grains start_event_grains\n+     * @return Machine Id\n+     */\n+    private Optional<String> getMachineId(String minionId, Optional<MinionStartupGrains> startupGrains) {\n+        Optional<String> machineId =\n+                Opt.or(startupGrains.flatMap(msg -> msg.getMachineId()), ()-> SALT_SERVICE.getMachineId(minionId));\n+        if (!machineId.isPresent()) {\n+            LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+        }\n+        return machineId;\n+    }\n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n-            () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId) {\n+        if (!duplicateMinionNamePresent(minionId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MzI3NQ==", "bodyText": "Now I'm wondering what is the purpose of having startup grains. Because up until this point machine id is not used anywhere. Couldn't we just refactored registerMinion routing to check for machingID only after this grain call?\nOr should we instead put all the necessary grains needed for registration to the startup grains and after the registration schedule hardware refresh to get the rest of the grains?\nOr am I missing something?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371273275", "createdAt": "2020-01-27T14:33:34Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,69 +128,67 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        getMachineId(minionId, empty())\n+                .ifPresent(machineId-> registerMinion(minionId, true, proxyId, activationKeyOverride, machineId));\n     }\n \n+     /**\n+     * Return the machine Id, it looks up start_event_grains & if it doesn't exist then fall back to the salt call\n+     * @param minionId minion id\n+     * @param startupGrains start up grains start_event_grains\n+     * @return Machine Id\n+     */\n+    private Optional<String> getMachineId(String minionId, Optional<MinionStartupGrains> startupGrains) {\n+        Optional<String> machineId =\n+                Opt.or(startupGrains.flatMap(msg -> msg.getMachineId()), ()-> SALT_SERVICE.getMachineId(minionId));\n+        if (!machineId.isPresent()) {\n+            LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+        }\n+        return machineId;\n+    }\n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n-            () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId) {\n+        if (!duplicateMinionNamePresent(minionId)) {\n+            boolean isReactivation = false;\n+            ActivationKey ak = null;\n+            ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjY4OQ==", "bodyText": "I would really put grains required to detect reactivation 'susemanager:management_key' as startup grains as well. So we can ask for the rest of grains either here or directly in finalizeMinionRegistration.\nWe will then skip the grains call for all already registered minions only having their salt minions restarted.\nCould that work?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371276689", "createdAt": "2020-01-27T14:39:03Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,69 +128,67 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        getMachineId(minionId, empty())\n+                .ifPresent(machineId-> registerMinion(minionId, true, proxyId, activationKeyOverride, machineId));\n     }\n \n+     /**\n+     * Return the machine Id, it looks up start_event_grains & if it doesn't exist then fall back to the salt call\n+     * @param minionId minion id\n+     * @param startupGrains start up grains start_event_grains\n+     * @return Machine Id\n+     */\n+    private Optional<String> getMachineId(String minionId, Optional<MinionStartupGrains> startupGrains) {\n+        Optional<String> machineId =\n+                Opt.or(startupGrains.flatMap(msg -> msg.getMachineId()), ()-> SALT_SERVICE.getMachineId(minionId));\n+        if (!machineId.isPresent()) {\n+            LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+        }\n+        return machineId;\n+    }\n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n-            () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId) {\n+        if (!duplicateMinionNamePresent(minionId)) {\n+            boolean isReactivation = false;\n+            ActivationKey ak = null;\n+            ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+            Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+            if (managmentKeyLabel.isPresent()) {\n+                ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n+                if (ak != null && ak.getKickstartSession() != null) {\n+                    ak.getKickstartSession().markComplete(\"Installation completed.\");\n                 }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n+                if (ak == null) {\n+                    LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n                 }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n+                else if (ak.getServer() == null) {\n+                    LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n                 }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n+                else {\n+                    isReactivation = true;\n                 }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n             }\n-        );\n+            Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+            if (!isReactivation &&\n+                    checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n+                return;\n+            }\n+            if (isReactivation) {\n+                reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n+            }\n+            finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3"}, "originalPosition": 123}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3eeecaaeee83c6f158eeea1a5f9789945813abb3", "committedDate": "2020-01-27T12:46:23Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}, "afterCommit": {"oid": "e400c307d401427d14f339fead52a74ed1a02918", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e400c307d401427d14f339fead52a74ed1a02918", "committedDate": "2020-01-28T13:41:22Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e400c307d401427d14f339fead52a74ed1a02918", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e400c307d401427d14f339fead52a74ed1a02918", "committedDate": "2020-01-28T13:41:22Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}, "afterCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "committedDate": "2020-01-30T10:31:53Z", "message": "update units test & some more refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTg0Mjc0", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-352184274", "createdAt": "2020-02-03T11:22:35Z", "commit": {"oid": "0e1e1a16e196d7e56cc2cd93f3f5301162064116"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyMjozNlrOFkuKUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMzozNDowN1rOFkxdBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0OTM2Mg==", "bodyText": "Please rephrase in a user-facing way - this is what we know happens under the hood, but what is the user-visible effect?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374049362", "createdAt": "2020-02-03T11:22:36Z", "author": {"login": "moio"}, "path": "java/spacewalk-java.changes", "diffHunk": "@@ -1,3 +1,4 @@\n+- Get the machineid grain from the minion startup event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1e1a16e196d7e56cc2cd93f3f5301162064116"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA2OTAxNA==", "bodyText": "Please rephrase in a user-facing way: why should one be interested?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374069014", "createdAt": "2020-02-03T12:12:42Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/susemanager-sls.changes", "diffHunk": "@@ -1,3 +1,4 @@\n+- Add mgr_start_event_grains.sls to update minion config", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3NzM2Mw==", "bodyText": "Do we have a plan to move this class in salt-netapi-library?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374077363", "createdAt": "2020-02-03T12:34:19Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/webui/utils/salt/Grains.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.suse.salt.netapi.calls.LocalCall;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+/**\n+ * salt.modules.grains\n+ */\n+public class Grains {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTIwMA==", "bodyText": "Do we have a plan to move this class in salt-netapi-library?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374079200", "createdAt": "2020-02-03T12:39:04Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartEvent.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonElement;\n+import com.google.gson.reflect.TypeToken;\n+import com.suse.salt.netapi.datatypes.Event;\n+import com.suse.salt.netapi.parser.JsonParser;\n+import com.suse.utils.Json;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Represents an event fired when a minion connects to the salt master\n+ */\n+public class MinionStartEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTgzNQ==", "bodyText": "Do we plan to use this new Grains class also elsewhere, eg. in the singular getGrain?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374079835", "createdAt": "2020-02-03T12:40:47Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/webui/services/impl/SaltService.java", "diffHunk": "@@ -416,6 +417,18 @@ public boolean keyExists(String id, KeyStatus... statusIn) {\n                 .orElseThrow(() -> new RuntimeException(\"no wheel results\"));\n     }\n \n+    /**\n+     * Get the specified grains for a given minion.\n+     * @param minionId id of the target minion\n+     * @param type  class type, result should be parsed into\n+     * @param grainNames list of grains names\n+     * @param <T> Type result should be parsed into\n+     * @return Optional containing the grains parsed into specified type\n+     */\n+    public <T> Optional<T> getGrains(String minionId, TypeToken<T> type, String... grainNames) {\n+       return callSync(com.suse.manager.webui.utils.salt.Grains.item(false, type, grainNames), minionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA4MDI0MA==", "bodyText": "Indentation seems off here and in other places in this file, please double check them all.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374080240", "createdAt": "2020-02-03T12:41:41Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/test/RegisterMinionActionTest.java", "diffHunk": "@@ -664,6 +680,8 @@ public void testRegisterMinionWithActivationKeySUSEManagerDefault() throws Excep\n                 will(returnValue(Optional.of(MINION_ID)));\n                 allowing(saltServiceMock).getMachineId(MINION_ID);\n                 will(returnValue(Optional.of(MACHINE_ID)));\n+                    allowing(saltServiceMock).getGrains(with(any(String.class)), with(any(TypeToken.class)),with(any(String[].class)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA4NjkxMg==", "bodyText": "Looks like this method is unused.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374086912", "createdAt": "2020-02-03T12:57:30Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +132,131 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration.\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, machineId,\n+                            saltbootInitrd));\n+            });\n     }\n \n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId, boolean saltbootInitrd) {\n+        Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+        Opt.consume(registeredMinionOpt,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n+               if (!duplicateMinionNamePresent(minionId)) {\n+                   ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+                   Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+                   Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+                   reactivateSystem(minionId, machineId, managmentKeyLabel);\n+                   finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH,\n+                                grains);\n+                     }\n+               },\n+            registeredMinion -> {\n+                updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+             });\n+    }\n \n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n             }\n-        );\n+        }\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+    private Optional<MinionServer> getRegisteredMinion(String machineId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA5OTQyMw==", "bodyText": "It seems like the meaning of this method has changed significantly: before it used to mean \"set minion and machine ids according to the reactivation key, if we have one\" - now it means \"conclude the kickstart session, if any, check that we have a Activation Key, that it is actually a reactivation key and only in that case then set minion and machine ids\". I think those are conceptually separate now and we should either keep the original name and meaning or change both, or rearrange code in some other way.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374099423", "createdAt": "2020-02-03T13:26:07Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +132,131 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration.\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, machineId,\n+                            saltbootInitrd));\n+            });\n     }\n \n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId, boolean saltbootInitrd) {\n+        Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+        Opt.consume(registeredMinionOpt,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n+               if (!duplicateMinionNamePresent(minionId)) {\n+                   ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+                   Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+                   Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+                   reactivateSystem(minionId, machineId, managmentKeyLabel);\n+                   finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH,\n+                                grains);\n+                     }\n+               },\n+            registeredMinion -> {\n+                updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+             });\n+    }\n \n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n             }\n-        );\n+        }\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+    private Optional<MinionServer> getRegisteredMinion(String machineId) {\n+        return  MinionServerFactory.findByMachineId(machineId);\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n-     * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param managmentKeyLabel managment_key grain\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-\n-                if (!minionId.equals(oldMinionId)) {\n-                    SALT_SERVICE.deleteKey(oldMinionId);\n-                }\n+    private void reactivateSystem(String minionId, String machineId, Optional<String> managmentKeyLabel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEwMzMwMQ==", "bodyText": "I have a hard time following if and why the logic has changed here.\nOld code called reactivateSystem only if a reactivation key is used (a managmentKeyLabel is set in grains, it actually corresponds to an existing Activation Key, that Activation Key has an attached Server). It does not care whatever duplicateMinionNamePresent returns, in fact it does not call that method at all in case of a reactivation key (isReactivation == true).\nNew code seems to rule out that a reactivation may happen if a duplicate minion name is present - but that is a possibility.\nAm I missing anything?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374103301", "createdAt": "2020-02-03T13:34:07Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +132,131 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration.\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, machineId,\n+                            saltbootInitrd));\n+            });\n     }\n \n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId, boolean saltbootInitrd) {\n+        Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+        Opt.consume(registeredMinionOpt,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n+               if (!duplicateMinionNamePresent(minionId)) {\n+                   ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+                   Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+                   Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+                   reactivateSystem(minionId, machineId, managmentKeyLabel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzY5ODIz", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-353369823", "createdAt": "2020-02-04T23:13:15Z", "commit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMzoxMzoxNVrOFlmzWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMzoxMzoxNVrOFlmzWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3NzM3MQ==", "bodyText": "As you are touching this code, can you take a look at #1835, please.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374977371", "createdAt": "2020-02-04T23:13:15Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation\n+        Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+        Opt.consume(managementKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride,\n+                                    isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n+            //Case-2 : Reactivation\n+            mk -> {\n+                reactivateSystem(minionId, machineId, mk);\n+                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+            }\n+        );\n+    }\n+\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param managmentKeyLabel managment_key grain\n+     */\n+    private void reactivateSystem(String minionId, String machineId, String managmentKeyLabel) {\n+        Optional<ActivationKey> akey = ofNullable(ActivationKeyFactory.lookupByKey(managmentKeyLabel));\n+        Opt.consume(akey,\n+                () -> LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel),\n+                ak -> {\n+                    if (Objects.nonNull(ak.getKickstartSession())) {\n                         ak.getKickstartSession().markComplete(\"Installation completed.\");\n                     }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n+                    if (Objects.isNull(ak.getServer())) {\n+                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel);\n                     }\n                     else {\n-                        isReactivation = true;\n+                        // The machine id may have changed, but we know from the reactivation key\n+                        // which system should become this one\n+                        ak.getServer().asMinionServer().ifPresent(minion -> {\n+                            minion.setMachineId(machineId);\n+                            minion.setMinionId(minionId);\n+                        });\n                     }\n                 }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n-            }\n         );\n-    }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n+     * Update information of already registered minion, in case minion_id is different.\n      * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * @param registeredMinion existing registered minion\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-\n-                if (!minionId.equals(oldMinionId)) {\n-                    SALT_SERVICE.deleteKey(oldMinionId);\n-                }\n-            }\n-\n-            // Saltboot treatment\n-            // HACK: try to guess if the minion is a retail minion based on its groups.\n-            // This way we don't need to call grains for each register minion event.\n-            if (isRetailMinion(registeredMinion)) {\n-                if (grains.getOptionalAsBoolean(\"saltboot_initrd\").orElse(false)) {\n-                    // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n-                    LOG.info(\"Applying saltboot for minion \" + minionId);\n-                    applySaltboot(registeredMinion);\n-                }\n-            }\n-            return true;\n+    public void updateAlreadyRegisteredInfo(String minionId, MinionServer registeredMinion) {\n+        String oldMinionId = registeredMinion.getMinionId();\n+        if (!minionId.equals(oldMinionId)) {\n+            LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n+                    \"profile to '\" + minionId + \"' [\" + registeredMinion.getMachineId() + \"]\");\n+            registeredMinion.setName(minionId);\n+            registeredMinion.setMinionId(minionId);\n+            ServerFactory.save(registeredMinion);\n+            SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n+                    oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n+\n+            SALT_SERVICE.deleteKey(oldMinionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 272}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg2NTAy", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-353486502", "createdAt": "2020-02-05T06:17:26Z", "commit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNjoxNzoyNlrOFlszww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo1OTozNlrOFl1SoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3NTc3OQ==", "bodyText": "This does render into correct YAML, but maybe it'll be easier to read inlined:\necho \"start_event_grains: [machine_id, saltboot_initrd, susemanager]\"", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375075779", "createdAt": "2020-02-05T06:17:26Z", "author": {"login": "moio"}, "path": "spacewalk/certs-tools/rhn_bootstrap_strings.py", "diffHunk": "@@ -993,6 +993,10 @@ def getRegistrationSaltSh(productName):\n     echo \"server_id_use_crc: adler32\" >> \"$SUSEMANAGER_MASTER_FILE\"\n     echo \"enable_legacy_startup_events: False\" >> \"$SUSEMANAGER_MASTER_FILE\"\n     echo \"enable_fqdns_grains: False\" >> \"$SUSEMANAGER_MASTER_FILE\"\n+    echo \"start_event_grains:\n+      - machine_id\n+      - saltboot_initrd\n+      - susemanager\" >> \"$SUSEMANAGER_MASTER_FILE\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3NzI1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Add mgr_start_event_grains.sls to update minion config in order to get needed grains from start event\n          \n          \n            \n            - Add mgr_start_event_grains.sls to update minion config in order to improve minion start event processing performance", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375077250", "createdAt": "2020-02-05T06:23:37Z", "author": {"login": "moio"}, "path": "susemanager-utils/susemanager-sls/susemanager-sls.changes", "diffHunk": "@@ -1,3 +1,4 @@\n+- Add mgr_start_event_grains.sls to update minion config in order to get needed grains from start event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3OTQwMw==", "bodyText": "Can't startupGrains just be passed as-is?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375079403", "createdAt": "2020-02-05T06:32:48Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/test/RegisterMinionActionTest.java", "diffHunk": "@@ -285,7 +300,12 @@ public void executeTest(ExpectationsFunction expectations, ActivationKeySupplier\n         }\n \n         RegisterMinionEventMessageAction action = new RegisterMinionEventMessageAction(saltServiceMock);\n-        action.execute(new RegisterMinionEventMessage(MINION_ID));\n+        if (startupGrains.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3OTUwNA==", "bodyText": "Please remove this comment if not necessary", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375079504", "createdAt": "2020-02-05T06:33:11Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/test/RegisterMinionActionTest.java", "diffHunk": "@@ -330,6 +350,75 @@ public void testRegisterDuplicateMinionId() throws Exception {\n         }, null, DEFAULT_CONTACT_METHOD);\n     }\n \n+    public void testAlreadyRegisteredMinionWithSameMachineId() throws Exception {\n+        MinionServer server = MinionServerFactoryTest.createTestMinionServer(user);\n+        server.setMinionId(MINION_ID);\n+        server.setMachineId(MACHINE_ID);\n+        //ServerFactory.save(server);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4MDQ5OQ==", "bodyText": "Style question: why is this class singular (SuseManagerGrain) while the parent is plural (MinionStartupGrains)? Shouldn't they both be either singular or plural?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375080499", "createdAt": "2020-02-05T06:37:35Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartupGrains.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Class to represent grains defined against 'start_event_grains'\n+ */\n+public class MinionStartupGrains {\n+    @SerializedName(\"machine_id\")\n+    private Optional<String> machineId = Optional.empty();\n+    @SerializedName(\"saltboot_initrd\")\n+    private boolean saltbootInitrd = false;\n+    @SerializedName(\"susemanager\")\n+    private Optional<SuseManagerGrain> suseManagerGrain = Optional.empty();\n+\n+    /**\n+     * no-arg constructor\n+     */\n+    public MinionStartupGrains() { }\n+\n+    /**\n+     * Constructor which accepts MinionStartupGrainsBuilder and use it to build object\n+     * @param builder MinionStartupGrainsBuilder\n+     */\n+    private MinionStartupGrains(MinionStartupGrainsBuilder builder) {\n+        this.machineId = Optional.ofNullable(builder.machineId);\n+        this.saltbootInitrd = builder.saltbootInitrd;\n+        this.suseManagerGrain = Optional.ofNullable(builder.suseManagerGrain);\n+    }\n+\n+    public Optional<String> getMachineId() {\n+        return machineId;\n+    }\n+\n+    public boolean getSaltbootInitrd() {\n+        return saltbootInitrd;\n+    }\n+\n+    public Optional<SuseManagerGrain> getSuseManagerGrain() {\n+        return suseManagerGrain;\n+    }\n+\n+    /**\n+     * Class to represent `susemanager grain\n+     */\n+    public static class SuseManagerGrain {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5ODI2NQ==", "bodyText": "Correct me if I am wrong: with this PR we get an improvement even in the case startup grains are not configured, as we call grains.items just once instead of:\n\ncalling grains.item to get the machine ID first and then\ncalling grains.items again to get all grains (only to filter out management_key and, possibly, saltboot_initrd)", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375098265", "createdAt": "2020-02-05T07:40:12Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -115,8 +118,11 @@ public RegisterMinionEventMessageAction(SaltService saltService) {\n      */\n     @Override\n     public void execute(EventMessage msg) {\n-        registerMinion(((RegisterMinionEventMessage) msg).getMinionId(), false,\n-                empty(), empty());\n+        RegisterMinionEventMessage registerMinionEventMessage = ((RegisterMinionEventMessage) msg);\n+        Optional<MinionStartupGrains> startupGrainsOpt = Opt.or(registerMinionEventMessage.getMinionStartupGrains(),\n+                () -> SALT_SERVICE.getGrains(registerMinionEventMessage.getMinionId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3ODI3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Performs minion registration/reactivation..\n          \n          \n            \n                 * Performs minion registration or reactivation.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375178279", "createdAt": "2020-02-05T10:36:43Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE4MzI4NA==", "bodyText": "Comment does not agree with code here", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375183284", "createdAt": "2020-02-05T10:46:41Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMjgzMQ==", "bodyText": "IIUC this variable is only and exclusively used by finalizeMinionRegistration, please move it inside of that method (so that getCreator does not get called if a minion is just being restarted and no reregistration/reactivation should actually happen).", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375202831", "createdAt": "2020-02-05T11:30:33Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation\n+        Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNDc1Mw==", "bodyText": "Corner case: if there is a management key but it is not a valid reactivation key, old code still checked whether the minion was already registered and if it was, it would update its name/id, possibly apply saltboot states, and move on without finalization.\nIIUC, new code will always perform finalization whenever management_key is set, which is not expected (think about a minion originally onboarded with an activation key and simply being restarted).\nWhat we might need is a method that tries to extract the management key from grains and directly checks if it is a valid reactivation key before entering this method.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375214753", "createdAt": "2020-02-05T11:59:36Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation\n+        Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+        Opt.consume(managementKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride,\n+                                    isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n+            //Case-2 : Reactivation\n+            mk -> {\n+                reactivateSystem(minionId, machineId, mk);\n+                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43a8a6f0c30d9900ff66086731ded43294e2f2a"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjkyMDg2", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-354292086", "createdAt": "2020-02-06T09:09:57Z", "commit": {"oid": "d8089f267c12a5149ab355f815c5897750fcec81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOTowOTo1OFrOFmTwMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOTowOTo1OFrOFmTwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxMzg0Mw==", "bodyText": "Sorry for being picky but I am still not convinced. Lines 199-201 are basically the same as 180+187-189: would it be possible to move isValidReactivationKey after line 155 so that we only enter the \"Case-2 branch\" if we have a key and we are also sure it's a reactivation key?\n(please double check my logic, I might be missing something as well!!!)", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375713843", "createdAt": "2020-02-06T09:09:58Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,147 +133,180 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration or reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        Opt.consume(managementKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n+            //Case-2 : Reactivation\n+            mk -> {\n+                if (isValidReactivationKey(mk, minionId)) {\n+                    reactivateSystem(minionId, machineId, mk);\n+                    finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n                 }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n+                else {\n+                    MinionServerFactory.findByMachineId(machineId).ifPresent(rm -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8089f267c12a5149ab355f815c5897750fcec81"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTU4MjQz", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-354958243", "createdAt": "2020-02-07T06:49:54Z", "commit": {"oid": "83fee18da7b6acf205bbe0e9d61ecdb21f65a5da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNjo0OTo1NFrOFmzrsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNjo0OTo1NFrOFmzrsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzNjk3Nw==", "bodyText": "One extra twist: in original code, the Kickstart session is marked complete as soon as the activation key is found in the database and has a session. In your code, this is done only if the activation key is a reactivation key.\nThinking about it a bit, completing a Kickstart session has nothing to do with reactivations, and actually nothing to do with registration either. It has more to do with normal rebooting / minion start event: if we see a minion that was being autoinstalled come up, then the autoinstallation has ended!\nI guess this if block has to be moved outside this method.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r376236977", "createdAt": "2020-02-07T06:49:54Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,147 +133,175 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> validReactivationKey =\n+                        mkey.flatMap(mk -> isValidReactivationKey(mk, minionId) ? mkey : empty());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride,\n+                            validReactivationKey, machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration or reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param reActivationKey valid reactivation key\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> reActivationKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        Opt.consume(reActivationKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n+            //Case-2 : Reactivation\n+            rk -> {\n+                reactivateSystem(minionId, machineId, rk);\n+                finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n             }\n         );\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+    /**\n+     * Check if the specified management_key is valid reactivation key or not\n+     * @param managmentKeyLabel management_key\n+     * @param minionId minion Id\n+     * @return\n+     */\n+    private boolean isValidReactivationKey(String managmentKeyLabel, String minionId) {\n+        Optional<ActivationKey> akey = ofNullable(ActivationKeyFactory.lookupByKey(managmentKeyLabel));\n+        Boolean isValid =\n+            Opt.fold(akey,\n+                () -> {\n+                    LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel);\n+                    return false;\n+                },\n+                ak -> {\n+                    if (Objects.isNull(ak.getServer())) {\n+                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel);\n+                        return false;\n+                    }\n+                    //considered valid reactivation key only in this case\n+                    return true;\n+                }\n+            );\n+        return isValid;\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n-     * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-\n-                if (!minionId.equals(oldMinionId)) {\n-                    SALT_SERVICE.deleteKey(oldMinionId);\n-                }\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n             }\n+        }\n+    }\n \n-            // Saltboot treatment\n-            // HACK: try to guess if the minion is a retail minion based on its groups.\n-            // This way we don't need to call grains for each register minion event.\n-            if (isRetailMinion(registeredMinion)) {\n-                if (grains.getOptionalAsBoolean(\"saltboot_initrd\").orElse(false)) {\n-                    // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n-                    LOG.info(\"Applying saltboot for minion \" + minionId);\n-                    applySaltboot(registeredMinion);\n-                }\n+    /**\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param reActivationKey valid Reaction key\n+     */\n+    private void reactivateSystem(String minionId, String machineId, String reActivationKey) {\n+        of(ActivationKeyFactory.lookupByKey(reActivationKey)).ifPresent(ak -> {\n+            if (Objects.nonNull(ak.getKickstartSession())) {\n+                ak.getKickstartSession().markComplete(\"Installation completed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83fee18da7b6acf205bbe0e9d61ecdb21f65a5da"}, "originalPosition": 261}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3cc38b66585d0a30da6ccb541c5f7df4aa48d45a", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3cc38b66585d0a30da6ccb541c5f7df4aa48d45a", "committedDate": "2020-02-07T17:41:31Z", "message": "another forgotten corner case"}, "afterCommit": {"oid": "d5917f6bba29ac61a334a74bf373186600f54557", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/d5917f6bba29ac61a334a74bf373186600f54557", "committedDate": "2020-02-07T17:45:09Z", "message": "another forgotten corner case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5ODQ1ODQ3", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-359845847", "createdAt": "2020-02-17T16:12:46Z", "commit": {"oid": "d5917f6bba29ac61a334a74bf373186600f54557"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNjoxMjo0NlrOFqpv0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNjoxMjo0NlrOFqpv0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODQ5Nw==", "bodyText": "Style nitpick: Optional supports filter", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r380268497", "createdAt": "2020-02-17T16:12:46Z", "author": {"login": "moio"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,147 +133,182 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<ActivationKey> activationKey =\n+                        mkey.flatMap(mk -> ofNullable(ActivationKeyFactory.lookupByKey(mk)));\n+                Optional<String> validReactivationKey =\n+                        mkey.flatMap(mk -> isValidReactivationKey(activationKey, minionId) ? mkey : empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5917f6bba29ac61a334a74bf373186600f54557"}, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d5917f6bba29ac61a334a74bf373186600f54557", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/d5917f6bba29ac61a334a74bf373186600f54557", "committedDate": "2020-02-07T17:45:09Z", "message": "another forgotten corner case"}, "afterCommit": {"oid": "ae33f6b6679c16d65f9d1d83a66daa8f2aca4faa", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ae33f6b6679c16d65f9d1d83a66daa8f2aca4faa", "committedDate": "2020-02-18T09:52:28Z", "message": "another forgotten corner case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMDY1Mjkx", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-361065291", "createdAt": "2020-02-19T12:19:51Z", "commit": {"oid": "ae33f6b6679c16d65f9d1d83a66daa8f2aca4faa"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae33f6b6679c16d65f9d1d83a66daa8f2aca4faa", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ae33f6b6679c16d65f9d1d83a66daa8f2aca4faa", "committedDate": "2020-02-18T09:52:28Z", "message": "another forgotten corner case"}, "afterCommit": {"oid": "483e566773644da185800ef4356a7bda5b583b15", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/483e566773644da185800ef4356a7bda5b583b15", "committedDate": "2020-02-21T10:30:13Z", "message": "more suggested changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNTk3ODY5", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-362597869", "createdAt": "2020-02-21T12:32:31Z", "commit": {"oid": "483e566773644da185800ef4356a7bda5b583b15"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxMjozMjozMVrOFs1bvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxMjozMjozMVrOFs1bvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU1NzExNw==", "bodyText": "typo in method name. One 'k' too much.", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r382557117", "createdAt": "2020-02-21T12:32:31Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -128,152 +134,187 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<ActivationKey> activationKey =\n+                        mkey.flatMap(mk -> ofNullable(ActivationKeyFactory.lookupByKey(mk)));\n+                Optional<String> validReactivationKey =\n+                        mkey.filter(mk -> isValidReactivationKey(activationKey, minionId));\n+                updatekKickStartSession(activationKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483e566773644da185800ef4356a7bda5b583b15"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNjEwNzU1", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-362610755", "createdAt": "2020-02-21T12:58:20Z", "commit": {"oid": "483e566773644da185800ef4356a7bda5b583b15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxMjo1ODoyMFrOFs2EhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxMjo1ODoyMFrOFs2EhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU2NzU1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n          \n          \n            \n                        SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Minion ID\", \"Minion '\" +", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r382567556", "createdAt": "2020-02-21T12:58:20Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -128,152 +134,187 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<ActivationKey> activationKey =\n+                        mkey.flatMap(mk -> ofNullable(ActivationKeyFactory.lookupByKey(mk)));\n+                Optional<String> validReactivationKey =\n+                        mkey.filter(mk -> isValidReactivationKey(activationKey, minionId));\n+                updatekKickStartSession(activationKey);\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride,\n+                            validReactivationKey, machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration or reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param reActivationKey valid reactivation key\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> reActivationKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        Opt.consume(reActivationKey,\n+            //Case-1 Registration\n+            () -> {\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+                    });\n+            },\n+            //Case-2 : Reactivation\n+            rk -> {\n+                reactivateSystem(minionId, machineId, rk);\n+                finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+            }\n+        );\n+    }\n \n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    /**\n+     * Check if the specified management_key is valid reactivation key or not\n+     * @param activationKey activationKey\n+     * @param minionId minion Id\n+     * @return true/false based on if activation is a valid reaction key or not\n+     */\n+    private boolean isValidReactivationKey(Optional<ActivationKey> activationKey, String minionId) {\n+        return Opt.fold(activationKey,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+                LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + activationKey);\n                 return false;\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n+            ak -> {\n+                if (Objects.isNull(ak.getServer())) {\n+                    LOG.error(\"Management Key is not a reactivation key: \" + ak.getKey());\n                     return false;\n                 }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n+                //considered valid reactivation key only in this case\n                 return true;\n             }\n         );\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param reActivationKey valid Reaction key\n+     */\n+    private void reactivateSystem(String minionId, String machineId, String reActivationKey) {\n         // The machine id may have changed, but we know from the reactivation key\n         // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+        of(ActivationKeyFactory.lookupByKey(reActivationKey))\n+                .flatMap(ak -> ak.getServer().asMinionServer())\n+                .ifPresent(minion -> {\n+                    minion.setMachineId(machineId);\n+                    minion.setMinionId(minionId);\n+        });\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n+     * Update information of already registered minion, in case minion_id is different.\n      * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * @param registeredMinion existing registered minion\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-\n-                MinionPillarManager.INSTANCE.generatePillar(registeredMinion);\n-                MinionPillarManager.INSTANCE.removePillar(oldMinionId);\n-\n-                migrateMinionFormula(minionId, Optional.of(oldMinionId));\n-\n-                SALT_SERVICE.deleteKey(oldMinionId);\n-\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Minion ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-            }\n+    public void updateAlreadyRegisteredInfo(String minionId, MinionServer registeredMinion) {\n+        String oldMinionId = registeredMinion.getMinionId();\n+        if (!minionId.equals(oldMinionId)) {\n+            LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n+                    \"profile to '\" + minionId + \"' [\" + registeredMinion.getMachineId() + \"]\");\n+            registeredMinion.setName(minionId);\n+            registeredMinion.setMinionId(minionId);\n+            ServerFactory.save(registeredMinion);\n+\n+            MinionPillarManager.INSTANCE.generatePillar(registeredMinion);\n+            MinionPillarManager.INSTANCE.removePillar(oldMinionId);\n+\n+            migrateMinionFormula(minionId, Optional.of(oldMinionId));\n+\n+            SALT_SERVICE.deleteKey(oldMinionId);\n+            SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483e566773644da185800ef4356a7bda5b583b15"}, "originalPosition": 278}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "483e566773644da185800ef4356a7bda5b583b15", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/483e566773644da185800ef4356a7bda5b583b15", "committedDate": "2020-02-21T10:30:13Z", "message": "more suggested changes"}, "afterCommit": {"oid": "acb0b9a6a1e9d3ee9cc57819bb137bfbbe6a7ade", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/acb0b9a6a1e9d3ee9cc57819bb137bfbbe6a7ade", "committedDate": "2020-02-21T14:11:01Z", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNjYxNDM3", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-362661437", "createdAt": "2020-02-21T14:21:57Z", "commit": {"oid": "acb0b9a6a1e9d3ee9cc57819bb137bfbbe6a7ade"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acb0b9a6a1e9d3ee9cc57819bb137bfbbe6a7ade", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/acb0b9a6a1e9d3ee9cc57819bb137bfbbe6a7ade", "committedDate": "2020-02-21T14:11:01Z", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script"}, "afterCommit": {"oid": "8cddc596dd7703970ddaa0b352c0c6722816b1cf", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8cddc596dd7703970ddaa0b352c0c6722816b1cf", "committedDate": "2020-02-21T15:14:27Z", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMzMzODc4", "url": "https://github.com/uyuni-project/uyuni/pull/1833#pullrequestreview-363333878", "createdAt": "2020-02-24T11:49:39Z", "commit": {"oid": "8cddc596dd7703970ddaa0b352c0c6722816b1cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMTo0OTozOVrOFtd-Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMTo0OTozOVrOFtd-Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTI1NQ==", "bodyText": "I'm missing something, but why here suseManagerGrain is serialized as 'susemanager', but later as 'management_key'?", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r383221255", "createdAt": "2020-02-24T11:49:39Z", "author": {"login": "aaannz"}, "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartupGrains.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Class to represent grains defined against 'start_event_grains'\n+ */\n+public class MinionStartupGrains {\n+    @SerializedName(\"machine_id\")\n+    private Optional<String> machineId = Optional.empty();\n+    @SerializedName(\"saltboot_initrd\")\n+    private boolean saltbootInitrd = false;\n+    @SerializedName(\"susemanager\")\n+    private Optional<SuseManagerGrain> suseManagerGrain = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cddc596dd7703970ddaa0b352c0c6722816b1cf"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84e419e2155cfd0b7bbf74b83b4ae2ad0ed9140a", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/84e419e2155cfd0b7bbf74b83b4ae2ad0ed9140a", "committedDate": "2020-02-25T07:57:07Z", "message": "get the machine-id grain from the start up event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35a8f1486b75929e5a595f22fd85d41973c8c9c9", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/35a8f1486b75929e5a595f22fd85d41973c8c9c9", "committedDate": "2020-02-25T07:57:08Z", "message": "add a helper sls file to update the minion config to make use of minion_start_grains"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40b88f2af8f5910a180ad7d89acf4aa9f91b4f2c", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/40b88f2af8f5910a180ad7d89acf4aa9f91b4f2c", "committedDate": "2020-02-25T07:57:08Z", "message": "Provided builder to construct object easily for testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e31ed92c3cf2c8c471f72cb39f811b78b8ccb56f", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e31ed92c3cf2c8c471f72cb39f811b78b8ccb56f", "committedDate": "2020-02-25T07:57:08Z", "message": "added new tests to cover scenerios when startup grains are passed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df0ea59c510fe179d94a8e18fbe3fa354fb57195", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/df0ea59c510fe179d94a8e18fbe3fa354fb57195", "committedDate": "2020-02-25T07:57:08Z", "message": "Modify existings tests to make use of new builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f58e220c1b153274d50e8de5cec0547d6e449ca", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2f58e220c1b153274d50e8de5cec0547d6e449ca", "committedDate": "2020-02-25T07:57:08Z", "message": "added susemanager and saltboot_initrd grains to the state file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fbc34b555dd59d163e4318cb6a4e1b14e1987bd", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/6fbc34b555dd59d163e4318cb6a4e1b14e1987bd", "committedDate": "2020-02-25T07:57:08Z", "message": "added config so new bootsrapped minions can get the config automatically"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0d897bf3a488e41784fd46030d6edcd7ee0e513", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a0d897bf3a488e41784fd46030d6edcd7ee0e513", "committedDate": "2020-02-25T07:57:08Z", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8cddc596dd7703970ddaa0b352c0c6722816b1cf", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8cddc596dd7703970ddaa0b352c0c6722816b1cf", "committedDate": "2020-02-21T15:14:27Z", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script"}, "afterCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "committedDate": "2020-01-30T10:31:53Z", "message": "update units test & some more refactoring"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "committedDate": "2020-01-30T10:31:53Z", "message": "update units test & some more refactoring"}, "afterCommit": {"oid": "a0d897bf3a488e41784fd46030d6edcd7ee0e513", "author": {"user": {"login": "admd", "name": "Abid Mehmood"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a0d897bf3a488e41784fd46030d6edcd7ee0e513", "committedDate": "2020-02-25T07:57:08Z", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1746, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}