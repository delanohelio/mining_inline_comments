{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5Njg5MTg2", "number": 2102, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODoyNzozNlrODxiVtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjoyMjo1OVrODxnnyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMjY5NDMwOnYy", "diffSide": "RIGHT", "path": "web/html/src/components/FormulaForm.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODoyNzozNlrOGFDsxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODoyNzozNlrOGFDsxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk1NjY3Ng==", "bodyText": "Debug leftover?", "url": "https://github.com/uyuni-project/uyuni/pull/2102#discussion_r407956676", "createdAt": "2020-04-14T08:27:36Z", "author": {"login": "mbologna"}, "path": "web/html/src/components/FormulaForm.js", "diffHunk": "@@ -58,143 +55,69 @@ class FormulaForm extends React.Component {\n         this.init();\n     }\n \n-    init() {\n-        Network.get(this.props.dataUrl).promise.then(data => {\n+    init = () => {\n+        var dataPromise;\n+        if (this.props.getDataPromise) {\n+            dataPromise = this.props.getDataPromise()\n+        } else {\n+            dataPromise = Network.get(this.props.dataUrl).promise;\n+        }\n+\n+        dataPromise.then(data => {\n             if (data === null)\n                 this.setState({\n                     formulaName: \"\",\n                     formulaList: [],\n-                    formulaLayout: {},\n-                    formulaValues: {},\n+                    formulaRawLayout: {},\n+                    systemData: {},\n+                    groupData: {},\n                     formulaChanged: false,\n                     metadata: {}\n                 });\n             else {\n-                const layout = preprocessLayout(data.layout);\n-                preprocessData(layout, get(data.system_data, {}));\n-                preprocessData(layout, get(data.group_data, {}));\n-                const values = generateValues(layout, get(data.group_data, {}), get(data.system_data, {}));\n-\n+                const rawLayout = data.layout;\n                 this.setState({\n                     formulaName: data.formula_name,\n                     formulaList: data.formula_list,\n-                    formulaLayout: layout,\n-                    formulaValues: values,\n+                    formulaRawLayout: rawLayout,\n+                    systemData: get(data.system_data, {}),\n+                    groupData: get(data.group_data, {}),\n                     formulaChanged: false,\n                     formulaMetadata: data.metadata\n                 });\n             }\n         });\n     }\n \n-    walkValueTree(value, formulaForm, formulaValues, validationFunc) {\n-        if (value instanceof Object) {\n-            for (let key in value) {\n-                if (!key.startsWith(\"$meta$\")) {\n-                    if ((\"$meta$\" + key) in value) {\n-                        const meta = value[\"$meta$\" + key];\n-                        const keepWalking = validationFunc(value, key, meta, formulaForm, formulaValues);\n-                        console.log(\"walkValueTree keepWalking: \" + keepWalking);\n-                        if (keepWalking) {\n-                            this.walkValueTree(value[key], formulaForm, formulaValues, validationFunc);\n-                        }\n-                    } else {\n-                        this.walkValueTree(value[key], formulaForm, formulaValues, validationFunc);\n-                    }\n-                }\n-            }\n-        }\n-    }    \n-\n-    getEmptyValues() {\n-        let requiredErrors = []\n-        this.walkValueTree(this.state.formulaValues, this, this.state.formulaValues, \n-            (parentVal, key, meta, formulaForm, formulaValues) => {\n-                const val = parentVal[key];\n-                if (meta[\"visibleIf\"]) {\n-                    const visibleIf = checkVisibilityCondition(meta[\"id\"], meta[\"visibleIf\"], formulaForm);\n-                    if (!visibleIf) {\n-                        return false;\n-                    }\n-                } else if (meta[\"visible\"]) {\n-                    const visible = evalExpression(meta[\"id\"], meta[\"visible\"], formulaForm);\n-                    if (!visible) {\n-                        return false;\n-                    }\n-                }\n-                if(meta[\"required\"]) {\n-                    const required = evalExpression(meta[\"id\"], meta[\"required\"] + \"\", formulaForm);\n-                    if (required) {\n-                        if (Array.isArray(val) && val.some(v => !v)) {\n-                            requiredErrors.push(meta[\"name\"]);\n-                        } else if (!val) {\n-                            requiredErrors.push(meta[\"name\"]);\n-                        }\n-                    }\n-                }\n-                return true;\n-            });\n-        return requiredErrors;\n-    }\n-\n-    checkFieldsFormat() {\n-        const errors = [];\n-        this.walkValueTree(this.state.formulaValues, this, this.state.formulaValues, \n-            (parentVal, key, meta, formulaForm, formulaValues) => {\n-                const value = parentVal[key];\n-                if(meta[\"match\"]) {\n-                    try {\n-                        const re = new RegExp(meta[\"match\"]);\n-                        if (Array.isArray(value)) {\n-                            // match each value\n-                            if (!value.every(v => re.test(v))) {\n-                                errors.push(meta[\"name\"]);\n-                            }\n-                        } else {\n-                            if (!re.test(value)) {\n-                                errors.push(meta[\"name\"]);\n-                            }\n-                        }\n-                    } catch (err) {\n-                        console.log(\"Error matching regex: '\" + meta[\"match\"] + \"':\" + err);\n-                    }\n-                }\n-                return true;\n-            });\n-        return errors;\n-    }\n-\n-    saveFormula(event) {\n-        event.preventDefault();\n+    saveFormula = (data) => {\n         this.setState({ formulaChanged: false });\n         let scope = this.props.scope;\n         let formType = scope.toUpperCase();\n         if (formType === 'SYSTEM') {\n             formType = 'SERVER';\n         }\n-        let formData = {\n-            type: formType,\n-            id: this.props.systemId,\n-            formula_name: this.state.formulaName,\n-            content: this.getValuesClean(preprocessCleanValues(this.state.formulaValues, this.state.formulaLayout))\n-        };\n \n-        const emptyRequiredFields = [...new Set(this.getEmptyValues())];\n-        const checkFieldsFormat = [...new Set(this.checkFieldsFormat())];\n-\n-        if(emptyRequiredFields.length > 0 || checkFieldsFormat.length > 0) {\n+        if(data.errors) {\n             const messages = [];\n-            if (emptyRequiredFields.length > 0) {\n-                messages.push(t(\"Please input required fields: {0}\", emptyRequiredFields.join(', ')));\n+            if (data.errors.required && data.errors.required.length > 0) {\n+                messages.push(t(\"Please input required fields: {0}\", data.errors.required.join(', ')));\n             }\n-            if (checkFieldsFormat.length > 0) {\n-                messages.push(t(\"Invalid format of fields: {0}\", checkFieldsFormat.join(', ')));\n+            if (data.errors.invalid && data.errors.invalid.length > 0) {\n+                messages.push(t(\"Invalid format of fields: {0}\", data.errors.invalid.join(', ')));\n             }\n             this.setState({\n                     messages: [],\n                     errors: messages\n             });\n         } else {\n+            console.log(\"saveFormula\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a41c36deb2eefe3a5fe15242735bf7aa8f54902e"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzU1OTc2OnYy", "diffSide": "RIGHT", "path": "web/html/src/components/formulas/FormulaComponentGenerator.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjoyMjo1OVrOGFMADw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjoyMjo1OVrOGFMADw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA5MjY4Nw==", "bodyText": "Is this line intended to be commented out?", "url": "https://github.com/uyuni-project/uyuni/pull/2102#discussion_r408092687", "createdAt": "2020-04-14T12:22:59Z", "author": {"login": "mbologna"}, "path": "web/html/src/components/formulas/FormulaComponentGenerator.js", "diffHunk": "@@ -235,8 +246,687 @@ function wrapLabel(text, required, label_for) {\n     );\n }\n \n-function get(value, def) {\n+function getValueById(values, id) {\n+    let parents = id.split(\"#\");\n+    let value = values;\n+    for (let i in parents) {\n+        if (value[parents[i]] === undefined) {\n+            return null;\n+        }\n+        value = value[parents[i]];\n+    }\n+    return value;\n+}\n+\n+export function get(value, def) {\n     if (value === undefined)\n         return def;\n     return value;\n }\n+\n+export function text(txt) {\n+    if (!txt) {\n+        return \"\";\n+    }\n+    // replace variables\n+    txt = txt.replace(/\\${productName}/g, Utils.getProductName());\n+    return txt;\n+}\n+\n+export const FormulaFormRenderer = () => (\n+    <FormulaFormContext.Consumer>\n+        {context => \n+            <UnwrappedFormulaFormRenderer {...context}/>}\n+    </FormulaFormContext.Consumer>\n+);\n+\n+// layout\n+// values\n+// onValuesChanged\n+class UnwrappedFormulaFormRenderer extends React.Component {\n+\n+    constructor(props) {\n+        super(props);\n+        this.submitButton = React.createRef();\n+    }\n+\n+    handleChange = (event) => {\n+        let id, value;\n+        if (event.id) {\n+            id = event.id;\n+            value = event.value;\n+        }\n+        else {\n+            id = event.target.id;\n+\n+            if (event.target.type === \"checkbox\") {\n+                value = event.target.checked;\n+            } else if (event.target.type === \"number\") {\n+                value = isNaN(event.target.valueAsNumber) ? \"\" : event.target.valueAsNumber;\n+            } else {\n+                value = event.target.value;\n+            }\n+        }\n+\n+        // notify the context provider about the values change\n+        this.props.onChange(id, value);\n+    }\n+\n+    componentDidMount() {\n+        this.props.registerValidationTrigger(this.triggerValidation);\n+    }\n+\n+    triggerValidation = () => {\n+        this.submitButton.current.click();\n+    }\n+\n+    dontSubmitForm = (event) => {\n+        // TODO checkValidity must be called on each form input, not on the entire form\n+        // this.form.current.checkValidity();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a41c36deb2eefe3a5fe15242735bf7aa8f54902e"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 109, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}