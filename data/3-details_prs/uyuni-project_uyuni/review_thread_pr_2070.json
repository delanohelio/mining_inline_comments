{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0ODkyNDY1", "number": 2070, "reviewThreads": {"totalCount": 105, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1MTozNVrOEC8YGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzowOTozNFrOEDPD2Q==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTIxODE3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1MTozNVrOGftOQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyNTo0MVrOGf8Wkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5OTk3MA==", "bodyText": "It's better the use ClusterFactory.findClusterByIdAndOrg() instead.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435899970", "createdAt": "2020-06-05T12:51:35Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));\n+\n+            Map<String, Object> otherValues = context.entrySet().stream()\n+                    .filter(e -> !e.getKey().equals(\"nodes\") &&\n+                            !e.getKey().equals(\"cluster\") &&\n+                            !e.getKey().equals(\"cluster_settings\"))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            ctx.putAll(otherValues);\n+\n+            evalFormInitialData(initialData, \"\", formulaData.get(), ctx);\n+\n+            initialData.putAll(otherValues);\n+        }\n+        else {\n+            initialData.putAll(context);\n+        }\n+        return initialData;\n+    }\n+\n+    /**\n+     * Public for unit tests\n+     * @param out\n+     * @param dataKey\n+     * @param data\n+     * @param context\n+     */\n+    public void evalFormInitialData(Map out, String dataKey, Map<String, Object> data, Map<String, Object> context) {\n+            Map<String, Object> map = (Map<String, Object>)data;\n+            if (\"edit-group\".equals(map.get(\"$type\"))) {\n+                String valueExpr = (String)map.get(\"$value\");\n+                String itemName = (String)map.get(\"$item\");\n+                Map<String, Object> prototype = (Map<String, Object>)map.get(\"$prototype\");\n+                Object value = evalExpression(valueExpr, context);\n+                if (value instanceof Collection) {\n+                    List<Map<String, Object>> items = new LinkedList<>();\n+                    out.put(dataKey, items);\n+                    for (var item : ((Collection)value)) {\n+                        Map<String, Object> itemVal = new HashMap<>();\n+                        prototype.forEach((key, valExpr) -> {\n+                            Map<String, Object> valCtx = new HashMap<>();\n+                            valCtx.putAll(context);\n+                            valCtx.put(itemName, item);\n+                            if (valExpr instanceof String) {\n+                                Object val = evalExpression((String)valExpr, valCtx);\n+                                itemVal.put((String)key, val);\n+                            }\n+                            else if (valExpr instanceof Map) {\n+                                Map nestedVal = new HashMap();\n+                                evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, valCtx);\n+                                itemVal.putAll(nestedVal);\n+                            }\n+\n+                        });\n+                        items.add(itemVal);\n+                    }\n+                }\n+                else {\n+                    throw new RuntimeException(\"$value for edit-group doesn't evaluate to a collection\");\n+                }\n+            }\n+            else {\n+                map.forEach((key, valExpr) -> {\n+                    if (valExpr instanceof String) {\n+                        Object val = evalExpression((String) valExpr, context);\n+                        out.put(key, val);\n+                    }\n+                    else if (valExpr instanceof Map) {\n+                        Map nestedVal = new HashMap();\n+                        evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, context);\n+                        out.putAll(nestedVal);\n+                    }\n+                });\n+            }\n+    }\n+\n+    /**\n+     * Get state hooks for cluster provider.\n+     * @param provider cluster provider label\n+     * @return state hooks as Map (if any)\n+     */\n+    public Optional<Map<String, List<String>>> getStateHooks(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"state_hooks\", Map.class)\n+                .map(m -> (Map<String, List<String>>)m);\n+\n+    }\n+\n+    /**\n+     * Get the details fields to show for each cluster node.\n+     * @param provider cluster provider label\n+     * @return detail fields to show (if any)\n+     */\n+    public Optional<List<String>> getNodesListFields(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"ui:nodes_list:fields\", List.class)\n+                .map(l -> (List<String>)l);\n+    }\n+\n+    /**\n+     * Update cluster name and description.\n+     * @param cluster cluster\n+     * @param name new name\n+     * @param description new description\n+     */\n+    public void update(Cluster cluster, String name, String description) {\n+        cluster.setName(name);\n+        cluster.setDescription(description);\n+        getSession().save(cluster);\n+        cluster.getGroup().setName(getGroupName(name));\n+        cluster.getGroup().setDescription(getGroupDescription(name));\n+        ServerGroupFactory.save(cluster.getGroup());\n+    }\n+\n+    private String getGroupName(String clusterName) {\n+        return \"Cluster \" + clusterName;\n+    }\n+\n+    private String getGroupDescription(String clusterName) {\n+        return \"Group for cluster \" + clusterName;\n+    }\n+\n+    /**\n+     * Find a cluster by id and user. Checks if the cluster is in the same org as the user.\n+     * @param id cluster ir\n+     * @param user user\n+     * @return the cluster if found\n+     */\n+    public Optional<Cluster> findClusterByIdAndUser(Long id, User user) {\n+        return ClusterFactory.findClusterById(id)\n+                .filter(c -> c.getOrg().equals(user.getOrg()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 607}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0Nzg1OQ==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436147859", "createdAt": "2020-06-05T20:25:41Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));\n+\n+            Map<String, Object> otherValues = context.entrySet().stream()\n+                    .filter(e -> !e.getKey().equals(\"nodes\") &&\n+                            !e.getKey().equals(\"cluster\") &&\n+                            !e.getKey().equals(\"cluster_settings\"))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            ctx.putAll(otherValues);\n+\n+            evalFormInitialData(initialData, \"\", formulaData.get(), ctx);\n+\n+            initialData.putAll(otherValues);\n+        }\n+        else {\n+            initialData.putAll(context);\n+        }\n+        return initialData;\n+    }\n+\n+    /**\n+     * Public for unit tests\n+     * @param out\n+     * @param dataKey\n+     * @param data\n+     * @param context\n+     */\n+    public void evalFormInitialData(Map out, String dataKey, Map<String, Object> data, Map<String, Object> context) {\n+            Map<String, Object> map = (Map<String, Object>)data;\n+            if (\"edit-group\".equals(map.get(\"$type\"))) {\n+                String valueExpr = (String)map.get(\"$value\");\n+                String itemName = (String)map.get(\"$item\");\n+                Map<String, Object> prototype = (Map<String, Object>)map.get(\"$prototype\");\n+                Object value = evalExpression(valueExpr, context);\n+                if (value instanceof Collection) {\n+                    List<Map<String, Object>> items = new LinkedList<>();\n+                    out.put(dataKey, items);\n+                    for (var item : ((Collection)value)) {\n+                        Map<String, Object> itemVal = new HashMap<>();\n+                        prototype.forEach((key, valExpr) -> {\n+                            Map<String, Object> valCtx = new HashMap<>();\n+                            valCtx.putAll(context);\n+                            valCtx.put(itemName, item);\n+                            if (valExpr instanceof String) {\n+                                Object val = evalExpression((String)valExpr, valCtx);\n+                                itemVal.put((String)key, val);\n+                            }\n+                            else if (valExpr instanceof Map) {\n+                                Map nestedVal = new HashMap();\n+                                evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, valCtx);\n+                                itemVal.putAll(nestedVal);\n+                            }\n+\n+                        });\n+                        items.add(itemVal);\n+                    }\n+                }\n+                else {\n+                    throw new RuntimeException(\"$value for edit-group doesn't evaluate to a collection\");\n+                }\n+            }\n+            else {\n+                map.forEach((key, valExpr) -> {\n+                    if (valExpr instanceof String) {\n+                        Object val = evalExpression((String) valExpr, context);\n+                        out.put(key, val);\n+                    }\n+                    else if (valExpr instanceof Map) {\n+                        Map nestedVal = new HashMap();\n+                        evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, context);\n+                        out.putAll(nestedVal);\n+                    }\n+                });\n+            }\n+    }\n+\n+    /**\n+     * Get state hooks for cluster provider.\n+     * @param provider cluster provider label\n+     * @return state hooks as Map (if any)\n+     */\n+    public Optional<Map<String, List<String>>> getStateHooks(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"state_hooks\", Map.class)\n+                .map(m -> (Map<String, List<String>>)m);\n+\n+    }\n+\n+    /**\n+     * Get the details fields to show for each cluster node.\n+     * @param provider cluster provider label\n+     * @return detail fields to show (if any)\n+     */\n+    public Optional<List<String>> getNodesListFields(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"ui:nodes_list:fields\", List.class)\n+                .map(l -> (List<String>)l);\n+    }\n+\n+    /**\n+     * Update cluster name and description.\n+     * @param cluster cluster\n+     * @param name new name\n+     * @param description new description\n+     */\n+    public void update(Cluster cluster, String name, String description) {\n+        cluster.setName(name);\n+        cluster.setDescription(description);\n+        getSession().save(cluster);\n+        cluster.getGroup().setName(getGroupName(name));\n+        cluster.getGroup().setDescription(getGroupDescription(name));\n+        ServerGroupFactory.save(cluster.getGroup());\n+    }\n+\n+    private String getGroupName(String clusterName) {\n+        return \"Cluster \" + clusterName;\n+    }\n+\n+    private String getGroupDescription(String clusterName) {\n+        return \"Group for cluster \" + clusterName;\n+    }\n+\n+    /**\n+     * Find a cluster by id and user. Checks if the cluster is in the same org as the user.\n+     * @param id cluster ir\n+     * @param user user\n+     * @return the cluster if found\n+     */\n+    public Optional<Cluster> findClusterByIdAndUser(Long id, User user) {\n+        return ClusterFactory.findClusterById(id)\n+                .filter(c -> c.getOrg().equals(user.getOrg()));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5OTk3MA=="}, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 607}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTcxMjM5OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/remove-node/remove-node.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTowMDo1OVrOGfyImA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoyODowN1rOGf3D9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4MDQ0MA==", "bodyText": "I think this is enough after the .filter() call\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(node => node.server ? node.server.id : 0),\n          \n          \n            \n                                .map(node => node.server.id),", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435980440", "createdAt": "2020-06-05T15:00:59Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/remove-node/remove-node.js", "diffHunk": "@@ -0,0 +1,88 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import React, {useState}  from 'react';\n+import {TopPanel} from \"components/panels/TopPanel\";\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import ScheduleClusterAction from '../shared/ui/schedule-cluster-action';\n+import {SystemLink} from 'components/links';\n+import FormulaConfig from '../shared/ui/formula-config';\n+\n+import type {ClusterType, FormulaValuesType, ClusterNodeType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  nodes: Array<ClusterNodeType>,\n+  serverId: ?number,\n+  flashMessage: string,\n+};\n+\n+const RemoveNode = (props: Props) => {\n+    const [removeConfig, setRemoveConfig] = useState<?FormulaValuesType>(null);\n+    const {scheduleRemoveNode} = useClustersApi();\n+\n+    const scheduleRemove = (earliest: Date, actionChain: ?string): Promise<any> => {\n+        if (removeConfig) {\n+            return scheduleRemoveNode(props.cluster.id,\n+                 props.nodes\n+                    .filter(node => node.server ? true : false)\n+                    .map(node => node.server ? node.server.id : 0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53830960e55d26fd07176ed605b701f928c4c51e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MTE3NA==", "bodyText": "The reason for this is Flowtype which is too strict in this case.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436061174", "createdAt": "2020-06-05T17:28:07Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/remove-node/remove-node.js", "diffHunk": "@@ -0,0 +1,88 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import React, {useState}  from 'react';\n+import {TopPanel} from \"components/panels/TopPanel\";\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import ScheduleClusterAction from '../shared/ui/schedule-cluster-action';\n+import {SystemLink} from 'components/links';\n+import FormulaConfig from '../shared/ui/formula-config';\n+\n+import type {ClusterType, FormulaValuesType, ClusterNodeType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  nodes: Array<ClusterNodeType>,\n+  serverId: ?number,\n+  flashMessage: string,\n+};\n+\n+const RemoveNode = (props: Props) => {\n+    const [removeConfig, setRemoveConfig] = useState<?FormulaValuesType>(null);\n+    const {scheduleRemoveNode} = useClustersApi();\n+\n+    const scheduleRemove = (earliest: Date, actionChain: ?string): Promise<any> => {\n+        if (removeConfig) {\n+            return scheduleRemoveNode(props.cluster.id,\n+                 props.nodes\n+                    .filter(node => node.server ? true : false)\n+                    .map(node => node.server ? node.server.id : 0),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4MDQ0MA=="}, "originalCommit": {"oid": "53830960e55d26fd07176ed605b701f928c4c51e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTc1MjA4OnYy", "diffSide": "LEFT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNToxMjoxNVrOGfyiXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODozOToyMlrOGf5aHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NzAzOA==", "bodyText": "We should also make sure that the name/label does not exist (both here and in React).\nOtherwise, the process reports a confusing error about a duplicate system group name. We should explicitly tell the user that a cluster with this name already exists.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435987038", "createdAt": "2020-06-05T15:12:15Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -274,24 +284,109 @@ private static ModelAndView showClusterUpgrade(Request request, Response respons\n         return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n     }\n \n+    private static class AddClusterRequest {\n+        private String name;\n+        private String label;\n+        private String description;\n+        private String provider;\n+        private Long managementNodeId;\n+        private Map<String, Object> managementSettings;\n+\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return label to get\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+\n+        /**\n+         * @return provider to get\n+         */\n+        public String getProvider() {\n+            return provider;\n+        }\n+\n+        /**\n+         * @return managementNodeId to get\n+         */\n+        public Long getManagementNodeId() {\n+            return managementNodeId;\n+        }\n+\n+        /**\n+         * @return managementSettings to get\n+         */\n+        public Map<String, Object> getManagementSettings() {\n+            return managementSettings;\n+        }\n+    }\n+\n     private static String addCluster(Request request, Response response, User user) {\n-        Optional<Map<String, Object>> json = parseJson(request, response);\n-        if (json.isEmpty()) {\n+        AddClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), AddClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n             return json(response, HttpStatus.SC_BAD_REQUEST,\n-                    ResultJson.error(\"request_error\"));\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+\n+        if (StringUtils.isBlank(clusterRequest.getName())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Name is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getLabel())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label is mandatory\"));\n+        }\n+\n+        if (!LABEL_REGEX.matcher(clusterRequest.getLabel()).matches()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label format is wrong\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getDescription())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Description is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Provider is mandatory\"));\n+        }\n+        if (!validProvider(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Invalid provider\"));\n+        }\n+        if (clusterRequest.getManagementNodeId() == null) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management node id is mandatory\"));\n+        }\n+        if (clusterRequest.getManagementSettings() == null ||\n+                clusterRequest.getManagementSettings().isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management settings are mandatory\"));\n         }\n \n-        // TODO validate input", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0301dddf87387a290cf76d26444870bfab3e3d0"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTYxNQ==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436099615", "createdAt": "2020-06-05T18:39:22Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -274,24 +284,109 @@ private static ModelAndView showClusterUpgrade(Request request, Response respons\n         return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n     }\n \n+    private static class AddClusterRequest {\n+        private String name;\n+        private String label;\n+        private String description;\n+        private String provider;\n+        private Long managementNodeId;\n+        private Map<String, Object> managementSettings;\n+\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return label to get\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+\n+        /**\n+         * @return provider to get\n+         */\n+        public String getProvider() {\n+            return provider;\n+        }\n+\n+        /**\n+         * @return managementNodeId to get\n+         */\n+        public Long getManagementNodeId() {\n+            return managementNodeId;\n+        }\n+\n+        /**\n+         * @return managementSettings to get\n+         */\n+        public Map<String, Object> getManagementSettings() {\n+            return managementSettings;\n+        }\n+    }\n+\n     private static String addCluster(Request request, Response response, User user) {\n-        Optional<Map<String, Object>> json = parseJson(request, response);\n-        if (json.isEmpty()) {\n+        AddClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), AddClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n             return json(response, HttpStatus.SC_BAD_REQUEST,\n-                    ResultJson.error(\"request_error\"));\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+\n+        if (StringUtils.isBlank(clusterRequest.getName())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Name is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getLabel())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label is mandatory\"));\n+        }\n+\n+        if (!LABEL_REGEX.matcher(clusterRequest.getLabel()).matches()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label format is wrong\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getDescription())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Description is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Provider is mandatory\"));\n+        }\n+        if (!validProvider(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Invalid provider\"));\n+        }\n+        if (clusterRequest.getManagementNodeId() == null) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management node id is mandatory\"));\n+        }\n+        if (clusterRequest.getManagementSettings() == null ||\n+                clusterRequest.getManagementSettings().isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management settings are mandatory\"));\n         }\n \n-        // TODO validate input", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NzAzOA=="}, "originalCommit": {"oid": "f0301dddf87387a290cf76d26444870bfab3e3d0"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODI3NjE2OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/NoSuchClusterException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzowNDozOFrOGgJYCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzowNDozOFrOGgJYCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTIyNA==", "bodyText": "wrong year", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436361224", "createdAt": "2020-06-07T13:04:38Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/NoSuchClusterException.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright (c) 2017 SUSE LLC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59a8ab144fba08cec9b7880690c19a0190794faf"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODI3OTI5OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/suseClusters.sql", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzowOTozNFrOGgJZtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo0NzoxM1rOGgP6Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTY1Mg==", "bodyText": "Is it wanted to not have an ON DELETE statement here?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436361652", "createdAt": "2020-06-07T13:09:34Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) DEFAULT '',\n+    provider    VARCHAR(50) NOT NULL,\n+    management_node_id  NUMERIC\n+                        CONSTRAINT suse_clusters_mgmt_node_fk\n+                        REFERENCES rhnServer (id)\n+                        ON DELETE SET NULL,\n+    group_id    NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_group_fk\n+                    REFERENCES rhnServerGroup (id),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59a8ab144fba08cec9b7880690c19a0190794faf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzYzNQ==", "bodyText": "Yes, it's intentional. The cluster group must be delete only together with the cluster. I added this commit to disable the delete button in the group UI and to throw an exception when deleting from the API.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436407635", "createdAt": "2020-06-07T22:26:11Z", "author": {"login": "mateiw"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) DEFAULT '',\n+    provider    VARCHAR(50) NOT NULL,\n+    management_node_id  NUMERIC\n+                        CONSTRAINT suse_clusters_mgmt_node_fk\n+                        REFERENCES rhnServer (id)\n+                        ON DELETE SET NULL,\n+    group_id    NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_group_fk\n+                    REFERENCES rhnServerGroup (id),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTY1Mg=="}, "originalCommit": {"oid": "59a8ab144fba08cec9b7880690c19a0190794faf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2ODI2Nw==", "bodyText": "Ok", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436468267", "createdAt": "2020-06-08T05:47:13Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) DEFAULT '',\n+    provider    VARCHAR(50) NOT NULL,\n+    management_node_id  NUMERIC\n+                        CONSTRAINT suse_clusters_mgmt_node_fk\n+                        REFERENCES rhnServer (id)\n+                        ON DELETE SET NULL,\n+    group_id    NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_group_fk\n+                    REFERENCES rhnServerGroup (id),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTY1Mg=="}, "originalCommit": {"oid": "59a8ab144fba08cec9b7880690c19a0190794faf"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzkzMDY4OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMjo1ODoxMlrOF9JSoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoxNDo1MlrOGBZz2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY1OTY4MQ==", "bodyText": "Potential dangerous. We should not drop if not needed.\nThe \"create if not exists\" should be enough.\nIf they exist they might also contain data we do not want to loose.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r399659681", "createdAt": "2020-03-28T12:58:12Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEyNDYzNQ==", "bodyText": "I'll remove them. They're only for development.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r404124635", "createdAt": "2020-04-06T14:14:52Z", "author": {"login": "mateiw"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY1OTY4MQ=="}, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzkzMjU2OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMzowMDoyM1rOF9JTgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoxNjozNVrOGBZ5XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY1OTkwNA==", "bodyText": "No NOT NULL ? Is this on purpose?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r399659904", "createdAt": "2020-03-28T13:00:23Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;\n+\n+\n+CREATE TABLE IF NOT EXISTS suseClusterTypes (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clustertypes_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_clustertypes_id_seq;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_clustertypes_idx\n+    ON suseClusterTypes (name);\n+\n+CREATE TABLE IF NOT EXISTS suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL,\n+    type_id     NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_type_fk\n+                    REFERENCES suseClusterTypes (id),\n+    management_node_id    NUMERIC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEyNjA0NA==", "bodyText": "I'll remove this table. For now we won't cache the nodes in the db. We're gonna query the provider every time we need to get the nodes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r404126044", "createdAt": "2020-04-06T14:16:35Z", "author": {"login": "mateiw"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;\n+\n+\n+CREATE TABLE IF NOT EXISTS suseClusterTypes (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clustertypes_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_clustertypes_id_seq;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_clustertypes_idx\n+    ON suseClusterTypes (name);\n+\n+CREATE TABLE IF NOT EXISTS suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL,\n+    type_id     NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_type_fk\n+                    REFERENCES suseClusterTypes (id),\n+    management_node_id    NUMERIC", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY1OTkwNA=="}, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzkzMzkzOnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMzowMjoyMFrOF9JUIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoxNjo1OVrOGBZ6ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY2MDA2NQ==", "bodyText": "What about Organizations? I think clusters cannot be global. Or is it on purpose?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r399660065", "createdAt": "2020-03-28T13:02:20Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;\n+\n+\n+CREATE TABLE IF NOT EXISTS suseClusterTypes (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clustertypes_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_clustertypes_id_seq;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_clustertypes_idx\n+    ON suseClusterTypes (name);\n+\n+CREATE TABLE IF NOT EXISTS suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL,\n+    type_id     NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_type_fk\n+                    REFERENCES suseClusterTypes (id),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEyNjM2Ng==", "bodyText": "Good point. I'll add org.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r404126366", "createdAt": "2020-04-06T14:16:59Z", "author": {"login": "mateiw"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;\n+\n+\n+CREATE TABLE IF NOT EXISTS suseClusterTypes (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clustertypes_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_clustertypes_id_seq;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_clustertypes_idx\n+    ON suseClusterTypes (name);\n+\n+CREATE TABLE IF NOT EXISTS suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL,\n+    type_id     NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_type_fk\n+                    REFERENCES suseClusterTypes (id),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY2MDA2NQ=="}, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDA1OTQ5OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/virtualization/nets/virtualization-nets-list-refresh-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1Njo1MVrOGcgXgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxNzo0OFrOGchKbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MzYxNw==", "bodyText": "What is that jqXHR thing? I have no clue about that: I trust that you know more those things than I do", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r432543617", "createdAt": "2020-05-29T14:56:51Z", "author": {"login": "cbosdo"}, "path": "web/html/src/manager/virtualization/nets/virtualization-nets-list-refresh-api.js", "diffHunk": "@@ -51,9 +52,9 @@ class VirtualizationNetsListRefreshApi extends React.Component<Props, State> {\n           errors: [],\n         });\n       })\n-      .catch((response) => {\n+      .catch(jqXHR => {\n         this.setState({\n-          errors: [Network.errorMessageByStatus(response.status)],\n+          errors: [Network.responseErrorMessage(jqXHR)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a07c17d330d48e38ed23a544660d8d72660e96"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1NjY1NA==", "bodyText": "It's the jQuery XMLHTTP request object.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r432556654", "createdAt": "2020-05-29T15:17:48Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/virtualization/nets/virtualization-nets-list-refresh-api.js", "diffHunk": "@@ -51,9 +52,9 @@ class VirtualizationNetsListRefreshApi extends React.Component<Props, State> {\n           errors: [],\n         });\n       })\n-      .catch((response) => {\n+      .catch(jqXHR => {\n         this.setState({\n-          errors: [Network.errorMessageByStatus(response.status)],\n+          errors: [Network.responseErrorMessage(jqXHR)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MzYxNw=="}, "originalCommit": {"oid": "a1a07c17d330d48e38ed23a544660d8d72660e96"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODEwMjA5OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDowNjoxOFrOGdFSQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDowNjoxOFrOGdFSQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODQ4MQ==", "bodyText": "I understand that this situation should not happen but, in case it does, we cannot raise and exception here and break the execution of suma_minion, because that breaks pillar rendering for any minion, which is critical.\nI would suggest to only logging the error here but do not break the execution.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433148481", "createdAt": "2020-06-01T10:06:18Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "diffHunk": "@@ -194,8 +199,22 @@ def load_formula_pillar(minion_id, group_id, formula_name):\n         log.error('Error loading data for formula \"{formula}\": {message}'.format(formula=formula_name, message=str(error)))\n         return {}\n \n+    # if group_data starts with mgr_clusters then merge and adjust without the mgr_clusters:<cluster>:settings prefix\n+    cluster_name = None\n+    cluster_pillar_key = None\n+    if formula_metadata and formula_metadata.get(\"type\", \"\") == \"cluster-formula\":\n+        if \"cluster_pillar_key\" not in formula_metadata:\n+            raise Exception(\"No 'cluster_pillar_key' in metadata of formula {}\".format(formula_name))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODEyNzg3OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDoxNjoxMVrOGdFiWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDoxNjoxMVrOGdFiWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MjYwMw==", "bodyText": "This would overwrite any previous existing cluster pillar data under a different cluster_name, because this recreates \"mgr_clusters\" entry everytime.\nMy suggestion would be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    merged_data = {\"mgr_clusters\": {cluster_name: {cluster_pillar_key: merged_data}}}\n          \n          \n            \n                    merged_data.setdefault(\"mgr_clusters\", {}).update({cluster_name: {cluster_pillar_key: merged_data}})", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433152603", "createdAt": "2020-06-01T10:16:11Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "diffHunk": "@@ -194,8 +199,22 @@ def load_formula_pillar(minion_id, group_id, formula_name):\n         log.error('Error loading data for formula \"{formula}\": {message}'.format(formula=formula_name, message=str(error)))\n         return {}\n \n+    # if group_data starts with mgr_clusters then merge and adjust without the mgr_clusters:<cluster>:settings prefix\n+    cluster_name = None\n+    cluster_pillar_key = None\n+    if formula_metadata and formula_metadata.get(\"type\", \"\") == \"cluster-formula\":\n+        if \"cluster_pillar_key\" not in formula_metadata:\n+            raise Exception(\"No 'cluster_pillar_key' in metadata of formula {}\".format(formula_name))\n+        cluster_pillar_key = formula_metadata[\"cluster_pillar_key\"]\n+        group_data, cluster_name = _pillar_value_by_path(group_data, \"mgr_clusters:*:{}\".format(cluster_pillar_key))\n+\n     merged_data = merge_formula_data(layout, group_data, system_data)\n     merged_data = adjust_empty_values(layout, merged_data)\n+\n+    # put back data under cluster pillar namespace\n+    if cluster_name:\n+        merged_data = {\"mgr_clusters\": {cluster_name: {cluster_pillar_key: merged_data}}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODE3NTU2OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDozNToxMFrOGdGAYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDozNToxMFrOGdGAYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDI4OQ==", "bodyText": "I would refactor this in order to have a more clean and simpler logic:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                metadata_filename = os.path.join( MANAGER_FORMULAS_METADATA_STANDALONE_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                if not os.path.isfile(metadata_filename):\n          \n          \n            \n                    metadata_filename = os.path.join(MANAGER_FORMULAS_METADATA_MANAGER_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                    if not os.path.isfile(metadata_filename):\n          \n          \n            \n                        metadata_filename = os.path.join(CUSTOM_FORMULAS_METADATA_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                        if not os.path.isfile(metadata_filename):\n          \n          \n            \n                            log.error('Error loading metadata for formula \"{formula}\": No metadata.yml found'.format(formula=formula_name))\n          \n          \n            \n                            return {}\n          \n          \n            \n                metadata_filename = None\n          \n          \n            \n                metadata_paths_ordered = [\n          \n          \n            \n                    os.path.join(MANAGER_FORMULAS_METADATA_STANDALONE_PATH, formula_name, \"metadata.yml\"),\n          \n          \n            \n                    os.path.join(MANAGER_FORMULAS_METADATA_MANAGER_PATH, formula_name, \"metadata.yml\"),\n          \n          \n            \n                    os.path.join(CUSTOM_FORMULAS_METADATA_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                ]\n          \n          \n            \n                \n          \n          \n            \n                # Take the first metadata file that exist\n          \n          \n            \n                for mpath in metadata_paths:\n          \n          \n            \n                    if os.path.isfile(metadata_filename):\n          \n          \n            \n                        metadata_filename = mpath\n          \n          \n            \n                        break\n          \n          \n            \n                        \n          \n          \n            \n                if not metadata_filename:             \n          \n          \n            \n                    log.error('Error loading metadata for formula \"{formula}\": No metadata.yml found'.format(formula=formula_name))\n          \n          \n            \n                    return {}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433160289", "createdAt": "2020-06-01T10:35:10Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "diffHunk": "@@ -303,3 +322,36 @@ def image_pillars(minion_id):\n \n     return ret\n \n+def load_formula_metadata(formula_name):\n+    if formula_name in formulas_metadata_cache:\n+        return formulas_metadata_cache[formula_name]\n+    metadata_filename = os.path.join( MANAGER_FORMULAS_METADATA_STANDALONE_PATH, formula_name, \"metadata.yml\")\n+    if not os.path.isfile(metadata_filename):\n+        metadata_filename = os.path.join(MANAGER_FORMULAS_METADATA_MANAGER_PATH, formula_name, \"metadata.yml\")\n+        if not os.path.isfile(metadata_filename):\n+            metadata_filename = os.path.join(CUSTOM_FORMULAS_METADATA_PATH, formula_name, \"metadata.yml\")\n+            if not os.path.isfile(metadata_filename):\n+                log.error('Error loading metadata for formula \"{formula}\": No metadata.yml found'.format(formula=formula_name))\n+                return {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODIwNTc3OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/salt/clusters/addnode.sls", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0Njo1NFrOGdGSsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0Njo1NFrOGdGSsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDk3OA==", "bodyText": "Hmm, I wouldn't go like this. We already have the pillars calculated and stored in pillar (which is a dictionary) variable. If we use salt['pillar.get'], that means calling the \"LazyLoader\" to run the \"pillar\" execution module for getting them again. Is this really necessary? (that would hit performance a little bit)\nYou could do instead:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            {%- if salt['pillar.get']('params:ssh_auth_sock', False) %}\n          \n          \n            \n            {%- if pillar['params'].get('ssh_auth_sock', False) %}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433164978", "createdAt": "2020-06-01T10:46:54Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/salt/clusters/addnode.sls", "diffHunk": "@@ -1,24 +1,37 @@\n-{%- if pillar.get('ssh_auth_sock', False) %}\n+{%- if salt['pillar.get']('params:ssh_auth_sock', False) %}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODIwNjc5OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/salt/clusters/addnode.sls", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0NzoyMFrOGdGTVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0NzoyMFrOGdGTVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NTE0Mg==", "bodyText": "Same as the previous comment", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433165142", "createdAt": "2020-06-01T10:47:20Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/salt/clusters/addnode.sls", "diffHunk": "@@ -1,24 +1,37 @@\n-{%- if pillar.get('ssh_auth_sock', False) %}\n+{%- if salt['pillar.get']('params:ssh_auth_sock', False) %}\n mgr_ssh_agent_socket_clusters_addnode:\n   environ.setenv:\n     - name: SSH_AUTH_SOCK\n-    - value: {{ pillar['ssh_auth_sock'] }}\n+    - value: {{ salt['pillar.get']('params:ssh_auth_sock') }}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI1OTQ4OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowNzoxMFrOGdGy3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowNzoxMFrOGdGy3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzIxMw==", "bodyText": "I would definitely consider implementing this method instead cmd.run.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433173213", "createdAt": "2020-06-01T11:07:10Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI2NDg0OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowOToxM1rOGdG2KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowOToxM1rOGdG2KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDA1Ng==", "bodyText": "Using cmd.run_all is highly risky here. I would consider using the above commented function. I'll elaborate why in one of the following comments", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433174056", "createdAt": "2020-06-01T11:09:13Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI2NzI0OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToxMDowOFrOGdG3rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToxMDowOFrOGdG3rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDQ0Nw==", "bodyText": "Same as above.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433174447", "createdAt": "2020-06-01T11:10:08Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+\n+    ssh_agent_lines = result['stdout'].splitlines()\n+\n+    variables = dict()\n+    for line in ssh_agent_lines:\n+        if line.startswith('SSH'):\n+            var, *rest = line.split(';')\n+            key, val = var.strip().split(\"=\", 1)\n+            variables[key] = val\n+\n+    __salt__['environ.setenv'](variables)\n+    return variables\n+\n+\n+def list_keys(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format('-l'), output_loglevel='quiet')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI5ODIxOnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToyMzowMlrOGdHKwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToyMzowMlrOGdHKwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3OTMzMA==", "bodyText": "Ok, let me elaborate the explanation here. There are few reasons why this should be avoided:\n\nUsing cmd.run or cmd.run_all like this means, it also executes a shell to run the process (not really needed)\nRunning a shell means we need to take care of possible code injection.\nIn this particular case here, we don't perform any safety check for the ssh_key_file argument of the function (provided by the user), and we use that to feed the cmd.run_all argument. This currently allow extra command injection:\n\n# salt-call --local cmd.run_all \"date; echo my injected code\"\nlocal:\n    ----------\n    pid:\n        15767\n    retcode:\n        0\n    stderr:\n    stdout:\n        Mon Jun  1 12:16:30 WEST 2020\n        my injected code\n\nTherefore doing something like:\n# salt-call --local ssh_agent.add_key \"my_test_file; some malicious rm code\"\n\nwould execute the malicious code.\nTo avoid this we could add python_shell=False to the cmd.run command or maybe using the unimplemented __call_ssh_tool method", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433179330", "createdAt": "2020-06-01T11:23:02Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+\n+    ssh_agent_lines = result['stdout'].splitlines()\n+\n+    variables = dict()\n+    for line in ssh_agent_lines:\n+        if line.startswith('SSH'):\n+            var, *rest = line.split(';')\n+            key, val = var.strip().split(\"=\", 1)\n+            variables[key] = val\n+\n+    __salt__['environ.setenv'](variables)\n+    return variables\n+\n+\n+def list_keys(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format('-l'), output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+    return result['stdout']\n+\n+\n+def add_key(ssh_key_file, **kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format(ssh_key_file), output_loglevel='quiet')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI5OTIzOnYy", "diffSide": "RIGHT", "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToyMzoyN1rOGdHLaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToyMzoyN1rOGdHLaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3OTQ5Nw==", "bodyText": "Same considerations as above", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433179497", "createdAt": "2020-06-01T11:23:27Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+\n+    ssh_agent_lines = result['stdout'].splitlines()\n+\n+    variables = dict()\n+    for line in ssh_agent_lines:\n+        if line.startswith('SSH'):\n+            var, *rest = line.split(';')\n+            key, val = var.strip().split(\"=\", 1)\n+            variables[key] = val\n+\n+    __salt__['environ.setenv'](variables)\n+    return variables\n+\n+\n+def list_keys(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format('-l'), output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+    return result['stdout']\n+\n+\n+def add_key(ssh_key_file, **kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format(ssh_key_file), output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+    return True\n+\n+def kill(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all']('{} -k'.format(__start_agent), output_loglevel='quiet')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2MDMzOnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0Njo0OVrOGeIhHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0Njo0OVrOGeIhHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDAxNQ==", "bodyText": "If we don't wan't this at the formulas repository: Is there any good reason for this to be 0.1? We better have all packages with the same X.Y.Z versioning. In this case 4.1.0.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250015", "createdAt": "2020-06-03T00:46:49Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-node\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-node-formula\n+Version:        0.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2MDg2OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0NzoxNFrOGeIheA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0NzoxNFrOGeIheA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDEwNA==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250104", "createdAt": "2020-06-03T00:47:14Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-settings-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-settings\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-settings-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2Mjc4OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0ODoxOFrOGeIioQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoyNzo1MlrOGeZgew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDQwMQ==", "bodyText": "You already have fdir. Why this is needed?\nAlso... don't we have other package owning this path? I am pretty sure there is, so this could provoke a conflict and we should instead depend on the other package. Check a head server.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250401", "createdAt": "2020-06-03T00:48:18Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-node\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-node-formula\n+Version:        0.1\n+Release:        0\n+Summary:        Salt formula for configuring a CaaSP management node\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt formula for configuring a CaaS Platform management node.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{fname}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{fname}\n+cp -R caasp-management-node/* %{buildroot}%{fdir}/states/%{fname}\n+cp -R metadata/* %{buildroot}%{fdir}/metadata/%{fname}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/salt-formulas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2ODIwOA==", "bodyText": "Afaik a directory can be owned by multiple packages. Please see the section about \"Common directory for unrelated packages\" here.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434468208", "createdAt": "2020-06-03T10:29:31Z", "author": {"login": "mateiw"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-node\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-node-formula\n+Version:        0.1\n+Release:        0\n+Summary:        Salt formula for configuring a CaaSP management node\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt formula for configuring a CaaS Platform management node.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{fname}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{fname}\n+cp -R caasp-management-node/* %{buildroot}%{fdir}/states/%{fname}\n+cp -R metadata/* %{buildroot}%{fdir}/metadata/%{fname}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/salt-formulas", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDQwMQ=="}, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NzU5OQ==", "bodyText": "I also checked on the ref server. /usr/share/susemanager is owned by various packages.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434477599", "createdAt": "2020-06-03T10:48:04Z", "author": {"login": "mateiw"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-node\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-node-formula\n+Version:        0.1\n+Release:        0\n+Summary:        Salt formula for configuring a CaaSP management node\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt formula for configuring a CaaS Platform management node.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{fname}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{fname}\n+cp -R caasp-management-node/* %{buildroot}%{fdir}/states/%{fname}\n+cp -R metadata/* %{buildroot}%{fdir}/metadata/%{fname}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/salt-formulas", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDQwMQ=="}, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyODM3OQ==", "bodyText": "@mateiw right, I checked the doc.\nIMHO this is sometimes masking missing dependencies. But OK, let's keep it.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434528379", "createdAt": "2020-06-03T12:27:52Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-node\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-node-formula\n+Version:        0.1\n+Release:        0\n+Summary:        Salt formula for configuring a CaaSP management node\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt formula for configuring a CaaS Platform management node.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{fname}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{fname}\n+cp -R caasp-management-node/* %{buildroot}%{fdir}/states/%{fname}\n+cp -R metadata/* %{buildroot}%{fdir}/metadata/%{fname}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/salt-formulas", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDQwMQ=="}, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2MzA2OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0ODozMVrOGeIizQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0ODozMVrOGeIizQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDQ0NQ==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250445", "createdAt": "2020-06-03T00:48:31Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-settings-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-settings\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-settings-formula\n+Version:        0.1\n+Release:        0\n+Summary:        Salt formula for storing the settings used to manage a CaaSP cluster\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt formula for storing the settings used to manage a CaaSP cluster\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{fname}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{fname}\n+cp -R caasp-management-settings/* %{buildroot}%{fdir}/states/%{fname}\n+cp -R metadata/* %{buildroot}%{fdir}/metadata/%{fname}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/salt-formulas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2MzcwOnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0ODo1NVrOGeIjLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0ODo1NVrOGeIjLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDU0MA==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250540", "createdAt": "2020-06-03T00:48:55Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2Mzg1OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0OTowM1rOGeIjRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0OTowM1rOGeIjRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDU2Nw==", "bodyText": "Wrong copyright.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250567", "createdAt": "2020-06-03T00:49:03Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2NDA3OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0OToxNVrOGeIjaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0OToxNVrOGeIjaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDYwMw==", "bodyText": "Wrong URL (needs to be https).", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250603", "createdAt": "2020-06-03T00:49:15Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2NDUxOnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0OTozNVrOGeIjuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0OTozNVrOGeIjuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDY4MQ==", "bodyText": "Why the trailing s? Looks like a typo.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250681", "createdAt": "2020-06-03T00:49:35Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0\n+Release:        1\n+Summary:        SUSE CaaS Platform cluster provider for SUSE Manager\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+Requires(pre):  coreutils\n+Requires:       susemanager-build-keys-web >= 12.0.1\n+Requires:       caasp-management-node-formula\n+Requires:       caasp-management-settings-formula\n+%if 0%{?build_py3}s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2NjA1OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1MDoyNlrOGeIknw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1MDoyNlrOGeIknw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDkxMQ==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250911", "createdAt": "2020-06-03T00:50:26Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-settings-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2NjY5OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1MDo0M1rOGeIk-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToxNzoyNVrOGeTTFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTAwMw==", "bodyText": "Shouldn't we have the formulas at the formulas repository?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434251003", "createdAt": "2020-06-03T00:50:43Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyNjY0Nw==", "bodyText": "For now this is tightly coupled with the susemanager-cluster-provider-caasp package so I think it makes more sense to keep it here. Maybe in the future we'll move the susemanager-cluster-provider-caasp.spec package and its dependent formulas to a separate repo.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434426647", "createdAt": "2020-06-03T09:17:25Z", "author": {"login": "mateiw"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTAwMw=="}, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2ODA5OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1MTo0M1rOGeIl0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToxODozNlrOGeTV2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTIxNw==", "bodyText": "Do we really want to call this susemanager- and not uyuni-?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434251217", "createdAt": "2020-06-03T00:51:43Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyNzM1Mw==", "bodyText": "Ok, I'll change the name to uyuni-.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434427353", "createdAt": "2020-06-03T09:18:36Z", "author": {"login": "mateiw"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTIxNw=="}, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk2OTE1OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1MjoyOFrOGeImfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoyODo1N1rOGeZi4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTM4OQ==", "bodyText": "I am pretty sure we have other package that owns this directory. If that's the case, we could have conflicts. We should depend on it. Check a head server.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434251389", "createdAt": "2020-06-03T00:52:28Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0\n+Release:        1\n+Summary:        SUSE CaaS Platform cluster provider for SUSE Manager\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+Requires(pre):  coreutils\n+Requires:       susemanager-build-keys-web >= 12.0.1\n+Requires:       caasp-management-node-formula\n+Requires:       caasp-management-settings-formula\n+%if 0%{?build_py3}s\n+BuildRequires:  python3-pytest\n+BuildRequires:  python3-mock\n+BuildRequires:  python3-salt\n+%else\n+BuildRequires:  python-pytest\n+BuildRequires:  python-mock\n+BuildRequires:  python-salt\n+%endif\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt files and metadata for intergrting with SUSE CaaS Platform.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{provider}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{provider}\n+cp -r caasp/* %{buildroot}%{fdir}/states/%{provider}\n+cp -r metadata/* %{buildroot}%{fdir}/metadata/%{provider}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/susemanager", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NzE3OQ==", "bodyText": "The package won't build without without this %dir. I think we're safe (please see my comment above).", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434477179", "createdAt": "2020-06-03T10:47:10Z", "author": {"login": "mateiw"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0\n+Release:        1\n+Summary:        SUSE CaaS Platform cluster provider for SUSE Manager\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+Requires(pre):  coreutils\n+Requires:       susemanager-build-keys-web >= 12.0.1\n+Requires:       caasp-management-node-formula\n+Requires:       caasp-management-settings-formula\n+%if 0%{?build_py3}s\n+BuildRequires:  python3-pytest\n+BuildRequires:  python3-mock\n+BuildRequires:  python3-salt\n+%else\n+BuildRequires:  python-pytest\n+BuildRequires:  python-mock\n+BuildRequires:  python-salt\n+%endif\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt files and metadata for intergrting with SUSE CaaS Platform.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{provider}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{provider}\n+cp -r caasp/* %{buildroot}%{fdir}/states/%{provider}\n+cp -r metadata/* %{buildroot}%{fdir}/metadata/%{provider}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/susemanager", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTM4OQ=="}, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyODk5NQ==", "bodyText": "The usually means a dependency should be added for the package that owns the directory. But as discusses above, there are quite a few, and maybe none of them is correct. So let's keep it.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434528995", "createdAt": "2020-06-03T12:28:57Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0\n+Release:        1\n+Summary:        SUSE CaaS Platform cluster provider for SUSE Manager\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+Requires(pre):  coreutils\n+Requires:       susemanager-build-keys-web >= 12.0.1\n+Requires:       caasp-management-node-formula\n+Requires:       caasp-management-settings-formula\n+%if 0%{?build_py3}s\n+BuildRequires:  python3-pytest\n+BuildRequires:  python3-mock\n+BuildRequires:  python3-salt\n+%else\n+BuildRequires:  python-pytest\n+BuildRequires:  python-mock\n+BuildRequires:  python-salt\n+%endif\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt files and metadata for intergrting with SUSE CaaS Platform.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{provider}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{provider}\n+cp -r caasp/* %{buildroot}%{fdir}/states/%{provider}\n+cp -r metadata/* %{buildroot}%{fdir}/metadata/%{provider}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/susemanager", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTM4OQ=="}, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjQyNDU4OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/menu/MenuTree.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowMDo0NFrOGeWzHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowMDo0NFrOGeWzHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4Mzk5Ng==", "bodyText": "We need to add all cluster related subdirectories with .withAltUrl() or .withDir() to any of these children so the active menu item and the breadcrumbs are displayed correctly with all pages.\n.withVisibility() can also be appended to hide the section for non-admins, if that's what we want.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434483996", "createdAt": "2020-06-03T11:00:44Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/menu/MenuTree.java", "diffHunk": "@@ -169,6 +170,11 @@\n                     .withDir(\"/rhn/manager/vhms\")\n                     .withVisibility(adminRoles.get(\"org\"))));\n \n+            // Clusters\n+            nodes.add(new MenuItem(\"clusters.nav.title\").withIcon(\"spacewalk-icon-clusters\")\n+                    .addChild(new MenuItem(\"clusters.nav.overview\").withPrimaryUrl(\"/rhn/manager/clusters\"))\n+                    .addChild(new MenuItem(\"clusters.nav.add\").withPrimaryUrl(\"/rhn/manager/clusters/add\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c21e07c3459702a055618719665ef92abe6fc526"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjQ0NTI3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/templates/cluster.jade", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowNzoyOFrOGeXAfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyNTo1M1rOGfqs7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4NzQyMQ==", "bodyText": "I wonder if it's safe to inject this as an HTML text. Maybe instead have this in a JS snippet just like csrfToken above? (same with the other .jade files)", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434487421", "createdAt": "2020-06-03T11:07:28Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/templates/cluster.jade", "diffHunk": "@@ -0,0 +1,23 @@\n+include /templates/common.jade\n+\n++userRoles\n+\n++userPreferences\n+\n+#cluster\n+\n+script(type='text/javascript').\n+    window.csrfToken = \"#{csrf_token}\";\n+\n+div#init_data_cluster(style=\"display: none\")\n+    | #{contentCluster}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c21e07c3459702a055618719665ef92abe6fc526"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1ODY2OQ==", "bodyText": "We do this in several other places already. The json is escaped and the parsed back to we should be on the safe side.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435858669", "createdAt": "2020-06-05T11:25:53Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/templates/cluster.jade", "diffHunk": "@@ -0,0 +1,23 @@\n+include /templates/common.jade\n+\n++userRoles\n+\n++userPreferences\n+\n+#cluster\n+\n+script(type='text/javascript').\n+    window.csrfToken = \"#{csrf_token}\";\n+\n+div#init_data_cluster(style=\"display: none\")\n+    | #{contentCluster}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4NzQyMQ=="}, "originalCommit": {"oid": "c21e07c3459702a055618719665ef92abe6fc526"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjUzMDU4OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTozNjoxM1rOGeX12A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxMTo0OVrOGfr-RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMTA4MA==", "bodyText": "LinkButton is intended to render regular anchors with button styles (when used like here, it adds btn class, which displays wrong when clicked). For this one, since it's not needed, you can instead use <a> tag directly, or add a Link component to the Links utils. It could use a general link component with icon support.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434501080", "createdAt": "2020-06-03T11:36:13Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3OTQ5Mg==", "bodyText": "Dully noted for the next iterations.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435879492", "createdAt": "2020-06-05T12:11:49Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMTA4MA=="}, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjcyMjQ4OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/uyuni-cluster-provider-caasp.spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNDozNVrOGeZvNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowMzozNlrOGedYWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMjE1MA==", "bodyText": "If you don't care about the differences between SLE and openSUSE, maybe you can consider:\n %if 0%{?sle_version} >= 15000\nAs it's easier to understand, and this way you don't need the comment.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434532150", "createdAt": "2020-06-03T12:34:35Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/uyuni-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,73 @@\n+#\n+# spec file for package uyuni-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MTgzNQ==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434591835", "createdAt": "2020-06-03T14:03:36Z", "author": {"login": "mateiw"}, "path": "susemanager-utils/cluster-providers/caasp/uyuni-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,73 @@\n+#\n+# spec file for package uyuni-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMjE1MA=="}, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzA0NDQxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzo1Mzo1N1rOGec8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoyNTo1MVrOGfpFYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDY2Mg==", "bodyText": "I think this method shouldn't be static", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434584662", "createdAt": "2020-06-03T13:53:57Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MjYzNw==", "bodyText": "Why? It should return the list of all installed clustd providers known to Uyuni/SUSE Manager, so it should not be tied to any cluster.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435772637", "createdAt": "2020-06-05T08:35:36Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDY2Mg=="}, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzMjE2Mw==", "bodyText": "My thought was that it's still called from the instance, but anyway it's not dependent on any class members, so ok, I guess either way is fine.\n\n  \n    \n      uyuni/java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java\n    \n    \n        Lines 702 to 708\n      in\n      af48d2b\n    \n    \n    \n    \n\n        \n          \n           private static ClusterProvider getClusterProvider(String label) { \n        \n\n        \n          \n               Optional<ClusterProvider> provider = clusterManager.findClusterProvider(label); \n        \n\n        \n          \n               if (provider.isEmpty()) { \n        \n\n        \n          \n                   halt(HttpStatus.SC_NOT_FOUND, \"Provider \" + label + \" not found\"); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return provider.get(); \n        \n\n        \n          \n           }", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435832163", "createdAt": "2020-06-05T10:25:51Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDY2Mg=="}, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzA0NjQxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzo1NDoyNFrOGec9kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODozNjozNVrOGfle4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDk3Nw==", "bodyText": "Also, shouldn't be static", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434584977", "createdAt": "2020-06-03T13:54:24Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MzE1Mw==", "bodyText": "Can you please detail the reason?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435773153", "createdAt": "2020-06-05T08:36:35Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDk3Nw=="}, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzEwNjUyOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowNzoxNVrOGedjMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowNzoxNVrOGedjMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NDYxMQ==", "bodyText": "Question: are transactions not auto-committed with save()?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434594611", "createdAt": "2020-06-03T14:07:15Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzE2OTA0OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/services/impl/SaltService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyMDozNFrOGeeKrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxMjoxMFrOGfr_CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwNDcxOQ==", "bodyText": "Thinking out loud: I think we'll have to break up this class according to different logical domains at some point.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434604719", "createdAt": "2020-06-03T14:20:34Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/services/impl/SaltService.java", "diffHunk": "@@ -1172,6 +1206,20 @@ private void changeGroupAndPerms(Path dir, GroupPrincipal group) {\n         ).map(s -> s.getContainers());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Optional<Map<String, Map<String, Object>>> listClusterNodes(\n+            MinionServer managementNode, ClusterProviderParameters clusterProviderParameters) {\n+        Map<String, Object> pillar = new HashMap<>();\n+        pillar.put(\"cluster_type\", clusterProviderParameters.getClusterProvider());\n+        clusterProviderParameters.getClusterParams().ifPresent(cpp -> pillar.put(\"params\", cpp));\n+        return callSync(State.apply(Arrays.asList(\"clusters.listnodes\"), Optional.of(pillar),\n+                Optional.of(true), Optional.empty(), ClusterOperationsSlsResult.class),\n+                managementNode.getMinionId()).map(ret -> ret.listNodesResult().getChanges().getRet());\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3OTY4OQ==", "bodyText": "Dully noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435879689", "createdAt": "2020-06-05T12:12:10Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/webui/services/impl/SaltService.java", "diffHunk": "@@ -1172,6 +1206,20 @@ private void changeGroupAndPerms(Path dir, GroupPrincipal group) {\n         ).map(s -> s.getContainers());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Optional<Map<String, Map<String, Object>>> listClusterNodes(\n+            MinionServer managementNode, ClusterProviderParameters clusterProviderParameters) {\n+        Map<String, Object> pillar = new HashMap<>();\n+        pillar.put(\"cluster_type\", clusterProviderParameters.getClusterProvider());\n+        clusterProviderParameters.getClusterParams().ifPresent(cpp -> pillar.put(\"params\", cpp));\n+        return callSync(State.apply(Arrays.asList(\"clusters.listnodes\"), Optional.of(pillar),\n+                Optional.of(true), Optional.empty(), ClusterOperationsSlsResult.class),\n+                managementNode.getMinionId()).map(ret -> ret.listNodesResult().getChanges().getRet());\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwNDcxOQ=="}, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzIzODc2OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozNToxMlrOGee2hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDo0NDozNFrOGf81Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTk0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n          \n          \n            \n                    if (!allMatch) {\n          \n          \n            \n                    if (!clusterNodeHostnames.containsAll(nodes)) {", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434615941", "createdAt": "2020-06-03T14:35:12Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NTcwNg==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436155706", "createdAt": "2020-06-05T20:44:34Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTk0MQ=="}, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzI1ODM4OnYy", "diffSide": "RIGHT", "path": "rel-eng/packages/caasp-management-node-formula", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozOTozMVrOGefDJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowMDowMFrOGfmSEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxOTE3NA==", "bodyText": "As discussed on rocket.chat, the three files from rel-eng/packages can go away. Together with that, remove the headers from the changelogs, so you only have the changelog entry (no empty lines).\nIf you need it for now, just remember to do it before merging, or tell me to do it after merging.\nDo NOT run tito tag!!!", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434619174", "createdAt": "2020-06-03T14:39:31Z", "author": {"login": "juliogonzalez"}, "path": "rel-eng/packages/caasp-management-node-formula", "diffHunk": "@@ -0,0 +1 @@\n+4.1.7-1 susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjI1Ng==", "bodyText": "Done now", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435786256", "createdAt": "2020-06-05T09:00:00Z", "author": {"login": "mbologna"}, "path": "rel-eng/packages/caasp-management-node-formula", "diffHunk": "@@ -0,0 +1 @@\n+4.1.7-1 susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxOTE3NA=="}, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzI5MDM2OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo0NzowMVrOGefYGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjo0MTowM1rOGfOmyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNDUzOQ==", "bodyText": "Another nested class like AddClusterRequest would be useful here", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434624539", "createdAt": "2020-06-03T14:47:01Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODM0Nw==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435398347", "createdAt": "2020-06-04T16:41:03Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNDUzOQ=="}, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzM1MzA1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTowMDozN1rOGef_3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxNDo0MlrOGfsD3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNDcxOQ==", "bodyText": "Heads up: It might be a potential performance issue to use this query in a loop", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434634719", "createdAt": "2020-06-03T15:00:37Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MDkyNQ==", "bodyText": "The number of management nodes is going to be quit small probably. For now I think we'll keep it like this.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435880925", "createdAt": "2020-06-05T12:14:42Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNDcxOQ=="}, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 418}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzM5NzgyOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToxMDozMFrOGegcYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowODowMlrOGfmjcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjAxOQ==", "bodyText": "I guess the message here is wrong", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434642019", "createdAt": "2020-06-03T15:10:30Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 560}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MDcwNA==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435790704", "createdAt": "2020-06-05T09:08:02Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjAxOQ=="}, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 560}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzQwMTM5OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToxMToxN1rOGegeqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjo0MTo1MlrOGfOoug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjYwMA==", "bodyText": "We must take the user org into account too", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434642600", "createdAt": "2020-06-03T15:11:17Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Long getId(Request request) {\n+        String idStr = request.params(\"id\");\n+        Long id = null;\n+        try {\n+            id = Long.parseLong(idStr);\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Id '\" + idStr + \"' is not a number.\");\n+            halt(HttpStatus.SC_BAD_REQUEST, \"id is not a number\");\n+        }\n+        return id;\n+    }\n+\n+    private static Cluster getCluster(Request request) {\n+        Long id = getId(request);\n+        Optional<Cluster> cluster = ClusterFactory.findClusterById(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 579}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODg0Mg==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435398842", "createdAt": "2020-06-04T16:41:52Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Long getId(Request request) {\n+        String idStr = request.params(\"id\");\n+        Long id = null;\n+        try {\n+            id = Long.parseLong(idStr);\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Id '\" + idStr + \"' is not a number.\");\n+            halt(HttpStatus.SC_BAD_REQUEST, \"id is not a number\");\n+        }\n+        return id;\n+    }\n+\n+    private static Cluster getCluster(Request request) {\n+        Long id = getId(request);\n+        Optional<Cluster> cluster = ClusterFactory.findClusterById(id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjYwMA=="}, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 579}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzQ3MDg3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyNjozMlrOGehKuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowOTowM1rOGfmlgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Mzg4MQ==", "bodyText": "To unify the messages with delete:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n          \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s' has been added successfully\", name));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434653881", "createdAt": "2020-06-03T15:26:32Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MTIzMw==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435791233", "createdAt": "2020-06-05T09:09:03Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Mzg4MQ=="}, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzQ3MjM5OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyNjo0OVrOGehLnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToxMDoyM1rOGfmomA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDEwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s'deleted successfully\", cluster.getName()));\n          \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s' has been deleted successfully\", cluster.getName()));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434654109", "createdAt": "2020-06-03T15:26:49Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s'deleted successfully\", cluster.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MjAyNA==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435792024", "createdAt": "2020-06-05T09:10:23Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s'deleted successfully\", cluster.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDEwOQ=="}, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzQ4OTkzOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozMDoyOVrOGehWyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozMDoyOVrOGehWyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Njk2OA==", "bodyText": "In the controller, some of the endpoint methods are public and some are private. I wouldn't mind either way but it's better if they all are the same.\nAlso, the checkstyle wouldn't complain about the private ones, but we could use some javadocs for all of the endpoint methods anyway.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434656968", "createdAt": "2020-06-03T15:30:29Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDMwNTY1OnYy", "diffSide": "RIGHT", "path": "web/html/src/components/utils/HashRouter.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxNTowNFrOGe8-4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxNDo1N1rOGfsEaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwOTYwMQ==", "bodyText": "We need some documentation for each of these components, what they do, how they work, etc. so people can reuse them with ease (if possible, a story page would be great). Also some unit tests for hashUrl() would be nice.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435109601", "createdAt": "2020-06-04T09:15:04Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/components/utils/HashRouter.js", "diffHunk": "@@ -0,0 +1,109 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useEffect} from 'react';\n+\n+declare var history: any;\n+\n+type HashContextType = {\n+    hash: ?string,\n+    switch?: boolean,\n+    match?: boolean,\n+    goTo: (string) => void,\n+    back: () => void\n+}\n+\n+export const HashRouterContext = React.createContext<HashContextType>({\n+        hash: null,\n+        renderOnlyMatching: true,\n+        goTo: (hash) => {},\n+        back: () => {}\n+    });\n+\n+const hashUrlRegex = /^#\\/(.*)$/;\n+\n+function hashUrl(): ?string {\n+    const match = window.location.hash.match(hashUrlRegex);\n+    return match ? match[1] : undefined;\n+}\n+\n+type HashRouterProps = {\n+    initialPath: string,\n+    children: React.Node\n+}\n+\n+const HashRouter = ({initialPath, children}: HashRouterProps) => {\n+    const [hash, setHash] = useState(initialPath);\n+\n+    useEffect(() => {\n+        const hash = hashUrl();\n+        if (hash) {\n+            setHash(hash);\n+        } else {\n+            goTo(initialPath);\n+        }\n+        window.addEventListener(\"popstate\", (event) => {\n+            setHash(hashUrl())\n+        });\n+    }, []);\n+\n+    const goTo = (hash: string) => {\n+        history.pushState(null, \"\", \"#/\" + hash);\n+        setHash(hash);\n+    }\n+\n+    const back = () => {\n+        history.back();\n+    }\n+\n+    return (\n+        <HashRouterContext.Provider value={{hash: hash, goTo: goTo, back: back}}>\n+            {children}\n+        </HashRouterContext.Provider>\n+    );\n+}\n+\n+type RouterProps = {\n+    path: string,\n+    children:  React.Node | (HashContextType) => React.Node\n+}\n+\n+const Route = ({path, children}: RouterProps) => {\n+    return <HashRouterContext.Consumer>\n+        {context => {\n+            const match = path === context.hash;\n+            if (context.switch) {\n+                if (match) {\n+                    if (typeof children === \"function\") {\n+                        return children({match: true, ...context});\n+                    } else {\n+                        return children;\n+                    }\n+                } else {\n+                    return null;\n+                }\n+            } else {\n+                if (typeof children === \"function\") {\n+                    return children({match: match, ...context});\n+                } else {\n+                    return children;\n+                }\n+            }\n+        }}\n+    </HashRouterContext.Consumer>;\n+}\n+\n+type SwitchProps = {\n+    children: React.Node\n+}\n+\n+const Switch = ({children}: SwitchProps) => {\n+    return <HashRouterContext.Consumer>\n+        {context =>\n+            <HashRouterContext.Provider value={{switch: true, ...context}}>\n+                {children}\n+            </HashRouterContext.Provider>\n+        }\n+        </HashRouterContext.Consumer>;\n+}\n+\n+export {HashRouter, Route, Switch};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MTA2NA==", "bodyText": "Dully noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435881064", "createdAt": "2020-06-05T12:14:57Z", "author": {"login": "mateiw"}, "path": "web/html/src/components/utils/HashRouter.js", "diffHunk": "@@ -0,0 +1,109 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useEffect} from 'react';\n+\n+declare var history: any;\n+\n+type HashContextType = {\n+    hash: ?string,\n+    switch?: boolean,\n+    match?: boolean,\n+    goTo: (string) => void,\n+    back: () => void\n+}\n+\n+export const HashRouterContext = React.createContext<HashContextType>({\n+        hash: null,\n+        renderOnlyMatching: true,\n+        goTo: (hash) => {},\n+        back: () => {}\n+    });\n+\n+const hashUrlRegex = /^#\\/(.*)$/;\n+\n+function hashUrl(): ?string {\n+    const match = window.location.hash.match(hashUrlRegex);\n+    return match ? match[1] : undefined;\n+}\n+\n+type HashRouterProps = {\n+    initialPath: string,\n+    children: React.Node\n+}\n+\n+const HashRouter = ({initialPath, children}: HashRouterProps) => {\n+    const [hash, setHash] = useState(initialPath);\n+\n+    useEffect(() => {\n+        const hash = hashUrl();\n+        if (hash) {\n+            setHash(hash);\n+        } else {\n+            goTo(initialPath);\n+        }\n+        window.addEventListener(\"popstate\", (event) => {\n+            setHash(hashUrl())\n+        });\n+    }, []);\n+\n+    const goTo = (hash: string) => {\n+        history.pushState(null, \"\", \"#/\" + hash);\n+        setHash(hash);\n+    }\n+\n+    const back = () => {\n+        history.back();\n+    }\n+\n+    return (\n+        <HashRouterContext.Provider value={{hash: hash, goTo: goTo, back: back}}>\n+            {children}\n+        </HashRouterContext.Provider>\n+    );\n+}\n+\n+type RouterProps = {\n+    path: string,\n+    children:  React.Node | (HashContextType) => React.Node\n+}\n+\n+const Route = ({path, children}: RouterProps) => {\n+    return <HashRouterContext.Consumer>\n+        {context => {\n+            const match = path === context.hash;\n+            if (context.switch) {\n+                if (match) {\n+                    if (typeof children === \"function\") {\n+                        return children({match: true, ...context});\n+                    } else {\n+                        return children;\n+                    }\n+                } else {\n+                    return null;\n+                }\n+            } else {\n+                if (typeof children === \"function\") {\n+                    return children({match: match, ...context});\n+                } else {\n+                    return children;\n+                }\n+            }\n+        }}\n+    </HashRouterContext.Consumer>;\n+}\n+\n+type SwitchProps = {\n+    children: React.Node\n+}\n+\n+const Switch = ({children}: SwitchProps) => {\n+    return <HashRouterContext.Consumer>\n+        {context =>\n+            <HashRouterContext.Provider value={{switch: true, ...context}}>\n+                {children}\n+            </HashRouterContext.Provider>\n+        }\n+        </HashRouterContext.Consumer>;\n+}\n+\n+export {HashRouter, Route, Switch};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwOTYwMQ=="}, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDMyNDgzOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/admin/config/monitoring-admin.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyMDoxN1rOGe9LTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxNjoyN1rOGfsHYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjc4MA==", "bodyText": "Same fix can be applied in the if block too", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435112780", "createdAt": "2020-06-04T09:20:17Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/admin/config/monitoring-admin.js", "diffHunk": "@@ -150,11 +150,11 @@ const MonitoringAdmin = (props) => {\n         return;\n       }\n       changeStatus(enable)\n-        .then((result) => {\n+        .then((result: any) => {\n           if (result.success) {\n             setMessages(MessagesUtils.success(msgMap[result.message]));\n           } else {\n-            setMessages(MessagesUtils.error(msgMap[result.message]));\n+            setMessages(MessagesUtils.error(result.message in msgMap ? msgMap[result.message] : result.message));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MTgyNQ==", "bodyText": "Duly noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435881825", "createdAt": "2020-06-05T12:16:27Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/admin/config/monitoring-admin.js", "diffHunk": "@@ -150,11 +150,11 @@ const MonitoringAdmin = (props) => {\n         return;\n       }\n       changeStatus(enable)\n-        .then((result) => {\n+        .then((result: any) => {\n           if (result.success) {\n             setMessages(MessagesUtils.success(msgMap[result.message]));\n           } else {\n-            setMessages(MessagesUtils.error(msgMap[result.message]));\n+            setMessages(MessagesUtils.error(result.message in msgMap ? msgMap[result.message] : result.message));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjc4MA=="}, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDMzMjQ1OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/admin/config/monitoring-admin.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyMjoyN1rOGe9QLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxNzoyMVrOGfsJEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNDAzMA==", "bodyText": "This check can be done inside Messages component so we can make sure nobody forgets it.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435114030", "createdAt": "2020-06-04T09:22:27Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/admin/config/monitoring-admin.js", "diffHunk": "@@ -210,7 +210,7 @@ const MonitoringAdmin = (props) => {\n     }\n     return (\n     <div className=\"responsive-wizard\">\n-      <Messages items={messages}/>\n+      {messages && <Messages items={messages}/>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MjI1OA==", "bodyText": "Noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435882258", "createdAt": "2020-06-05T12:17:21Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/admin/config/monitoring-admin.js", "diffHunk": "@@ -210,7 +210,7 @@ const MonitoringAdmin = (props) => {\n     }\n     return (\n     <div className=\"responsive-wizard\">\n-      <Messages items={messages}/>\n+      {messages && <Messages items={messages}/>}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNDAzMA=="}, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDMzNTkwOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/admin/config/use-monitoring-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyMzoxOFrOGe9SSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxNzo0N1rOGfsJ2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNDU2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import type {JsonResult} from \"../../../utils/network\";\n          \n          \n            \n            import type {JsonResult} from \"utils/network\";", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435114568", "createdAt": "2020-06-04T09:23:18Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/admin/config/use-monitoring-api.js", "diffHunk": "@@ -1,8 +1,9 @@\n // @flow\n import {useState} from 'react';\n-import Network from 'utils/network';\n+import * as Network from 'utils/network';\n \n-import type JsonResult from \"../../../utils/network\";\n+import type {JsonResult} from \"../../../utils/network\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MjQ1OQ==", "bodyText": "Noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435882459", "createdAt": "2020-06-05T12:17:47Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/admin/config/use-monitoring-api.js", "diffHunk": "@@ -1,8 +1,9 @@\n // @flow\n import {useState} from 'react';\n-import Network from 'utils/network';\n+import * as Network from 'utils/network';\n \n-import type JsonResult from \"../../../utils/network\";\n+import type {JsonResult} from \"../../../utils/network\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNDU2OA=="}, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDM0MTU1OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/systems/activation-key/activation-key-channels-api.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyNDo1M1rOGe9V-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyNDo1M1rOGe9V-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNTUxMg==", "bodyText": "Question in general: What's the difference between these two?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435115512", "createdAt": "2020-06-04T09:24:53Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/systems/activation-key/activation-key-channels-api.js", "diffHunk": "@@ -1,7 +1,7 @@\n /* eslint-disable */\n // @flow\n import React from 'react';\n-import Network from 'utils/network';\n+import * as Network from 'utils/network';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDM5NDQ3OnYy", "diffSide": "RIGHT", "path": "web/html/src/utils/network.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOTozOToxMlrOGe93yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoyNzoyN1rOGfsdVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDE2OA==", "bodyText": "Would this work?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import Functions from '../utils/functions';\n          \n          \n            \n            import {Messages, Utils as MessagesUtils} from '../components/messages';\n          \n          \n            \n            \n          \n          \n            \n            import type {Cancelable} from \"../utils/functions\";\n          \n          \n            \n            import Functions from 'utils/functions';\n          \n          \n            \n            import {Messages, Utils as MessagesUtils} from 'components/messages';\n          \n          \n            \n            \n          \n          \n            \n            import type {Cancelable} from \"utils/functions\";", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435124168", "createdAt": "2020-06-04T09:39:12Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/utils/network.js", "diffHunk": "@@ -1,16 +1,22 @@\n+// @flow\n /* eslint-disable */\n \"use strict\";\n \n-const Functions = require(\"../utils/functions.js\");\n-const MessagesUtils = require(\"../components/messages.js\").Utils;\n+import Functions from '../utils/functions';\n+import {Messages, Utils as MessagesUtils} from '../components/messages';\n+\n+import type {Cancelable} from \"../utils/functions\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NzQ0Nw==", "bodyText": "Noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435887447", "createdAt": "2020-06-05T12:27:27Z", "author": {"login": "mateiw"}, "path": "web/html/src/utils/network.js", "diffHunk": "@@ -1,16 +1,22 @@\n+// @flow\n /* eslint-disable */\n \"use strict\";\n \n-const Functions = require(\"../utils/functions.js\");\n-const MessagesUtils = require(\"../components/messages.js\").Utils;\n+import Functions from '../utils/functions';\n+import {Messages, Utils as MessagesUtils} from '../components/messages';\n+\n+import type {Cancelable} from \"../utils/functions\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDE2OA=="}, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDQzNDE0OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOTo1MDowNlrOGe-Q-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoyNzo1N1rOGfseRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMDYxOQ==", "bodyText": "Nitpick: Block elements (div) inside span is considered invalid.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n          \n          \n            \n                      content={\n          \n          \n            \n                        <div>\n          \n          \n            \n                          <div>{t(\"Are you sure you want to delete cluster?\")}</div>\n          \n          \n            \n                          <div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div>\n          \n          \n            \n                        </div>\n          \n          \n            \n                      }", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435130619", "createdAt": "2020-06-04T09:50:06Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4NzY4Ng==", "bodyText": "Noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435887686", "createdAt": "2020-06-05T12:27:57Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMDYxOQ=="}, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDQ5NTcwOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster.js", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDowNjozNFrOGe-3RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoyODo1NVrOGfsgaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MDQyMA==", "bodyText": "We have a component called TabContainer with hash navigation for this purpose. So I'd prefer we either reuse it, refactoring if necessary, or get rid of it so we have only one component that does the job.\nSee images/image-view.js for an example.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435140420", "createdAt": "2020-06-04T10:06:34Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n+          onConfirmAsync={onDelete}\n+        />\n+        <TopPanel title={name}\n+            button={panelButtons}\n+            icon=\"spacewalk-icon-clusters\"\n+            helpUrl=\"/docs/reference/clusters/clusters-menu.html\">\n+            <HashRouter initialPath=\"overview\">\n+              <div className=\"spacewalk-content-nav\">\n+                <ul className=\"nav nav-tabs\">\n+                    <Route path=\"overview\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Overview\")} hash=\"#/overview\" />\n+                        }\n+                    </Route>\n+                    <Route path=\"settings\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Provider Settings\")} hash=\"#/settings\" />\n+                        }\n+                    </Route>\n+                </ul>        \n+              </div>\n+              <Switch>\n+                <Route path=\"overview\">\n+                  <ClusterOverview cluster={props.cluster} setMessages={props.setMessages} onUpdateName={onUpdateName}/>\n+                </Route>\n+                <Route path=\"settings\">\n+                  <ManagementSettings cluster={props.cluster} setMessages={props.setMessages}/>\n+                </Route>\n+              </Switch>\n+\n+            </HashRouter>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MTAzMg==", "bodyText": "Personally, I like this implementation better, but let's not forget to change the existing TabContainer usages and get rid of it so it won't be confusing for people looking for a similar thing in the future.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435841032", "createdAt": "2020-06-05T10:45:08Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n+          onConfirmAsync={onDelete}\n+        />\n+        <TopPanel title={name}\n+            button={panelButtons}\n+            icon=\"spacewalk-icon-clusters\"\n+            helpUrl=\"/docs/reference/clusters/clusters-menu.html\">\n+            <HashRouter initialPath=\"overview\">\n+              <div className=\"spacewalk-content-nav\">\n+                <ul className=\"nav nav-tabs\">\n+                    <Route path=\"overview\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Overview\")} hash=\"#/overview\" />\n+                        }\n+                    </Route>\n+                    <Route path=\"settings\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Provider Settings\")} hash=\"#/settings\" />\n+                        }\n+                    </Route>\n+                </ul>        \n+              </div>\n+              <Switch>\n+                <Route path=\"overview\">\n+                  <ClusterOverview cluster={props.cluster} setMessages={props.setMessages} onUpdateName={onUpdateName}/>\n+                </Route>\n+                <Route path=\"settings\">\n+                  <ManagementSettings cluster={props.cluster} setMessages={props.setMessages}/>\n+                </Route>\n+              </Switch>\n+\n+            </HashRouter>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MDQyMA=="}, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4ODIzNQ==", "bodyText": "Noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435888235", "createdAt": "2020-06-05T12:28:55Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n+          onConfirmAsync={onDelete}\n+        />\n+        <TopPanel title={name}\n+            button={panelButtons}\n+            icon=\"spacewalk-icon-clusters\"\n+            helpUrl=\"/docs/reference/clusters/clusters-menu.html\">\n+            <HashRouter initialPath=\"overview\">\n+              <div className=\"spacewalk-content-nav\">\n+                <ul className=\"nav nav-tabs\">\n+                    <Route path=\"overview\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Overview\")} hash=\"#/overview\" />\n+                        }\n+                    </Route>\n+                    <Route path=\"settings\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Provider Settings\")} hash=\"#/settings\" />\n+                        }\n+                    </Route>\n+                </ul>        \n+              </div>\n+              <Switch>\n+                <Route path=\"overview\">\n+                  <ClusterOverview cluster={props.cluster} setMessages={props.setMessages} onUpdateName={onUpdateName}/>\n+                </Route>\n+                <Route path=\"settings\">\n+                  <ManagementSettings cluster={props.cluster} setMessages={props.setMessages}/>\n+                </Route>\n+              </Switch>\n+\n+            </HashRouter>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MDQyMA=="}, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDUwMzgxOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDowOTowMFrOGe-8rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyNzozNlrOGfqvrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MTgwNA==", "bodyText": "These tabs act weird with the browser back button (see how the previous tab is darkened):", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435141804", "createdAt": "2020-06-04T10:09:00Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n+          onConfirmAsync={onDelete}\n+        />\n+        <TopPanel title={name}\n+            button={panelButtons}\n+            icon=\"spacewalk-icon-clusters\"\n+            helpUrl=\"/docs/reference/clusters/clusters-menu.html\">\n+            <HashRouter initialPath=\"overview\">\n+              <div className=\"spacewalk-content-nav\">\n+                <ul className=\"nav nav-tabs\">\n+                    <Route path=\"overview\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Overview\")} hash=\"#/overview\" />\n+                        }\n+                    </Route>\n+                    <Route path=\"settings\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Provider Settings\")} hash=\"#/settings\" />\n+                        }\n+                    </Route>\n+                </ul>        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1OTM3NA==", "bodyText": "It's just a cosmetic issue. If the Provider Settings tab has the focus this happens. If you click somewhere else it will lose the focus and look fine.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435859374", "createdAt": "2020-06-05T11:27:36Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n+          onConfirmAsync={onDelete}\n+        />\n+        <TopPanel title={name}\n+            button={panelButtons}\n+            icon=\"spacewalk-icon-clusters\"\n+            helpUrl=\"/docs/reference/clusters/clusters-menu.html\">\n+            <HashRouter initialPath=\"overview\">\n+              <div className=\"spacewalk-content-nav\">\n+                <ul className=\"nav nav-tabs\">\n+                    <Route path=\"overview\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Overview\")} hash=\"#/overview\" />\n+                        }\n+                    </Route>\n+                    <Route path=\"settings\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Provider Settings\")} hash=\"#/settings\" />\n+                        }\n+                    </Route>\n+                </ul>        ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MTgwNA=="}, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTY3OTg3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNzo0N1rOGfKlWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTozMjoyMFrOGfq3tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMjQ0Mw==", "bodyText": "This applies to all usages of the flash scope:\nThese messages should be shown as \"success\" (green) instead of \"info\" (blue).\nWe can push MessageResponse objects to the scope instead. Otherwise, we have only one type of message that is interpreted as info on the frontend.\nInstead, we should deserialize the message objects with the types, and render them with toastr, etc. accordingly.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435332443", "createdAt": "2020-06-04T15:07:47Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTQzMQ==", "bodyText": "Good point. Will address this in the next iterations.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435861431", "createdAt": "2020-06-05T11:32:20Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMjQ0Mw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTkzMDk4OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjowMTo0NlrOGfNEGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo1ODo0MVrOGfrl2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MzA4Mw==", "bodyText": "Are these necessary?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435373083", "createdAt": "2020-06-04T16:01:46Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3MzI0MQ==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435873241", "createdAt": "2020-06-05T11:58:41Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MzA4Mw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk2MDYyOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjowODo1N1rOGfNWyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTozOTowNVrOGfrC8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3Nzg2Nw==", "bodyText": "Mentioned before; buttons components are meant to be styled as buttons, for a link, it'd be nice to have a general Link component inside of links utils.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435377867", "createdAt": "2020-06-04T16:08:57Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "diffHunk": "@@ -0,0 +1,102 @@\n+// @flow\n+import { hot } from 'react-hot-loader';\n+import React, {useEffect} from 'react';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {LinkButton} from 'components/buttons';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import Functions from 'utils/functions';\n+import {SystemLink} from 'components/links';\n+import {showInfoToastr} from 'components/toastr/toastr';\n+\n+import type {ClusterType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  clusters: Array<ClusterType>,\n+  flashMessage: String,\n+};\n+\n+const ListClusters = (props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"addCluster\"\n+                icon=\"fa-plus\"\n+                className=\"btn-link js-spa\"\n+                title={t('Add an existing cluster')}\n+                text={t('Add Cluster')}\n+                href=\"/rhn/manager/clusters/add\"\n+            />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e66ccddb08be968c94ba9349a094fd55aa3b6f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2NDMwNQ==", "bodyText": "Dully noted for the next iterations.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435864305", "createdAt": "2020-06-05T11:39:05Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "diffHunk": "@@ -0,0 +1,102 @@\n+// @flow\n+import { hot } from 'react-hot-loader';\n+import React, {useEffect} from 'react';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {LinkButton} from 'components/buttons';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import Functions from 'utils/functions';\n+import {SystemLink} from 'components/links';\n+import {showInfoToastr} from 'components/toastr/toastr';\n+\n+import type {ClusterType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  clusters: Array<ClusterType>,\n+  flashMessage: String,\n+};\n+\n+const ListClusters = (props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"addCluster\"\n+                icon=\"fa-plus\"\n+                className=\"btn-link js-spa\"\n+                title={t('Add an existing cluster')}\n+                text={t('Add Cluster')}\n+                href=\"/rhn/manager/clusters/add\"\n+            />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3Nzg2Nw=="}, "originalCommit": {"oid": "b1e66ccddb08be968c94ba9349a094fd55aa3b6f"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk3MTA3OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxMTozNFrOGfNd2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTozOTozMFrOGfrDsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3OTY3Mg==", "bodyText": "setMessages from withErrorMessages in use-cluster-api can be used here instead.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435379672", "createdAt": "2020-06-04T16:11:34Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "diffHunk": "@@ -0,0 +1,102 @@\n+// @flow\n+import { hot } from 'react-hot-loader';\n+import React, {useEffect} from 'react';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {LinkButton} from 'components/buttons';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import Functions from 'utils/functions';\n+import {SystemLink} from 'components/links';\n+import {showInfoToastr} from 'components/toastr/toastr';\n+\n+import type {ClusterType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  clusters: Array<ClusterType>,\n+  flashMessage: String,\n+};\n+\n+const ListClusters = (props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"addCluster\"\n+                icon=\"fa-plus\"\n+                className=\"btn-link js-spa\"\n+                title={t('Add an existing cluster')}\n+                text={t('Add Cluster')}\n+                href=\"/rhn/manager/clusters/add\"\n+            />\n+        }\n+        </div>\n+    );\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name', 'type'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    useEffect(()=> {\n+        if(props.flashMessage) {\n+            showInfoToastr(props.flashMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e66ccddb08be968c94ba9349a094fd55aa3b6f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2NDQ5OA==", "bodyText": "Dully noted for the next iterations.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435864498", "createdAt": "2020-06-05T11:39:30Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "diffHunk": "@@ -0,0 +1,102 @@\n+// @flow\n+import { hot } from 'react-hot-loader';\n+import React, {useEffect} from 'react';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {LinkButton} from 'components/buttons';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import Functions from 'utils/functions';\n+import {SystemLink} from 'components/links';\n+import {showInfoToastr} from 'components/toastr/toastr';\n+\n+import type {ClusterType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  clusters: Array<ClusterType>,\n+  flashMessage: String,\n+};\n+\n+const ListClusters = (props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"addCluster\"\n+                icon=\"fa-plus\"\n+                className=\"btn-link js-spa\"\n+                title={t('Add an existing cluster')}\n+                text={t('Add Cluster')}\n+                href=\"/rhn/manager/clusters/add\"\n+            />\n+        }\n+        </div>\n+    );\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name', 'type'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    useEffect(()=> {\n+        if(props.flashMessage) {\n+            showInfoToastr(props.flashMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3OTY3Mg=="}, "originalCommit": {"oid": "b1e66ccddb08be968c94ba9349a094fd55aa3b6f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk3NTI5OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxMjo0NVrOGfNgrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToxMzo1NVrOGfmwOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDM5OA==", "bodyText": "Unused code", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435380398", "createdAt": "2020-06-04T16:12:45Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5Mzk3OA==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435793978", "createdAt": "2020-06-05T09:13:55Z", "author": {"login": "mbologna"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDM5OA=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk3NzU1OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxMzoyNFrOGfNiNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo1NzoyNFrOGfrjJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDc5MQ==", "bodyText": "We can either make use of this somewhere, or get rid of fetching altogether.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435380791", "createdAt": "2020-06-04T16:13:24Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3MjU0OQ==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435872549", "createdAt": "2020-06-05T11:57:24Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDc5MQ=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk4MjMxOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNDozOVrOGfNlNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo0NjoyNlrOGfrPTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTU1Nw==", "bodyText": "stringify() is not needed here. Network methods support plain objects through ajax()\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify(context),\n          \n          \n            \n                        context,", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435381557", "createdAt": "2020-06-04T16:14:39Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2NzQ3MQ==", "bodyText": "For some reason it doesn't seem to work correctly without stringify. Keeping it as it is.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435867471", "createdAt": "2020-06-05T11:46:26Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTU1Nw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk4NTA2OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNToxOFrOGfNm3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo0Njo1OFrOGfrQMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTk4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify(data),\n          \n          \n            \n                        data,", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435381983", "createdAt": "2020-06-04T16:15:18Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2NzY5Nw==", "bodyText": "See previous comment. Keeping it as it is.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435867697", "createdAt": "2020-06-05T11:46:58Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTk4Mw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk4NjIxOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNTozNlrOGfNnmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo0NzoyMFrOGfrQzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjE3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            name: name,\n          \n          \n            \n                            label: label,\n          \n          \n            \n                            description: description,\n          \n          \n            \n                            managementNodeId: managementNodeId,\n          \n          \n            \n                            provider: providerLabel,\n          \n          \n            \n                            managementSettings: managementSettings\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            name: name,\n          \n          \n            \n                            label: label,\n          \n          \n            \n                            description: description,\n          \n          \n            \n                            managementNodeId: managementNodeId,\n          \n          \n            \n                            provider: providerLabel,\n          \n          \n            \n                            managementSettings: managementSettings\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382171", "createdAt": "2020-06-04T16:15:36Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2Nzg1NQ==", "bodyText": "See previous comment. Keeping it as it is.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435867855", "createdAt": "2020-06-05T11:47:20Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjE3MQ=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk4Nzc0OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNTo1OVrOGfNojg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo1NzowNVrOGfricQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: joinFormula\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: joinFormula\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382414", "createdAt": "2020-06-04T16:15:59Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3MjM2OQ==", "bodyText": "See previous comment. Keeping it as it is.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435872369", "createdAt": "2020-06-05T11:57:05Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQxNA=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk4ODk1OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNjoxOFrOGfNpUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo0NzoyOFrOGfrREg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjYwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: removeFormula\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: removeFormula\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382609", "createdAt": "2020-06-04T16:16:18Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2NzkyMg==", "bodyText": "See previous comment. Keeping it as it is.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435867922", "createdAt": "2020-06-05T11:47:28Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjYwOQ=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk5MDkyOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNjo0NlrOGfNqhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo1Njo1NVrOGfriIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjkxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            earliest: earliest\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            earliest: earliest\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382917", "createdAt": "2020-06-04T16:16:46Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleUpgradeCluster = (clusterId: number, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/upgrade`,\n+            JSON.stringify({\n+                earliest: earliest\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3MjI4OA==", "bodyText": "See previous comment. Keeping it as it is.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435872288", "createdAt": "2020-06-05T11:56:55Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleUpgradeCluster = (clusterId: number, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/upgrade`,\n+            JSON.stringify({\n+                earliest: earliest\n+            }),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjkxNw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk5Mjk1OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNzoxOVrOGfNr1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo0NzozNVrOGfrRTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MzI1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify(cluster),\n          \n          \n            \n                        cluster,", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435383253", "createdAt": "2020-06-04T16:17:19Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleUpgradeCluster = (clusterId: number, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/upgrade`,\n+            JSON.stringify({\n+                earliest: earliest\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const saveClusterProps = (clusterId: number, cluster: EditableClusterPropsType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}`,\n+            JSON.stringify(cluster),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2Nzk4MA==", "bodyText": "See previous comment. Keeping it as it is.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435867980", "createdAt": "2020-06-05T11:47:35Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleUpgradeCluster = (clusterId: number, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/upgrade`,\n+            JSON.stringify({\n+                earliest: earliest\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const saveClusterProps = (clusterId: number, cluster: EditableClusterPropsType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}`,\n+            JSON.stringify(cluster),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MzI1Mw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjE4ODg0OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzowOToxNlrOGfPpyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo1NjozM1rOGfrhbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNTQ5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    const selectedServers = [];\n          \n          \n            \n                    for (const srvId of selections) {\n          \n          \n            \n                        const server = servers.find(srv => srv.id === srvId);\n          \n          \n            \n                        if (server) {\n          \n          \n            \n                            selectedServers.push(server);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    const selectedServers = servers.filter(srv => selections.has(srv.id));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435415497", "createdAt": "2020-06-04T17:09:16Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "diffHunk": "@@ -0,0 +1,159 @@\n+// @flow\n+import React, {useState, useEffect} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import {SystemLink} from 'components/links';\n+import {IconTag as Icon} from 'components/icontag';\n+import Functions from 'utils/functions';\n+import {withErrorMessages} from '../api/use-clusters-api';\n+\n+import type {MessageType} from 'components/messages';\n+import type {ErrorMessagesType, ServerType} from  '../api/use-clusters-api';\n+\n+type Props = {\n+    title: string,\n+    selectedServers: ?Array<ServerType>,\n+    onNext: (Array<ServerType>) => void,\n+    onPrev: () => void,\n+    setMessages: (Array<MessageType>) => void,\n+    fetchServers: () => Promise<Array<ServerType>>,\n+    multiple: boolean\n+};\n+\n+const SystemMessages = (props: {messages: Array<MessageType>}) => {\n+    return <ul style={{listStyle: 'none', paddingLeft: '0px', margin: '0px'}}>\n+        { props.messages.map(msg => \n+          <li>\n+            <Icon type=\"system-warn\" className=\"fa-1-5x\"/>{ msg.text }\n+          </li>)  \n+        }\n+        </ul>;\n+}\n+\n+const SelectServer = (props: Props) => {\n+    const [selections, setSelections] = useState<Set<number>>(props.selectedServers ? new Set(props.selectedServers.map(srv => srv.id)) : new Set());\n+    const [servers, setServers] = useState<Array<ServerType>>([]);\n+    const [fetching, setFetching] = useState<boolean>(false);\n+\n+    useEffect(() => {\n+        setFetching(true);\n+        props.fetchServers().then(data => {\n+            setServers(data);\n+            setSelections(new Set());\n+        })\n+        .catch((error : ErrorMessagesType) => {\n+            props.setMessages(error.messages);\n+        })\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }, [])\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    const selectServers = (selections: Set<number>) => {\n+        const selectedServers = [];\n+        for (const srvId of selections) {\n+            const server = servers.find(srv => srv.id === srvId);\n+            if (server) {\n+                selectedServers.push(server);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3MjExMQ==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435872111", "createdAt": "2020-06-05T11:56:33Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "diffHunk": "@@ -0,0 +1,159 @@\n+// @flow\n+import React, {useState, useEffect} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import {SystemLink} from 'components/links';\n+import {IconTag as Icon} from 'components/icontag';\n+import Functions from 'utils/functions';\n+import {withErrorMessages} from '../api/use-clusters-api';\n+\n+import type {MessageType} from 'components/messages';\n+import type {ErrorMessagesType, ServerType} from  '../api/use-clusters-api';\n+\n+type Props = {\n+    title: string,\n+    selectedServers: ?Array<ServerType>,\n+    onNext: (Array<ServerType>) => void,\n+    onPrev: () => void,\n+    setMessages: (Array<MessageType>) => void,\n+    fetchServers: () => Promise<Array<ServerType>>,\n+    multiple: boolean\n+};\n+\n+const SystemMessages = (props: {messages: Array<MessageType>}) => {\n+    return <ul style={{listStyle: 'none', paddingLeft: '0px', margin: '0px'}}>\n+        { props.messages.map(msg => \n+          <li>\n+            <Icon type=\"system-warn\" className=\"fa-1-5x\"/>{ msg.text }\n+          </li>)  \n+        }\n+        </ul>;\n+}\n+\n+const SelectServer = (props: Props) => {\n+    const [selections, setSelections] = useState<Set<number>>(props.selectedServers ? new Set(props.selectedServers.map(srv => srv.id)) : new Set());\n+    const [servers, setServers] = useState<Array<ServerType>>([]);\n+    const [fetching, setFetching] = useState<boolean>(false);\n+\n+    useEffect(() => {\n+        setFetching(true);\n+        props.fetchServers().then(data => {\n+            setServers(data);\n+            setSelections(new Set());\n+        })\n+        .catch((error : ErrorMessagesType) => {\n+            props.setMessages(error.messages);\n+        })\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }, [])\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    const selectServers = (selections: Set<number>) => {\n+        const selectedServers = [];\n+        for (const srvId of selections) {\n+            const server = servers.find(srv => srv.id === srvId);\n+            if (server) {\n+                selectedServers.push(server);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNTQ5Nw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjIzMjg0OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzoyMjowOFrOGfQHBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo1OTozMlrOGfrn4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMjk4Mw==", "bodyText": "IMO we should use the existing Input library here instead.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435422983", "createdAt": "2020-06-04T17:22:08Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "diffHunk": "@@ -0,0 +1,93 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useRef} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {withErrorMessages} from '../shared/api/use-clusters-api';\n+import {Messages} from 'components/messages';\n+import {Label} from 'components/input/Label';\n+\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+    panel: React.Node,\n+    onAdd: (name: string, label: string, description: string) => Promise<any>,\n+    onPrev: () =>  void,\n+    setMessages: (Array<MessageType>) => void\n+};\n+\n+const FinishAddCluster = (props: Props) => {\n+    const [name, setName] = useState<string>(\"\");\n+    const [label, setLabel] = useState<string>(\"\");\n+    const [description, setDescription] = useState<string>(\"\");\n+    const [submitted, setSubmitted] = useState<boolean>(false);\n+    const theForm = useRef(null);\n+\n+    const onAdd = () => {\n+        const isValid = theForm.current ? theForm.current.reportValidity() : false;\n+        if (isValid) {\n+            return props.onAdd(name, label, description).then(data => {\n+                setSubmitted(true);\n+                window.location = `/rhn/manager/cluster/${data}`;\n+            })\n+            .catch((err: Error) => {\n+                console.log(err);\n+                props.setMessages([Messages.error(\"Error adding cluster: \" + err.message)]);\n+                throw err;\n+            });\n+        } else {\n+            console.log(\"form is not valid\");\n+        }\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={t(\"Add cluster\")}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            disabled={submitted}\n+                            text={t(\"Prev\")}\n+                            className=\"btn-default\"\n+                            icon=\"fa-arrow-left\"\n+                            handler={() => props.onPrev()}\n+                        />\n+                        <AsyncButton\n+                            id=\"btn-next\"\n+                            disabled={submitted}\n+                            text={t(\"Add\")}\n+                            defaultType=\"btn-success\"\n+                            icon=\"fa-plus\"\n+                            action={onAdd}\n+                        />\n+                    </div>\n+                }>\n+                <form id=\"formula-form\" ref={theForm} className=\"form-horizontal\" onSubmit={(event) => {event.preventDefault(); return false;}}>\n+                    <div className=\"form-horizontal\">\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Name:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={name} onChange={ev => setName(ev.target.value)} required/>\n+                            </div>\n+                        </div>\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Label:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={label} onChange={ev => setLabel(ev.target.value)}\n+                                required pattern=\"^[a-zA-Z_][a-zA-Z0-9_]+$\" title=\"only letters, numbers or underscore\"/>\n+                            </div>\n+                        </div>\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Description:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={description} onChange={ev =>  setDescription(ev.target.value)} required/>\n+                            </div>\n+                        </div>                                        \n+                    </div>   \n+                </form>                                             ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3Mzc2MA==", "bodyText": "Dully noted.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435873760", "createdAt": "2020-06-05T11:59:32Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "diffHunk": "@@ -0,0 +1,93 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useRef} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {withErrorMessages} from '../shared/api/use-clusters-api';\n+import {Messages} from 'components/messages';\n+import {Label} from 'components/input/Label';\n+\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+    panel: React.Node,\n+    onAdd: (name: string, label: string, description: string) => Promise<any>,\n+    onPrev: () =>  void,\n+    setMessages: (Array<MessageType>) => void\n+};\n+\n+const FinishAddCluster = (props: Props) => {\n+    const [name, setName] = useState<string>(\"\");\n+    const [label, setLabel] = useState<string>(\"\");\n+    const [description, setDescription] = useState<string>(\"\");\n+    const [submitted, setSubmitted] = useState<boolean>(false);\n+    const theForm = useRef(null);\n+\n+    const onAdd = () => {\n+        const isValid = theForm.current ? theForm.current.reportValidity() : false;\n+        if (isValid) {\n+            return props.onAdd(name, label, description).then(data => {\n+                setSubmitted(true);\n+                window.location = `/rhn/manager/cluster/${data}`;\n+            })\n+            .catch((err: Error) => {\n+                console.log(err);\n+                props.setMessages([Messages.error(\"Error adding cluster: \" + err.message)]);\n+                throw err;\n+            });\n+        } else {\n+            console.log(\"form is not valid\");\n+        }\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={t(\"Add cluster\")}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            disabled={submitted}\n+                            text={t(\"Prev\")}\n+                            className=\"btn-default\"\n+                            icon=\"fa-arrow-left\"\n+                            handler={() => props.onPrev()}\n+                        />\n+                        <AsyncButton\n+                            id=\"btn-next\"\n+                            disabled={submitted}\n+                            text={t(\"Add\")}\n+                            defaultType=\"btn-success\"\n+                            icon=\"fa-plus\"\n+                            action={onAdd}\n+                        />\n+                    </div>\n+                }>\n+                <form id=\"formula-form\" ref={theForm} className=\"form-horizontal\" onSubmit={(event) => {event.preventDefault(); return false;}}>\n+                    <div className=\"form-horizontal\">\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Name:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={name} onChange={ev => setName(ev.target.value)} required/>\n+                            </div>\n+                        </div>\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Label:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={label} onChange={ev => setLabel(ev.target.value)}\n+                                required pattern=\"^[a-zA-Z_][a-zA-Z0-9_]+$\" title=\"only letters, numbers or underscore\"/>\n+                            </div>\n+                        </div>\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Description:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={description} onChange={ev =>  setDescription(ev.target.value)} required/>\n+                            </div>\n+                        </div>                                        \n+                    </div>   \n+                </form>                                             ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMjk4Mw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjQwNTUxOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODowOTowM1rOGfR0gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODowOTowM1rOGfR0gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTAxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      onChange={(model) => {setEditModel(model); console.log(model)}} \n          \n          \n            \n                      onChange={setEditModel}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435451011", "createdAt": "2020-06-04T18:09:03Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjQ3OTkxOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODoyNzoxNlrOGfSj3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowMzoxMVrOGfru0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MzEzNA==", "bodyText": "I guess this is leftover from debugging.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n          \n          \n            \n                      onValidate={setValid}\n          \n      \n    \n    \n  \n\nWhere setValid is the setter of an isValid flag:\nconst [isValid, setValid] = useState<boolean>(true);\nThen saving should be prevented/button disabled according to the flag.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435463134", "createdAt": "2020-06-04T18:27:16Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NTUzNg==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435875536", "createdAt": "2020-06-05T12:03:11Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MzEzNA=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjQ5MDE4OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODoyOToyNFrOGfSqMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjozMTo1MlrOGfsmWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NDc1NQ==", "bodyText": "As mentioned; this should be disabled with an isValid flag.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435464755", "createdAt": "2020-06-04T18:29:24Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4OTc1NQ==", "bodyText": "Validation is done on save and the form will show the errors and a toastr err message will be shown so I guess it can stay enabled.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435889755", "createdAt": "2020-06-05T12:31:52Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NDc1NQ=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjQ5MjYxOnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODozMDowM1rOGfSrrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowMzoyMFrOGfrvHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NTEzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            onClosePopUp={() => {console.log(\"onclose\")}}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435465132", "createdAt": "2020-06-04T18:30:03Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />\n+              </div>\n+          </div>\n+  </React.Fragment>;\n+\n+  return (\n+      <>\n+        <Dialog id=\"cluster-edit-dialog\"\n+                title={t(\"Edit cluster details\")}\n+                closableModal={true}\n+                className=\"modal-lg\"\n+                content={editContent}\n+                onClosePopUp={() => {console.log(\"onclose\")}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NTYxMw==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435875613", "createdAt": "2020-06-05T12:03:20Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />\n+              </div>\n+          </div>\n+  </React.Fragment>;\n+\n+  return (\n+      <>\n+        <Dialog id=\"cluster-edit-dialog\"\n+                title={t(\"Edit cluster details\")}\n+                closableModal={true}\n+                className=\"modal-lg\"\n+                content={editContent}\n+                onClosePopUp={() => {console.log(\"onclose\")}}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NTEzMg=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjUwMTc3OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODozMjozMVrOGfSxzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODozMjozMVrOGfSxzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NjcwMA==", "bodyText": "Why not set the model during initialization on top?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435466700", "createdAt": "2020-06-04T18:32:31Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />\n+              </div>\n+          </div>\n+  </React.Fragment>;\n+\n+  return (\n+      <>\n+        <Dialog id=\"cluster-edit-dialog\"\n+                title={t(\"Edit cluster details\")}\n+                closableModal={true}\n+                className=\"modal-lg\"\n+                content={editContent}\n+                onClosePopUp={() => {console.log(\"onclose\")}}\n+                buttons={editButtons}\n+              />\n+\n+        <SectionToolbar>\n+          <div className=\"pull-right btn-group\">\n+              <LinkButton\n+                id=\"join-btn\"\n+                icon=\"fa-plus\"\n+                text={t(\"Join node\")}\n+                className=\"gap-right btn-default\"\n+                href={`/rhn/manager/cluster/${props.cluster.id}/join`}\n+                />\n+              <Button\n+                id=\"remove-btn\"\n+                disabled={selections.size === 0}\n+                icon=\"fa-minus\"\n+                text={t(\"Remove node\")}\n+                className=\"gap-right btn-default\"\n+                handler={onRemove}\n+                />\n+              <AsyncButton id=\"refresh-btn\" defaultType=\"btn-default\"\n+                icon=\"fa-refresh\"\n+                text={t(\"Refresh\") }\n+                className=\"gap-right\"\n+                action={() => fetchData() }\n+                />\n+              <LinkButton\n+                id=\"upgrade\"\n+                disabled={true}\n+                icon=\"spacewalk-icon-package-upgrade\"\n+                text={t(\"Upgrade cluster\") }\n+                className=\"btn-default gap-right\"\n+                href={`/rhn/manager/cluster/${props.cluster.id}/upgrade`}\n+                />                \n+              <AsyncButton id=\"refresh-group-btn\" defaultType=\"btn-default\"\n+                icon=\"fa-refresh\"\n+                text={t(\"Refresh system group\") }\n+                className=\"gap-right\"\n+                action={() => onRefreshGroupNodes()}\n+                />\n+\n+          </div>\n+        </SectionToolbar>\n+        \n+        <Panel headingLevel=\"h3\" title={t('Cluster Properties')}\n+          buttons={<ModalLink\n+                  target=\"cluster-edit-dialog\"\n+                  icon=\"fa-plus\"\n+                  className=\"btn-link\"\n+                  text={t(\"Edit properties\")}\n+                  title={t(\"Edit cluster details\")}\n+                  onClick={() => setEditModel({name: cluster.name, description: cluster.description})}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjU0NTc3OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0MTo1NlrOGfTNUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowMzo1NFrOGfrwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mzc0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        text={t(\"Prev\")}\n          \n          \n            \n                                        text={t(\"Back\")} // or \"Previous\"", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435473745", "createdAt": "2020-06-04T18:41:56Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "diffHunk": "@@ -0,0 +1,93 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useRef} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {withErrorMessages} from '../shared/api/use-clusters-api';\n+import {Messages} from 'components/messages';\n+import {Label} from 'components/input/Label';\n+\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+    panel: React.Node,\n+    onAdd: (name: string, label: string, description: string) => Promise<any>,\n+    onPrev: () =>  void,\n+    setMessages: (Array<MessageType>) => void\n+};\n+\n+const FinishAddCluster = (props: Props) => {\n+    const [name, setName] = useState<string>(\"\");\n+    const [label, setLabel] = useState<string>(\"\");\n+    const [description, setDescription] = useState<string>(\"\");\n+    const [submitted, setSubmitted] = useState<boolean>(false);\n+    const theForm = useRef(null);\n+\n+    const onAdd = () => {\n+        const isValid = theForm.current ? theForm.current.reportValidity() : false;\n+        if (isValid) {\n+            return props.onAdd(name, label, description).then(data => {\n+                setSubmitted(true);\n+                window.location = `/rhn/manager/cluster/${data}`;\n+            })\n+            .catch((err: Error) => {\n+                console.log(err);\n+                props.setMessages([Messages.error(\"Error adding cluster: \" + err.message)]);\n+                throw err;\n+            });\n+        } else {\n+            console.log(\"form is not valid\");\n+        }\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={t(\"Add cluster\")}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            disabled={submitted}\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NTg5Nw==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435875897", "createdAt": "2020-06-05T12:03:54Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "diffHunk": "@@ -0,0 +1,93 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useRef} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {withErrorMessages} from '../shared/api/use-clusters-api';\n+import {Messages} from 'components/messages';\n+import {Label} from 'components/input/Label';\n+\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+    panel: React.Node,\n+    onAdd: (name: string, label: string, description: string) => Promise<any>,\n+    onPrev: () =>  void,\n+    setMessages: (Array<MessageType>) => void\n+};\n+\n+const FinishAddCluster = (props: Props) => {\n+    const [name, setName] = useState<string>(\"\");\n+    const [label, setLabel] = useState<string>(\"\");\n+    const [description, setDescription] = useState<string>(\"\");\n+    const [submitted, setSubmitted] = useState<boolean>(false);\n+    const theForm = useRef(null);\n+\n+    const onAdd = () => {\n+        const isValid = theForm.current ? theForm.current.reportValidity() : false;\n+        if (isValid) {\n+            return props.onAdd(name, label, description).then(data => {\n+                setSubmitted(true);\n+                window.location = `/rhn/manager/cluster/${data}`;\n+            })\n+            .catch((err: Error) => {\n+                console.log(err);\n+                props.setMessages([Messages.error(\"Error adding cluster: \" + err.message)]);\n+                throw err;\n+            });\n+        } else {\n+            console.log(\"form is not valid\");\n+        }\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={t(\"Add cluster\")}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            disabled={submitted}\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mzc0NQ=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjU1MTk5OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0MzowNlrOGfTQ_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowNDowN1rOGfrwmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NDY4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                  text={t(\"Prev\")}\n          \n          \n            \n                                                  text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435474687", "createdAt": "2020-06-04T18:43:06Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "diffHunk": "@@ -0,0 +1,144 @@\n+// @flow\n+import React, {useEffect, useState} from 'react';\n+import useClustersApi, {withErrorMessages} from '../api/use-clusters-api';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Messages} from 'components/messages';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {FormulaFormContext, FormulaFormContextProvider, FormulaFormRenderer} from 'components/formulas/FormulaComponentGenerator';\n+import {Loading} from 'components/utils/Loading';\n+\n+import type {FormulaValuesType, FormulaContextType, ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator once its flow-ified\n+// type ValidatedFormulaType = {\n+//   errors: {\n+//     required: Array<string>,\n+//     invalid: Array<string>\n+//   },\n+//   values: {[string]: any}\n+// }\n+\n+type Props = {\n+  provider: string,\n+  title: string,\n+  values: ?FormulaValuesType,\n+  formula: string,\n+  context: ?FormulaContextType,\n+  onNext: (FormulaValuesType) => void,\n+  onPrev?: () => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const FormulaConfig = (props: Props) => {\n+    const [form, setForm] = useState<any>(null);\n+    const [formulaValues, setFormulaValues] = useState<?FormulaValuesType>(null);\n+    const {fetchProviderFormulaForm} = useClustersApi();\n+\n+    useEffect(() => {\n+      fetchProviderFormulaForm(props.provider, props.formula, props.context ? props.context : null).then(data => {\n+        setForm(data.form);\n+        if (data.params) {\n+          // merge params with props.values\n+          setFormulaValues(Object.assign({}, data.params, props.values)); // order is important\n+        } else if (props.values) {\n+          setFormulaValues(props.values);\n+        } else {\n+          setFormulaValues({})\n+        }\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })\n+    }, []);\n+\n+    const clickNext = ({errors, values}) => {\n+      if (errors) {\n+        const messages = [];\n+        if (errors.required && errors.required.length > 0) {\n+            messages.push(Messages.error(t(\"Please input required fields: {0}\", errors.required.join(', '))));\n+        }\n+        if (errors.invalid && errors.invalid.length > 0) {\n+            messages.push(Messages.error(t(\"Invalid format of fields: {0}\", errors.invalid.join(', '))));\n+        }\n+        props.setMessages(messages);\n+      } else {\n+        props.onNext(values);\n+      }\n+    }\n+\n+    return (form && formulaValues ? \n+              <FormulaFormContextProvider layout={form}\n+                systemData={formulaValues ? formulaValues : {}}\n+                groupData={{}}\n+                scope=\"system\">\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                          <FormulaFormContext.Consumer>\n+                            {({validate}) => \n+                                <div className=\"btn-group\">\n+                                  {props.onPrev ? <Button\n+                                      id=\"btn-prev\"\n+                                      text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NTk5NA==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435875994", "createdAt": "2020-06-05T12:04:07Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "diffHunk": "@@ -0,0 +1,144 @@\n+// @flow\n+import React, {useEffect, useState} from 'react';\n+import useClustersApi, {withErrorMessages} from '../api/use-clusters-api';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Messages} from 'components/messages';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {FormulaFormContext, FormulaFormContextProvider, FormulaFormRenderer} from 'components/formulas/FormulaComponentGenerator';\n+import {Loading} from 'components/utils/Loading';\n+\n+import type {FormulaValuesType, FormulaContextType, ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator once its flow-ified\n+// type ValidatedFormulaType = {\n+//   errors: {\n+//     required: Array<string>,\n+//     invalid: Array<string>\n+//   },\n+//   values: {[string]: any}\n+// }\n+\n+type Props = {\n+  provider: string,\n+  title: string,\n+  values: ?FormulaValuesType,\n+  formula: string,\n+  context: ?FormulaContextType,\n+  onNext: (FormulaValuesType) => void,\n+  onPrev?: () => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const FormulaConfig = (props: Props) => {\n+    const [form, setForm] = useState<any>(null);\n+    const [formulaValues, setFormulaValues] = useState<?FormulaValuesType>(null);\n+    const {fetchProviderFormulaForm} = useClustersApi();\n+\n+    useEffect(() => {\n+      fetchProviderFormulaForm(props.provider, props.formula, props.context ? props.context : null).then(data => {\n+        setForm(data.form);\n+        if (data.params) {\n+          // merge params with props.values\n+          setFormulaValues(Object.assign({}, data.params, props.values)); // order is important\n+        } else if (props.values) {\n+          setFormulaValues(props.values);\n+        } else {\n+          setFormulaValues({})\n+        }\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })\n+    }, []);\n+\n+    const clickNext = ({errors, values}) => {\n+      if (errors) {\n+        const messages = [];\n+        if (errors.required && errors.required.length > 0) {\n+            messages.push(Messages.error(t(\"Please input required fields: {0}\", errors.required.join(', '))));\n+        }\n+        if (errors.invalid && errors.invalid.length > 0) {\n+            messages.push(Messages.error(t(\"Invalid format of fields: {0}\", errors.invalid.join(', '))));\n+        }\n+        props.setMessages(messages);\n+      } else {\n+        props.onNext(values);\n+      }\n+    }\n+\n+    return (form && formulaValues ? \n+              <FormulaFormContextProvider layout={form}\n+                systemData={formulaValues ? formulaValues : {}}\n+                groupData={{}}\n+                scope=\"system\">\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                          <FormulaFormContext.Consumer>\n+                            {({validate}) => \n+                                <div className=\"btn-group\">\n+                                  {props.onPrev ? <Button\n+                                      id=\"btn-prev\"\n+                                      text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NDY4Nw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjU1Mzk5OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0MzozMFrOGfTSPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowNToyMVrOGfry6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTAwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        text={t(\"Prev\")}\n          \n          \n            \n                                        text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435475007", "createdAt": "2020-06-04T18:43:30Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "diffHunk": "@@ -0,0 +1,144 @@\n+// @flow\n+import React, {useEffect, useState} from 'react';\n+import useClustersApi, {withErrorMessages} from '../api/use-clusters-api';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Messages} from 'components/messages';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {FormulaFormContext, FormulaFormContextProvider, FormulaFormRenderer} from 'components/formulas/FormulaComponentGenerator';\n+import {Loading} from 'components/utils/Loading';\n+\n+import type {FormulaValuesType, FormulaContextType, ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator once its flow-ified\n+// type ValidatedFormulaType = {\n+//   errors: {\n+//     required: Array<string>,\n+//     invalid: Array<string>\n+//   },\n+//   values: {[string]: any}\n+// }\n+\n+type Props = {\n+  provider: string,\n+  title: string,\n+  values: ?FormulaValuesType,\n+  formula: string,\n+  context: ?FormulaContextType,\n+  onNext: (FormulaValuesType) => void,\n+  onPrev?: () => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const FormulaConfig = (props: Props) => {\n+    const [form, setForm] = useState<any>(null);\n+    const [formulaValues, setFormulaValues] = useState<?FormulaValuesType>(null);\n+    const {fetchProviderFormulaForm} = useClustersApi();\n+\n+    useEffect(() => {\n+      fetchProviderFormulaForm(props.provider, props.formula, props.context ? props.context : null).then(data => {\n+        setForm(data.form);\n+        if (data.params) {\n+          // merge params with props.values\n+          setFormulaValues(Object.assign({}, data.params, props.values)); // order is important\n+        } else if (props.values) {\n+          setFormulaValues(props.values);\n+        } else {\n+          setFormulaValues({})\n+        }\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })\n+    }, []);\n+\n+    const clickNext = ({errors, values}) => {\n+      if (errors) {\n+        const messages = [];\n+        if (errors.required && errors.required.length > 0) {\n+            messages.push(Messages.error(t(\"Please input required fields: {0}\", errors.required.join(', '))));\n+        }\n+        if (errors.invalid && errors.invalid.length > 0) {\n+            messages.push(Messages.error(t(\"Invalid format of fields: {0}\", errors.invalid.join(', '))));\n+        }\n+        props.setMessages(messages);\n+      } else {\n+        props.onNext(values);\n+      }\n+    }\n+\n+    return (form && formulaValues ? \n+              <FormulaFormContextProvider layout={form}\n+                systemData={formulaValues ? formulaValues : {}}\n+                groupData={{}}\n+                scope=\"system\">\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                          <FormulaFormContext.Consumer>\n+                            {({validate}) => \n+                                <div className=\"btn-group\">\n+                                  {props.onPrev ? <Button\n+                                      id=\"btn-prev\"\n+                                      text={t(\"Prev\")}\n+                                      className=\"btn-default\"\n+                                      icon=\"fa-arrow-left\"\n+                                      handler={props.onPrev}\n+                                  /> : null}\n+                                  <Button id=\"btn-next\"\n+                                    icon=\"fa-arrow-right\"\n+                                    text={t(\"Next\")}\n+                                    className={\"btn-success\"}\n+                                    handler={() => {clickNext(validate())}} />\n+                                </div>\n+                            }\n+                          </FormulaFormContext.Consumer>\n+                    }>\n+                      <SectionToolbar>\n+                        <div className='action-button-wrapper'>\n+                          <div className='btn-group'>\n+                            <FormulaFormContext.Consumer>\n+                              {({clearValues}) => \n+                                <Button id=\"reset-btn\" icon=\"fa-eraser\" text=\"Clear values\"\n+                                  className=\"btn btn-default\"\n+                                  handler={() => clearValues(() => window.confirm(\"Are you sure you want to clear all values?\"))} />\n+                              }\n+                            </FormulaFormContext.Consumer>\n+                          </div>\n+                        </div>    \n+                      </SectionToolbar>\n+                      <div style={{marginTop: \"15px\"}}>\n+                        <FormulaFormRenderer />\n+                      </div>\n+                  </Panel>\n+                </FormulaFormContextProvider>\n+                :\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                      <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NjU4NA==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435876584", "createdAt": "2020-06-05T12:05:21Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "diffHunk": "@@ -0,0 +1,144 @@\n+// @flow\n+import React, {useEffect, useState} from 'react';\n+import useClustersApi, {withErrorMessages} from '../api/use-clusters-api';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Messages} from 'components/messages';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {FormulaFormContext, FormulaFormContextProvider, FormulaFormRenderer} from 'components/formulas/FormulaComponentGenerator';\n+import {Loading} from 'components/utils/Loading';\n+\n+import type {FormulaValuesType, FormulaContextType, ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator once its flow-ified\n+// type ValidatedFormulaType = {\n+//   errors: {\n+//     required: Array<string>,\n+//     invalid: Array<string>\n+//   },\n+//   values: {[string]: any}\n+// }\n+\n+type Props = {\n+  provider: string,\n+  title: string,\n+  values: ?FormulaValuesType,\n+  formula: string,\n+  context: ?FormulaContextType,\n+  onNext: (FormulaValuesType) => void,\n+  onPrev?: () => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const FormulaConfig = (props: Props) => {\n+    const [form, setForm] = useState<any>(null);\n+    const [formulaValues, setFormulaValues] = useState<?FormulaValuesType>(null);\n+    const {fetchProviderFormulaForm} = useClustersApi();\n+\n+    useEffect(() => {\n+      fetchProviderFormulaForm(props.provider, props.formula, props.context ? props.context : null).then(data => {\n+        setForm(data.form);\n+        if (data.params) {\n+          // merge params with props.values\n+          setFormulaValues(Object.assign({}, data.params, props.values)); // order is important\n+        } else if (props.values) {\n+          setFormulaValues(props.values);\n+        } else {\n+          setFormulaValues({})\n+        }\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })\n+    }, []);\n+\n+    const clickNext = ({errors, values}) => {\n+      if (errors) {\n+        const messages = [];\n+        if (errors.required && errors.required.length > 0) {\n+            messages.push(Messages.error(t(\"Please input required fields: {0}\", errors.required.join(', '))));\n+        }\n+        if (errors.invalid && errors.invalid.length > 0) {\n+            messages.push(Messages.error(t(\"Invalid format of fields: {0}\", errors.invalid.join(', '))));\n+        }\n+        props.setMessages(messages);\n+      } else {\n+        props.onNext(values);\n+      }\n+    }\n+\n+    return (form && formulaValues ? \n+              <FormulaFormContextProvider layout={form}\n+                systemData={formulaValues ? formulaValues : {}}\n+                groupData={{}}\n+                scope=\"system\">\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                          <FormulaFormContext.Consumer>\n+                            {({validate}) => \n+                                <div className=\"btn-group\">\n+                                  {props.onPrev ? <Button\n+                                      id=\"btn-prev\"\n+                                      text={t(\"Prev\")}\n+                                      className=\"btn-default\"\n+                                      icon=\"fa-arrow-left\"\n+                                      handler={props.onPrev}\n+                                  /> : null}\n+                                  <Button id=\"btn-next\"\n+                                    icon=\"fa-arrow-right\"\n+                                    text={t(\"Next\")}\n+                                    className={\"btn-success\"}\n+                                    handler={() => {clickNext(validate())}} />\n+                                </div>\n+                            }\n+                          </FormulaFormContext.Consumer>\n+                    }>\n+                      <SectionToolbar>\n+                        <div className='action-button-wrapper'>\n+                          <div className='btn-group'>\n+                            <FormulaFormContext.Consumer>\n+                              {({clearValues}) => \n+                                <Button id=\"reset-btn\" icon=\"fa-eraser\" text=\"Clear values\"\n+                                  className=\"btn btn-default\"\n+                                  handler={() => clearValues(() => window.confirm(\"Are you sure you want to clear all values?\"))} />\n+                              }\n+                            </FormulaFormContext.Consumer>\n+                          </div>\n+                        </div>    \n+                      </SectionToolbar>\n+                      <div style={{marginTop: \"15px\"}}>\n+                        <FormulaFormRenderer />\n+                      </div>\n+                  </Panel>\n+                </FormulaFormContextProvider>\n+                :\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                      <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTAwNw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjU1NTE4OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/ui/schedule-cluster-action.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0Mzo0NlrOGfTTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowNTo0NVrOGfrz0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTIxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            text={t(\"Prev\")}\n          \n          \n            \n                                            text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435475217", "createdAt": "2020-06-04T18:43:46Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/schedule-cluster-action.js", "diffHunk": "@@ -0,0 +1,86 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {ActionLink, ActionChainLink} from 'components/links';\n+import {ActionSchedule} from 'components/action-schedule';\n+import Functions from 'utils/functions';\n+import {withErrorMessages}  from '../api/use-clusters-api';\n+import useUserLocalization from 'core/user-localization/use-user-localization';\n+import {Messages} from 'components/messages';\n+\n+import type {ActionChain} from \"components/action-schedule\";\n+import type {ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+declare var actionChains: Array<ActionChain>;\n+\n+type Props = {\n+    title: string,\n+    panel: React.Node,\n+    schedule: (earliest: Date, actionChain: ?string) => Promise<any>,\n+    onPrev?: () =>  void,\n+    setMessages: (Array<MessageType>) => void,\n+    scheduleButtonLabel: string\n+};\n+\n+const ScheduleClusterAction = (props: Props) => {\n+    const {timezone, localTime} = useUserLocalization();\n+\n+    const [actionChain, setActionChain] = useState<?ActionChain>(null);\n+    const [earliest, setEarliest] = useState(Functions.Utils.dateWithTimezone(localTime));\n+    const [disableSchedule, setDisableSchedule] = useState(false);\n+\n+    const onSchedule = (): Promise<any> => {\n+        return props.schedule(earliest, actionChain ? actionChain.text: null).then(\n+            (actionId) => {\n+                // setDisableSchedule(true);\n+                const actionChainMsg = Messages.success(<span>{t(\"Action has been successfully added to the Action Chain \")}\n+                        <ActionChainLink id={actionId}>{actionChain ? actionChain.text : \"\"}</ActionChainLink>.</span>);\n+                const actionMsg = Messages.success(<span>{t(\"Action has been \")}\n+                          <ActionLink id={actionId}>{t(\"scheduled\")}</ActionLink>{t(\" successfully.\")}</span>);\n+                props.setMessages([actionChain ? actionChainMsg : actionMsg]);\n+            },\n+            (error: ErrorMessagesType) => {\n+                props.setMessages(error.messages);\n+            });\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={props.title}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        {\n+                            props.onPrev ? <Button\n+                                id=\"btn-prev\"\n+                                disabled={disableSchedule}\n+                                text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NjgxNg==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435876816", "createdAt": "2020-06-05T12:05:45Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/ui/schedule-cluster-action.js", "diffHunk": "@@ -0,0 +1,86 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {ActionLink, ActionChainLink} from 'components/links';\n+import {ActionSchedule} from 'components/action-schedule';\n+import Functions from 'utils/functions';\n+import {withErrorMessages}  from '../api/use-clusters-api';\n+import useUserLocalization from 'core/user-localization/use-user-localization';\n+import {Messages} from 'components/messages';\n+\n+import type {ActionChain} from \"components/action-schedule\";\n+import type {ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+declare var actionChains: Array<ActionChain>;\n+\n+type Props = {\n+    title: string,\n+    panel: React.Node,\n+    schedule: (earliest: Date, actionChain: ?string) => Promise<any>,\n+    onPrev?: () =>  void,\n+    setMessages: (Array<MessageType>) => void,\n+    scheduleButtonLabel: string\n+};\n+\n+const ScheduleClusterAction = (props: Props) => {\n+    const {timezone, localTime} = useUserLocalization();\n+\n+    const [actionChain, setActionChain] = useState<?ActionChain>(null);\n+    const [earliest, setEarliest] = useState(Functions.Utils.dateWithTimezone(localTime));\n+    const [disableSchedule, setDisableSchedule] = useState(false);\n+\n+    const onSchedule = (): Promise<any> => {\n+        return props.schedule(earliest, actionChain ? actionChain.text: null).then(\n+            (actionId) => {\n+                // setDisableSchedule(true);\n+                const actionChainMsg = Messages.success(<span>{t(\"Action has been successfully added to the Action Chain \")}\n+                        <ActionChainLink id={actionId}>{actionChain ? actionChain.text : \"\"}</ActionChainLink>.</span>);\n+                const actionMsg = Messages.success(<span>{t(\"Action has been \")}\n+                          <ActionLink id={actionId}>{t(\"scheduled\")}</ActionLink>{t(\" successfully.\")}</span>);\n+                props.setMessages([actionChain ? actionChainMsg : actionMsg]);\n+            },\n+            (error: ErrorMessagesType) => {\n+                props.setMessages(error.messages);\n+            });\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={props.title}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        {\n+                            props.onPrev ? <Button\n+                                id=\"btn-prev\"\n+                                disabled={disableSchedule}\n+                                text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTIxNw=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjU1NjI1OnYy", "diffSide": "RIGHT", "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0NDowMVrOGfTTyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowNjowN1rOGfr0gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTQwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        text={t(\"Prev\")}\n          \n          \n            \n                                        text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435475402", "createdAt": "2020-06-04T18:44:01Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "diffHunk": "@@ -0,0 +1,159 @@\n+// @flow\n+import React, {useState, useEffect} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import {SystemLink} from 'components/links';\n+import {IconTag as Icon} from 'components/icontag';\n+import Functions from 'utils/functions';\n+import {withErrorMessages} from '../api/use-clusters-api';\n+\n+import type {MessageType} from 'components/messages';\n+import type {ErrorMessagesType, ServerType} from  '../api/use-clusters-api';\n+\n+type Props = {\n+    title: string,\n+    selectedServers: ?Array<ServerType>,\n+    onNext: (Array<ServerType>) => void,\n+    onPrev: () => void,\n+    setMessages: (Array<MessageType>) => void,\n+    fetchServers: () => Promise<Array<ServerType>>,\n+    multiple: boolean\n+};\n+\n+const SystemMessages = (props: {messages: Array<MessageType>}) => {\n+    return <ul style={{listStyle: 'none', paddingLeft: '0px', margin: '0px'}}>\n+        { props.messages.map(msg => \n+          <li>\n+            <Icon type=\"system-warn\" className=\"fa-1-5x\"/>{ msg.text }\n+          </li>)  \n+        }\n+        </ul>;\n+}\n+\n+const SelectServer = (props: Props) => {\n+    const [selections, setSelections] = useState<Set<number>>(props.selectedServers ? new Set(props.selectedServers.map(srv => srv.id)) : new Set());\n+    const [servers, setServers] = useState<Array<ServerType>>([]);\n+    const [fetching, setFetching] = useState<boolean>(false);\n+\n+    useEffect(() => {\n+        setFetching(true);\n+        props.fetchServers().then(data => {\n+            setServers(data);\n+            setSelections(new Set());\n+        })\n+        .catch((error : ErrorMessagesType) => {\n+            props.setMessages(error.messages);\n+        })\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }, [])\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    const selectServers = (selections: Set<number>) => {\n+        const selectedServers = [];\n+        for (const srvId of selections) {\n+            const server = servers.find(srv => srv.id === srvId);\n+            if (server) {\n+                selectedServers.push(server);\n+            }\n+        }\n+        props.onNext(selectedServers);\n+    }\n+\n+    const onSelectServer = (event, id) => {\n+        let newSelections;\n+        if (props.multiple) {\n+            newSelections = new Set(selections);\n+            if (event.target.checked) {\n+                newSelections.add(id);\n+            } else {\n+                newSelections.delete(id);\n+            }\n+        }\n+        else {\n+            newSelections = new Set([id]);\n+        }\n+        setSelections(newSelections);\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={props.title}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        {props.onPrev ? <Button\n+                            id=\"btn-prev\"\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3Njk5Mg==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435876992", "createdAt": "2020-06-05T12:06:07Z", "author": {"login": "mateiw"}, "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "diffHunk": "@@ -0,0 +1,159 @@\n+// @flow\n+import React, {useState, useEffect} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import {SystemLink} from 'components/links';\n+import {IconTag as Icon} from 'components/icontag';\n+import Functions from 'utils/functions';\n+import {withErrorMessages} from '../api/use-clusters-api';\n+\n+import type {MessageType} from 'components/messages';\n+import type {ErrorMessagesType, ServerType} from  '../api/use-clusters-api';\n+\n+type Props = {\n+    title: string,\n+    selectedServers: ?Array<ServerType>,\n+    onNext: (Array<ServerType>) => void,\n+    onPrev: () => void,\n+    setMessages: (Array<MessageType>) => void,\n+    fetchServers: () => Promise<Array<ServerType>>,\n+    multiple: boolean\n+};\n+\n+const SystemMessages = (props: {messages: Array<MessageType>}) => {\n+    return <ul style={{listStyle: 'none', paddingLeft: '0px', margin: '0px'}}>\n+        { props.messages.map(msg => \n+          <li>\n+            <Icon type=\"system-warn\" className=\"fa-1-5x\"/>{ msg.text }\n+          </li>)  \n+        }\n+        </ul>;\n+}\n+\n+const SelectServer = (props: Props) => {\n+    const [selections, setSelections] = useState<Set<number>>(props.selectedServers ? new Set(props.selectedServers.map(srv => srv.id)) : new Set());\n+    const [servers, setServers] = useState<Array<ServerType>>([]);\n+    const [fetching, setFetching] = useState<boolean>(false);\n+\n+    useEffect(() => {\n+        setFetching(true);\n+        props.fetchServers().then(data => {\n+            setServers(data);\n+            setSelections(new Set());\n+        })\n+        .catch((error : ErrorMessagesType) => {\n+            props.setMessages(error.messages);\n+        })\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }, [])\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    const selectServers = (selections: Set<number>) => {\n+        const selectedServers = [];\n+        for (const srvId of selections) {\n+            const server = servers.find(srv => srv.id === srvId);\n+            if (server) {\n+                selectedServers.push(server);\n+            }\n+        }\n+        props.onNext(selectedServers);\n+    }\n+\n+    const onSelectServer = (event, id) => {\n+        let newSelections;\n+        if (props.multiple) {\n+            newSelections = new Set(selections);\n+            if (event.target.checked) {\n+                newSelections.add(id);\n+            } else {\n+                newSelections.delete(id);\n+            }\n+        }\n+        else {\n+            newSelections = new Set([id]);\n+        }\n+        setSelections(newSelections);\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={props.title}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        {props.onPrev ? <Button\n+                            id=\"btn-prev\"\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTQwMg=="}, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjYwMTg1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo1Njo1M1rOGfTxBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToxNjozN1rOGfm2Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4Mjg4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 /**\n          \n          \n            \n                /**", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435482885", "createdAt": "2020-06-04T18:56:53Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -446,7 +453,7 @@ else if (layoutFileCustom.exists()) {\n         }\n     }\n \n-    /**\n+     /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab08f8e591253ab09ff397ac46e4f2ed31d2acef"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NTQ5NA==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435795494", "createdAt": "2020-06-05T09:16:37Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -446,7 +453,7 @@ else if (layoutFileCustom.exists()) {\n         }\n     }\n \n-    /**\n+     /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4Mjg4NQ=="}, "originalCommit": {"oid": "ab08f8e591253ab09ff397ac46e4f2ed31d2acef"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYwNDk1OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterGroupRefreshNodes.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyOToyN1rOGfnR4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyOToyN1rOGfnR4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjU5Mw==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435802593", "createdAt": "2020-06-05T09:29:27Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterGroupRefreshNodes.sql", "diffHunk": "@@ -0,0 +1,31 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterGroupRefreshNodes (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclgrref_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclgrref_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclustergrn_aid_idx ON rhnActionClusterGroupRefreshNodes (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYwNTQxOnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterJoinNode.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyOTozNVrOGfnSMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyOTozNVrOGfnSMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjY3Mw==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435802673", "createdAt": "2020-06-05T09:29:35Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterJoinNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterJoinNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclusterjn_aid_idx ON rhnActionClusterJoinNode (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYwNjQ2OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterRemoveNode.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDowMVrOGfnS9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDowMVrOGfnS9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjg3MA==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435802870", "createdAt": "2020-06-05T09:30:01Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterRemoveNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterRemoveNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclusterrn_aid_idx ON rhnActionClusterRemoveNode (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYwNzY0OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterServers.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDoyMVrOGfnTuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDoyMVrOGfnTuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMzA2NQ==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435803065", "createdAt": "2020-06-05T09:30:21Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterServers.sql", "diffHunk": "@@ -0,0 +1,27 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterServers (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclsrvs_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    server_id           NUMERIC\n+                            CONSTRAINT rhn_actionclsrvs_sid_fk\n+                            REFERENCES rhnServer (id)\n+                            ON DELETE CASCADE\n+);\n+\n+CREATE UNIQUE INDEX rhn_action_cluster_srvs_idx", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYxNDQ3OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterJoinNode.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMjowN1rOGfnX5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMjowN1rOGfnX5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDEzMg==", "bodyText": "Would it make sense to use \"TEXT\" here. AFAIK there is no changes in the hibernate schema needed for this.\nBut you do not have limits on the length.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804132", "createdAt": "2020-06-05T09:32:07Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterJoinNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterJoinNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYxNTA5OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterRemoveNode.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMjoxOFrOGfnYUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMjoxOFrOGfnYUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDI0MA==", "bodyText": "Would it make sense to use \"TEXT\" here.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804240", "createdAt": "2020-06-05T09:32:18Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterRemoveNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterRemoveNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYxNjU1OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterUpgradeCluster.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMjo0NFrOGfnZPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMjo0NFrOGfnZPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDQ3Nw==", "bodyText": "Would it make sense to use \"TEXT\" here.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804477", "createdAt": "2020-06-05T09:32:44Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterUpgradeCluster.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterUpgradeCluster (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclupgrade_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYxODQ0OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterUpgradeCluster.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMzoxOVrOGfnacQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMzoxOVrOGfnacQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDc4NQ==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804785", "createdAt": "2020-06-05T09:33:19Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterUpgradeCluster.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterUpgradeCluster (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclupgrade_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclusteruc_aid_idx ON rhnActionClusterUpgradeCluster (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYyNDg3OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/suseClusters.sql", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozNToxNVrOGfnedQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjoxMDoyOVrOGfr76w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNTgxMw==", "bodyText": "I think this does not work. In postgresql an empty string is the same as NULL. So we have a rule that \"NOT NULL\" columns do not allow empty string. Please check, I wonder why this does not create problems.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435805813", "createdAt": "2020-06-05T09:35:15Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) NOT NULL DEFAULT '',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzNTY3OA==", "bodyText": "@mcalmer I think you're thinking about Oracle, where null and an empty string is indeed interpreted the same, but not in PostgreSQL, so this is technically valid.\nBut still, since it's a DB specific and generally confusing, we can just make it nullable instead.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435835678", "createdAt": "2020-06-05T10:33:15Z", "author": {"login": "cbbayburt"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) NOT NULL DEFAULT '',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNTgxMw=="}, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MjM1OA==", "bodyText": "Maybe it was the other way around? As it was in oracle the same, they tried to prevent that somebody use it in postgresql and therefor they setup a check which does not allow it.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435852358", "createdAt": "2020-06-05T11:10:51Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) NOT NULL DEFAULT '',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNTgxMw=="}, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODg5MQ==", "bodyText": "I changed to  VARCHAR(4096) DEFAULT ''. I tested and PostgreSQL treats doesn't treat empty string as NULL like Oracle.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435878891", "createdAt": "2020-06-05T12:10:29Z", "author": {"login": "mateiw"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) NOT NULL DEFAULT '',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNTgxMw=="}, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYzNDY5OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/suseClusters.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozODowOVrOGfnkrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozODowOVrOGfnkrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNzQwNA==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435807404", "createdAt": "2020-06-05T09:38:09Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) NOT NULL DEFAULT '',\n+    provider    VARCHAR(50) NOT NULL,\n+    management_node_id  NUMERIC\n+                        CONSTRAINT suse_clusters_mgmt_node_fk\n+                        REFERENCES rhnServer (id)\n+                        ON DELETE SET NULL,\n+    group_id    NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_group_fk\n+                    REFERENCES rhnServerGroup (id),\n+    created     TIMESTAMPTZ\n+                     DEFAULT (current_timestamp) NOT NULL,\n+    modified    TIMESTAMPTZ\n+                     DEFAULT (current_timestamp) NOT NULL\n+);\n+\n+CREATE SEQUENCE suse_cluster_id_seq;\n+\n+CREATE UNIQUE INDEX suse_cluster_name_idx\n+    ON suseClusters (name);\n+\n+CREATE UNIQUE INDEX suse_cluster_label_idx\n+    ON suseClusters (label);\n+\n+CREATE UNIQUE INDEX suse_cluster_group_idx\n+    ON suseClusters (group_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc1ODg4OnYy", "diffSide": "RIGHT", "path": "susemanager-utils/cluster-providers/caasp/caasp/kill_ssh_agent.sls", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxNjo0MlrOGfoz2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzoxNDoyOVrOGgJbZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzY3Mg==", "bodyText": "Is order: last really needed? Can we use more require statements instead?\nThe reason is, that the only state where we use order: last is, updating and starting salt-minion.\nIf possible, please prevent this usage.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435827672", "createdAt": "2020-06-05T10:16:42Z", "author": {"login": "mcalmer"}, "path": "susemanager-utils/cluster-providers/caasp/caasp/kill_ssh_agent.sls", "diffHunk": "@@ -0,0 +1,8 @@\n+{%- if not salt['pillar.get']('params:use_ssh_agent') %}\n+mgr_caasp_kill_agent:\n+  module.run:\n+    - name: ssh_agent.kill\n+    - order: last", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMDczMQ==", "bodyText": "This can be included in several other cluster sls files. The problem is that it doesn't know in which files it's being included. For now I think we can keep it like this and think about a better solution in the next iterations. I don't think this will conflict with updating and restarting salt-minon.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435900731", "createdAt": "2020-06-05T12:52:58Z", "author": {"login": "mateiw"}, "path": "susemanager-utils/cluster-providers/caasp/caasp/kill_ssh_agent.sls", "diffHunk": "@@ -0,0 +1,8 @@\n+{%- if not salt['pillar.get']('params:use_ssh_agent') %}\n+mgr_caasp_kill_agent:\n+  module.run:\n+    - name: ssh_agent.kill\n+    - order: last", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzY3Mg=="}, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MjA4Ng==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436362086", "createdAt": "2020-06-07T13:14:29Z", "author": {"login": "mcalmer"}, "path": "susemanager-utils/cluster-providers/caasp/caasp/kill_ssh_agent.sls", "diffHunk": "@@ -0,0 +1,8 @@\n+{%- if not salt['pillar.get']('params:use_ssh_agent') %}\n+mgr_caasp_kill_agent:\n+  module.run:\n+    - name: ssh_agent.kill\n+    - order: last", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzY3Mg=="}, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDgwNzM1OnYy", "diffSide": "RIGHT", "path": "schema/spacewalk/common/tables/rhnActionClusterGroupRefreshNodes.sql", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDozMjo1OVrOGfpSnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDozMjo1OVrOGfpSnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzNTU0OQ==", "bodyText": "Is modified needed or used at all?\nYou do not have a trigger configured and I am unsure if the java hibernate part is adapting it automatically.\nAFAIK not as this was only possible with annotations.\nThis apply to all these Action classes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435835549", "createdAt": "2020-06-05T10:32:59Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterGroupRefreshNodes.sql", "diffHunk": "@@ -0,0 +1,31 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterGroupRefreshNodes (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclgrref_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclgrref_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDkxNDYxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxMDo1MVrOGfqUQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowMzoyM1rOGf4MYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MjM1NA==", "bodyText": "Can be exported into a separate method", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435852354", "createdAt": "2020-06-05T11:10:51Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -499,8 +506,40 @@ else if (layoutFileCustom.exists()) {\n                 groupId + \"_\" + name + \".\" + PILLAR_FILE_EXTENSION);\n         try {\n             if (dataFile.exists()) {\n-                return Optional.of((Map<String, Object>) GSON.fromJson(\n-                        new BufferedReader(new FileReader(dataFile)), Map.class));\n+                Map<String, Object> data = (Map<String, Object>) GSON.fromJson(\n+                        new BufferedReader(new FileReader(dataFile)), Map.class);\n+\n+                if (formulaHasType(name, \"cluster-formula\")) {\n+                    // find cluster for this group\n+                    Optional<Cluster> cluster = ClusterFactory.findClusterByGroupId(groupId);\n+                    if (cluster.isPresent()) {\n+                        // load cluster provider metadata and look for the key of this formula\n+                        Map<String, Object> metadata = getClusterProviderMetadata(cluster.get().getProvider());\n+                        Map<String, Object> formulas = (Map<String, Object>) metadata.get(\"formulas\");\n+                        Optional<String> formulaKey = formulas.entrySet().stream()\n+                                .filter(e -> e.getValue() instanceof Map)\n+                                .filter(e -> ((Map) e.getValue()).get(\"name\").equals(name))\n+                                .map(e -> e.getKey())\n+                                .findFirst();\n+                        if (formulaKey.isPresent()) {\n+                            // return values under mgr_clusters:<cluster-name>:<formula-key>\n+                            return getValueByPath(data,\n+                                    \"mgr_clusters:\" + cluster.get().getLabel() + \":\" + formulaKey.get())\n+                                    .filter(Map.class::isInstance)\n+                                    .map(Map.class::cast);\n+                        }\n+                        else {\n+                            return Optional.empty();\n+                        }\n+                    }\n+                    else {\n+                        return Optional.empty();\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTcxMw==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436079713", "createdAt": "2020-06-05T18:03:23Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -499,8 +506,40 @@ else if (layoutFileCustom.exists()) {\n                 groupId + \"_\" + name + \".\" + PILLAR_FILE_EXTENSION);\n         try {\n             if (dataFile.exists()) {\n-                return Optional.of((Map<String, Object>) GSON.fromJson(\n-                        new BufferedReader(new FileReader(dataFile)), Map.class));\n+                Map<String, Object> data = (Map<String, Object>) GSON.fromJson(\n+                        new BufferedReader(new FileReader(dataFile)), Map.class);\n+\n+                if (formulaHasType(name, \"cluster-formula\")) {\n+                    // find cluster for this group\n+                    Optional<Cluster> cluster = ClusterFactory.findClusterByGroupId(groupId);\n+                    if (cluster.isPresent()) {\n+                        // load cluster provider metadata and look for the key of this formula\n+                        Map<String, Object> metadata = getClusterProviderMetadata(cluster.get().getProvider());\n+                        Map<String, Object> formulas = (Map<String, Object>) metadata.get(\"formulas\");\n+                        Optional<String> formulaKey = formulas.entrySet().stream()\n+                                .filter(e -> e.getValue() instanceof Map)\n+                                .filter(e -> ((Map) e.getValue()).get(\"name\").equals(name))\n+                                .map(e -> e.getKey())\n+                                .findFirst();\n+                        if (formulaKey.isPresent()) {\n+                            // return values under mgr_clusters:<cluster-name>:<formula-key>\n+                            return getValueByPath(data,\n+                                    \"mgr_clusters:\" + cluster.get().getLabel() + \":\" + formulaKey.get())\n+                                    .filter(Map.class::isInstance)\n+                                    .map(Map.class::cast);\n+                        }\n+                        else {\n+                            return Optional.empty();\n+                        }\n+                    }\n+                    else {\n+                        return Optional.empty();\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MjM1NA=="}, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDkyNjU1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxNTowNVrOGfqbdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowMzoxN1rOGf4MOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NDE5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param keyType the Java type of the value\n          \n          \n            \n                 * @param <T> the Java type of the value\n          \n          \n            \n                 * @return the value of the metadata key\n          \n          \n            \n                 */\n          \n          \n            \n                public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n          \n          \n            \n                    Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n          \n          \n            \n                    return FormulaFactory.getValueByPath(metadata, key)\n          \n          \n            \n                            .filter(keyType::isInstance)\n          \n          \n            \n                            .map(keyType::cast);\n          \n          \n            \n                 * @param valueType the Java type of the value\n          \n          \n            \n                 * @param <T> the Java type of the value\n          \n          \n            \n                 * @return the value of the metadata key\n          \n          \n            \n                 */\n          \n          \n            \n                public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> valueType) {\n          \n          \n            \n                    Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n          \n          \n            \n                    return FormulaFactory.getValueByPath(metadata, key)\n          \n          \n            \n                            .filter(valueType::isInstance)\n          \n          \n            \n                            .map(valueType::cast);", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435854199", "createdAt": "2020-06-05T11:15:05Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTY3Mw==", "bodyText": "done", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436079673", "createdAt": "2020-06-05T18:03:17Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NDE5OQ=="}, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDk0MDIwOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyMDoxMVrOGfqjtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyMDoxMVrOGfqjtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjMwOA==", "bodyText": "Does it make sense to continue execution in this case? Otherwise maybe just throw a RuntimeException?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435856308", "createdAt": "2020-06-05T11:20:11Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);\n+    }\n+\n+    /**\n+     * Get a formula layout from a cluster provider. The formula is referenced by its key not by it's actual name.\n+     * @param provider the name of the cluster provider\n+     * @param formulaKey the key of the formula used by the provider\n+     * @return the formula layout as a Map\n+     */\n+    public static Optional<Map<String, Object>> getClusterProviderFormulaLayout(String provider, String formulaKey) {\n+        Map<String, Object> metadata = getClusterProviderMetadata(provider);\n+        Optional<String> formulaName = getValueByPath(metadata, \"formulas:\" + formulaKey + \":name\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast);\n+\n+        String formulaSource = getValueByPath(metadata, \"formulas:\" + formulaKey + \":source\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .orElse(\"system\");\n+\n+        if (formulaName.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (\"system\".equals(formulaSource)) {\n+            return getFormulaLayoutByName(formulaName.get());\n+        }\n+        else if (\"cluster-provider\".equals(formulaSource)) {\n+            return getFormulaLayoutByClusterProviderAndName(provider, formulaName.get());\n+        }\n+        else {\n+            throw new RuntimeException(\"Unknown formula source \" + formulaSource);\n+        }\n+    }\n+\n+    private static Optional<Map<String, Object>> getFormulaLayoutByClusterProviderAndName(String provider,\n+                                                                                          String name) {\n+        Path layoutFile = Paths.get(METADATA_DIR_CLUSTER_PROVIDERS, provider, name + \".yml\");\n+        try {\n+            if (Files.exists(layoutFile)) {\n+                return Optional.of((Map<String, Object>) YAML.load(new FileInputStream(layoutFile.toFile())));\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        catch (FileNotFoundException | YAMLException e) {\n+            LOG.error(\"Error loading layout for formula '\" + name +\n+                    \"' from cluster provider '\" + provider + \"'\", e);\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDk0NTU1OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyMjoyMlrOGfqnGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyMjoyMlrOGfqnGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NzE3Nw==", "bodyText": "Also here, maybe throw a RuntimeException so it propagates to the UI?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435857177", "createdAt": "2020-06-05T11:22:22Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);\n+    }\n+\n+    /**\n+     * Get a formula layout from a cluster provider. The formula is referenced by its key not by it's actual name.\n+     * @param provider the name of the cluster provider\n+     * @param formulaKey the key of the formula used by the provider\n+     * @return the formula layout as a Map\n+     */\n+    public static Optional<Map<String, Object>> getClusterProviderFormulaLayout(String provider, String formulaKey) {\n+        Map<String, Object> metadata = getClusterProviderMetadata(provider);\n+        Optional<String> formulaName = getValueByPath(metadata, \"formulas:\" + formulaKey + \":name\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast);\n+\n+        String formulaSource = getValueByPath(metadata, \"formulas:\" + formulaKey + \":source\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .orElse(\"system\");\n+\n+        if (formulaName.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (\"system\".equals(formulaSource)) {\n+            return getFormulaLayoutByName(formulaName.get());\n+        }\n+        else if (\"cluster-provider\".equals(formulaSource)) {\n+            return getFormulaLayoutByClusterProviderAndName(provider, formulaName.get());\n+        }\n+        else {\n+            throw new RuntimeException(\"Unknown formula source \" + formulaSource);\n+        }\n+    }\n+\n+    private static Optional<Map<String, Object>> getFormulaLayoutByClusterProviderAndName(String provider,\n+                                                                                          String name) {\n+        Path layoutFile = Paths.get(METADATA_DIR_CLUSTER_PROVIDERS, provider, name + \".yml\");\n+        try {\n+            if (Files.exists(layoutFile)) {\n+                return Optional.of((Map<String, Object>) YAML.load(new FileInputStream(layoutFile.toFile())));\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        catch (FileNotFoundException | YAMLException e) {\n+            LOG.error(\"Error loading layout for formula '\" + name +\n+                    \"' from cluster provider '\" + provider + \"'\", e);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Checks the type of the formula.\n+     * @param formula the name of the formula\n+     * @param type the type\n+     * @return whether the formula has the given type or not\n+     */\n+    public static boolean formulaHasType(String formula, String type) {\n+        Map<String, Object> metadata = getMetadata(formula);\n+        return Optional.ofNullable(metadata.get(\"type\"))\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .map(t -> t.equals(type))\n+                .orElse(false);\n+    }\n+\n+\n+    /**\n+     * Get the value from a nested map structure by a colon separated path.\n+     * E.g. key1:key2:key3 for a map with a depth of 3.\n+     * @param data the nested map\n+     * @param path the path\n+     * @return a value if available\n+     */\n+    public static Optional<Object> getValueByPath(Map<String, Object> data, String path) {\n+        String[] tokens = StringUtils.split(path, \":\");\n+        Map<String, Object> current = data;\n+        for (int i = 0; i < tokens.length; i++) {\n+            String token = tokens[i];\n+            Object val = current.get(token);\n+            if (i == tokens.length - 1) {\n+                return Optional.ofNullable(val);\n+            }\n+            if (val == null) {\n+                return Optional.empty();\n+            }\n+            if (val instanceof Map) {\n+                current = (Map<String, Object>)val;\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers.\n+     * @return a list containing the metadata of all installed cluster providers\n+     */\n+    public static List<Map<String, Object>> getClusterProvidersMetadata() {\n+        Path dir = Path.of(METADATA_DIR_CLUSTER_PROVIDERS);\n+        try {\n+            return Files.list(dir)\n+                    .filter(Files::isDirectory)\n+                    .map(p -> {\n+                        String provider = p.getFileName().toString();\n+                        Map<String, Object> m = getClusterProviderMetadata(provider);\n+                        m = new HashMap<>(m);\n+                        m.put(\"label\", provider);\n+                        return m;\n+                    })\n+                    .collect(Collectors.toList());\n+        }\n+        catch (IOException e) {\n+            LOG.error(\"Error loading providers metadata\", e);\n+            return Collections.emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE2Nzc5OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjozNjoxMlrOGfsu8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyOTo0NVrOGf8dbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MTk1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435891953", "createdAt": "2020-06-05T12:36:12Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0OTYxMw==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436149613", "createdAt": "2020-06-05T20:29:45Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MTk1Mw=="}, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE3MjM3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjozNzo0NVrOGfsxxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDo0MToyM1rOGf8wPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MjY3OQ==", "bodyText": "We should use LocalizationService here", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435892679", "createdAt": "2020-06-05T12:37:45Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NDQyOQ==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436154429", "createdAt": "2020-06-05T20:41:23Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MjY3OQ=="}, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE4NDk0OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0MTo0MFrOGfs5xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTozNjo0NFrOGfzeuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDcyNQ==", "bodyText": "If possible, the whole thing should be done in a single DB transaction", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435894725", "createdAt": "2020-06-05T12:41:40Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTM4Ng==", "bodyText": "Are you referring to refresh group nodes ? It must query the cluster so it can take some time, that's why it's done async.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435991386", "createdAt": "2020-06-05T15:19:05Z", "author": {"login": "mateiw"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDcyNQ=="}, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwMjQ5MQ==", "bodyText": "No, I mean:\n\nCreate the server group\nCreate the cluster\nCreate and store the action entry\n\nThese should be all-or-nothing", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436002491", "createdAt": "2020-06-05T15:36:44Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDcyNQ=="}, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE4Nzg3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0MjozNVrOGfs7jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0MjozNVrOGfs7jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NTE4Mw==", "bodyText": "If possible, the whole thing should be done in a single DB transaction", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435895183", "createdAt": "2020-06-05T12:42:35Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE5ODY3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0NTozNlrOGftCBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyMDo1MVrOGf8Oww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjgzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435896836", "createdAt": "2020-06-05T12:45:36Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 458}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NTg1OQ==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436145859", "createdAt": "2020-06-05T20:20:51Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjgzNg=="}, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 458}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTIwMzY3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0Njo1OVrOGftE9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyNzozNVrOGf8Zzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NzU4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                },\n          \n          \n            \n                                        () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));\n          \n          \n            \n                                    },\n          \n          \n            \n                                    () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435897588", "createdAt": "2020-06-05T12:46:59Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 479}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0ODY4Nw==", "bodyText": "Fixed", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436148687", "createdAt": "2020-06-05T20:27:35Z", "author": {"login": "mbologna"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NzU4OA=="}, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 479}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 55, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}