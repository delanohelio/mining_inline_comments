{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNDAzNDcw", "number": 2367, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTozMDowNFrOEJtpFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMzoyNjoxOFrOEKGIYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjIwNDM5OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTozMDowNFrOGqWXKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjo0NzoyMVrOGquCnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTc1Mw==", "bodyText": "This give a warning in eclipse as \"m\" is a full minion object and we check a List<Long>.contains(Minion)", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447059753", "createdAt": "2020-06-29T15:30:04Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -777,90 +640,67 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n-    private Collection<CalendarComponent> getScheduleEventsAtDate(\n-            Date date, MaintenanceSchedule schedule, Optional<Calendar> calendarOpt) {\n-        if (calendarOpt.isEmpty()) {\n-            return emptySet();\n-        }\n-\n-        Period p = new Period(new DateTime(date), java.time.Duration.ofSeconds(1));\n-        ArrayList<Predicate<Component>> rules = new ArrayList<>();\n-        rules.add(new PeriodRule<>(p));\n-\n-        if (schedule.getScheduleType().equals(ScheduleType.MULTI)) {\n-            Summary summary = new Summary(schedule.getName());\n-            HasPropertyRule<Component> propertyRule = new HasPropertyRule<>(summary);\n-            rules.add(propertyRule);\n-        }\n-        @SuppressWarnings(\"unchecked\")\n-        Predicate<CalendarComponent>[] comArr = new Predicate[rules.size()];\n-        comArr = rules.toArray(comArr);\n-\n-        Filter<CalendarComponent> filter = new Filter<>(comArr, Filter.MATCH_ALL);\n-\n-        return filter.filter(calendarOpt.get().getComponents(Component.VEVENT));\n+    private Collection<CalendarComponent> getCalendarForNow(MaintenanceSchedule ms) {\n+        return ms.getCalendarOpt()\n+                .map(cal -> icalUtils.getCalendarEventsAtDate(\n+                        new Date(), icalUtils.parseCalendar(cal),\n+                        getScheduleNameForMulti(ms)))\n+                .orElse(Collections.emptyList());\n     }\n \n     /**\n-     * Assign {@link MaintenanceSchedule} to given set of {@link Server}s.\n+     * Check if system is in maintenance mode\n      *\n-     * @param user the user\n-     * @param schedule the {@link MaintenanceSchedule}\n-     * @param systemIds the set of {@link Server} IDs\n-     * @throws PermissionException if the user does not have access to given servers\n-     * @throws IllegalArgumentException if systems have pending maintenance-only actions\n-     * @return the number of involved {@link Server}s\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise falsegg\n      */\n-    public int assignScheduleToSystems(User user, MaintenanceSchedule schedule, Set<Long> systemIds) {\n-        ensureOrgAdmin(user);\n-        ensureSystemsAccessible(user, systemIds);\n-        ensureScheduleAccessible(user, schedule);\n-\n-        Set<Long> withMaintenanceActions = ServerFactory.filterSystemsWithPendingMaintOnlyActions(systemIds);\n-        if (!withMaintenanceActions.isEmpty()) {\n-            throw new IllegalArgumentException(\"Systems have pending maintenance-only actions:\" +\n-                    withMaintenanceActions);\n-        }\n-\n-        return ServerFactory.setMaintenanceScheduleToSystems(schedule, systemIds);\n+    public boolean isSystemInMaintenanceMode(MinionServer server) {\n+        return server.getMaintenanceScheduleOpt()\n+                .map(schedule -> !getCalendarForNow(schedule).isEmpty())\n+                .orElse(true);\n     }\n \n     /**\n-     * Retract {@link MaintenanceSchedule} from given set of {@link Server}s.\n+     * Given a list of minions, sorts by maintenance mode status, logs skipped minions\n      *\n-     * @param user the user\n-     * @param systemIds the set of {@link Server} IDs\n-     * @throws PermissionException if the user does not have access to given servers\n-     * @return the number of involved {@link Server}s\n-     */\n-    public int retractScheduleFromSystems(User user, Set<Long> systemIds) {\n-        ensureOrgAdmin(user);\n-        ensureSystemsAccessible(user, systemIds);\n+     * @param minions servers to check\n+     * @return List of minions in maintenance mode\n+     */\n+    public List<Long> systemIdsMaintenanceMode(List<MinionServer> minions) {\n+        Set<MaintenanceSchedule> schedulesInMaintMode = minions.stream()\n+                .flatMap(minion -> minion.getMaintenanceScheduleOpt().stream())\n+                .distinct()\n+                .filter(sched -> !getCalendarForNow(sched).isEmpty())\n+                .collect(Collectors.toSet());\n+\n+        List<Long> minionsInMaintMode = minions.stream()\n+                .filter(minion -> minion.getMaintenanceScheduleOpt()\n+                .map(sched -> schedulesInMaintMode.contains(sched)) // keep minions that have maintenance mode\n+                .orElse(true)) // or that have no maintenance schedule whatsoever\n+                .map(minion -> minion.getId())\n+                .collect(toList());\n \n-        return ServerFactory.setMaintenanceScheduleToSystems(null, systemIds);\n+         List<MinionServer> logList = minions.stream()\n+                 .filter(m -> !minionsInMaintMode.contains(m))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995"}, "originalPosition": 963}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0NzcwOA==", "bodyText": "This is an inherited code, but I'll fix that anyway. Good catch!", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447447708", "createdAt": "2020-06-30T06:47:21Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -777,90 +640,67 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n-    private Collection<CalendarComponent> getScheduleEventsAtDate(\n-            Date date, MaintenanceSchedule schedule, Optional<Calendar> calendarOpt) {\n-        if (calendarOpt.isEmpty()) {\n-            return emptySet();\n-        }\n-\n-        Period p = new Period(new DateTime(date), java.time.Duration.ofSeconds(1));\n-        ArrayList<Predicate<Component>> rules = new ArrayList<>();\n-        rules.add(new PeriodRule<>(p));\n-\n-        if (schedule.getScheduleType().equals(ScheduleType.MULTI)) {\n-            Summary summary = new Summary(schedule.getName());\n-            HasPropertyRule<Component> propertyRule = new HasPropertyRule<>(summary);\n-            rules.add(propertyRule);\n-        }\n-        @SuppressWarnings(\"unchecked\")\n-        Predicate<CalendarComponent>[] comArr = new Predicate[rules.size()];\n-        comArr = rules.toArray(comArr);\n-\n-        Filter<CalendarComponent> filter = new Filter<>(comArr, Filter.MATCH_ALL);\n-\n-        return filter.filter(calendarOpt.get().getComponents(Component.VEVENT));\n+    private Collection<CalendarComponent> getCalendarForNow(MaintenanceSchedule ms) {\n+        return ms.getCalendarOpt()\n+                .map(cal -> icalUtils.getCalendarEventsAtDate(\n+                        new Date(), icalUtils.parseCalendar(cal),\n+                        getScheduleNameForMulti(ms)))\n+                .orElse(Collections.emptyList());\n     }\n \n     /**\n-     * Assign {@link MaintenanceSchedule} to given set of {@link Server}s.\n+     * Check if system is in maintenance mode\n      *\n-     * @param user the user\n-     * @param schedule the {@link MaintenanceSchedule}\n-     * @param systemIds the set of {@link Server} IDs\n-     * @throws PermissionException if the user does not have access to given servers\n-     * @throws IllegalArgumentException if systems have pending maintenance-only actions\n-     * @return the number of involved {@link Server}s\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise falsegg\n      */\n-    public int assignScheduleToSystems(User user, MaintenanceSchedule schedule, Set<Long> systemIds) {\n-        ensureOrgAdmin(user);\n-        ensureSystemsAccessible(user, systemIds);\n-        ensureScheduleAccessible(user, schedule);\n-\n-        Set<Long> withMaintenanceActions = ServerFactory.filterSystemsWithPendingMaintOnlyActions(systemIds);\n-        if (!withMaintenanceActions.isEmpty()) {\n-            throw new IllegalArgumentException(\"Systems have pending maintenance-only actions:\" +\n-                    withMaintenanceActions);\n-        }\n-\n-        return ServerFactory.setMaintenanceScheduleToSystems(schedule, systemIds);\n+    public boolean isSystemInMaintenanceMode(MinionServer server) {\n+        return server.getMaintenanceScheduleOpt()\n+                .map(schedule -> !getCalendarForNow(schedule).isEmpty())\n+                .orElse(true);\n     }\n \n     /**\n-     * Retract {@link MaintenanceSchedule} from given set of {@link Server}s.\n+     * Given a list of minions, sorts by maintenance mode status, logs skipped minions\n      *\n-     * @param user the user\n-     * @param systemIds the set of {@link Server} IDs\n-     * @throws PermissionException if the user does not have access to given servers\n-     * @return the number of involved {@link Server}s\n-     */\n-    public int retractScheduleFromSystems(User user, Set<Long> systemIds) {\n-        ensureOrgAdmin(user);\n-        ensureSystemsAccessible(user, systemIds);\n+     * @param minions servers to check\n+     * @return List of minions in maintenance mode\n+     */\n+    public List<Long> systemIdsMaintenanceMode(List<MinionServer> minions) {\n+        Set<MaintenanceSchedule> schedulesInMaintMode = minions.stream()\n+                .flatMap(minion -> minion.getMaintenanceScheduleOpt().stream())\n+                .distinct()\n+                .filter(sched -> !getCalendarForNow(sched).isEmpty())\n+                .collect(Collectors.toSet());\n+\n+        List<Long> minionsInMaintMode = minions.stream()\n+                .filter(minion -> minion.getMaintenanceScheduleOpt()\n+                .map(sched -> schedulesInMaintMode.contains(sched)) // keep minions that have maintenance mode\n+                .orElse(true)) // or that have no maintenance schedule whatsoever\n+                .map(minion -> minion.getId())\n+                .collect(toList());\n \n-        return ServerFactory.setMaintenanceScheduleToSystems(null, systemIds);\n+         List<MinionServer> logList = minions.stream()\n+                 .filter(m -> !minionsInMaintMode.contains(m))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTc1Mw=="}, "originalCommit": {"oid": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995"}, "originalPosition": 963}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjIxMzY4OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/factory/CalendarFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTozMjoxMFrOGqWdEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjo0Nzo1MVrOGquDgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTI2Nw==", "bodyText": "As this is now in CalendarFactory why is \"Calendar\" in the method name? I think this can refactored as well.", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447061267", "createdAt": "2020-06-29T15:32:10Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/maintenance/factory/CalendarFactory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance.factory;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * {@link HibernateFactory} for {@link MaintenanceCalendar}\n+ */\n+public class CalendarFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(CalendarFactory.class);\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceCalendar}\n+     * @param calendar to remove\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        removeObject(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Calendar Labels belonging to the given User\n+     * @param user the user\n+     * @return a list of Calendar labels\n+     */\n+    public List<String> listCalendarLabelsByUser(User user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0NzkzOA==", "bodyText": "Makes sense. Changing.", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447447938", "createdAt": "2020-06-30T06:47:51Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/factory/CalendarFactory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance.factory;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * {@link HibernateFactory} for {@link MaintenanceCalendar}\n+ */\n+public class CalendarFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(CalendarFactory.class);\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceCalendar}\n+     * @param calendar to remove\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        removeObject(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Calendar Labels belonging to the given User\n+     * @param user the user\n+     * @return a list of Calendar labels\n+     */\n+    public List<String> listCalendarLabelsByUser(User user) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTI2Nw=="}, "originalCommit": {"oid": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjIxNzIxOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/factory/ScheduleFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTozMjo1N1rOGqWfNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjo0NzozNlrOGquDDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTgxNA==", "bodyText": "Same as in CalendarFactory: as we are in ScheduleFactory, we do not need the word Schedule in the method name.", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447061814", "createdAt": "2020-06-29T15:32:57Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/maintenance/factory/ScheduleFactory.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance.factory;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toSet;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * {@link HibernateFactory} for Maintenance Windows-related objects.\n+ */\n+public class ScheduleFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(ScheduleFactory.class);\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        saveObject(schedule);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceSchedule}\n+     * @param schedule to remove\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        removeObject(schedule);\n+    }\n+\n+    /**\n+     * List schedules by User and Calendar\n+     * @param user the User\n+     * @param calendar the Calendar\n+     * @return the list of Schedules\n+     */\n+    public List<MaintenanceSchedule> listSchedulesByUserAndCalendar(User user, MaintenanceCalendar calendar) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0NzgyMA==", "bodyText": "Makes sense. Changing.", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447447820", "createdAt": "2020-06-30T06:47:36Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/factory/ScheduleFactory.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance.factory;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toSet;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * {@link HibernateFactory} for Maintenance Windows-related objects.\n+ */\n+public class ScheduleFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(ScheduleFactory.class);\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        saveObject(schedule);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceSchedule}\n+     * @param schedule to remove\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        removeObject(schedule);\n+    }\n+\n+    /**\n+     * List schedules by User and Calendar\n+     * @param user the User\n+     * @param calendar the Calendar\n+     * @return the list of Schedules\n+     */\n+    public List<MaintenanceSchedule> listSchedulesByUserAndCalendar(User user, MaintenanceCalendar calendar) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTgxNA=="}, "originalCommit": {"oid": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODk2ODgyOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/maintenance/IcalUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzo1MjoyNlrOGqwMhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMTowNzo1M1rOGq3Y-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MzAxMg==", "bodyText": "I guess that one slipped through the net ;)", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447483012", "createdAt": "2020-06-30T07:52:26Z", "author": {"login": "parlt91"}, "path": "java/code/src/com/suse/manager/maintenance/IcalUtils.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static java.util.Optional.ofNullable;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import net.fortuna.ical4j.data.CalendarBuilder;\n+import net.fortuna.ical4j.data.ParserException;\n+import net.fortuna.ical4j.filter.Filter;\n+import net.fortuna.ical4j.filter.HasPropertyRule;\n+import net.fortuna.ical4j.filter.PeriodRule;\n+import net.fortuna.ical4j.model.Calendar;\n+import net.fortuna.ical4j.model.Component;\n+import net.fortuna.ical4j.model.ComponentList;\n+import net.fortuna.ical4j.model.DateTime;\n+import net.fortuna.ical4j.model.Period;\n+import net.fortuna.ical4j.model.PeriodList;\n+import net.fortuna.ical4j.model.component.CalendarComponent;\n+import net.fortuna.ical4j.model.property.Summary;\n+\n+/**\n+ * Computation related to the ICalendar objects\n+ */\n+public class IcalUtils {\n+\n+    private static Logger log = Logger.getLogger(IcalUtils.class);\n+\n+    /**\n+     * Given MaintenanceSchedule calculate upcoming maintenance windows\n+     *\n+     * The windows are returned as a list of triples consisting of:\n+     * - window start date as a human-readable string\n+     * - window end date as a human-readable string\n+     * - start date as number of milliseconds since the epoch\n+     *\n+     * The formatting is done by {@link LocalizationService}.\n+     *\n+     * The upper limit of returned maintenance windows is currently hardcoded to 10.\n+     *\n+     * @param schedule the given MaintenanceSchedule\n+     * @return the optional upcoming maintenance windows\n+     */\n+    public Optional<List<MaintenanceWindowData>> calculateUpcomingMaintenanceWindows(MaintenanceSchedule schedule) {\n+        Optional<String> multiScheduleName = getScheduleNameForMulti(schedule);\n+\n+        Stream<Pair<Instant, Instant>> periodStream = schedule.getCalendarOpt()\n+                .flatMap(c -> parseCalendar(c))\n+                .map(c -> calculateUpcomingPeriods(c, multiScheduleName, Instant.now(), 10))\n+                .orElseGet(Stream::empty);\n+\n+        List<MaintenanceWindowData> result = periodStream\n+                .map(p -> new MaintenanceWindowData(p.getLeft(), p.getRight()))\n+                .collect(toList());\n+        return of(result);\n+    }\n+\n+    /**\n+     * Convenience method: return schedule name if the schedule type is MULTI, return empty otherwise\n+     * @param schedule the schedule\n+     * @return optional of schedule name\n+     */\n+    private static Optional<String> getScheduleNameForMulti(MaintenanceSchedule schedule) {\n+        if (schedule.getScheduleType() == MaintenanceSchedule.ScheduleType.MULTI) {\n+            return of(schedule.getName());\n+        }\n+        return empty();\n+    }\n+\n+    /**\n+     * THIS IS ONLY PUBLIC FOR TESTING.\n+     *\n+     * Calculate upcoming maintenance windows starting from given date based on calendar and optional filter name\n+     * (in case we're dealing with MULTI calendar and want to filter only events we're interested in).\n+     *\n+     * The algorithm only checks maintenance windows within roughly a year and a month since the startDate.\n+     *\n+     * @param calendar the {@link Calendar}\n+     * @param eventName for MULTI calendars: only deal with events with this name, filter out the rest\n+     * @param startDate the start date\n+     * @param limit upper limit of maintenance windows to return\n+     * @return the list of upcoming maintenance windows\n+     */\n+    public Stream<Pair<Instant, Instant>> calculateUpcomingPeriods(Calendar calendar, Optional<String> eventName,\n+            Instant startDate, int limit) {\n+        ComponentList<CalendarComponent> allEvents = calendar.getComponents(Component.VEVENT);\n+\n+        Collection<CalendarComponent> filteredEvents = eventName.map(name -> {\n+            Predicate<CalendarComponent> summary = c -> c.getProperty(\"SUMMARY\").equals(name);\n+            Predicate<CalendarComponent>[] ps = new Predicate[]{summary};\n+            Filter<CalendarComponent> filter = new Filter<>(ps, Filter.MATCH_ALL);\n+            return filter.filter(allEvents);\n+        }).orElse(allEvents);\n+\n+        // we will look a year and month to the future\n+        Period period = new Period(new DateTime(startDate.toEpochMilli()), Duration.ofDays(365 + 31));\n+\n+        List<PeriodList> periodLists = filteredEvents.stream()\n+                .map(c -> c.calculateRecurrenceSet(period))\n+                .filter(l -> !l.isEmpty())\n+                .collect(toList());\n+\n+        Stream<Pair<Instant, Instant>> sortedLimited = periodLists.stream()\n+                .map(pl -> pl.stream())\n+                .reduce(Stream.empty(), Stream::concat)\n+                .sorted()\n+                .limit(limit)\n+                .map(p -> Pair.of(p.getStart().toInstant(), p.getRangeEnd().toInstant()));\n+\n+        return sortedLimited;\n+    }\n+\n+    /**\n+     * Get all schedules of given calendar at given date.\n+     * Filter results by summary, if the summary parameter is passed.\n+     *\n+     * @param date the date\n+     * @param calendar the calendar\n+     * @param summary event summary\n+     * @return the collection of calendars components matching given date (and optionally summary)\n+     */\n+    public Collection<CalendarComponent> getCalendarEventsAtDate(Date date, Optional<Calendar> calendar,\n+            Optional<String> summary) {\n+        if (calendar.isEmpty()) {\n+            return emptySet();\n+        }\n+\n+        Period p = new Period(new DateTime(date), java.time.Duration.ofSeconds(1));\n+        ArrayList<Predicate<Component>> rules = new ArrayList<>();\n+        rules.add(new PeriodRule<>(p));\n+\n+        summary.ifPresent(s -> {\n+            Summary filterSummary = new Summary(s);\n+            HasPropertyRule<Component> propertyRule = new HasPropertyRule<>(filterSummary);\n+            rules.add(propertyRule);\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85bd9b7329f088d7de572ed1023cea57bced63aa"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODIzMg==", "bodyText": "Uf, I actually didn't want to remove these annotations in this PR (it's a separate task in our task list). Removing the others was \"an accident\". I'll leave it like this for now, but we need to talk about it with @mcalmer , who said, it produced some errors in his IDE.", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447588232", "createdAt": "2020-06-30T10:43:10Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/maintenance/IcalUtils.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static java.util.Optional.ofNullable;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import net.fortuna.ical4j.data.CalendarBuilder;\n+import net.fortuna.ical4j.data.ParserException;\n+import net.fortuna.ical4j.filter.Filter;\n+import net.fortuna.ical4j.filter.HasPropertyRule;\n+import net.fortuna.ical4j.filter.PeriodRule;\n+import net.fortuna.ical4j.model.Calendar;\n+import net.fortuna.ical4j.model.Component;\n+import net.fortuna.ical4j.model.ComponentList;\n+import net.fortuna.ical4j.model.DateTime;\n+import net.fortuna.ical4j.model.Period;\n+import net.fortuna.ical4j.model.PeriodList;\n+import net.fortuna.ical4j.model.component.CalendarComponent;\n+import net.fortuna.ical4j.model.property.Summary;\n+\n+/**\n+ * Computation related to the ICalendar objects\n+ */\n+public class IcalUtils {\n+\n+    private static Logger log = Logger.getLogger(IcalUtils.class);\n+\n+    /**\n+     * Given MaintenanceSchedule calculate upcoming maintenance windows\n+     *\n+     * The windows are returned as a list of triples consisting of:\n+     * - window start date as a human-readable string\n+     * - window end date as a human-readable string\n+     * - start date as number of milliseconds since the epoch\n+     *\n+     * The formatting is done by {@link LocalizationService}.\n+     *\n+     * The upper limit of returned maintenance windows is currently hardcoded to 10.\n+     *\n+     * @param schedule the given MaintenanceSchedule\n+     * @return the optional upcoming maintenance windows\n+     */\n+    public Optional<List<MaintenanceWindowData>> calculateUpcomingMaintenanceWindows(MaintenanceSchedule schedule) {\n+        Optional<String> multiScheduleName = getScheduleNameForMulti(schedule);\n+\n+        Stream<Pair<Instant, Instant>> periodStream = schedule.getCalendarOpt()\n+                .flatMap(c -> parseCalendar(c))\n+                .map(c -> calculateUpcomingPeriods(c, multiScheduleName, Instant.now(), 10))\n+                .orElseGet(Stream::empty);\n+\n+        List<MaintenanceWindowData> result = periodStream\n+                .map(p -> new MaintenanceWindowData(p.getLeft(), p.getRight()))\n+                .collect(toList());\n+        return of(result);\n+    }\n+\n+    /**\n+     * Convenience method: return schedule name if the schedule type is MULTI, return empty otherwise\n+     * @param schedule the schedule\n+     * @return optional of schedule name\n+     */\n+    private static Optional<String> getScheduleNameForMulti(MaintenanceSchedule schedule) {\n+        if (schedule.getScheduleType() == MaintenanceSchedule.ScheduleType.MULTI) {\n+            return of(schedule.getName());\n+        }\n+        return empty();\n+    }\n+\n+    /**\n+     * THIS IS ONLY PUBLIC FOR TESTING.\n+     *\n+     * Calculate upcoming maintenance windows starting from given date based on calendar and optional filter name\n+     * (in case we're dealing with MULTI calendar and want to filter only events we're interested in).\n+     *\n+     * The algorithm only checks maintenance windows within roughly a year and a month since the startDate.\n+     *\n+     * @param calendar the {@link Calendar}\n+     * @param eventName for MULTI calendars: only deal with events with this name, filter out the rest\n+     * @param startDate the start date\n+     * @param limit upper limit of maintenance windows to return\n+     * @return the list of upcoming maintenance windows\n+     */\n+    public Stream<Pair<Instant, Instant>> calculateUpcomingPeriods(Calendar calendar, Optional<String> eventName,\n+            Instant startDate, int limit) {\n+        ComponentList<CalendarComponent> allEvents = calendar.getComponents(Component.VEVENT);\n+\n+        Collection<CalendarComponent> filteredEvents = eventName.map(name -> {\n+            Predicate<CalendarComponent> summary = c -> c.getProperty(\"SUMMARY\").equals(name);\n+            Predicate<CalendarComponent>[] ps = new Predicate[]{summary};\n+            Filter<CalendarComponent> filter = new Filter<>(ps, Filter.MATCH_ALL);\n+            return filter.filter(allEvents);\n+        }).orElse(allEvents);\n+\n+        // we will look a year and month to the future\n+        Period period = new Period(new DateTime(startDate.toEpochMilli()), Duration.ofDays(365 + 31));\n+\n+        List<PeriodList> periodLists = filteredEvents.stream()\n+                .map(c -> c.calculateRecurrenceSet(period))\n+                .filter(l -> !l.isEmpty())\n+                .collect(toList());\n+\n+        Stream<Pair<Instant, Instant>> sortedLimited = periodLists.stream()\n+                .map(pl -> pl.stream())\n+                .reduce(Stream.empty(), Stream::concat)\n+                .sorted()\n+                .limit(limit)\n+                .map(p -> Pair.of(p.getStart().toInstant(), p.getRangeEnd().toInstant()));\n+\n+        return sortedLimited;\n+    }\n+\n+    /**\n+     * Get all schedules of given calendar at given date.\n+     * Filter results by summary, if the summary parameter is passed.\n+     *\n+     * @param date the date\n+     * @param calendar the calendar\n+     * @param summary event summary\n+     * @return the collection of calendars components matching given date (and optionally summary)\n+     */\n+    public Collection<CalendarComponent> getCalendarEventsAtDate(Date date, Optional<Calendar> calendar,\n+            Optional<String> summary) {\n+        if (calendar.isEmpty()) {\n+            return emptySet();\n+        }\n+\n+        Period p = new Period(new DateTime(date), java.time.Duration.ofSeconds(1));\n+        ArrayList<Predicate<Component>> rules = new ArrayList<>();\n+        rules.add(new PeriodRule<>(p));\n+\n+        summary.ifPresent(s -> {\n+            Summary filterSummary = new Summary(s);\n+            HasPropertyRule<Component> propertyRule = new HasPropertyRule<>(filterSummary);\n+            rules.add(propertyRule);\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MzAxMg=="}, "originalCommit": {"oid": "85bd9b7329f088d7de572ed1023cea57bced63aa"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDg5MQ==", "bodyText": "Right let's have a discussion about this. This can also be addressed later", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447600891", "createdAt": "2020-06-30T11:07:53Z", "author": {"login": "parlt91"}, "path": "java/code/src/com/suse/manager/maintenance/IcalUtils.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static java.util.Optional.ofNullable;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import net.fortuna.ical4j.data.CalendarBuilder;\n+import net.fortuna.ical4j.data.ParserException;\n+import net.fortuna.ical4j.filter.Filter;\n+import net.fortuna.ical4j.filter.HasPropertyRule;\n+import net.fortuna.ical4j.filter.PeriodRule;\n+import net.fortuna.ical4j.model.Calendar;\n+import net.fortuna.ical4j.model.Component;\n+import net.fortuna.ical4j.model.ComponentList;\n+import net.fortuna.ical4j.model.DateTime;\n+import net.fortuna.ical4j.model.Period;\n+import net.fortuna.ical4j.model.PeriodList;\n+import net.fortuna.ical4j.model.component.CalendarComponent;\n+import net.fortuna.ical4j.model.property.Summary;\n+\n+/**\n+ * Computation related to the ICalendar objects\n+ */\n+public class IcalUtils {\n+\n+    private static Logger log = Logger.getLogger(IcalUtils.class);\n+\n+    /**\n+     * Given MaintenanceSchedule calculate upcoming maintenance windows\n+     *\n+     * The windows are returned as a list of triples consisting of:\n+     * - window start date as a human-readable string\n+     * - window end date as a human-readable string\n+     * - start date as number of milliseconds since the epoch\n+     *\n+     * The formatting is done by {@link LocalizationService}.\n+     *\n+     * The upper limit of returned maintenance windows is currently hardcoded to 10.\n+     *\n+     * @param schedule the given MaintenanceSchedule\n+     * @return the optional upcoming maintenance windows\n+     */\n+    public Optional<List<MaintenanceWindowData>> calculateUpcomingMaintenanceWindows(MaintenanceSchedule schedule) {\n+        Optional<String> multiScheduleName = getScheduleNameForMulti(schedule);\n+\n+        Stream<Pair<Instant, Instant>> periodStream = schedule.getCalendarOpt()\n+                .flatMap(c -> parseCalendar(c))\n+                .map(c -> calculateUpcomingPeriods(c, multiScheduleName, Instant.now(), 10))\n+                .orElseGet(Stream::empty);\n+\n+        List<MaintenanceWindowData> result = periodStream\n+                .map(p -> new MaintenanceWindowData(p.getLeft(), p.getRight()))\n+                .collect(toList());\n+        return of(result);\n+    }\n+\n+    /**\n+     * Convenience method: return schedule name if the schedule type is MULTI, return empty otherwise\n+     * @param schedule the schedule\n+     * @return optional of schedule name\n+     */\n+    private static Optional<String> getScheduleNameForMulti(MaintenanceSchedule schedule) {\n+        if (schedule.getScheduleType() == MaintenanceSchedule.ScheduleType.MULTI) {\n+            return of(schedule.getName());\n+        }\n+        return empty();\n+    }\n+\n+    /**\n+     * THIS IS ONLY PUBLIC FOR TESTING.\n+     *\n+     * Calculate upcoming maintenance windows starting from given date based on calendar and optional filter name\n+     * (in case we're dealing with MULTI calendar and want to filter only events we're interested in).\n+     *\n+     * The algorithm only checks maintenance windows within roughly a year and a month since the startDate.\n+     *\n+     * @param calendar the {@link Calendar}\n+     * @param eventName for MULTI calendars: only deal with events with this name, filter out the rest\n+     * @param startDate the start date\n+     * @param limit upper limit of maintenance windows to return\n+     * @return the list of upcoming maintenance windows\n+     */\n+    public Stream<Pair<Instant, Instant>> calculateUpcomingPeriods(Calendar calendar, Optional<String> eventName,\n+            Instant startDate, int limit) {\n+        ComponentList<CalendarComponent> allEvents = calendar.getComponents(Component.VEVENT);\n+\n+        Collection<CalendarComponent> filteredEvents = eventName.map(name -> {\n+            Predicate<CalendarComponent> summary = c -> c.getProperty(\"SUMMARY\").equals(name);\n+            Predicate<CalendarComponent>[] ps = new Predicate[]{summary};\n+            Filter<CalendarComponent> filter = new Filter<>(ps, Filter.MATCH_ALL);\n+            return filter.filter(allEvents);\n+        }).orElse(allEvents);\n+\n+        // we will look a year and month to the future\n+        Period period = new Period(new DateTime(startDate.toEpochMilli()), Duration.ofDays(365 + 31));\n+\n+        List<PeriodList> periodLists = filteredEvents.stream()\n+                .map(c -> c.calculateRecurrenceSet(period))\n+                .filter(l -> !l.isEmpty())\n+                .collect(toList());\n+\n+        Stream<Pair<Instant, Instant>> sortedLimited = periodLists.stream()\n+                .map(pl -> pl.stream())\n+                .reduce(Stream.empty(), Stream::concat)\n+                .sorted()\n+                .limit(limit)\n+                .map(p -> Pair.of(p.getStart().toInstant(), p.getRangeEnd().toInstant()));\n+\n+        return sortedLimited;\n+    }\n+\n+    /**\n+     * Get all schedules of given calendar at given date.\n+     * Filter results by summary, if the summary parameter is passed.\n+     *\n+     * @param date the date\n+     * @param calendar the calendar\n+     * @param summary event summary\n+     * @return the collection of calendars components matching given date (and optionally summary)\n+     */\n+    public Collection<CalendarComponent> getCalendarEventsAtDate(Date date, Optional<Calendar> calendar,\n+            Optional<String> summary) {\n+        if (calendar.isEmpty()) {\n+            return emptySet();\n+        }\n+\n+        Period p = new Period(new DateTime(date), java.time.Duration.ofSeconds(1));\n+        ArrayList<Predicate<Component>> rules = new ArrayList<>();\n+        rules.add(new PeriodRule<>(p));\n+\n+        summary.ifPresent(s -> {\n+            Summary filterSummary = new Summary(s);\n+            HasPropertyRule<Component> propertyRule = new HasPropertyRule<>(filterSummary);\n+            rules.add(propertyRule);\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MzAxMg=="}, "originalCommit": {"oid": "85bd9b7329f088d7de572ed1023cea57bced63aa"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDIwNzcwOnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/model/maintenance/CalendarFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMzoyNDoyN1rOGq8I6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo0NzoxMlrOGrABYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3ODY5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public List<String> listCalendarLabelsByUser(User user) {\n          \n          \n            \n                public List<String> listLabelsByUser(User user) {\n          \n      \n    \n    \n  \n\nOr was Calendar left here for a reason?", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447678697", "createdAt": "2020-06-30T13:24:27Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/model/maintenance/CalendarFactory.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * {@link HibernateFactory} for {@link MaintenanceCalendar}\n+ */\n+public class CalendarFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(CalendarFactory.class);\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceCalendar}\n+     * @param calendar to remove\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        removeObject(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Calendar Labels belonging to the given User\n+     * @param user the user\n+     * @return a list of Calendar labels\n+     */\n+    public List<String> listCalendarLabelsByUser(User user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "195e22cc1952543800bfdcb905317791b270920e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0MjMwNA==", "bodyText": "Yes, I left this one on purpose. I was thinking, that listLabelsByUser was too puristic :) Same for the Schedule case...", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447742304", "createdAt": "2020-06-30T14:47:12Z", "author": {"login": "hustodemon"}, "path": "java/code/src/com/suse/manager/model/maintenance/CalendarFactory.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * {@link HibernateFactory} for {@link MaintenanceCalendar}\n+ */\n+public class CalendarFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(CalendarFactory.class);\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceCalendar}\n+     * @param calendar to remove\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        removeObject(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Calendar Labels belonging to the given User\n+     * @param user the user\n+     * @return a list of Calendar labels\n+     */\n+    public List<String> listCalendarLabelsByUser(User user) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3ODY5Nw=="}, "originalCommit": {"oid": "195e22cc1952543800bfdcb905317791b270920e"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDIxNjY3OnYy", "diffSide": "RIGHT", "path": "java/code/src/com/suse/manager/model/maintenance/ScheduleFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMzoyNjoxOFrOGq8Obg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMzoyNjoxOFrOGq8Obg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY4MDExMA==", "bodyText": "Is Schedule still here for a reason?", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447680110", "createdAt": "2020-06-30T13:26:18Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/suse/manager/model/maintenance/ScheduleFactory.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.model.maintenance;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toSet;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * {@link HibernateFactory} for Maintenance Windows-related objects.\n+ */\n+public class ScheduleFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(ScheduleFactory.class);\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        saveObject(schedule);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceSchedule}\n+     * @param schedule to remove\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        removeObject(schedule);\n+    }\n+\n+    /**\n+     * List schedules by User and Calendar\n+     * @param user the User\n+     * @param calendar the Calendar\n+     * @return the list of Schedules\n+     */\n+    public List<MaintenanceSchedule> listByUserAndCalendar(User user, MaintenanceCalendar calendar) {\n+        return getSession()\n+                .createQuery(\"FROM MaintenanceSchedule \" +\n+                        \"WHERE org = :org and calendar = :calendar \" +\n+                        \"ORDER BY name ASC\")\n+                .setParameter(\"org\", user.getOrg())\n+                .setParameter(\"calendar\", calendar).getResultList();\n+    }\n+\n+    /**\n+     * List Maintenance Schedule Names belong to the given User\n+     * @param user the user\n+     * @return a list of Schedule names\n+     */\n+    public List<String> listScheduleNamesByUser(User user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "195e22cc1952543800bfdcb905317791b270920e"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4220, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}