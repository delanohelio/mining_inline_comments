{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0ODkyNDY1", "number": 2070, "title": "Cluster management (MVP)", "bodyText": "What does this PR change?\nImplements the RFC for clustering awareness, targeting a CaaSP cluster. The user will be able to:\n\nadd/delete an existing cluster\nlist the clusters\nlist the nodes of the cluster with additional information\njoin/removing nodes to the cluster\nissue a cluster upgrade\n\nCI:\n\nCucumber test suite: http://suma-testorion-ctl.mgr.suse.de/\nServer: https://suma-testorion-srv.mgr.suse.de/\n\nGUI diff\nAdded a whole subsection for clustering. An example:\nBefore:\nN/A\nAfter:\n\n\n DONE\n\nDocumentation\n\n\ndoc-susemanager\n\n\n DONE\n\n\nTest coverage\n\n\nUnit tests were added\n\n\n DONE\n\n\nLinks\nTracks:\n\n\nSUSE/spacewalk#11185\n\n\nSUSE/spacewalk#11061\n\n\n DONE\n\n\nChangelogs\nIf you don't need a changelog check, please mark this checkbox:\n\n No changelog needed\n\nIf you uncheck the checkbox after the PR is created, you will need to re-run changelog_test (see below)\nRe-run a test\nIf you need to re-run a test, please mark the related checkbox, it will be unchecked automatically once it has re-run:\n\n Re-run test \"changelog_test\"\n Re-run test \"backend_unittests_pgsql\"\n Re-run test \"java_lint_checkstyle\"\n Re-run test \"java_pgsql_tests\"\n Re-run test \"ruby_rubocop\"\n Re-run test \"schema_migration_test_oracle\"\n Re-run test \"schema_migration_test_pgsql\"\n Re-run test \"susemanager_unittests\" (Test skipped, there are no changes to test)\n Re-run test \"javascript_lint\"\n Re-run test \"spacecmd_unittests\" (Test skipped, there are no changes to test)", "createdAt": "2020-03-27T17:51:49Z", "url": "https://github.com/uyuni-project/uyuni/pull/2070", "merged": true, "mergeCommit": {"oid": "4d4ebe78f1a12b575c09545dc784827d66355e22"}, "closed": true, "closedAt": "2020-06-08T13:27:15Z", "author": {"login": "mateiw"}, "timelineItems": {"totalCount": 86, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcSE4oqAFqTM4MzMxMTA5NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpQWcDAH2gAyMzk0ODkyNDY1OjZkYWY5MTc2YWJjYWFmYTA5NzM2OGMyZjYzOTI1NGUxYjJhOGJkOTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzExMDk1", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-383311095", "createdAt": "2020-03-28T12:58:12Z", "commit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMjo1ODoxMlrOF9JSoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMjo1ODoxMlrOF9JSoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY1OTY4MQ==", "bodyText": "Potential dangerous. We should not drop if not needed.\nThe \"create if not exists\" should be enough.\nIf they exist they might also contain data we do not want to loose.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r399659681", "createdAt": "2020-03-28T12:58:12Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzExMjM0", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-383311234", "createdAt": "2020-03-28T13:00:22Z", "commit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMzowMDoyM1rOF9JTgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMzowMDoyM1rOF9JTgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY1OTkwNA==", "bodyText": "No NOT NULL ? Is this on purpose?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r399659904", "createdAt": "2020-03-28T13:00:23Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;\n+\n+\n+CREATE TABLE IF NOT EXISTS suseClusterTypes (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clustertypes_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_clustertypes_id_seq;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_clustertypes_idx\n+    ON suseClusterTypes (name);\n+\n+CREATE TABLE IF NOT EXISTS suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL,\n+    type_id     NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_type_fk\n+                    REFERENCES suseClusterTypes (id),\n+    management_node_id    NUMERIC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzExMzc3", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-383311377", "createdAt": "2020-03-28T13:02:20Z", "commit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMzowMjoyMFrOF9JUIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxMzowMjoyMFrOF9JUIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY2MDA2NQ==", "bodyText": "What about Organizations? I think clusters cannot be global. Or is it on purpose?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r399660065", "createdAt": "2020-03-28T13:02:20Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/upgrade/susemanager-schema-4.1.5-to-susemanager-schema-4.1.6/002-suseClusters.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+DROP TABLE IF EXISTS suseClusters;\n+DROP SEQUENCE IF EXISTS suse_cluster_id_seq;\n+\n+DROP TABLE IF EXISTS suseClusterTypes;\n+DROP SEQUENCE IF EXISTS suse_clustertypes_id_seq;\n+\n+\n+CREATE TABLE IF NOT EXISTS suseClusterTypes (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clustertypes_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL\n+);\n+\n+CREATE SEQUENCE IF NOT EXISTS suse_clustertypes_id_seq;\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS suse_clustertypes_idx\n+    ON suseClusterTypes (name);\n+\n+CREATE TABLE IF NOT EXISTS suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    name        VARCHAR(256) NOT NULL,\n+    type_id     NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_type_fk\n+                    REFERENCES suseClusterTypes (id),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee20dffc50c808fa411c2c75dee2fe8775edde"}, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0b39312b31644a8e828af6893bbb23d9b6da04f2", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/0b39312b31644a8e828af6893bbb23d9b6da04f2", "committedDate": "2020-04-13T16:57:21Z", "message": "cluster UI: select mgmt node and finalize import page"}, "afterCommit": {"oid": "c574053b34c428bec4aabb0f252d078af0441b84", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/c574053b34c428bec4aabb0f252d078af0441b84", "committedDate": "2020-04-16T22:31:47Z", "message": "cluster UI: select mgmt node and finalize import page"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c574053b34c428bec4aabb0f252d078af0441b84", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/c574053b34c428bec4aabb0f252d078af0441b84", "committedDate": "2020-04-16T22:31:47Z", "message": "cluster UI: select mgmt node and finalize import page"}, "afterCommit": {"oid": "bb99e00da43170fd80dc9cde4bb16a13d97d5973", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/bb99e00da43170fd80dc9cde4bb16a13d97d5973", "committedDate": "2020-04-16T23:01:38Z", "message": "after rebase fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c716f91062d22375df8166201c11a3cf8cce90e8", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/c716f91062d22375df8166201c11a3cf8cce90e8", "committedDate": "2020-04-24T10:59:56Z", "message": "cluster UI improvements\n\n- renamed import to add\n- changed last step of add flow to add without scheduling action\n- initial boilerplate code for saving cluster formulas"}, "afterCommit": {"oid": "2551d373d6c57c1850bebb37faa89ed372914c76", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2551d373d6c57c1850bebb37faa89ed372914c76", "committedDate": "2020-04-29T14:12:05Z", "message": "cluster UI improvements\n\n- renamed import to add\n- changed last step of add flow to add without scheduling action\n- initial boilerplate code for saving cluster formulas"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2551d373d6c57c1850bebb37faa89ed372914c76", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/2551d373d6c57c1850bebb37faa89ed372914c76", "committedDate": "2020-04-29T14:12:05Z", "message": "cluster UI improvements\n\n- renamed import to add\n- changed last step of add flow to add without scheduling action\n- initial boilerplate code for saving cluster formulas"}, "afterCommit": {"oid": "4db1c989ea9cc5f0ada3f2b81732a0eb9025ce9b", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4db1c989ea9cc5f0ada3f2b81732a0eb9025ce9b", "committedDate": "2020-05-05T19:55:30Z", "message": "cluster UI improvements\n\n- renamed import to add\n- changed last step of add flow to add without scheduling action\n- initial boilerplate code for saving cluster formulas"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c904bc831666591390cfe20b7003880214590a1", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7c904bc831666591390cfe20b7003880214590a1", "committedDate": "2020-05-10T22:46:01Z", "message": "show cluster provider name in overview page"}, "afterCommit": {"oid": "08662a9241cf3932b942cfdbc9f9003b58d422dd", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/08662a9241cf3932b942cfdbc9f9003b58d422dd", "committedDate": "2020-05-11T10:40:23Z", "message": "show cluster provider name in overview page"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f00e9a9b1b7da21f549eec7865c377c5ecca3533", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f00e9a9b1b7da21f549eec7865c377c5ecca3533", "committedDate": "2020-05-14T15:26:26Z", "message": "fixup! Fix: match parameters with the example"}, "afterCommit": {"oid": "de73030bafc18fee3f6c706c06b05535534e3c7a", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/de73030bafc18fee3f6c706c06b05535534e3c7a", "committedDate": "2020-05-14T15:34:57Z", "message": "Fix: match parameters with the example"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c875c0973d5f231f17eea2f938a6eab7342c1dcc", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/c875c0973d5f231f17eea2f938a6eab7342c1dcc", "committedDate": "2020-05-20T12:02:33Z", "message": "action details format, unit tests for remove node from cluster"}, "afterCommit": {"oid": "7b3fe7a032e4914cf65464d93625b14762937fcd", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7b3fe7a032e4914cf65464d93625b14762937fcd", "committedDate": "2020-05-22T11:34:36Z", "message": "Use toast messages container component in cluster UI"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89e302cac9c6fdd3516aadc9a6c1d15373483c24", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/89e302cac9c6fdd3516aadc9a6c1d15373483c24", "committedDate": "2020-05-23T23:30:37Z", "message": "Add commons-jexl BuildRequires to spacewalk-java"}, "afterCommit": {"oid": "ba4ca73b0e675ab1f486463244aa73f53c389967", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ba4ca73b0e675ab1f486463244aa73f53c389967", "committedDate": "2020-05-24T12:49:38Z", "message": "make commons-jexl a build dep"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e377891b4657dd49ac9f37d0dbb94ea4db65ccbc", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e377891b4657dd49ac9f37d0dbb94ea4db65ccbc", "committedDate": "2020-05-26T14:20:39Z", "message": "Checkstyle fixes and java code cleanup"}, "afterCommit": {"oid": "fa455aaf3d257a380ba9f5e96a740afd61d6884a", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/fa455aaf3d257a380ba9f5e96a740afd61d6884a", "committedDate": "2020-05-26T14:28:19Z", "message": "Checkstyle fixes and java code cleanup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0cd5dbb3c8547e4bff0a0973623739cb3b2c3c7", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e0cd5dbb3c8547e4bff0a0973623739cb3b2c3c7", "committedDate": "2020-05-26T17:53:21Z", "message": "Feat: add/remove nodes with the API"}, "afterCommit": {"oid": "f9fb103dbc9572f9e0cabfd1287bfbbf383dacc8", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f9fb103dbc9572f9e0cabfd1287bfbbf383dacc8", "committedDate": "2020-05-27T08:31:09Z", "message": "Feat: add/remove nodes with the API"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d5862a17eba2437bef175041aca83ea6b2d4b66", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3d5862a17eba2437bef175041aca83ea6b2d4b66", "committedDate": "2020-05-28T10:43:54Z", "message": "fixup"}, "afterCommit": {"oid": "cfc0b7a079bf081bc5428733e8e8c9bb8d9440c6", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/cfc0b7a079bf081bc5428733e8e8c9bb8d9440c6", "committedDate": "2020-05-28T13:01:27Z", "message": "Chore: announce changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cfc0b7a079bf081bc5428733e8e8c9bb8d9440c6", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/cfc0b7a079bf081bc5428733e8e8c9bb8d9440c6", "committedDate": "2020-05-28T13:01:27Z", "message": "Chore: announce changes"}, "afterCommit": {"oid": "4e5610b65d50ab7a08c47a4a559e8893f41a7722", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4e5610b65d50ab7a08c47a4a559e8893f41a7722", "committedDate": "2020-05-28T13:19:42Z", "message": "Chore: announce changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e5610b65d50ab7a08c47a4a559e8893f41a7722", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4e5610b65d50ab7a08c47a4a559e8893f41a7722", "committedDate": "2020-05-28T13:19:42Z", "message": "Chore: announce changes"}, "afterCommit": {"oid": "e2f035917738aa5d6b7d8c392150bd369f8914d1", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e2f035917738aa5d6b7d8c392150bd369f8914d1", "committedDate": "2020-05-28T13:53:02Z", "message": "Chore: announce changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2f035917738aa5d6b7d8c392150bd369f8914d1", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e2f035917738aa5d6b7d8c392150bd369f8914d1", "committedDate": "2020-05-28T13:53:02Z", "message": "Chore: announce changes"}, "afterCommit": {"oid": "3a2026737073af00b3f3715298f9418626a7df89", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3a2026737073af00b3f3715298f9418626a7df89", "committedDate": "2020-05-28T14:37:07Z", "message": "Chore: announce changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a2026737073af00b3f3715298f9418626a7df89", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3a2026737073af00b3f3715298f9418626a7df89", "committedDate": "2020-05-28T14:37:07Z", "message": "Chore: announce changes"}, "afterCommit": {"oid": "10d9a3a7b7f1a41c578fbd98fd0498e5f14ba7d1", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/10d9a3a7b7f1a41c578fbd98fd0498e5f14ba7d1", "committedDate": "2020-05-28T20:04:47Z", "message": "Fix: avoid route clashing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10d9a3a7b7f1a41c578fbd98fd0498e5f14ba7d1", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/10d9a3a7b7f1a41c578fbd98fd0498e5f14ba7d1", "committedDate": "2020-05-28T20:04:47Z", "message": "Fix: avoid route clashing"}, "afterCommit": {"oid": "137451134b0f6cbd4a6db28b69fda1f8fffcefb0", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/137451134b0f6cbd4a6db28b69fda1f8fffcefb0", "committedDate": "2020-05-28T20:39:16Z", "message": "Fix: avoid route clashing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "606902b2a003867148d476c91229a44fba261d4d", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/606902b2a003867148d476c91229a44fba261d4d", "committedDate": "2020-05-29T09:39:08Z", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a."}, "afterCommit": {"oid": "01c05ac3bc5de21e6381fa00aaa0656d65a11ec6", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/01c05ac3bc5de21e6381fa00aaa0656d65a11ec6", "committedDate": "2020-05-29T10:51:13Z", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65c3396a54c432b5fa19ceeea0e4ab1d696a1501", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/65c3396a54c432b5fa19ceeea0e4ab1d696a1501", "committedDate": "2020-05-29T12:11:43Z", "message": "fixup! Chore: require jexl in spacewalk-java"}, "afterCommit": {"oid": "019e1e09be3230456b7ddb29d3e75aad08cb3fb0", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/019e1e09be3230456b7ddb29d3e75aad08cb3fb0", "committedDate": "2020-05-29T13:46:01Z", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "019e1e09be3230456b7ddb29d3e75aad08cb3fb0", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/019e1e09be3230456b7ddb29d3e75aad08cb3fb0", "committedDate": "2020-05-29T13:46:01Z", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a."}, "afterCommit": {"oid": "e0ae30e884c22ca8cb73a774d3b17a50ed2edf98", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e0ae30e884c22ca8cb73a774d3b17a50ed2edf98", "committedDate": "2020-05-29T14:15:50Z", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMyOTQ1", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-421032945", "createdAt": "2020-05-29T14:56:51Z", "commit": {"oid": "a1a07c17d330d48e38ed23a544660d8d72660e96"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1Njo1MVrOGcgXgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1Njo1MVrOGcgXgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MzYxNw==", "bodyText": "What is that jqXHR thing? I have no clue about that: I trust that you know more those things than I do", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r432543617", "createdAt": "2020-05-29T14:56:51Z", "author": {"login": "cbosdo"}, "path": "web/html/src/manager/virtualization/nets/virtualization-nets-list-refresh-api.js", "diffHunk": "@@ -51,9 +52,9 @@ class VirtualizationNetsListRefreshApi extends React.Component<Props, State> {\n           errors: [],\n         });\n       })\n-      .catch((response) => {\n+      .catch(jqXHR => {\n         this.setState({\n-          errors: [Network.errorMessageByStatus(response.status)],\n+          errors: [Network.responseErrorMessage(jqXHR)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1a07c17d330d48e38ed23a544660d8d72660e96"}, "originalPosition": 23}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9947536292ac0cf456b2d55fa9d7a3beb2ee8dba", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/9947536292ac0cf456b2d55fa9d7a3beb2ee8dba", "committedDate": "2020-05-29T15:02:57Z", "message": "fixup! Feat: Model: Cluster (Java + database)"}, "afterCommit": {"oid": "9217e3b9fc719f7cd00d7427537089d49bb4e3fa", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/9217e3b9fc719f7cd00d7427537089d49bb4e3fa", "committedDate": "2020-05-29T15:44:33Z", "message": "jslint fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNzMwNjky", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-421730692", "createdAt": "2020-06-01T10:06:17Z", "commit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDowNjoxOFrOGdFSQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToyMzoyN1rOGdHLaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODQ4MQ==", "bodyText": "I understand that this situation should not happen but, in case it does, we cannot raise and exception here and break the execution of suma_minion, because that breaks pillar rendering for any minion, which is critical.\nI would suggest to only logging the error here but do not break the execution.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433148481", "createdAt": "2020-06-01T10:06:18Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "diffHunk": "@@ -194,8 +199,22 @@ def load_formula_pillar(minion_id, group_id, formula_name):\n         log.error('Error loading data for formula \"{formula}\": {message}'.format(formula=formula_name, message=str(error)))\n         return {}\n \n+    # if group_data starts with mgr_clusters then merge and adjust without the mgr_clusters:<cluster>:settings prefix\n+    cluster_name = None\n+    cluster_pillar_key = None\n+    if formula_metadata and formula_metadata.get(\"type\", \"\") == \"cluster-formula\":\n+        if \"cluster_pillar_key\" not in formula_metadata:\n+            raise Exception(\"No 'cluster_pillar_key' in metadata of formula {}\".format(formula_name))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MjYwMw==", "bodyText": "This would overwrite any previous existing cluster pillar data under a different cluster_name, because this recreates \"mgr_clusters\" entry everytime.\nMy suggestion would be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    merged_data = {\"mgr_clusters\": {cluster_name: {cluster_pillar_key: merged_data}}}\n          \n          \n            \n                    merged_data.setdefault(\"mgr_clusters\", {}).update({cluster_name: {cluster_pillar_key: merged_data}})", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433152603", "createdAt": "2020-06-01T10:16:11Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "diffHunk": "@@ -194,8 +199,22 @@ def load_formula_pillar(minion_id, group_id, formula_name):\n         log.error('Error loading data for formula \"{formula}\": {message}'.format(formula=formula_name, message=str(error)))\n         return {}\n \n+    # if group_data starts with mgr_clusters then merge and adjust without the mgr_clusters:<cluster>:settings prefix\n+    cluster_name = None\n+    cluster_pillar_key = None\n+    if formula_metadata and formula_metadata.get(\"type\", \"\") == \"cluster-formula\":\n+        if \"cluster_pillar_key\" not in formula_metadata:\n+            raise Exception(\"No 'cluster_pillar_key' in metadata of formula {}\".format(formula_name))\n+        cluster_pillar_key = formula_metadata[\"cluster_pillar_key\"]\n+        group_data, cluster_name = _pillar_value_by_path(group_data, \"mgr_clusters:*:{}\".format(cluster_pillar_key))\n+\n     merged_data = merge_formula_data(layout, group_data, system_data)\n     merged_data = adjust_empty_values(layout, merged_data)\n+\n+    # put back data under cluster pillar namespace\n+    if cluster_name:\n+        merged_data = {\"mgr_clusters\": {cluster_name: {cluster_pillar_key: merged_data}}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDI4OQ==", "bodyText": "I would refactor this in order to have a more clean and simpler logic:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                metadata_filename = os.path.join( MANAGER_FORMULAS_METADATA_STANDALONE_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                if not os.path.isfile(metadata_filename):\n          \n          \n            \n                    metadata_filename = os.path.join(MANAGER_FORMULAS_METADATA_MANAGER_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                    if not os.path.isfile(metadata_filename):\n          \n          \n            \n                        metadata_filename = os.path.join(CUSTOM_FORMULAS_METADATA_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                        if not os.path.isfile(metadata_filename):\n          \n          \n            \n                            log.error('Error loading metadata for formula \"{formula}\": No metadata.yml found'.format(formula=formula_name))\n          \n          \n            \n                            return {}\n          \n          \n            \n                metadata_filename = None\n          \n          \n            \n                metadata_paths_ordered = [\n          \n          \n            \n                    os.path.join(MANAGER_FORMULAS_METADATA_STANDALONE_PATH, formula_name, \"metadata.yml\"),\n          \n          \n            \n                    os.path.join(MANAGER_FORMULAS_METADATA_MANAGER_PATH, formula_name, \"metadata.yml\"),\n          \n          \n            \n                    os.path.join(CUSTOM_FORMULAS_METADATA_PATH, formula_name, \"metadata.yml\")\n          \n          \n            \n                ]\n          \n          \n            \n                \n          \n          \n            \n                # Take the first metadata file that exist\n          \n          \n            \n                for mpath in metadata_paths:\n          \n          \n            \n                    if os.path.isfile(metadata_filename):\n          \n          \n            \n                        metadata_filename = mpath\n          \n          \n            \n                        break\n          \n          \n            \n                        \n          \n          \n            \n                if not metadata_filename:             \n          \n          \n            \n                    log.error('Error loading metadata for formula \"{formula}\": No metadata.yml found'.format(formula=formula_name))\n          \n          \n            \n                    return {}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433160289", "createdAt": "2020-06-01T10:35:10Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/modules/pillar/suma_minion.py", "diffHunk": "@@ -303,3 +322,36 @@ def image_pillars(minion_id):\n \n     return ret\n \n+def load_formula_metadata(formula_name):\n+    if formula_name in formulas_metadata_cache:\n+        return formulas_metadata_cache[formula_name]\n+    metadata_filename = os.path.join( MANAGER_FORMULAS_METADATA_STANDALONE_PATH, formula_name, \"metadata.yml\")\n+    if not os.path.isfile(metadata_filename):\n+        metadata_filename = os.path.join(MANAGER_FORMULAS_METADATA_MANAGER_PATH, formula_name, \"metadata.yml\")\n+        if not os.path.isfile(metadata_filename):\n+            metadata_filename = os.path.join(CUSTOM_FORMULAS_METADATA_PATH, formula_name, \"metadata.yml\")\n+            if not os.path.isfile(metadata_filename):\n+                log.error('Error loading metadata for formula \"{formula}\": No metadata.yml found'.format(formula=formula_name))\n+                return {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDk3OA==", "bodyText": "Hmm, I wouldn't go like this. We already have the pillars calculated and stored in pillar (which is a dictionary) variable. If we use salt['pillar.get'], that means calling the \"LazyLoader\" to run the \"pillar\" execution module for getting them again. Is this really necessary? (that would hit performance a little bit)\nYou could do instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            {%- if salt['pillar.get']('params:ssh_auth_sock', False) %}\n          \n          \n            \n            {%- if pillar['params'].get('ssh_auth_sock', False) %}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433164978", "createdAt": "2020-06-01T10:46:54Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/salt/clusters/addnode.sls", "diffHunk": "@@ -1,24 +1,37 @@\n-{%- if pillar.get('ssh_auth_sock', False) %}\n+{%- if salt['pillar.get']('params:ssh_auth_sock', False) %}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NTE0Mg==", "bodyText": "Same as the previous comment", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433165142", "createdAt": "2020-06-01T10:47:20Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/salt/clusters/addnode.sls", "diffHunk": "@@ -1,24 +1,37 @@\n-{%- if pillar.get('ssh_auth_sock', False) %}\n+{%- if salt['pillar.get']('params:ssh_auth_sock', False) %}\n mgr_ssh_agent_socket_clusters_addnode:\n   environ.setenv:\n     - name: SSH_AUTH_SOCK\n-    - value: {{ pillar['ssh_auth_sock'] }}\n+    - value: {{ salt['pillar.get']('params:ssh_auth_sock') }}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzIxMw==", "bodyText": "I would definitely consider implementing this method instead cmd.run.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433173213", "createdAt": "2020-06-01T11:07:10Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDA1Ng==", "bodyText": "Using cmd.run_all is highly risky here. I would consider using the above commented function. I'll elaborate why in one of the following comments", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433174056", "createdAt": "2020-06-01T11:09:13Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDQ0Nw==", "bodyText": "Same as above.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433174447", "createdAt": "2020-06-01T11:10:08Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+\n+    ssh_agent_lines = result['stdout'].splitlines()\n+\n+    variables = dict()\n+    for line in ssh_agent_lines:\n+        if line.startswith('SSH'):\n+            var, *rest = line.split(';')\n+            key, val = var.strip().split(\"=\", 1)\n+            variables[key] = val\n+\n+    __salt__['environ.setenv'](variables)\n+    return variables\n+\n+\n+def list_keys(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format('-l'), output_loglevel='quiet')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3OTMzMA==", "bodyText": "Ok, let me elaborate the explanation here. There are few reasons why this should be avoided:\n\nUsing cmd.run or cmd.run_all like this means, it also executes a shell to run the process (not really needed)\nRunning a shell means we need to take care of possible code injection.\nIn this particular case here, we don't perform any safety check for the ssh_key_file argument of the function (provided by the user), and we use that to feed the cmd.run_all argument. This currently allow extra command injection:\n\n# salt-call --local cmd.run_all \"date; echo my injected code\"\nlocal:\n    ----------\n    pid:\n        15767\n    retcode:\n        0\n    stderr:\n    stdout:\n        Mon Jun  1 12:16:30 WEST 2020\n        my injected code\n\nTherefore doing something like:\n# salt-call --local ssh_agent.add_key \"my_test_file; some malicious rm code\"\n\nwould execute the malicious code.\nTo avoid this we could add python_shell=False to the cmd.run command or maybe using the unimplemented __call_ssh_tool method", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433179330", "createdAt": "2020-06-01T11:23:02Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+\n+    ssh_agent_lines = result['stdout'].splitlines()\n+\n+    variables = dict()\n+    for line in ssh_agent_lines:\n+        if line.startswith('SSH'):\n+            var, *rest = line.split(';')\n+            key, val = var.strip().split(\"=\", 1)\n+            variables[key] = val\n+\n+    __salt__['environ.setenv'](variables)\n+    return variables\n+\n+\n+def list_keys(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format('-l'), output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+    return result['stdout']\n+\n+\n+def add_key(ssh_key_file, **kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format(ssh_key_file), output_loglevel='quiet')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3OTQ5Nw==", "bodyText": "Same considerations as above", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r433179497", "createdAt": "2020-06-01T11:23:27Z", "author": {"login": "meaksh"}, "path": "susemanager-utils/susemanager-sls/src/modules/ssh_agent.py", "diffHunk": "@@ -0,0 +1,84 @@\n+import logging\n+from salt.exceptions import CommandExecutionError\n+try:\n+    from salt.utils.path import which_bin as _which_bin\n+except ImportError:\n+    from salt.utils import which_bin as _which_bin\n+\n+log = logging.getLogger(__name__)\n+\n+__virtualname__ = 'ssh_agent'\n+\n+__start_agent = '/usr/bin/ssh-agent'\n+__ssh_add = '/usr/bin/ssh-add {}'\n+\n+def __virtual__():\n+    '''\n+    This module is always enabled while 'ssh-agent' is available.\n+    '''\n+    return __virtualname__ if _which_bin(['ssh-agent']) else (False, 'ssh-agent is not available')\n+\n+# def __call_ssh_tool(ssh_tool, cmd_args, **kwargs):\n+#     log.debug(\"Calling ssh-agent: 'skuba {}' - Timeout: {}\".format(cmd_args, timeout))\n+#     try:\n+#         ssh_tool_proc = salt.utils.timed_subprocess.TimedProc(\n+#             [ssh_tool] + cmd_args.split(),\n+#             stdout=subprocess.PIPE,\n+#             stderr=subprocess.PIPE,\n+#             timeout=timeout\n+#         )\n+#         ssh_tool_proc.run()\n+#     except Exception as exc:\n+#         error_msg = \"Unexpected error while calling {}: {}\".format(ssh_tool, exc)\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)    \n+\n+#     if ssh_tool_proc.process.returncode != 0 or ssh_tool_proc.stderr:\n+#         error_msg = \"Unexpected error {} when calling {}: {}\".format(\n+#                 ssh_tool_proc.returncode,\n+#                 ssh_tool,\n+#                 salt.utils.stringutils.to_str(ssh_tool_proc.stderr))\n+#         log.error(error_msg)\n+#         raise CommandExecutionError(error_msg)\n+\n+\n+def start_agent(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__start_agent, output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+\n+    ssh_agent_lines = result['stdout'].splitlines()\n+\n+    variables = dict()\n+    for line in ssh_agent_lines:\n+        if line.startswith('SSH'):\n+            var, *rest = line.split(';')\n+            key, val = var.strip().split(\"=\", 1)\n+            variables[key] = val\n+\n+    __salt__['environ.setenv'](variables)\n+    return variables\n+\n+\n+def list_keys(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format('-l'), output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+    return result['stdout']\n+\n+\n+def add_key(ssh_key_file, **kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all'](__ssh_add.format(ssh_key_file), output_loglevel='quiet')\n+    if result['retcode'] != 0:\n+        raise CommandExecutionError(result['stderr'])\n+    return True\n+\n+def kill(**kwargs):\n+    # TODO add socket param\n+    result = __salt__['cmd.run_all']('{} -k'.format(__start_agent), output_loglevel='quiet')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474678d3885da4cf3e4d3955242a37cec7610105"}, "originalPosition": 81}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f166d58909f48df06fd48cf949feaec69a98fd1", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1f166d58909f48df06fd48cf949feaec69a98fd1", "committedDate": "2020-06-01T14:00:39Z", "message": "upgrade cluster fixes"}, "afterCommit": {"oid": "49df912ae34148fe3bbf011ecb3fab0d2f195a09", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/49df912ae34148fe3bbf011ecb3fab0d2f195a09", "committedDate": "2020-06-01T15:09:12Z", "message": "upgrade cluster fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82fbff9f04b68ccda5f729b4c8021bc68706c6ba", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/82fbff9f04b68ccda5f729b4c8021bc68706c6ba", "committedDate": "2020-06-02T14:36:34Z", "message": "initial unit test for ClusterFactory"}, "afterCommit": {"oid": "fa654dc663f88179d84fb24e9879c79deb6c39e2", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/fa654dc663f88179d84fb24e9879c79deb6c39e2", "committedDate": "2020-06-02T16:05:02Z", "message": "package build files for caasp formulas"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTQ4MTQ1", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-423148145", "createdAt": "2020-06-03T00:46:49Z", "commit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo0Njo0OVrOGeIhHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1MjoyOFrOGeImfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDAxNQ==", "bodyText": "If we don't wan't this at the formulas repository: Is there any good reason for this to be 0.1? We better have all packages with the same X.Y.Z versioning. In this case 4.1.0.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250015", "createdAt": "2020-06-03T00:46:49Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-node\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-node-formula\n+Version:        0.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDEwNA==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250104", "createdAt": "2020-06-03T00:47:14Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-settings-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-settings\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-settings-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDQwMQ==", "bodyText": "You already have fdir. Why this is needed?\nAlso... don't we have other package owning this path? I am pretty sure there is, so this could provoke a conflict and we should instead depend on the other package. Check a head server.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250401", "createdAt": "2020-06-03T00:48:18Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-node\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-node-formula\n+Version:        0.1\n+Release:        0\n+Summary:        Salt formula for configuring a CaaSP management node\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt formula for configuring a CaaS Platform management node.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{fname}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{fname}\n+cp -R caasp-management-node/* %{buildroot}%{fdir}/states/%{fname}\n+cp -R metadata/* %{buildroot}%{fdir}/metadata/%{fname}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/salt-formulas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDQ0NQ==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250445", "createdAt": "2020-06-03T00:48:31Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-settings-formula\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+\n+%define fname caasp-management-settings\n+%define fdir  %{_datadir}/salt-formulas\n+Name:           caasp-management-settings-formula\n+Version:        0.1\n+Release:        0\n+Summary:        Salt formula for storing the settings used to manage a CaaSP cluster\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt formula for storing the settings used to manage a CaaSP cluster\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{fname}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{fname}\n+cp -R caasp-management-settings/* %{buildroot}%{fdir}/states/%{fname}\n+cp -R metadata/* %{buildroot}%{fdir}/metadata/%{fname}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/salt-formulas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDU0MA==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250540", "createdAt": "2020-06-03T00:48:55Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDU2Nw==", "bodyText": "Wrong copyright.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250567", "createdAt": "2020-06-03T00:49:03Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDYwMw==", "bodyText": "Wrong URL (needs to be https).", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250603", "createdAt": "2020-06-03T00:49:15Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDY4MQ==", "bodyText": "Why the trailing s? Looks like a typo.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250681", "createdAt": "2020-06-03T00:49:35Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0\n+Release:        1\n+Summary:        SUSE CaaS Platform cluster provider for SUSE Manager\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+Requires(pre):  coreutils\n+Requires:       susemanager-build-keys-web >= 12.0.1\n+Requires:       caasp-management-node-formula\n+Requires:       caasp-management-settings-formula\n+%if 0%{?build_py3}s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MDkxMQ==", "bodyText": "Same as before.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434250911", "createdAt": "2020-06-03T00:50:26Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-settings-formula/caasp-management-settings-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-settings-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTAwMw==", "bodyText": "Shouldn't we have the formulas at the formulas repository?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434251003", "createdAt": "2020-06-03T00:50:43Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula/caasp-management-node-formula.spec", "diffHunk": "@@ -0,0 +1,54 @@\n+#\n+# spec file for package caasp-management-node-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTIxNw==", "bodyText": "Do we really want to call this susemanager- and not uyuni-?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434251217", "createdAt": "2020-06-03T00:51:43Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MTM4OQ==", "bodyText": "I am pretty sure we have other package that owns this directory. If that's the case, we could have conflicts. We should depend on it. Check a head server.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434251389", "createdAt": "2020-06-03T00:52:28Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/susemanager-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,72 @@\n+#\n+# spec file for package susemanager-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LINUX GmbH, Nuernberg, Germany.\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via http://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320\n+# SLE15 builds on Python 3\n+%global build_py3   1\n+%endif\n+\n+%define provider caasp\n+%define fdir %{_datadir}/susemanager/cluster-providers\n+Name:           susemanager-cluster-provider-caasp\n+Version:        1.0\n+Release:        1\n+Summary:        SUSE CaaS Platform cluster provider for SUSE Manager\n+License:        GPL-2.0-only\n+Group:          Applications/System\n+Source:         %{name}-%{version}.tar.gz\n+Requires(pre):  coreutils\n+Requires:       susemanager-build-keys-web >= 12.0.1\n+Requires:       caasp-management-node-formula\n+Requires:       caasp-management-settings-formula\n+%if 0%{?build_py3}s\n+BuildRequires:  python3-pytest\n+BuildRequires:  python3-mock\n+BuildRequires:  python3-salt\n+%else\n+BuildRequires:  python-pytest\n+BuildRequires:  python-mock\n+BuildRequires:  python-salt\n+%endif\n+BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n+BuildArch:      noarch\n+\n+%description\n+Salt files and metadata for intergrting with SUSE CaaS Platform.\n+\n+%prep\n+%setup -q\n+\n+%build\n+\n+%install\n+mkdir -p %{buildroot}%{fdir}/states/%{provider}\n+mkdir -p %{buildroot}%{fdir}/metadata/%{provider}\n+cp -r caasp/* %{buildroot}%{fdir}/states/%{provider}\n+cp -r metadata/* %{buildroot}%{fdir}/metadata/%{provider}\n+\n+%files\n+%defattr(-,root,root)\n+%dir %{_datadir}/susemanager", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9b746aa338648aa68520bee489ab19431246314"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTA1Nzg3", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-423505787", "createdAt": "2020-06-03T12:34:35Z", "commit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNDozNVrOGeZvNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNDozNVrOGeZvNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMjE1MA==", "bodyText": "If you don't care about the differences between SLE and openSUSE, maybe you can consider:\n %if 0%{?sle_version} >= 15000\nAs it's easier to understand, and this way you don't need the comment.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434532150", "createdAt": "2020-06-03T12:34:35Z", "author": {"login": "juliogonzalez"}, "path": "susemanager-utils/cluster-providers/caasp/uyuni-cluster-provider-caasp.spec", "diffHunk": "@@ -0,0 +1,73 @@\n+#\n+# spec file for package uyuni-cluster-provider-caasp\n+#\n+# Copyright (c) 2020 SUSE LLC\n+#\n+# All modifications and additions to the file contributed by third parties\n+# remain the property of their copyright owners, unless otherwise agreed\n+# upon. The license for this file, and modifications and additions to the\n+# file, is the same license as for the pristine package itself (unless the\n+# license for the pristine package is not an Open Source License, in which\n+# case the license is the MIT License). An \"Open Source License\" is a\n+# license that conforms to the Open Source Definition (Version 1.9)\n+# published by the Open Source Initiative.\n+\n+# Please submit bugfixes or comments via https://bugs.opensuse.org/\n+#\n+\n+%if 0%{?suse_version} > 1320", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjIyNDk5", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-423622499", "createdAt": "2020-06-03T14:39:31Z", "commit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozOTozMVrOGefDJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozOTozMVrOGefDJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxOTE3NA==", "bodyText": "As discussed on rocket.chat, the three files from rel-eng/packages can go away. Together with that, remove the headers from the changelogs, so you only have the changelog entry (no empty lines).\nIf you need it for now, just remember to do it before merging, or tell me to do it after merging.\nDo NOT run tito tag!!!", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434619174", "createdAt": "2020-06-03T14:39:31Z", "author": {"login": "juliogonzalez"}, "path": "rel-eng/packages/caasp-management-node-formula", "diffHunk": "@@ -0,0 +1 @@\n+4.1.7-1 susemanager-utils/cluster-providers/caasp/formulas/caasp-management-node-formula", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8ceba6525f6d0bb8aa20908885320c7939a26dd6", "committedDate": "2020-06-03T14:01:54Z", "message": "fixup! package build files for caasp formulas"}, "afterCommit": {"oid": "61f09c325da2f7f960d930d9b16526f575a32431", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/61f09c325da2f7f960d930d9b16526f575a32431", "committedDate": "2020-06-03T15:48:46Z", "message": "Chore: announce changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61f09c325da2f7f960d930d9b16526f575a32431", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/61f09c325da2f7f960d930d9b16526f575a32431", "committedDate": "2020-06-03T15:48:46Z", "message": "Chore: announce changes"}, "afterCommit": {"oid": "a7225fa3241441601f57f1f6a4ac7b81489fb639", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a7225fa3241441601f57f1f6a4ac7b81489fb639", "committedDate": "2020-06-03T15:54:08Z", "message": "Chore: announce changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzA2MDkz", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-424306093", "createdAt": "2020-06-04T10:23:51Z", "commit": {"oid": "00e93e7e5ad0a74426bbc77132737a0027a75c71"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDQyNTU5", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-423442559", "createdAt": "2020-06-03T11:00:44Z", "commit": {"oid": "c21e07c3459702a055618719665ef92abe6fc526"}, "state": "COMMENTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowMDo0NFrOGeWzHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNzo0N1rOGfKlWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4Mzk5Ng==", "bodyText": "We need to add all cluster related subdirectories with .withAltUrl() or .withDir() to any of these children so the active menu item and the breadcrumbs are displayed correctly with all pages.\n.withVisibility() can also be appended to hide the section for non-admins, if that's what we want.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434483996", "createdAt": "2020-06-03T11:00:44Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/menu/MenuTree.java", "diffHunk": "@@ -169,6 +170,11 @@\n                     .withDir(\"/rhn/manager/vhms\")\n                     .withVisibility(adminRoles.get(\"org\"))));\n \n+            // Clusters\n+            nodes.add(new MenuItem(\"clusters.nav.title\").withIcon(\"spacewalk-icon-clusters\")\n+                    .addChild(new MenuItem(\"clusters.nav.overview\").withPrimaryUrl(\"/rhn/manager/clusters\"))\n+                    .addChild(new MenuItem(\"clusters.nav.add\").withPrimaryUrl(\"/rhn/manager/clusters/add\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c21e07c3459702a055618719665ef92abe6fc526"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4NzQyMQ==", "bodyText": "I wonder if it's safe to inject this as an HTML text. Maybe instead have this in a JS snippet just like csrfToken above? (same with the other .jade files)", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434487421", "createdAt": "2020-06-03T11:07:28Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/templates/cluster.jade", "diffHunk": "@@ -0,0 +1,23 @@\n+include /templates/common.jade\n+\n++userRoles\n+\n++userPreferences\n+\n+#cluster\n+\n+script(type='text/javascript').\n+    window.csrfToken = \"#{csrf_token}\";\n+\n+div#init_data_cluster(style=\"display: none\")\n+    | #{contentCluster}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c21e07c3459702a055618719665ef92abe6fc526"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMTA4MA==", "bodyText": "LinkButton is intended to render regular anchors with button styles (when used like here, it adds btn class, which displays wrong when clicked). For this one, since it's not needed, you can instead use <a> tag directly, or add a Link component to the Links utils. It could use a general link component with icon support.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434501080", "createdAt": "2020-06-03T11:36:13Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDY2Mg==", "bodyText": "I think this method shouldn't be static", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434584662", "createdAt": "2020-06-03T13:53:57Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDk3Nw==", "bodyText": "Also, shouldn't be static", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434584977", "createdAt": "2020-06-03T13:54:24Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NDYxMQ==", "bodyText": "Question: are transactions not auto-committed with save()?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434594611", "createdAt": "2020-06-03T14:07:15Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwNDcxOQ==", "bodyText": "Thinking out loud: I think we'll have to break up this class according to different logical domains at some point.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434604719", "createdAt": "2020-06-03T14:20:34Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/services/impl/SaltService.java", "diffHunk": "@@ -1172,6 +1206,20 @@ private void changeGroupAndPerms(Path dir, GroupPrincipal group) {\n         ).map(s -> s.getContainers());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Optional<Map<String, Map<String, Object>>> listClusterNodes(\n+            MinionServer managementNode, ClusterProviderParameters clusterProviderParameters) {\n+        Map<String, Object> pillar = new HashMap<>();\n+        pillar.put(\"cluster_type\", clusterProviderParameters.getClusterProvider());\n+        clusterProviderParameters.getClusterParams().ifPresent(cpp -> pillar.put(\"params\", cpp));\n+        return callSync(State.apply(Arrays.asList(\"clusters.listnodes\"), Optional.of(pillar),\n+                Optional.of(true), Optional.empty(), ClusterOperationsSlsResult.class),\n+                managementNode.getMinionId()).map(ret -> ret.listNodesResult().getChanges().getRet());\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTk0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n          \n          \n            \n                    if (!allMatch) {\n          \n          \n            \n                    if (!clusterNodeHostnames.containsAll(nodes)) {", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434615941", "createdAt": "2020-06-03T14:35:12Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNDUzOQ==", "bodyText": "Another nested class like AddClusterRequest would be useful here", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434624539", "createdAt": "2020-06-03T14:47:01Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNDcxOQ==", "bodyText": "Heads up: It might be a potential performance issue to use this query in a loop", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434634719", "createdAt": "2020-06-03T15:00:37Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjAxOQ==", "bodyText": "I guess the message here is wrong", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434642019", "createdAt": "2020-06-03T15:10:30Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 560}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjYwMA==", "bodyText": "We must take the user org into account too", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434642600", "createdAt": "2020-06-03T15:11:17Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Long getId(Request request) {\n+        String idStr = request.params(\"id\");\n+        Long id = null;\n+        try {\n+            id = Long.parseLong(idStr);\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Id '\" + idStr + \"' is not a number.\");\n+            halt(HttpStatus.SC_BAD_REQUEST, \"id is not a number\");\n+        }\n+        return id;\n+    }\n+\n+    private static Cluster getCluster(Request request) {\n+        Long id = getId(request);\n+        Optional<Cluster> cluster = ClusterFactory.findClusterById(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ceba6525f6d0bb8aa20908885320c7939a26dd6"}, "originalPosition": 579}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Mzg4MQ==", "bodyText": "To unify the messages with delete:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n          \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s' has been added successfully\", name));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434653881", "createdAt": "2020-06-03T15:26:32Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDEwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s'deleted successfully\", cluster.getName()));\n          \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s' has been deleted successfully\", cluster.getName()));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434654109", "createdAt": "2020-06-03T15:26:49Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s'deleted successfully\", cluster.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Njk2OA==", "bodyText": "In the controller, some of the endpoint methods are public and some are private. I wouldn't mind either way but it's better if they all are the same.\nAlso, the checkstyle wouldn't complain about the private ones, but we could use some javadocs for all of the endpoint methods anyway.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434656968", "createdAt": "2020-06-03T15:30:29Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19df63f9966f029850eb336b8df98fb1901febc3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwOTYwMQ==", "bodyText": "We need some documentation for each of these components, what they do, how they work, etc. so people can reuse them with ease (if possible, a story page would be great). Also some unit tests for hashUrl() would be nice.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435109601", "createdAt": "2020-06-04T09:15:04Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/components/utils/HashRouter.js", "diffHunk": "@@ -0,0 +1,109 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useEffect} from 'react';\n+\n+declare var history: any;\n+\n+type HashContextType = {\n+    hash: ?string,\n+    switch?: boolean,\n+    match?: boolean,\n+    goTo: (string) => void,\n+    back: () => void\n+}\n+\n+export const HashRouterContext = React.createContext<HashContextType>({\n+        hash: null,\n+        renderOnlyMatching: true,\n+        goTo: (hash) => {},\n+        back: () => {}\n+    });\n+\n+const hashUrlRegex = /^#\\/(.*)$/;\n+\n+function hashUrl(): ?string {\n+    const match = window.location.hash.match(hashUrlRegex);\n+    return match ? match[1] : undefined;\n+}\n+\n+type HashRouterProps = {\n+    initialPath: string,\n+    children: React.Node\n+}\n+\n+const HashRouter = ({initialPath, children}: HashRouterProps) => {\n+    const [hash, setHash] = useState(initialPath);\n+\n+    useEffect(() => {\n+        const hash = hashUrl();\n+        if (hash) {\n+            setHash(hash);\n+        } else {\n+            goTo(initialPath);\n+        }\n+        window.addEventListener(\"popstate\", (event) => {\n+            setHash(hashUrl())\n+        });\n+    }, []);\n+\n+    const goTo = (hash: string) => {\n+        history.pushState(null, \"\", \"#/\" + hash);\n+        setHash(hash);\n+    }\n+\n+    const back = () => {\n+        history.back();\n+    }\n+\n+    return (\n+        <HashRouterContext.Provider value={{hash: hash, goTo: goTo, back: back}}>\n+            {children}\n+        </HashRouterContext.Provider>\n+    );\n+}\n+\n+type RouterProps = {\n+    path: string,\n+    children:  React.Node | (HashContextType) => React.Node\n+}\n+\n+const Route = ({path, children}: RouterProps) => {\n+    return <HashRouterContext.Consumer>\n+        {context => {\n+            const match = path === context.hash;\n+            if (context.switch) {\n+                if (match) {\n+                    if (typeof children === \"function\") {\n+                        return children({match: true, ...context});\n+                    } else {\n+                        return children;\n+                    }\n+                } else {\n+                    return null;\n+                }\n+            } else {\n+                if (typeof children === \"function\") {\n+                    return children({match: match, ...context});\n+                } else {\n+                    return children;\n+                }\n+            }\n+        }}\n+    </HashRouterContext.Consumer>;\n+}\n+\n+type SwitchProps = {\n+    children: React.Node\n+}\n+\n+const Switch = ({children}: SwitchProps) => {\n+    return <HashRouterContext.Consumer>\n+        {context =>\n+            <HashRouterContext.Provider value={{switch: true, ...context}}>\n+                {children}\n+            </HashRouterContext.Provider>\n+        }\n+        </HashRouterContext.Consumer>;\n+}\n+\n+export {HashRouter, Route, Switch};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjc4MA==", "bodyText": "Same fix can be applied in the if block too", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435112780", "createdAt": "2020-06-04T09:20:17Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/admin/config/monitoring-admin.js", "diffHunk": "@@ -150,11 +150,11 @@ const MonitoringAdmin = (props) => {\n         return;\n       }\n       changeStatus(enable)\n-        .then((result) => {\n+        .then((result: any) => {\n           if (result.success) {\n             setMessages(MessagesUtils.success(msgMap[result.message]));\n           } else {\n-            setMessages(MessagesUtils.error(msgMap[result.message]));\n+            setMessages(MessagesUtils.error(result.message in msgMap ? msgMap[result.message] : result.message));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNDAzMA==", "bodyText": "This check can be done inside Messages component so we can make sure nobody forgets it.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435114030", "createdAt": "2020-06-04T09:22:27Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/admin/config/monitoring-admin.js", "diffHunk": "@@ -210,7 +210,7 @@ const MonitoringAdmin = (props) => {\n     }\n     return (\n     <div className=\"responsive-wizard\">\n-      <Messages items={messages}/>\n+      {messages && <Messages items={messages}/>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNDU2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import type {JsonResult} from \"../../../utils/network\";\n          \n          \n            \n            import type {JsonResult} from \"utils/network\";", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435114568", "createdAt": "2020-06-04T09:23:18Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/admin/config/use-monitoring-api.js", "diffHunk": "@@ -1,8 +1,9 @@\n // @flow\n import {useState} from 'react';\n-import Network from 'utils/network';\n+import * as Network from 'utils/network';\n \n-import type JsonResult from \"../../../utils/network\";\n+import type {JsonResult} from \"../../../utils/network\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExNTUxMg==", "bodyText": "Question in general: What's the difference between these two?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435115512", "createdAt": "2020-06-04T09:24:53Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/systems/activation-key/activation-key-channels-api.js", "diffHunk": "@@ -1,7 +1,7 @@\n /* eslint-disable */\n // @flow\n import React from 'react';\n-import Network from 'utils/network';\n+import * as Network from 'utils/network';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDE2OA==", "bodyText": "Would this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import Functions from '../utils/functions';\n          \n          \n            \n            import {Messages, Utils as MessagesUtils} from '../components/messages';\n          \n          \n            \n            \n          \n          \n            \n            import type {Cancelable} from \"../utils/functions\";\n          \n          \n            \n            import Functions from 'utils/functions';\n          \n          \n            \n            import {Messages, Utils as MessagesUtils} from 'components/messages';\n          \n          \n            \n            \n          \n          \n            \n            import type {Cancelable} from \"utils/functions\";", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435124168", "createdAt": "2020-06-04T09:39:12Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/utils/network.js", "diffHunk": "@@ -1,16 +1,22 @@\n+// @flow\n /* eslint-disable */\n \"use strict\";\n \n-const Functions = require(\"../utils/functions.js\");\n-const MessagesUtils = require(\"../components/messages.js\").Utils;\n+import Functions from '../utils/functions';\n+import {Messages, Utils as MessagesUtils} from '../components/messages';\n+\n+import type {Cancelable} from \"../utils/functions\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df054fac56c2bea7f1961fc4760dcdb72bfabcb1"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMDYxOQ==", "bodyText": "Nitpick: Block elements (div) inside span is considered invalid.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n          \n          \n            \n                      content={\n          \n          \n            \n                        <div>\n          \n          \n            \n                          <div>{t(\"Are you sure you want to delete cluster?\")}</div>\n          \n          \n            \n                          <div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div>\n          \n          \n            \n                        </div>\n          \n          \n            \n                      }", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435130619", "createdAt": "2020-06-04T09:50:06Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MDQyMA==", "bodyText": "We have a component called TabContainer with hash navigation for this purpose. So I'd prefer we either reuse it, refactoring if necessary, or get rid of it so we have only one component that does the job.\nSee images/image-view.js for an example.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435140420", "createdAt": "2020-06-04T10:06:34Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n+          onConfirmAsync={onDelete}\n+        />\n+        <TopPanel title={name}\n+            button={panelButtons}\n+            icon=\"spacewalk-icon-clusters\"\n+            helpUrl=\"/docs/reference/clusters/clusters-menu.html\">\n+            <HashRouter initialPath=\"overview\">\n+              <div className=\"spacewalk-content-nav\">\n+                <ul className=\"nav nav-tabs\">\n+                    <Route path=\"overview\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Overview\")} hash=\"#/overview\" />\n+                        }\n+                    </Route>\n+                    <Route path=\"settings\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Provider Settings\")} hash=\"#/settings\" />\n+                        }\n+                    </Route>\n+                </ul>        \n+              </div>\n+              <Switch>\n+                <Route path=\"overview\">\n+                  <ClusterOverview cluster={props.cluster} setMessages={props.setMessages} onUpdateName={onUpdateName}/>\n+                </Route>\n+                <Route path=\"settings\">\n+                  <ManagementSettings cluster={props.cluster} setMessages={props.setMessages}/>\n+                </Route>\n+              </Switch>\n+\n+            </HashRouter>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MTgwNA==", "bodyText": "These tabs act weird with the browser back button (see how the previous tab is darkened):", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435141804", "createdAt": "2020-06-04T10:09:00Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster.js", "diffHunk": "@@ -0,0 +1,112 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import React from 'react';\n+import {useEffect, useState} from 'react';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import {TabLabel} from 'components/tab-container'\n+import ClusterOverview from './cluster-overview';\n+import ManagementSettings from './cluster-config';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {LinkButton} from 'components/buttons';\n+import {DeleteDialog} from 'components/dialog/DeleteDialog';\n+import {showDialog} from 'components/dialog/util';\n+import {Messages} from 'components/messages';\n+\n+import type {ClusterType, ErrorMessagesType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  flashMessage: String,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const Cluster = (props: Props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const {deleteCluster} = useClustersApi();\n+    const [name, setName] = useState<string>(props.cluster.name);\n+\n+    const onShowDelete = () => {\n+        showDialog(\"delete-cluster\");\n+    }\n+\n+    const onDelete = () => {\n+      return deleteCluster(props.cluster.id).then((_) => {\n+          window.location = \"/rhn/manager/clusters\";\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+          props.setMessages(error.messages);\n+      });\n+    }\n+\n+    const onUpdateName = (name: string) => {\n+      setName(name);\n+    }\n+\n+    useEffect(() => {\n+      if(props.flashMessage) {\n+        props.setMessages([Messages.info(props.flashMessage)])\n+      }\n+    }, []);\n+\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"deleteCluster\"\n+                icon=\"fa-trash-o\"\n+                title={t('Delete cluster')}\n+                text={t('Delete Cluster')}\n+                handler={onShowDelete}\n+            />\n+        }\n+        </div>\n+    );\n+\n+    return (\n+      <React.Fragment>\n+        <DeleteDialog id=\"delete-cluster\"\n+          title={t(\"Delete cluster\")}\n+          content={<span><div>{t(\"Are you sure you want to delete cluster?\")}</div><div>{t(\"This will not destroy the cluster. It will only remove it from Uyuni\")}</div></span>}\n+          onConfirmAsync={onDelete}\n+        />\n+        <TopPanel title={name}\n+            button={panelButtons}\n+            icon=\"spacewalk-icon-clusters\"\n+            helpUrl=\"/docs/reference/clusters/clusters-menu.html\">\n+            <HashRouter initialPath=\"overview\">\n+              <div className=\"spacewalk-content-nav\">\n+                <ul className=\"nav nav-tabs\">\n+                    <Route path=\"overview\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Overview\")} hash=\"#/overview\" />\n+                        }\n+                    </Route>\n+                    <Route path=\"settings\">\n+                        {({match}) =>\n+                            <TabLabel active={match} text={t(\"Provider Settings\")} hash=\"#/settings\" />\n+                        }\n+                    </Route>\n+                </ul>        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ea08bb815639226b64b2c5de7e08c3856f411f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMjQ0Mw==", "bodyText": "This applies to all usages of the flash scope:\nThese messages should be shown as \"success\" (green) instead of \"info\" (blue).\nWe can push MessageResponse objects to the scope instead. Otherwise, we have only one type of message that is interpreted as info on the frontend.\nInstead, we should deserialize the message objects with the types, and render them with toastr, etc. accordingly.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435332443", "createdAt": "2020-06-04T15:07:47Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 316}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NjAyNDIy", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-424602422", "createdAt": "2020-06-04T16:01:46Z", "commit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "state": "COMMENTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjowMTo0NlrOGfNEGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo1Njo1M1rOGfTxBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MzA4Mw==", "bodyText": "Are these necessary?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435373083", "createdAt": "2020-06-04T16:01:46Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3Nzg2Nw==", "bodyText": "Mentioned before; buttons components are meant to be styled as buttons, for a link, it'd be nice to have a general Link component inside of links utils.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435377867", "createdAt": "2020-06-04T16:08:57Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "diffHunk": "@@ -0,0 +1,102 @@\n+// @flow\n+import { hot } from 'react-hot-loader';\n+import React, {useEffect} from 'react';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {LinkButton} from 'components/buttons';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import Functions from 'utils/functions';\n+import {SystemLink} from 'components/links';\n+import {showInfoToastr} from 'components/toastr/toastr';\n+\n+import type {ClusterType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  clusters: Array<ClusterType>,\n+  flashMessage: String,\n+};\n+\n+const ListClusters = (props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"addCluster\"\n+                icon=\"fa-plus\"\n+                className=\"btn-link js-spa\"\n+                title={t('Add an existing cluster')}\n+                text={t('Add Cluster')}\n+                href=\"/rhn/manager/clusters/add\"\n+            />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e66ccddb08be968c94ba9349a094fd55aa3b6f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3OTY3Mg==", "bodyText": "setMessages from withErrorMessages in use-cluster-api can be used here instead.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435379672", "createdAt": "2020-06-04T16:11:34Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/list-clusters/list-clusters.js", "diffHunk": "@@ -0,0 +1,102 @@\n+// @flow\n+import { hot } from 'react-hot-loader';\n+import React, {useEffect} from 'react';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import {TopPanel} from 'components/panels/TopPanel';\n+import {LinkButton} from 'components/buttons';\n+import useRoles from \"core/auth/use-roles\";\n+import {isOrgAdmin} from \"core/auth/auth.utils\";\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import Functions from 'utils/functions';\n+import {SystemLink} from 'components/links';\n+import {showInfoToastr} from 'components/toastr/toastr';\n+\n+import type {ClusterType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  clusters: Array<ClusterType>,\n+  flashMessage: String,\n+};\n+\n+const ListClusters = (props) => {\n+    const roles = useRoles();\n+    const hasEditingPermissions = isOrgAdmin(roles);\n+    const panelButtons = (\n+        <div className=\"pull-right btn-group\">\n+        {\n+            hasEditingPermissions &&\n+            <LinkButton\n+                id=\"addCluster\"\n+                icon=\"fa-plus\"\n+                className=\"btn-link js-spa\"\n+                title={t('Add an existing cluster')}\n+                text={t('Add Cluster')}\n+                href=\"/rhn/manager/clusters/add\"\n+            />\n+        }\n+        </div>\n+    );\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name', 'type'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    useEffect(()=> {\n+        if(props.flashMessage) {\n+            showInfoToastr(props.flashMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e66ccddb08be968c94ba9349a094fd55aa3b6f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDM5OA==", "bodyText": "Unused code", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435380398", "createdAt": "2020-06-04T16:12:45Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDc5MQ==", "bodyText": "We can either make use of this somewhere, or get rid of fetching altogether.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435380791", "createdAt": "2020-06-04T16:13:24Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTU1Nw==", "bodyText": "stringify() is not needed here. Network methods support plain objects through ajax()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify(context),\n          \n          \n            \n                        context,", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435381557", "createdAt": "2020-06-04T16:14:39Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTk4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify(data),\n          \n          \n            \n                        data,", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435381983", "createdAt": "2020-06-04T16:15:18Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjE3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            name: name,\n          \n          \n            \n                            label: label,\n          \n          \n            \n                            description: description,\n          \n          \n            \n                            managementNodeId: managementNodeId,\n          \n          \n            \n                            provider: providerLabel,\n          \n          \n            \n                            managementSettings: managementSettings\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            name: name,\n          \n          \n            \n                            label: label,\n          \n          \n            \n                            description: description,\n          \n          \n            \n                            managementNodeId: managementNodeId,\n          \n          \n            \n                            provider: providerLabel,\n          \n          \n            \n                            managementSettings: managementSettings\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382171", "createdAt": "2020-06-04T16:15:36Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: joinFormula\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: joinFormula\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382414", "createdAt": "2020-06-04T16:15:59Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjYwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: removeFormula\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            earliest: earliest,\n          \n          \n            \n                            serverIds: serverIds,\n          \n          \n            \n                            formula: removeFormula\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382609", "createdAt": "2020-06-04T16:16:18Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjkxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify({\n          \n          \n            \n                            earliest: earliest\n          \n          \n            \n                        }),\n          \n          \n            \n                        {\n          \n          \n            \n                            earliest: earliest\n          \n          \n            \n                        },", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435382917", "createdAt": "2020-06-04T16:16:46Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleUpgradeCluster = (clusterId: number, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/upgrade`,\n+            JSON.stringify({\n+                earliest: earliest\n+            }),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MzI1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSON.stringify(cluster),\n          \n          \n            \n                        cluster,", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435383253", "createdAt": "2020-06-04T16:17:19Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/api/use-clusters-api.js", "diffHunk": "@@ -0,0 +1,363 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import * as Network from 'utils/network';\n+import {showInfoToastr, showSuccessToastr, showWarningToastr, showErrorToastr} from 'components/toastr/toastr';\n+\n+import type {JsonResult} from \"utils/network\";\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator when flowified\n+export type FormulaValuesType = {[string]: any};\n+\n+export type FormulaContextType = {[string]: any};\n+\n+export type ClusterProviderType = {\n+    label: string,\n+    name: string,\n+    description: string\n+}\n+\n+export type ServerType = {\n+    id: number,\n+    name: string,\n+    messages: Array<MessageType>\n+}\n+\n+export type ServerGroupType = {\n+    id: number,\n+    name: string\n+}\n+\n+export type ClusterType = {\n+    id: number,\n+    name: string,\n+    label: string,\n+    description: string,\n+    provider: ClusterProviderType,\n+    managementNode: ServerType,\n+    group: ServerGroupType\n+}\n+\n+export type ClusterNodeType = {\n+    hostname: string,\n+    server?: ServerType,\n+    details: {[string]: any}\n+}\n+\n+export type EditableClusterPropsType = {\n+    name: string,\n+    description: string\n+}\n+\n+type ClusterNodesResultType = {\n+    nodes: Array<ClusterNodeType>,\n+    fields: Array<string>\n+}\n+\n+export type ErrorMessagesType = {\n+    messages: Array<MessageType>\n+}\n+\n+export class ErrorMessages extends Error {\n+\n+    msg: ?MessageType = null;\n+\n+    constructor(message: MessageType) {\n+        super(message.text);\n+        this.msg = message;\n+    }\n+}\n+\n+type Props = {}\n+type State = {}\n+\n+export const withErrorMessages = (PageComponent: React.AbstractComponent<any>) => {\n+    return class extends React.Component<Props, State> {\n+\n+        showMessages = (messages: Array<MessageType>) => {\n+            messages.forEach((msg) => {\n+                switch (msg.severity ) {\n+                    case \"info\":\n+                        showInfoToastr(msg.text);\n+                        break;\n+                    case \"success\":\n+                        showSuccessToastr(msg.text);\n+                        break;\n+                    case \"warning\":\n+                        showWarningToastr(msg.text);\n+                        break;\n+                    case \"error\":\n+                        showErrorToastr(msg.text, {autoHide: false});\n+                        break;\n+                    default:\n+                        showInfoToastr(msg.text);\n+                }\n+            })\n+        }\n+\n+        render() {\n+            return <React.Fragment>\n+                    <PageComponent setMessages={(messages) => this.showMessages(messages)} {...this.props}/>\n+                </React.Fragment>\n+        }\n+    };\n+}\n+\n+const useClustersApi = ()  => {\n+    const [fetching, setFetching] = useState<boolean>(false);\n+    // const [fetchListeners] = useState<Array<(boolean) => void>>([]);\n+\n+    const handleResponseError = (jqXHR: Object, arg: string = \"\") => {\n+        throw new ErrorMessages(Network.responseErrorMessage(jqXHR));\n+    };\n+\n+    // const fetchClustersList = () : Promise<Array<ClusterType>> => {\n+    //     return Network.get(\"/rhn/manager/api/clusters\").promise\n+    //         .then((data: JsonResult<ClustersListResultType>) => {\n+    //             setClusters(data.data.clusters);\n+    //             setClustersMessages(data.data.messages);\n+    //             return data.data.clusters;\n+    //         })\n+    //         .catch(handleResponseError)\n+    //         .finally(() => {\n+    //             setFetching(false);\n+    //         });\n+    // }\n+\n+    const fetchClusterNodes = (clusterId: number): Promise<ClusterNodesResultType> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes`).promise\n+            .then((data: JsonResult<ClusterNodesResultType>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchManagementNodes = (provider: string): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/provider/${provider}/management-nodes`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchNodesToJoin = (clusterId: number): Promise<Array<ServerType>> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/nodes-to-join`).promise\n+            .then((data: JsonResult<Array<ServerType>>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchProviderFormulaForm = (provider: string, formula: string, context: ?FormulaContextType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(`/rhn/manager/api/cluster/provider/${provider}/formula/${formula}/form`,\n+            JSON.stringify(context),\n+            \"application/json\"\n+        ).promise\n+            .then((data: JsonResult<any>) => {\n+                return Promise.resolve({\n+                    \"formula_name\": provider,\n+                    \"formula_list\": [],\n+                    \"metadata\": {},\n+                    ...data.data\n+                    });\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const fetchClusterFormulaData = (clusterId: number, formula: string): Promise<any> => {\n+        setFetching(true);\n+        return Network.get(`/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`).promise\n+            .then((data: JsonResult<any>) => {\n+                return data.data;\n+            })\n+            .catch(handleResponseError)\n+            .finally(() => {\n+                setFetching(false);\n+            });\n+    }\n+\n+    const saveClusterFormulaData = (clusterId: number, formula: string, data: FormulaValuesType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/formula/${formula}/data`,\n+            JSON.stringify(data),\n+            \"application/json\"\n+        ).promise\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const addCluster = (name: string, label: string, description: string, providerLabel: string, managementNodeId: number, managementSettings: FormulaValuesType) : Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            \"/rhn/manager/api/cluster/new/add\",\n+            JSON.stringify({\n+                name: name,\n+                label: label,\n+                description: description,\n+                managementNodeId: managementNodeId,\n+                provider: providerLabel,\n+                managementSettings: managementSettings\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleJoinNode = (clusterId: number, serverIds: Array<number>, joinFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/join`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: joinFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleRemoveNode = (clusterId: number, serverIds: Array<number>, removeFormula: FormulaValuesType, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/remove-node`,\n+            JSON.stringify({\n+                earliest: earliest,\n+                serverIds: serverIds,\n+                formula: removeFormula\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const scheduleUpgradeCluster = (clusterId: number, earliest: Date, actionChain: ?string): Promise<number> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}/upgrade`,\n+            JSON.stringify({\n+                earliest: earliest\n+            }),\n+            \"application/json\"\n+        ).promise\n+        .then((data: JsonResult<number>) => {\n+            return data.data\n+        })\n+        .catch(handleResponseError)\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }\n+\n+    const saveClusterProps = (clusterId: number, cluster: EditableClusterPropsType): Promise<any> => {\n+        setFetching(true);\n+        return Network.post(\n+            `/rhn/manager/api/cluster/${clusterId}`,\n+            JSON.stringify(cluster),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNTQ5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    const selectedServers = [];\n          \n          \n            \n                    for (const srvId of selections) {\n          \n          \n            \n                        const server = servers.find(srv => srv.id === srvId);\n          \n          \n            \n                        if (server) {\n          \n          \n            \n                            selectedServers.push(server);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    const selectedServers = servers.filter(srv => selections.has(srv.id));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435415497", "createdAt": "2020-06-04T17:09:16Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "diffHunk": "@@ -0,0 +1,159 @@\n+// @flow\n+import React, {useState, useEffect} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import {SystemLink} from 'components/links';\n+import {IconTag as Icon} from 'components/icontag';\n+import Functions from 'utils/functions';\n+import {withErrorMessages} from '../api/use-clusters-api';\n+\n+import type {MessageType} from 'components/messages';\n+import type {ErrorMessagesType, ServerType} from  '../api/use-clusters-api';\n+\n+type Props = {\n+    title: string,\n+    selectedServers: ?Array<ServerType>,\n+    onNext: (Array<ServerType>) => void,\n+    onPrev: () => void,\n+    setMessages: (Array<MessageType>) => void,\n+    fetchServers: () => Promise<Array<ServerType>>,\n+    multiple: boolean\n+};\n+\n+const SystemMessages = (props: {messages: Array<MessageType>}) => {\n+    return <ul style={{listStyle: 'none', paddingLeft: '0px', margin: '0px'}}>\n+        { props.messages.map(msg => \n+          <li>\n+            <Icon type=\"system-warn\" className=\"fa-1-5x\"/>{ msg.text }\n+          </li>)  \n+        }\n+        </ul>;\n+}\n+\n+const SelectServer = (props: Props) => {\n+    const [selections, setSelections] = useState<Set<number>>(props.selectedServers ? new Set(props.selectedServers.map(srv => srv.id)) : new Set());\n+    const [servers, setServers] = useState<Array<ServerType>>([]);\n+    const [fetching, setFetching] = useState<boolean>(false);\n+\n+    useEffect(() => {\n+        setFetching(true);\n+        props.fetchServers().then(data => {\n+            setServers(data);\n+            setSelections(new Set());\n+        })\n+        .catch((error : ErrorMessagesType) => {\n+            props.setMessages(error.messages);\n+        })\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }, [])\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    const selectServers = (selections: Set<number>) => {\n+        const selectedServers = [];\n+        for (const srvId of selections) {\n+            const server = servers.find(srv => srv.id === srvId);\n+            if (server) {\n+                selectedServers.push(server);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMjk4Mw==", "bodyText": "IMO we should use the existing Input library here instead.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435422983", "createdAt": "2020-06-04T17:22:08Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "diffHunk": "@@ -0,0 +1,93 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useRef} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {withErrorMessages} from '../shared/api/use-clusters-api';\n+import {Messages} from 'components/messages';\n+import {Label} from 'components/input/Label';\n+\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+    panel: React.Node,\n+    onAdd: (name: string, label: string, description: string) => Promise<any>,\n+    onPrev: () =>  void,\n+    setMessages: (Array<MessageType>) => void\n+};\n+\n+const FinishAddCluster = (props: Props) => {\n+    const [name, setName] = useState<string>(\"\");\n+    const [label, setLabel] = useState<string>(\"\");\n+    const [description, setDescription] = useState<string>(\"\");\n+    const [submitted, setSubmitted] = useState<boolean>(false);\n+    const theForm = useRef(null);\n+\n+    const onAdd = () => {\n+        const isValid = theForm.current ? theForm.current.reportValidity() : false;\n+        if (isValid) {\n+            return props.onAdd(name, label, description).then(data => {\n+                setSubmitted(true);\n+                window.location = `/rhn/manager/cluster/${data}`;\n+            })\n+            .catch((err: Error) => {\n+                console.log(err);\n+                props.setMessages([Messages.error(\"Error adding cluster: \" + err.message)]);\n+                throw err;\n+            });\n+        } else {\n+            console.log(\"form is not valid\");\n+        }\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={t(\"Add cluster\")}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            disabled={submitted}\n+                            text={t(\"Prev\")}\n+                            className=\"btn-default\"\n+                            icon=\"fa-arrow-left\"\n+                            handler={() => props.onPrev()}\n+                        />\n+                        <AsyncButton\n+                            id=\"btn-next\"\n+                            disabled={submitted}\n+                            text={t(\"Add\")}\n+                            defaultType=\"btn-success\"\n+                            icon=\"fa-plus\"\n+                            action={onAdd}\n+                        />\n+                    </div>\n+                }>\n+                <form id=\"formula-form\" ref={theForm} className=\"form-horizontal\" onSubmit={(event) => {event.preventDefault(); return false;}}>\n+                    <div className=\"form-horizontal\">\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Name:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={name} onChange={ev => setName(ev.target.value)} required/>\n+                            </div>\n+                        </div>\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Label:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={label} onChange={ev => setLabel(ev.target.value)}\n+                                required pattern=\"^[a-zA-Z_][a-zA-Z0-9_]+$\" title=\"only letters, numbers or underscore\"/>\n+                            </div>\n+                        </div>\n+                        <div className=\"form-group\">\n+                            <Label required={true} className=\"col-md-3\" name={t(\"Description:\")}/>\n+                            <div className=\"col-md-3\">\n+                                <input className=\"form-control\" type=\"text\" value={description} onChange={ev =>  setDescription(ev.target.value)} required/>\n+                            </div>\n+                        </div>                                        \n+                    </div>   \n+                </form>                                             ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTAxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      onChange={(model) => {setEditModel(model); console.log(model)}} \n          \n          \n            \n                      onChange={setEditModel}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435451011", "createdAt": "2020-06-04T18:09:03Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MzEzNA==", "bodyText": "I guess this is leftover from debugging.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n          \n          \n            \n                      onValidate={setValid}\n          \n      \n    \n    \n  \n\nWhere setValid is the setter of an isValid flag:\nconst [isValid, setValid] = useState<boolean>(true);\nThen saving should be prevented/button disabled according to the flag.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435463134", "createdAt": "2020-06-04T18:27:16Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NDc1NQ==", "bodyText": "As mentioned; this should be disabled with an isValid flag.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435464755", "createdAt": "2020-06-04T18:29:24Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NTEzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            onClosePopUp={() => {console.log(\"onclose\")}}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435465132", "createdAt": "2020-06-04T18:30:03Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />\n+              </div>\n+          </div>\n+  </React.Fragment>;\n+\n+  return (\n+      <>\n+        <Dialog id=\"cluster-edit-dialog\"\n+                title={t(\"Edit cluster details\")}\n+                closableModal={true}\n+                className=\"modal-lg\"\n+                content={editContent}\n+                onClosePopUp={() => {console.log(\"onclose\")}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NjcwMA==", "bodyText": "Why not set the model during initialization on top?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435466700", "createdAt": "2020-06-04T18:32:31Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/cluster/cluster-overview.js", "diffHunk": "@@ -0,0 +1,328 @@\n+// @flow\n+import * as React from 'react';\n+import {useEffect, useState, useRef} from 'react';\n+import useClustersApi from '../shared/api/use-clusters-api';\n+import {AsyncButton, LinkButton, Button} from 'components/buttons';\n+import {SystemLink, SystemGroupLink} from 'components/links';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import Functions from 'utils/functions';\n+import {SearchField} from 'components/table/SearchField';\n+import {Panel} from 'components/panels/Panel';\n+import {PanelRow} from 'components/panels/PanelRow';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {Label} from 'components/input/Label';\n+import {Messages} from 'components/messages';\n+import {ModalLink} from 'components/dialog/ModalLink';\n+import {closeDialog, Dialog} from \"../../../components/dialog/Dialog\";\n+import {Form} from \"components/input/Form\";\n+import {Text} from \"components/input/Text\";\n+import {Loading} from 'components/utils/Loading';\n+import {Utils} from 'utils/functions';\n+\n+import type {ClusterType, ClusterNodeType, ErrorMessagesType, EditableClusterPropsType} from '../shared/api/use-clusters-api'\n+import type {MessageType} from 'components/messages';\n+\n+const {capitalize} = Utils;\n+\n+\n+const NodeField = (props: {value: any}) => {\n+  if (props.value !== null && props.value !== undefined) {\n+    if (typeof props.value === \"boolean\") {\n+      return props.value ? \n+        <span>{t(\"Yes\")}</span> : \n+        <span>{t(\"No\")}</span>\n+    } else {\n+      return <span>{props.value}</span>\n+    }\n+  } else {\n+    return <span>{t(\"(none)\")}</span>;\n+  }\n+}\n+\n+type Props = {\n+  cluster: ClusterType,\n+  onUpdateName: (string) => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const ClusterOverview = (props: Props) => {\n+  const [cluster, setCluster] = useState<ClusterType>(props.cluster);\n+  const [selections, setSelections] = useState<Set<string>>(new Set());\n+  const [nodes, setNodes] = useState<Array<ClusterNodeType>>([]);\n+  const [nodeDetailFields, setNodeDetailFields] = useState<Array<string>>([]);\n+  const [fetching, setFetching] = useState<boolean>(false);\n+  const [fetchingProps, setFetchingProps] = useState<boolean>(false);  \n+  const [editModel, setEditModel] = useState<EditableClusterPropsType>({name: \"\", description: \"\"});\n+  const nodesForm = useRef(null);\n+\n+  const {fetchClusterNodes, refreshGroupNodes, saveClusterProps, fetchClusterProps} = useClustersApi();\n+\n+  const fetchData = () => {\n+    setFetching(true);\n+    fetchClusterNodes(props.cluster.id)\n+    .then((clusterNodes) => {\n+      setNodes(clusterNodes.nodes);\n+      setNodeDetailFields(clusterNodes.fields);\n+      setSelections(new Set());\n+    })\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+    .finally((fetching) => setFetching(false));\n+  }\n+\n+  useEffect(() => {\n+    fetchData();\n+  }, []);\n+\n+  const onRemove = () => {\n+    if (selections.size > 0 && nodesForm.current) {\n+      nodesForm.current.submit();\n+    }\n+  };\n+\n+  const onRefreshGroupNodes = () => {\n+    refreshGroupNodes(props.cluster.id)\n+    .then((actionId) => props.setMessages([Messages.success(t(\"System group refresh action scheduled successfully\"))]))\n+    .catch((error : ErrorMessagesType) => {\n+      props.setMessages(error.messages);\n+    })\n+  };\n+\n+  const onFetchClusterProps = () => {\n+    setFetchingProps(true);\n+    fetchClusterProps(props.cluster.id)\n+      .then((data: ClusterType) => {\n+        setCluster(data);\n+        props.onUpdateName(data.name);\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })      \n+      .finally(() => {\n+          setFetchingProps(false);\n+      });    \n+  }\n+\n+  const onSaveClusterProps = () => {\n+    return saveClusterProps(props.cluster.id, editModel)\n+      .then(_ => {\n+        closeDialog(\"cluster-edit-dialog\");\n+        props.setMessages([Messages.success(t(\"Cluster properties updated successfully\"))]);\n+        onFetchClusterProps();\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      });\n+  };\n+\n+  const filterFunc = (row, criteria) => {\n+      const keysToSearch = ['hostname'];\n+      if (criteria) {\n+          return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+      }\n+      return true;\n+  };\n+\n+  const onSelectNode = (event, hostname) => {\n+      const newSelections = new Set(selections);\n+      if (event.target.checked) {\n+          newSelections.add(hostname);\n+      } else {\n+          newSelections.delete(hostname);\n+      }\n+      setSelections(newSelections);\n+  }  \n+\n+  const editContent =\n+      <Form\n+          model={editModel}\n+          onValidate={(valid) => console.log(\"valid: \" + (valid ? \"true\" : \"false\"))}\n+          onChange={(model) => {setEditModel(model); console.log(model)}} \n+          formDirection=\"form-horizontal\"\n+          >\n+          <Text\n+              name=\"name\"\n+              label={t('Name')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />\n+          <Text\n+              name=\"description\"\n+              label={t('Description')}\n+              required\n+              labelClass=\"col-md-3\"\n+              divClass=\"col-md-6\"\n+              />                \n+      </Form>;   \n+\n+  const editButtons = <React.Fragment>\n+          <div className=\"btn-group col-lg-6\"></div>\n+          <div className=\"col-lg-6\">\n+              <div className=\"pull-right btn-group\">\n+                  <Button\n+                      id=\"cancel-btn\"\n+                      text={t(\"Cancel\")}\n+                      className=\"gap-right btn-default\"\n+                      handler={() => {\n+                          closeDialog(\"cluster-edit-dialog\");\n+                      }}\n+                      />\n+                  <AsyncButton id=\"save-btn\" defaultType=\"btn-primary\"\n+                      icon=\"fa-save\"\n+                      text={t(\"Save\") }\n+                      className=\"gap-right\"\n+                      action={() => onSaveClusterProps()}\n+                      />\n+              </div>\n+          </div>\n+  </React.Fragment>;\n+\n+  return (\n+      <>\n+        <Dialog id=\"cluster-edit-dialog\"\n+                title={t(\"Edit cluster details\")}\n+                closableModal={true}\n+                className=\"modal-lg\"\n+                content={editContent}\n+                onClosePopUp={() => {console.log(\"onclose\")}}\n+                buttons={editButtons}\n+              />\n+\n+        <SectionToolbar>\n+          <div className=\"pull-right btn-group\">\n+              <LinkButton\n+                id=\"join-btn\"\n+                icon=\"fa-plus\"\n+                text={t(\"Join node\")}\n+                className=\"gap-right btn-default\"\n+                href={`/rhn/manager/cluster/${props.cluster.id}/join`}\n+                />\n+              <Button\n+                id=\"remove-btn\"\n+                disabled={selections.size === 0}\n+                icon=\"fa-minus\"\n+                text={t(\"Remove node\")}\n+                className=\"gap-right btn-default\"\n+                handler={onRemove}\n+                />\n+              <AsyncButton id=\"refresh-btn\" defaultType=\"btn-default\"\n+                icon=\"fa-refresh\"\n+                text={t(\"Refresh\") }\n+                className=\"gap-right\"\n+                action={() => fetchData() }\n+                />\n+              <LinkButton\n+                id=\"upgrade\"\n+                disabled={true}\n+                icon=\"spacewalk-icon-package-upgrade\"\n+                text={t(\"Upgrade cluster\") }\n+                className=\"btn-default gap-right\"\n+                href={`/rhn/manager/cluster/${props.cluster.id}/upgrade`}\n+                />                \n+              <AsyncButton id=\"refresh-group-btn\" defaultType=\"btn-default\"\n+                icon=\"fa-refresh\"\n+                text={t(\"Refresh system group\") }\n+                className=\"gap-right\"\n+                action={() => onRefreshGroupNodes()}\n+                />\n+\n+          </div>\n+        </SectionToolbar>\n+        \n+        <Panel headingLevel=\"h3\" title={t('Cluster Properties')}\n+          buttons={<ModalLink\n+                  target=\"cluster-edit-dialog\"\n+                  icon=\"fa-plus\"\n+                  className=\"btn-link\"\n+                  text={t(\"Edit properties\")}\n+                  title={t(\"Edit cluster details\")}\n+                  onClick={() => setEditModel({name: cluster.name, description: cluster.description})}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mzc0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        text={t(\"Prev\")}\n          \n          \n            \n                                        text={t(\"Back\")} // or \"Previous\"", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435473745", "createdAt": "2020-06-04T18:41:56Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/add-cluster/finish-add.js", "diffHunk": "@@ -0,0 +1,93 @@\n+// @flow\n+import * as React from 'react';\n+import {useState, useRef} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {withErrorMessages} from '../shared/api/use-clusters-api';\n+import {Messages} from 'components/messages';\n+import {Label} from 'components/input/Label';\n+\n+import type {MessageType} from 'components/messages';\n+\n+type Props = {\n+    panel: React.Node,\n+    onAdd: (name: string, label: string, description: string) => Promise<any>,\n+    onPrev: () =>  void,\n+    setMessages: (Array<MessageType>) => void\n+};\n+\n+const FinishAddCluster = (props: Props) => {\n+    const [name, setName] = useState<string>(\"\");\n+    const [label, setLabel] = useState<string>(\"\");\n+    const [description, setDescription] = useState<string>(\"\");\n+    const [submitted, setSubmitted] = useState<boolean>(false);\n+    const theForm = useRef(null);\n+\n+    const onAdd = () => {\n+        const isValid = theForm.current ? theForm.current.reportValidity() : false;\n+        if (isValid) {\n+            return props.onAdd(name, label, description).then(data => {\n+                setSubmitted(true);\n+                window.location = `/rhn/manager/cluster/${data}`;\n+            })\n+            .catch((err: Error) => {\n+                console.log(err);\n+                props.setMessages([Messages.error(\"Error adding cluster: \" + err.message)]);\n+                throw err;\n+            });\n+        } else {\n+            console.log(\"form is not valid\");\n+        }\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={t(\"Add cluster\")}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            disabled={submitted}\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NDY4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                  text={t(\"Prev\")}\n          \n          \n            \n                                                  text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435474687", "createdAt": "2020-06-04T18:43:06Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "diffHunk": "@@ -0,0 +1,144 @@\n+// @flow\n+import React, {useEffect, useState} from 'react';\n+import useClustersApi, {withErrorMessages} from '../api/use-clusters-api';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Messages} from 'components/messages';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {FormulaFormContext, FormulaFormContextProvider, FormulaFormRenderer} from 'components/formulas/FormulaComponentGenerator';\n+import {Loading} from 'components/utils/Loading';\n+\n+import type {FormulaValuesType, FormulaContextType, ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator once its flow-ified\n+// type ValidatedFormulaType = {\n+//   errors: {\n+//     required: Array<string>,\n+//     invalid: Array<string>\n+//   },\n+//   values: {[string]: any}\n+// }\n+\n+type Props = {\n+  provider: string,\n+  title: string,\n+  values: ?FormulaValuesType,\n+  formula: string,\n+  context: ?FormulaContextType,\n+  onNext: (FormulaValuesType) => void,\n+  onPrev?: () => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const FormulaConfig = (props: Props) => {\n+    const [form, setForm] = useState<any>(null);\n+    const [formulaValues, setFormulaValues] = useState<?FormulaValuesType>(null);\n+    const {fetchProviderFormulaForm} = useClustersApi();\n+\n+    useEffect(() => {\n+      fetchProviderFormulaForm(props.provider, props.formula, props.context ? props.context : null).then(data => {\n+        setForm(data.form);\n+        if (data.params) {\n+          // merge params with props.values\n+          setFormulaValues(Object.assign({}, data.params, props.values)); // order is important\n+        } else if (props.values) {\n+          setFormulaValues(props.values);\n+        } else {\n+          setFormulaValues({})\n+        }\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })\n+    }, []);\n+\n+    const clickNext = ({errors, values}) => {\n+      if (errors) {\n+        const messages = [];\n+        if (errors.required && errors.required.length > 0) {\n+            messages.push(Messages.error(t(\"Please input required fields: {0}\", errors.required.join(', '))));\n+        }\n+        if (errors.invalid && errors.invalid.length > 0) {\n+            messages.push(Messages.error(t(\"Invalid format of fields: {0}\", errors.invalid.join(', '))));\n+        }\n+        props.setMessages(messages);\n+      } else {\n+        props.onNext(values);\n+      }\n+    }\n+\n+    return (form && formulaValues ? \n+              <FormulaFormContextProvider layout={form}\n+                systemData={formulaValues ? formulaValues : {}}\n+                groupData={{}}\n+                scope=\"system\">\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                          <FormulaFormContext.Consumer>\n+                            {({validate}) => \n+                                <div className=\"btn-group\">\n+                                  {props.onPrev ? <Button\n+                                      id=\"btn-prev\"\n+                                      text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTAwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        text={t(\"Prev\")}\n          \n          \n            \n                                        text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435475007", "createdAt": "2020-06-04T18:43:30Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/formula-config.js", "diffHunk": "@@ -0,0 +1,144 @@\n+// @flow\n+import React, {useEffect, useState} from 'react';\n+import useClustersApi, {withErrorMessages} from '../api/use-clusters-api';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Messages} from 'components/messages';\n+import {SectionToolbar} from 'components/section-toolbar/section-toolbar';\n+import {FormulaFormContext, FormulaFormContextProvider, FormulaFormRenderer} from 'components/formulas/FormulaComponentGenerator';\n+import {Loading} from 'components/utils/Loading';\n+\n+import type {FormulaValuesType, FormulaContextType, ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+// TODO move this to FormulaComponentGenerator once its flow-ified\n+// type ValidatedFormulaType = {\n+//   errors: {\n+//     required: Array<string>,\n+//     invalid: Array<string>\n+//   },\n+//   values: {[string]: any}\n+// }\n+\n+type Props = {\n+  provider: string,\n+  title: string,\n+  values: ?FormulaValuesType,\n+  formula: string,\n+  context: ?FormulaContextType,\n+  onNext: (FormulaValuesType) => void,\n+  onPrev?: () => void,\n+  setMessages: (Array<MessageType>) => void\n+};\n+\n+const FormulaConfig = (props: Props) => {\n+    const [form, setForm] = useState<any>(null);\n+    const [formulaValues, setFormulaValues] = useState<?FormulaValuesType>(null);\n+    const {fetchProviderFormulaForm} = useClustersApi();\n+\n+    useEffect(() => {\n+      fetchProviderFormulaForm(props.provider, props.formula, props.context ? props.context : null).then(data => {\n+        setForm(data.form);\n+        if (data.params) {\n+          // merge params with props.values\n+          setFormulaValues(Object.assign({}, data.params, props.values)); // order is important\n+        } else if (props.values) {\n+          setFormulaValues(props.values);\n+        } else {\n+          setFormulaValues({})\n+        }\n+      })\n+      .catch((error : ErrorMessagesType) => {\n+        props.setMessages(error.messages);\n+      })\n+    }, []);\n+\n+    const clickNext = ({errors, values}) => {\n+      if (errors) {\n+        const messages = [];\n+        if (errors.required && errors.required.length > 0) {\n+            messages.push(Messages.error(t(\"Please input required fields: {0}\", errors.required.join(', '))));\n+        }\n+        if (errors.invalid && errors.invalid.length > 0) {\n+            messages.push(Messages.error(t(\"Invalid format of fields: {0}\", errors.invalid.join(', '))));\n+        }\n+        props.setMessages(messages);\n+      } else {\n+        props.onNext(values);\n+      }\n+    }\n+\n+    return (form && formulaValues ? \n+              <FormulaFormContextProvider layout={form}\n+                systemData={formulaValues ? formulaValues : {}}\n+                groupData={{}}\n+                scope=\"system\">\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                          <FormulaFormContext.Consumer>\n+                            {({validate}) => \n+                                <div className=\"btn-group\">\n+                                  {props.onPrev ? <Button\n+                                      id=\"btn-prev\"\n+                                      text={t(\"Prev\")}\n+                                      className=\"btn-default\"\n+                                      icon=\"fa-arrow-left\"\n+                                      handler={props.onPrev}\n+                                  /> : null}\n+                                  <Button id=\"btn-next\"\n+                                    icon=\"fa-arrow-right\"\n+                                    text={t(\"Next\")}\n+                                    className={\"btn-success\"}\n+                                    handler={() => {clickNext(validate())}} />\n+                                </div>\n+                            }\n+                          </FormulaFormContext.Consumer>\n+                    }>\n+                      <SectionToolbar>\n+                        <div className='action-button-wrapper'>\n+                          <div className='btn-group'>\n+                            <FormulaFormContext.Consumer>\n+                              {({clearValues}) => \n+                                <Button id=\"reset-btn\" icon=\"fa-eraser\" text=\"Clear values\"\n+                                  className=\"btn btn-default\"\n+                                  handler={() => clearValues(() => window.confirm(\"Are you sure you want to clear all values?\"))} />\n+                              }\n+                            </FormulaFormContext.Consumer>\n+                          </div>\n+                        </div>    \n+                      </SectionToolbar>\n+                      <div style={{marginTop: \"15px\"}}>\n+                        <FormulaFormRenderer />\n+                      </div>\n+                  </Panel>\n+                </FormulaFormContextProvider>\n+                :\n+                  <Panel\n+                    headingLevel=\"h4\"\n+                    title={props.title}\n+                    footer={\n+                      <div className=\"btn-group\">\n+                        <Button\n+                            id=\"btn-prev\"\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTIxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            text={t(\"Prev\")}\n          \n          \n            \n                                            text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435475217", "createdAt": "2020-06-04T18:43:46Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/schedule-cluster-action.js", "diffHunk": "@@ -0,0 +1,86 @@\n+// @flow\n+import * as React from 'react';\n+import {useState} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {AsyncButton, Button} from 'components/buttons';\n+import {ActionLink, ActionChainLink} from 'components/links';\n+import {ActionSchedule} from 'components/action-schedule';\n+import Functions from 'utils/functions';\n+import {withErrorMessages}  from '../api/use-clusters-api';\n+import useUserLocalization from 'core/user-localization/use-user-localization';\n+import {Messages} from 'components/messages';\n+\n+import type {ActionChain} from \"components/action-schedule\";\n+import type {ErrorMessagesType} from '../api/use-clusters-api';\n+import type {MessageType} from 'components/messages';\n+\n+declare var actionChains: Array<ActionChain>;\n+\n+type Props = {\n+    title: string,\n+    panel: React.Node,\n+    schedule: (earliest: Date, actionChain: ?string) => Promise<any>,\n+    onPrev?: () =>  void,\n+    setMessages: (Array<MessageType>) => void,\n+    scheduleButtonLabel: string\n+};\n+\n+const ScheduleClusterAction = (props: Props) => {\n+    const {timezone, localTime} = useUserLocalization();\n+\n+    const [actionChain, setActionChain] = useState<?ActionChain>(null);\n+    const [earliest, setEarliest] = useState(Functions.Utils.dateWithTimezone(localTime));\n+    const [disableSchedule, setDisableSchedule] = useState(false);\n+\n+    const onSchedule = (): Promise<any> => {\n+        return props.schedule(earliest, actionChain ? actionChain.text: null).then(\n+            (actionId) => {\n+                // setDisableSchedule(true);\n+                const actionChainMsg = Messages.success(<span>{t(\"Action has been successfully added to the Action Chain \")}\n+                        <ActionChainLink id={actionId}>{actionChain ? actionChain.text : \"\"}</ActionChainLink>.</span>);\n+                const actionMsg = Messages.success(<span>{t(\"Action has been \")}\n+                          <ActionLink id={actionId}>{t(\"scheduled\")}</ActionLink>{t(\" successfully.\")}</span>);\n+                props.setMessages([actionChain ? actionChainMsg : actionMsg]);\n+            },\n+            (error: ErrorMessagesType) => {\n+                props.setMessages(error.messages);\n+            });\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={props.title}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        {\n+                            props.onPrev ? <Button\n+                                id=\"btn-prev\"\n+                                disabled={disableSchedule}\n+                                text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NTQwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        text={t(\"Prev\")}\n          \n          \n            \n                                        text={t(\"Back\")}", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435475402", "createdAt": "2020-06-04T18:44:01Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/shared/ui/select-server.js", "diffHunk": "@@ -0,0 +1,159 @@\n+// @flow\n+import React, {useState, useEffect} from 'react';\n+import {Panel} from 'components/panels/Panel';\n+import {Button} from 'components/buttons';\n+import {Table} from 'components/table/Table';\n+import {Column} from 'components/table/Column';\n+import {SearchField} from 'components/table/SearchField';\n+import {SystemLink} from 'components/links';\n+import {IconTag as Icon} from 'components/icontag';\n+import Functions from 'utils/functions';\n+import {withErrorMessages} from '../api/use-clusters-api';\n+\n+import type {MessageType} from 'components/messages';\n+import type {ErrorMessagesType, ServerType} from  '../api/use-clusters-api';\n+\n+type Props = {\n+    title: string,\n+    selectedServers: ?Array<ServerType>,\n+    onNext: (Array<ServerType>) => void,\n+    onPrev: () => void,\n+    setMessages: (Array<MessageType>) => void,\n+    fetchServers: () => Promise<Array<ServerType>>,\n+    multiple: boolean\n+};\n+\n+const SystemMessages = (props: {messages: Array<MessageType>}) => {\n+    return <ul style={{listStyle: 'none', paddingLeft: '0px', margin: '0px'}}>\n+        { props.messages.map(msg => \n+          <li>\n+            <Icon type=\"system-warn\" className=\"fa-1-5x\"/>{ msg.text }\n+          </li>)  \n+        }\n+        </ul>;\n+}\n+\n+const SelectServer = (props: Props) => {\n+    const [selections, setSelections] = useState<Set<number>>(props.selectedServers ? new Set(props.selectedServers.map(srv => srv.id)) : new Set());\n+    const [servers, setServers] = useState<Array<ServerType>>([]);\n+    const [fetching, setFetching] = useState<boolean>(false);\n+\n+    useEffect(() => {\n+        setFetching(true);\n+        props.fetchServers().then(data => {\n+            setServers(data);\n+            setSelections(new Set());\n+        })\n+        .catch((error : ErrorMessagesType) => {\n+            props.setMessages(error.messages);\n+        })\n+        .finally(() => {\n+            setFetching(false);\n+        });\n+    }, [])\n+\n+    const filterFunc = (row, criteria) => {\n+        const keysToSearch = ['name'];\n+        if (criteria) {\n+            return keysToSearch.map(key => row[key]).join().toLowerCase().includes(criteria.toLowerCase());\n+        }\n+        return true;\n+    };\n+\n+    const selectServers = (selections: Set<number>) => {\n+        const selectedServers = [];\n+        for (const srvId of selections) {\n+            const server = servers.find(srv => srv.id === srvId);\n+            if (server) {\n+                selectedServers.push(server);\n+            }\n+        }\n+        props.onNext(selectedServers);\n+    }\n+\n+    const onSelectServer = (event, id) => {\n+        let newSelections;\n+        if (props.multiple) {\n+            newSelections = new Set(selections);\n+            if (event.target.checked) {\n+                newSelections.add(id);\n+            } else {\n+                newSelections.delete(id);\n+            }\n+        }\n+        else {\n+            newSelections = new Set([id]);\n+        }\n+        setSelections(newSelections);\n+    }\n+\n+    return (<Panel\n+                headingLevel=\"h4\"\n+                title={props.title}\n+                footer={\n+                    <div className=\"btn-group\">\n+                        {props.onPrev ? <Button\n+                            id=\"btn-prev\"\n+                            text={t(\"Prev\")}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4Mjg4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 /**\n          \n          \n            \n                /**", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435482885", "createdAt": "2020-06-04T18:56:53Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -446,7 +453,7 @@ else if (layoutFileCustom.exists()) {\n         }\n     }\n \n-    /**\n+     /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab08f8e591253ab09ff397ac46e4f2ed31d2acef"}, "originalPosition": 78}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b245bb74972090589fe16795aefb98315e9f2d2", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8b245bb74972090589fe16795aefb98315e9f2d2", "committedDate": "2020-06-04T16:28:58Z", "message": "Show multiple toastr messages if input is array"}, "afterCommit": {"oid": "e246b839a56e58e6409c3553234ca3a0ce59b5c9", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e246b839a56e58e6409c3553234ca3a0ce59b5c9", "committedDate": "2020-06-05T08:59:27Z", "message": "Chore: announce changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTQyMjE3", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-425142217", "createdAt": "2020-06-05T09:29:26Z", "commit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyOToyN1rOGfnR4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxNjo0MlrOGfoz2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjU5Mw==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435802593", "createdAt": "2020-06-05T09:29:27Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterGroupRefreshNodes.sql", "diffHunk": "@@ -0,0 +1,31 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterGroupRefreshNodes (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclgrref_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclgrref_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclustergrn_aid_idx ON rhnActionClusterGroupRefreshNodes (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjY3Mw==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435802673", "createdAt": "2020-06-05T09:29:35Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterJoinNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterJoinNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclusterjn_aid_idx ON rhnActionClusterJoinNode (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjg3MA==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435802870", "createdAt": "2020-06-05T09:30:01Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterRemoveNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterRemoveNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclusterrn_aid_idx ON rhnActionClusterRemoveNode (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMzA2NQ==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435803065", "createdAt": "2020-06-05T09:30:21Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterServers.sql", "diffHunk": "@@ -0,0 +1,27 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterServers (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclsrvs_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    server_id           NUMERIC\n+                            CONSTRAINT rhn_actionclsrvs_sid_fk\n+                            REFERENCES rhnServer (id)\n+                            ON DELETE CASCADE\n+);\n+\n+CREATE UNIQUE INDEX rhn_action_cluster_srvs_idx", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDEzMg==", "bodyText": "Would it make sense to use \"TEXT\" here. AFAIK there is no changes in the hibernate schema needed for this.\nBut you do not have limits on the length.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804132", "createdAt": "2020-06-05T09:32:07Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterJoinNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterJoinNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actioncljoin_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDI0MA==", "bodyText": "Would it make sense to use \"TEXT\" here.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804240", "createdAt": "2020-06-05T09:32:18Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterRemoveNode.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterRemoveNode (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDQ3Nw==", "bodyText": "Would it make sense to use \"TEXT\" here.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804477", "createdAt": "2020-06-05T09:32:44Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterUpgradeCluster.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterUpgradeCluster (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclupgrade_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNDc4NQ==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435804785", "createdAt": "2020-06-05T09:33:19Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterUpgradeCluster.sql", "diffHunk": "@@ -0,0 +1,32 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterUpgradeCluster (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclupgrade_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclrmnode_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    json_params         VARCHAR(8192),\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL\n+)\n+;\n+\n+CREATE UNIQUE INDEX rhnactionclusteruc_aid_idx ON rhnActionClusterUpgradeCluster (action_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNTgxMw==", "bodyText": "I think this does not work. In postgresql an empty string is the same as NULL. So we have a rule that \"NOT NULL\" columns do not allow empty string. Please check, I wonder why this does not create problems.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435805813", "createdAt": "2020-06-05T09:35:15Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) NOT NULL DEFAULT '',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNzQwNA==", "bodyText": "\"unique\" indexes have the suffix _uq for the constraints names. \"_idx\" is used for normal indexes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435807404", "createdAt": "2020-06-05T09:38:09Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) NOT NULL DEFAULT '',\n+    provider    VARCHAR(50) NOT NULL,\n+    management_node_id  NUMERIC\n+                        CONSTRAINT suse_clusters_mgmt_node_fk\n+                        REFERENCES rhnServer (id)\n+                        ON DELETE SET NULL,\n+    group_id    NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_group_fk\n+                    REFERENCES rhnServerGroup (id),\n+    created     TIMESTAMPTZ\n+                     DEFAULT (current_timestamp) NOT NULL,\n+    modified    TIMESTAMPTZ\n+                     DEFAULT (current_timestamp) NOT NULL\n+);\n+\n+CREATE SEQUENCE suse_cluster_id_seq;\n+\n+CREATE UNIQUE INDEX suse_cluster_name_idx\n+    ON suseClusters (name);\n+\n+CREATE UNIQUE INDEX suse_cluster_label_idx\n+    ON suseClusters (label);\n+\n+CREATE UNIQUE INDEX suse_cluster_group_idx\n+    ON suseClusters (group_id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzY3Mg==", "bodyText": "Is order: last really needed? Can we use more require statements instead?\nThe reason is, that the only state where we use order: last is, updating and starting salt-minion.\nIf possible, please prevent this usage.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435827672", "createdAt": "2020-06-05T10:16:42Z", "author": {"login": "mcalmer"}, "path": "susemanager-utils/cluster-providers/caasp/caasp/kill_ssh_agent.sls", "diffHunk": "@@ -0,0 +1,8 @@\n+{%- if not salt['pillar.get']('params:use_ssh_agent') %}\n+mgr_caasp_kill_agent:\n+  module.run:\n+    - name: ssh_agent.kill\n+    - order: last", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTg0ODY5", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-425184869", "createdAt": "2020-06-05T10:32:59Z", "commit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDozMjo1OVrOGfpSnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDozMjo1OVrOGfpSnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzNTU0OQ==", "bodyText": "Is modified needed or used at all?\nYou do not have a trigger configured and I am unsure if the java hibernate part is adapting it automatically.\nAFAIK not as this was only possible with annotations.\nThis apply to all these Action classes.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435835549", "createdAt": "2020-06-05T10:32:59Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/rhnActionClusterGroupRefreshNodes.sql", "diffHunk": "@@ -0,0 +1,31 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE rhnActionClusterGroupRefreshNodes (\n+    action_id           NUMERIC NOT NULL\n+                            CONSTRAINT rhn_actionclgrref_aid_fk\n+                            REFERENCES rhnAction (id)\n+                            ON DELETE CASCADE,\n+    cluster_id          NUMERIC\n+                            CONSTRAINT rhn_actionclgrref_cluster_fk\n+                            REFERENCES suseClusters (id)\n+                            ON DELETE CASCADE,\n+    created             TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n+    modified            TIMESTAMPTZ\n+                            DEFAULT (CURRENT_TIMESTAMP) NOT NULL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MjA0NzM2", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-425204736", "createdAt": "2020-06-05T11:06:36Z", "commit": {"oid": "ab08f8e591253ab09ff397ac46e4f2ed31d2acef"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxMDo1MVrOGfqUQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1MTozNVrOGftOQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MjM1NA==", "bodyText": "Can be exported into a separate method", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435852354", "createdAt": "2020-06-05T11:10:51Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -499,8 +506,40 @@ else if (layoutFileCustom.exists()) {\n                 groupId + \"_\" + name + \".\" + PILLAR_FILE_EXTENSION);\n         try {\n             if (dataFile.exists()) {\n-                return Optional.of((Map<String, Object>) GSON.fromJson(\n-                        new BufferedReader(new FileReader(dataFile)), Map.class));\n+                Map<String, Object> data = (Map<String, Object>) GSON.fromJson(\n+                        new BufferedReader(new FileReader(dataFile)), Map.class);\n+\n+                if (formulaHasType(name, \"cluster-formula\")) {\n+                    // find cluster for this group\n+                    Optional<Cluster> cluster = ClusterFactory.findClusterByGroupId(groupId);\n+                    if (cluster.isPresent()) {\n+                        // load cluster provider metadata and look for the key of this formula\n+                        Map<String, Object> metadata = getClusterProviderMetadata(cluster.get().getProvider());\n+                        Map<String, Object> formulas = (Map<String, Object>) metadata.get(\"formulas\");\n+                        Optional<String> formulaKey = formulas.entrySet().stream()\n+                                .filter(e -> e.getValue() instanceof Map)\n+                                .filter(e -> ((Map) e.getValue()).get(\"name\").equals(name))\n+                                .map(e -> e.getKey())\n+                                .findFirst();\n+                        if (formulaKey.isPresent()) {\n+                            // return values under mgr_clusters:<cluster-name>:<formula-key>\n+                            return getValueByPath(data,\n+                                    \"mgr_clusters:\" + cluster.get().getLabel() + \":\" + formulaKey.get())\n+                                    .filter(Map.class::isInstance)\n+                                    .map(Map.class::cast);\n+                        }\n+                        else {\n+                            return Optional.empty();\n+                        }\n+                    }\n+                    else {\n+                        return Optional.empty();\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NDE5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param keyType the Java type of the value\n          \n          \n            \n                 * @param <T> the Java type of the value\n          \n          \n            \n                 * @return the value of the metadata key\n          \n          \n            \n                 */\n          \n          \n            \n                public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n          \n          \n            \n                    Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n          \n          \n            \n                    return FormulaFactory.getValueByPath(metadata, key)\n          \n          \n            \n                            .filter(keyType::isInstance)\n          \n          \n            \n                            .map(keyType::cast);\n          \n          \n            \n                 * @param valueType the Java type of the value\n          \n          \n            \n                 * @param <T> the Java type of the value\n          \n          \n            \n                 * @return the value of the metadata key\n          \n          \n            \n                 */\n          \n          \n            \n                public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> valueType) {\n          \n          \n            \n                    Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n          \n          \n            \n                    return FormulaFactory.getValueByPath(metadata, key)\n          \n          \n            \n                            .filter(valueType::isInstance)\n          \n          \n            \n                            .map(valueType::cast);", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435854199", "createdAt": "2020-06-05T11:15:05Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjMwOA==", "bodyText": "Does it make sense to continue execution in this case? Otherwise maybe just throw a RuntimeException?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435856308", "createdAt": "2020-06-05T11:20:11Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);\n+    }\n+\n+    /**\n+     * Get a formula layout from a cluster provider. The formula is referenced by its key not by it's actual name.\n+     * @param provider the name of the cluster provider\n+     * @param formulaKey the key of the formula used by the provider\n+     * @return the formula layout as a Map\n+     */\n+    public static Optional<Map<String, Object>> getClusterProviderFormulaLayout(String provider, String formulaKey) {\n+        Map<String, Object> metadata = getClusterProviderMetadata(provider);\n+        Optional<String> formulaName = getValueByPath(metadata, \"formulas:\" + formulaKey + \":name\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast);\n+\n+        String formulaSource = getValueByPath(metadata, \"formulas:\" + formulaKey + \":source\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .orElse(\"system\");\n+\n+        if (formulaName.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (\"system\".equals(formulaSource)) {\n+            return getFormulaLayoutByName(formulaName.get());\n+        }\n+        else if (\"cluster-provider\".equals(formulaSource)) {\n+            return getFormulaLayoutByClusterProviderAndName(provider, formulaName.get());\n+        }\n+        else {\n+            throw new RuntimeException(\"Unknown formula source \" + formulaSource);\n+        }\n+    }\n+\n+    private static Optional<Map<String, Object>> getFormulaLayoutByClusterProviderAndName(String provider,\n+                                                                                          String name) {\n+        Path layoutFile = Paths.get(METADATA_DIR_CLUSTER_PROVIDERS, provider, name + \".yml\");\n+        try {\n+            if (Files.exists(layoutFile)) {\n+                return Optional.of((Map<String, Object>) YAML.load(new FileInputStream(layoutFile.toFile())));\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        catch (FileNotFoundException | YAMLException e) {\n+            LOG.error(\"Error loading layout for formula '\" + name +\n+                    \"' from cluster provider '\" + provider + \"'\", e);\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NzE3Nw==", "bodyText": "Also here, maybe throw a RuntimeException so it propagates to the UI?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435857177", "createdAt": "2020-06-05T11:22:22Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);\n+    }\n+\n+    /**\n+     * Get a formula layout from a cluster provider. The formula is referenced by its key not by it's actual name.\n+     * @param provider the name of the cluster provider\n+     * @param formulaKey the key of the formula used by the provider\n+     * @return the formula layout as a Map\n+     */\n+    public static Optional<Map<String, Object>> getClusterProviderFormulaLayout(String provider, String formulaKey) {\n+        Map<String, Object> metadata = getClusterProviderMetadata(provider);\n+        Optional<String> formulaName = getValueByPath(metadata, \"formulas:\" + formulaKey + \":name\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast);\n+\n+        String formulaSource = getValueByPath(metadata, \"formulas:\" + formulaKey + \":source\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .orElse(\"system\");\n+\n+        if (formulaName.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (\"system\".equals(formulaSource)) {\n+            return getFormulaLayoutByName(formulaName.get());\n+        }\n+        else if (\"cluster-provider\".equals(formulaSource)) {\n+            return getFormulaLayoutByClusterProviderAndName(provider, formulaName.get());\n+        }\n+        else {\n+            throw new RuntimeException(\"Unknown formula source \" + formulaSource);\n+        }\n+    }\n+\n+    private static Optional<Map<String, Object>> getFormulaLayoutByClusterProviderAndName(String provider,\n+                                                                                          String name) {\n+        Path layoutFile = Paths.get(METADATA_DIR_CLUSTER_PROVIDERS, provider, name + \".yml\");\n+        try {\n+            if (Files.exists(layoutFile)) {\n+                return Optional.of((Map<String, Object>) YAML.load(new FileInputStream(layoutFile.toFile())));\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        catch (FileNotFoundException | YAMLException e) {\n+            LOG.error(\"Error loading layout for formula '\" + name +\n+                    \"' from cluster provider '\" + provider + \"'\", e);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Checks the type of the formula.\n+     * @param formula the name of the formula\n+     * @param type the type\n+     * @return whether the formula has the given type or not\n+     */\n+    public static boolean formulaHasType(String formula, String type) {\n+        Map<String, Object> metadata = getMetadata(formula);\n+        return Optional.ofNullable(metadata.get(\"type\"))\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .map(t -> t.equals(type))\n+                .orElse(false);\n+    }\n+\n+\n+    /**\n+     * Get the value from a nested map structure by a colon separated path.\n+     * E.g. key1:key2:key3 for a map with a depth of 3.\n+     * @param data the nested map\n+     * @param path the path\n+     * @return a value if available\n+     */\n+    public static Optional<Object> getValueByPath(Map<String, Object> data, String path) {\n+        String[] tokens = StringUtils.split(path, \":\");\n+        Map<String, Object> current = data;\n+        for (int i = 0; i < tokens.length; i++) {\n+            String token = tokens[i];\n+            Object val = current.get(token);\n+            if (i == tokens.length - 1) {\n+                return Optional.ofNullable(val);\n+            }\n+            if (val == null) {\n+                return Optional.empty();\n+            }\n+            if (val instanceof Map) {\n+                current = (Map<String, Object>)val;\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers.\n+     * @return a list containing the metadata of all installed cluster providers\n+     */\n+    public static List<Map<String, Object>> getClusterProvidersMetadata() {\n+        Path dir = Path.of(METADATA_DIR_CLUSTER_PROVIDERS);\n+        try {\n+            return Files.list(dir)\n+                    .filter(Files::isDirectory)\n+                    .map(p -> {\n+                        String provider = p.getFileName().toString();\n+                        Map<String, Object> m = getClusterProviderMetadata(provider);\n+                        m = new HashMap<>(m);\n+                        m.put(\"label\", provider);\n+                        return m;\n+                    })\n+                    .collect(Collectors.toList());\n+        }\n+        catch (IOException e) {\n+            LOG.error(\"Error loading providers metadata\", e);\n+            return Collections.emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bef3086ed1232b6f6343df22ec53ad91f189ba2"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MTk1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435891953", "createdAt": "2020-06-05T12:36:12Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MjY3OQ==", "bodyText": "We should use LocalizationService here", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435892679", "createdAt": "2020-06-05T12:37:45Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDcyNQ==", "bodyText": "If possible, the whole thing should be done in a single DB transaction", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435894725", "createdAt": "2020-06-05T12:41:40Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NTE4Mw==", "bodyText": "If possible, the whole thing should be done in a single DB transaction", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435895183", "createdAt": "2020-06-05T12:42:35Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjgzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435896836", "createdAt": "2020-06-05T12:45:36Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 458}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NzU4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                },\n          \n          \n            \n                                        () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));\n          \n          \n            \n                                    },\n          \n          \n            \n                                    () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435897588", "createdAt": "2020-06-05T12:46:59Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 479}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5OTk3MA==", "bodyText": "It's better the use ClusterFactory.findClusterByIdAndOrg() instead.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435899970", "createdAt": "2020-06-05T12:51:35Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));\n+\n+            Map<String, Object> otherValues = context.entrySet().stream()\n+                    .filter(e -> !e.getKey().equals(\"nodes\") &&\n+                            !e.getKey().equals(\"cluster\") &&\n+                            !e.getKey().equals(\"cluster_settings\"))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            ctx.putAll(otherValues);\n+\n+            evalFormInitialData(initialData, \"\", formulaData.get(), ctx);\n+\n+            initialData.putAll(otherValues);\n+        }\n+        else {\n+            initialData.putAll(context);\n+        }\n+        return initialData;\n+    }\n+\n+    /**\n+     * Public for unit tests\n+     * @param out\n+     * @param dataKey\n+     * @param data\n+     * @param context\n+     */\n+    public void evalFormInitialData(Map out, String dataKey, Map<String, Object> data, Map<String, Object> context) {\n+            Map<String, Object> map = (Map<String, Object>)data;\n+            if (\"edit-group\".equals(map.get(\"$type\"))) {\n+                String valueExpr = (String)map.get(\"$value\");\n+                String itemName = (String)map.get(\"$item\");\n+                Map<String, Object> prototype = (Map<String, Object>)map.get(\"$prototype\");\n+                Object value = evalExpression(valueExpr, context);\n+                if (value instanceof Collection) {\n+                    List<Map<String, Object>> items = new LinkedList<>();\n+                    out.put(dataKey, items);\n+                    for (var item : ((Collection)value)) {\n+                        Map<String, Object> itemVal = new HashMap<>();\n+                        prototype.forEach((key, valExpr) -> {\n+                            Map<String, Object> valCtx = new HashMap<>();\n+                            valCtx.putAll(context);\n+                            valCtx.put(itemName, item);\n+                            if (valExpr instanceof String) {\n+                                Object val = evalExpression((String)valExpr, valCtx);\n+                                itemVal.put((String)key, val);\n+                            }\n+                            else if (valExpr instanceof Map) {\n+                                Map nestedVal = new HashMap();\n+                                evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, valCtx);\n+                                itemVal.putAll(nestedVal);\n+                            }\n+\n+                        });\n+                        items.add(itemVal);\n+                    }\n+                }\n+                else {\n+                    throw new RuntimeException(\"$value for edit-group doesn't evaluate to a collection\");\n+                }\n+            }\n+            else {\n+                map.forEach((key, valExpr) -> {\n+                    if (valExpr instanceof String) {\n+                        Object val = evalExpression((String) valExpr, context);\n+                        out.put(key, val);\n+                    }\n+                    else if (valExpr instanceof Map) {\n+                        Map nestedVal = new HashMap();\n+                        evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, context);\n+                        out.putAll(nestedVal);\n+                    }\n+                });\n+            }\n+    }\n+\n+    /**\n+     * Get state hooks for cluster provider.\n+     * @param provider cluster provider label\n+     * @return state hooks as Map (if any)\n+     */\n+    public Optional<Map<String, List<String>>> getStateHooks(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"state_hooks\", Map.class)\n+                .map(m -> (Map<String, List<String>>)m);\n+\n+    }\n+\n+    /**\n+     * Get the details fields to show for each cluster node.\n+     * @param provider cluster provider label\n+     * @return detail fields to show (if any)\n+     */\n+    public Optional<List<String>> getNodesListFields(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"ui:nodes_list:fields\", List.class)\n+                .map(l -> (List<String>)l);\n+    }\n+\n+    /**\n+     * Update cluster name and description.\n+     * @param cluster cluster\n+     * @param name new name\n+     * @param description new description\n+     */\n+    public void update(Cluster cluster, String name, String description) {\n+        cluster.setName(name);\n+        cluster.setDescription(description);\n+        getSession().save(cluster);\n+        cluster.getGroup().setName(getGroupName(name));\n+        cluster.getGroup().setDescription(getGroupDescription(name));\n+        ServerGroupFactory.save(cluster.getGroup());\n+    }\n+\n+    private String getGroupName(String clusterName) {\n+        return \"Cluster \" + clusterName;\n+    }\n+\n+    private String getGroupDescription(String clusterName) {\n+        return \"Group for cluster \" + clusterName;\n+    }\n+\n+    /**\n+     * Find a cluster by id and user. Checks if the cluster is in the same org as the user.\n+     * @param id cluster ir\n+     * @param user user\n+     * @return the cluster if found\n+     */\n+    public Optional<Cluster> findClusterByIdAndUser(Long id, User user) {\n+        return ClusterFactory.findClusterById(id)\n+                .filter(c -> c.getOrg().equals(user.getOrg()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800b8cd852916c9933548fb77c1dcf6fea4938f8"}, "originalPosition": 607}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MzgwMjk5", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-425380299", "createdAt": "2020-06-05T15:00:59Z", "commit": {"oid": "53830960e55d26fd07176ed605b701f928c4c51e"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTowMDo1OVrOGfyImA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNToxMjoxNVrOGfyiXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4MDQ0MA==", "bodyText": "I think this is enough after the .filter() call\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(node => node.server ? node.server.id : 0),\n          \n          \n            \n                                .map(node => node.server.id),", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435980440", "createdAt": "2020-06-05T15:00:59Z", "author": {"login": "cbbayburt"}, "path": "web/html/src/manager/clusters/remove-node/remove-node.js", "diffHunk": "@@ -0,0 +1,88 @@\n+// @flow\n+import {hot} from 'react-hot-loader';\n+import React, {useState}  from 'react';\n+import {TopPanel} from \"components/panels/TopPanel\";\n+import {HashRouter, Route, Switch} from 'components/utils/HashRouter';\n+import withPageWrapper from 'components/general/with-page-wrapper';\n+import useClustersApi, {withErrorMessages} from '../shared/api/use-clusters-api';\n+import ScheduleClusterAction from '../shared/ui/schedule-cluster-action';\n+import {SystemLink} from 'components/links';\n+import FormulaConfig from '../shared/ui/formula-config';\n+\n+import type {ClusterType, FormulaValuesType, ClusterNodeType} from '../shared/api/use-clusters-api';\n+\n+type Props = {\n+  cluster: ClusterType,\n+  nodes: Array<ClusterNodeType>,\n+  serverId: ?number,\n+  flashMessage: string,\n+};\n+\n+const RemoveNode = (props: Props) => {\n+    const [removeConfig, setRemoveConfig] = useState<?FormulaValuesType>(null);\n+    const {scheduleRemoveNode} = useClustersApi();\n+\n+    const scheduleRemove = (earliest: Date, actionChain: ?string): Promise<any> => {\n+        if (removeConfig) {\n+            return scheduleRemoveNode(props.cluster.id,\n+                 props.nodes\n+                    .filter(node => node.server ? true : false)\n+                    .map(node => node.server ? node.server.id : 0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53830960e55d26fd07176ed605b701f928c4c51e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NzAzOA==", "bodyText": "We should also make sure that the name/label does not exist (both here and in React).\nOtherwise, the process reports a confusing error about a duplicate system group name. We should explicitly tell the user that a cluster with this name already exists.", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435987038", "createdAt": "2020-06-05T15:12:15Z", "author": {"login": "cbbayburt"}, "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -274,24 +284,109 @@ private static ModelAndView showClusterUpgrade(Request request, Response respons\n         return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n     }\n \n+    private static class AddClusterRequest {\n+        private String name;\n+        private String label;\n+        private String description;\n+        private String provider;\n+        private Long managementNodeId;\n+        private Map<String, Object> managementSettings;\n+\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return label to get\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+\n+        /**\n+         * @return provider to get\n+         */\n+        public String getProvider() {\n+            return provider;\n+        }\n+\n+        /**\n+         * @return managementNodeId to get\n+         */\n+        public Long getManagementNodeId() {\n+            return managementNodeId;\n+        }\n+\n+        /**\n+         * @return managementSettings to get\n+         */\n+        public Map<String, Object> getManagementSettings() {\n+            return managementSettings;\n+        }\n+    }\n+\n     private static String addCluster(Request request, Response response, User user) {\n-        Optional<Map<String, Object>> json = parseJson(request, response);\n-        if (json.isEmpty()) {\n+        AddClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), AddClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n             return json(response, HttpStatus.SC_BAD_REQUEST,\n-                    ResultJson.error(\"request_error\"));\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+\n+        if (StringUtils.isBlank(clusterRequest.getName())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Name is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getLabel())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label is mandatory\"));\n+        }\n+\n+        if (!LABEL_REGEX.matcher(clusterRequest.getLabel()).matches()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label format is wrong\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getDescription())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Description is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Provider is mandatory\"));\n+        }\n+        if (!validProvider(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Invalid provider\"));\n+        }\n+        if (clusterRequest.getManagementNodeId() == null) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management node id is mandatory\"));\n+        }\n+        if (clusterRequest.getManagementSettings() == null ||\n+                clusterRequest.getManagementSettings().isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management settings are mandatory\"));\n         }\n \n-        // TODO validate input", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0301dddf87387a290cf76d26444870bfab3e3d0"}, "originalPosition": 262}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e3a1455ed7c5ece503b443f62dd85518c3a74216", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e3a1455ed7c5ece503b443f62dd85518c3a74216", "committedDate": "2020-06-05T18:38:47Z", "message": "Validate cluster name and label on add"}, "afterCommit": {"oid": "0a87e1d16a889501664c7aa5f036cb5fadb4141e", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/0a87e1d16a889501664c7aa5f036cb5fadb4141e", "committedDate": "2020-06-05T20:14:28Z", "message": "Feat: handler for clusters"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODE4MzE0", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-425818314", "createdAt": "2020-06-07T13:04:38Z", "commit": {"oid": "59a8ab144fba08cec9b7880690c19a0190794faf"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzowNDozOFrOGgJYCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzoxNDoyOVrOGgJbZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTIyNA==", "bodyText": "wrong year", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436361224", "createdAt": "2020-06-07T13:04:38Z", "author": {"login": "mcalmer"}, "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/NoSuchClusterException.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright (c) 2017 SUSE LLC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59a8ab144fba08cec9b7880690c19a0190794faf"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTY1Mg==", "bodyText": "Is it wanted to not have an ON DELETE statement here?", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436361652", "createdAt": "2020-06-07T13:09:34Z", "author": {"login": "mcalmer"}, "path": "schema/spacewalk/common/tables/suseClusters.sql", "diffHunk": "@@ -0,0 +1,48 @@\n+-- Copyright (c) 2020 SUSE LLC\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+CREATE TABLE suseClusters (\n+    id          NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_id_pk PRIMARY KEY,\n+    org_id      NUMERIC NOT NULL\n+                    CONSTRAINT rhn_server_oid_fk\n+                    REFERENCES web_customer (id)\n+                    ON DELETE CASCADE,\n+    label       VARCHAR(256) NOT NULL,\n+    name        VARCHAR(256) NOT NULL,\n+    description VARCHAR(4096) DEFAULT '',\n+    provider    VARCHAR(50) NOT NULL,\n+    management_node_id  NUMERIC\n+                        CONSTRAINT suse_clusters_mgmt_node_fk\n+                        REFERENCES rhnServer (id)\n+                        ON DELETE SET NULL,\n+    group_id    NUMERIC NOT NULL\n+                    CONSTRAINT suse_clusters_group_fk\n+                    REFERENCES rhnServerGroup (id),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59a8ab144fba08cec9b7880690c19a0190794faf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MjA4Ng==", "bodyText": "ok", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436362086", "createdAt": "2020-06-07T13:14:29Z", "author": {"login": "mcalmer"}, "path": "susemanager-utils/cluster-providers/caasp/caasp/kill_ssh_agent.sls", "diffHunk": "@@ -0,0 +1,8 @@\n+{%- if not salt['pillar.get']('params:use_ssh_agent') %}\n+mgr_caasp_kill_agent:\n+  module.run:\n+    - name: ssh_agent.kill\n+    - order: last", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzY3Mg=="}, "originalCommit": {"oid": "af48d2bc9beaaea86885e30d04f6ba50c56eb55a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17254afee3251655488327e5be52181491c06fbb", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/17254afee3251655488327e5be52181491c06fbb", "committedDate": "2020-06-08T11:59:32Z", "message": "Chore: prereq: ES6 export style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae9d4b94fb8fb2431a65ac4790800aeb892faf74", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ae9d4b94fb8fb2431a65ac4790800aeb892faf74", "committedDate": "2020-06-08T11:59:32Z", "message": "Chore: copy pillar modules with Ant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd92784393a3da2f988efe0be8614fadbb6d175e", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/bd92784393a3da2f988efe0be8614fadbb6d175e", "committedDate": "2020-06-08T11:59:32Z", "message": "Feat: UI: cluster menu and fonts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde9424d41e0006e5db92d550a4a0e566c3b47bf", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/cde9424d41e0006e5db92d550a4a0e566c3b47bf", "committedDate": "2020-06-08T11:59:32Z", "message": "Feat: UI: add cluster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "029f352b05055e406a93cd863bba89f1aebfe841", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/029f352b05055e406a93cd863bba89f1aebfe841", "committedDate": "2020-06-08T11:59:32Z", "message": "Feat: backend: add cluster_admin role"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbdf21a19d2e8aded8bd939cc05ff599bf317359", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/cbdf21a19d2e8aded8bd939cc05ff599bf317359", "committedDate": "2020-06-08T11:59:32Z", "message": "Feat: backend: cluster model (db + POJOs)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa9960aa290c66eb370fcf3637124c754959fa2a", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/aa9960aa290c66eb370fcf3637124c754959fa2a", "committedDate": "2020-06-08T11:59:32Z", "message": "Feat: backend: brokers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32599561bba0ed25a97cc30f55b3b0052bef25e2", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/32599561bba0ed25a97cc30f55b3b0052bef25e2", "committedDate": "2020-06-08T11:59:32Z", "message": "Feat: backend: formula provider utils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "033cd7a647ba3fdc69faaa46337ac7c49137a389", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/033cd7a647ba3fdc69faaa46337ac7c49137a389", "committedDate": "2020-06-08T11:59:32Z", "message": "Feat: Salt: CaaSP cluster provider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fb41c23ad90f3bedb75418c893aca3cb61e7306", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4fb41c23ad90f3bedb75418c893aca3cb61e7306", "committedDate": "2020-06-08T11:59:33Z", "message": "Feat: backend+UI: base cluster actions definition"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9be3ce4fa968a58783558afb4ea21040c6c5db4", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/c9be3ce4fa968a58783558afb4ea21040c6c5db4", "committedDate": "2020-06-08T11:57:47Z", "message": "Flowtype errs fixes"}, "afterCommit": {"oid": "9e8c519c47031a862f35a4d48d01c1a524aee3c5", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/9e8c519c47031a862f35a4d48d01c1a524aee3c5", "committedDate": "2020-06-08T12:00:31Z", "message": "Flowtype errs fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MTYxNTgz", "url": "https://github.com/uyuni-project/uyuni/pull/2070#pullrequestreview-426161583", "createdAt": "2020-06-08T12:06:58Z", "commit": {"oid": "9e8c519c47031a862f35a4d48d01c1a524aee3c5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e14d879c7c2805e464443ee6fa62a5fdaf2f78b", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4e14d879c7c2805e464443ee6fa62a5fdaf2f78b", "committedDate": "2020-06-08T12:27:53Z", "message": "Feat: backend: cluster manager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfe2e6ce5ba25a949a60bc52a73fd7d1633ea86f", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/cfe2e6ce5ba25a949a60bc52a73fd7d1633ea86f", "committedDate": "2020-06-08T12:27:53Z", "message": "Feat: backend: cluster list nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f29383012e581da3ee3de21dccad91250b4e5c3", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3f29383012e581da3ee3de21dccad91250b4e5c3", "committedDate": "2020-06-08T12:27:53Z", "message": "Feat: backend: cluster refresh system group action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4f19ff7d0399e70afd76db1e304718671dd96fb", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a4f19ff7d0399e70afd76db1e304718671dd96fb", "committedDate": "2020-06-08T12:27:53Z", "message": "Feat: backend: cluster join node action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f6a0ab415d22e13cf45cb168161fd9190f665cb", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/5f6a0ab415d22e13cf45cb168161fd9190f665cb", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: backend: cluster remove node action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dece145242d6b6b71ea350c793d65a2c9f55121f", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/dece145242d6b6b71ea350c793d65a2c9f55121f", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: backend: cluster upgrade action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fee75ef3bb741acfe24ace85fd9d455f6d64f73", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8fee75ef3bb741acfe24ace85fd9d455f6d64f73", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: UI: cluster join node action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd6b1c6964e35b1aaed9fa93def40165a029a0cb", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/fd6b1c6964e35b1aaed9fa93def40165a029a0cb", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: UI: cluster remove node action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94e32c270b2224c73567ac625f42cf6a532e7440", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/94e32c270b2224c73567ac625f42cf6a532e7440", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: UI: cluster upgrade action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe1f0d4ef4b2cb91cf4ce03dadf623c24df8f167", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/fe1f0d4ef4b2cb91cf4ce03dadf623c24df8f167", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: UI: validation and cluster_admin role checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62b5e45c6a2e5192f8040e6e8777a3a5b0e91830", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/62b5e45c6a2e5192f8040e6e8777a3a5b0e91830", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: UI: show multiple toastr messages if input is array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b821598261dee8c8fde629c7b00afe649a41ac7", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/5b821598261dee8c8fde629c7b00afe649a41ac7", "committedDate": "2020-06-08T12:27:54Z", "message": "Chore: update tables deps"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab3598e68555b46310ebb0ab1afb391aa2460f0d", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ab3598e68555b46310ebb0ab1afb391aa2460f0d", "committedDate": "2020-06-08T12:27:54Z", "message": " Chore: require jexl in spacewalk-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24d178b5a0aab388b5e57fedddc888ed98cb8d70", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/24d178b5a0aab388b5e57fedddc888ed98cb8d70", "committedDate": "2020-06-08T12:27:54Z", "message": "Chore: announce changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4910ca171e2b3c7b3cf361a9ffbef19a4d90f0b", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/a4910ca171e2b3c7b3cf361a9ffbef19a4d90f0b", "committedDate": "2020-06-08T12:27:54Z", "message": "HashRouter component fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e08b0c0794abb4485f93b3dd1c50142a042dce11", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e08b0c0794abb4485f93b3dd1c50142a042dce11", "committedDate": "2020-06-08T12:27:54Z", "message": "DB schema fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9867610bd9998e7e06c15b17189a2d8d8a5646ed", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/9867610bd9998e7e06c15b17189a2d8d8a5646ed", "committedDate": "2020-06-08T12:27:54Z", "message": "Cluster UI fixes after review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca02c307076d7e0963d22e5b0ef37c75522cf347", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ca02c307076d7e0963d22e5b0ef37c75522cf347", "committedDate": "2020-06-08T12:27:54Z", "message": "Drop modified column from action cluster tables and add trigger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9a976074fdd5de85519a182b215274e2e130ae3", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e9a976074fdd5de85519a182b215274e2e130ae3", "committedDate": "2020-06-08T12:27:54Z", "message": "Fix cluster menu tree selection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fe3e9f0d698cc2fab499c18a1eebbeab639857e", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7fe3e9f0d698cc2fab499c18a1eebbeab639857e", "committedDate": "2020-06-08T12:27:54Z", "message": "Expose caasp version in the list of cluster nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0de2ba68b5f35c8878f197074c2cc8e25df1123", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f0de2ba68b5f35c8878f197074c2cc8e25df1123", "committedDate": "2020-06-08T12:27:54Z", "message": "Feat: handler for clusters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1033f775e1d870bc731c098b5091e82e57b145b3", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/1033f775e1d870bc731c098b5091e82e57b145b3", "committedDate": "2020-06-08T12:27:54Z", "message": "Fix DangerDialog button style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7270c049c7dc1d67c3b3716813c16083ed5307b", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/e7270c049c7dc1d67c3b3716813c16083ed5307b", "committedDate": "2020-06-08T12:27:54Z", "message": "Revert refactoring of messages.js"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ee4bc129f4393d63d2a40e3fdeff4d33ec0752f", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/4ee4bc129f4393d63d2a40e3fdeff4d33ec0752f", "committedDate": "2020-06-08T12:27:54Z", "message": "Disable deleting the cluster group"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "161afc4059db963cbd5c20cea2bffea409002f51", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/161afc4059db963cbd5c20cea2bffea409002f51", "committedDate": "2020-06-08T12:27:54Z", "message": "Show kublet version in cluster nodes list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a203348e43b01f30228cf8743a5e734e77fb3a5", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/8a203348e43b01f30228cf8743a5e734e77fb3a5", "committedDate": "2020-06-08T12:27:54Z", "message": "Fix usage of ssh_auth_sock when applying the cluster upgrade state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c5ddd0fad3389ed3ab08c1e8f8d6e89dc903f15", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/3c5ddd0fad3389ed3ab08c1e8f8d6e89dc903f15", "committedDate": "2020-06-08T12:27:54Z", "message": "Store cluster action result as yaml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7df87c5775ca712d498fa268a37a127391fba141", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/7df87c5775ca712d498fa268a37a127391fba141", "committedDate": "2020-06-08T12:27:54Z", "message": "Copyright year"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3ab62debaf5385111dd01c86d0643e57c3174d1", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/f3ab62debaf5385111dd01c86d0643e57c3174d1", "committedDate": "2020-06-08T12:27:55Z", "message": "Show message when group owned by cluster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca032fd114dab94eb11882c58563e3e1a8f5f90a", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ca032fd114dab94eb11882c58563e3e1a8f5f90a", "committedDate": "2020-06-08T12:27:55Z", "message": "Flowtype errs fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "108c9e2d0c005a0d980d91bbc9613f10e1551f32", "author": {"user": {"login": "mbologna", "name": "Michele Bologna"}}, "url": "https://github.com/uyuni-project/uyuni/commit/108c9e2d0c005a0d980d91bbc9613f10e1551f32", "committedDate": "2020-06-08T12:24:50Z", "message": "fixup! Show message when group owned by cluster"}, "afterCommit": {"oid": "ca032fd114dab94eb11882c58563e3e1a8f5f90a", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/ca032fd114dab94eb11882c58563e3e1a8f5f90a", "committedDate": "2020-06-08T12:27:55Z", "message": "Flowtype errs fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6daf9176abcaafa097368c2f639254e1b2a8bd98", "author": {"user": {"login": "mateiw", "name": "Matei Albu"}}, "url": "https://github.com/uyuni-project/uyuni/commit/6daf9176abcaafa097368c2f639254e1b2a8bd98", "committedDate": "2020-06-08T13:19:58Z", "message": "Merge branch 'master' into master-cluster-awareness-mvp-impl"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1556, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}