{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NDcxNTk5", "number": 4992, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDo1NToyOVrOEVQg8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNTo0NTowNVrOEVRF_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzI2MTMxOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/Cache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDo1NToyOVrOG76LMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDo1NToyOVrOG76LMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MjMwNg==", "bodyText": "We don't use LoadingCache any more...", "url": "https://github.com/pravega/pravega/pull/4992#discussion_r465472306", "createdAt": "2020-08-05T04:55:29Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/Cache.java", "diffHunk": "@@ -10,53 +10,42 @@\n package io.pravega.controller.store.stream;\n \n import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n import io.pravega.controller.store.VersionedMetadata;\n \n-import javax.annotation.ParametersAreNonnullByDefault;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n \n /**\n  * Cache for asynchronously retrieving and loading records from underlying store using the supplied loader.\n  * This uses Guava's loading cache and takes a loader function for loading entries into the cache. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deea8b20c80a204b9316820078fad78073eea34c"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzM1NjE0OnYy", "diffSide": "LEFT", "path": "controller/src/main/java/io/pravega/controller/store/stream/Cache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNTo0NTowNlrOG77CtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoxMzo1OFrOG79JMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NjUxNw==", "bodyText": "While I understand the reason for removing Future from the Cache Value, I don't see why we are moving away from auto loading cache entries?", "url": "https://github.com/pravega/pravega/pull/4992#discussion_r465486517", "createdAt": "2020-08-05T05:45:06Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/Cache.java", "diffHunk": "@@ -10,53 +10,42 @@\n package io.pravega.controller.store.stream;\n \n import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n import io.pravega.controller.store.VersionedMetadata;\n \n-import javax.annotation.ParametersAreNonnullByDefault;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n \n /**\n  * Cache for asynchronously retrieving and loading records from underlying store using the supplied loader.\n  * This uses Guava's loading cache and takes a loader function for loading entries into the cache. \n- * This class caches Futures which hold the metadata record with version. The cache is untyped and the CompletableFutures\n+ * This class caches Futures which hold the metadata record with version. The cache  \n  * can hold any value under the VersionedMetadata wrapper.\n  * The values are by default held for 2 minutes after creation unless invalidated explicitly.\n  * The maximum number of records that can be held in the cache is 10000. \n  */\n public class Cache {\n     private static final int MAX_CACHE_SIZE = 10000;\n     \n-    private final LoadingCache<CacheKey, CompletableFuture<VersionedMetadata<?>>> cache;\n+    private final com.google.common.cache.Cache<CacheKey, VersionedMetadata<?>> cache;\n \n-    public Cache(final Function<CacheKey, CompletableFuture<VersionedMetadata<?>>> loader) {\n+    public Cache() {\n         cache = CacheBuilder.newBuilder()\n                             .maximumSize(MAX_CACHE_SIZE)\n                             .expireAfterAccess(2, TimeUnit.MINUTES)\n-                            .build(new CacheLoader<CacheKey, CompletableFuture<VersionedMetadata<?>>>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deea8b20c80a204b9316820078fad78073eea34c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxNTQyNg==", "bodyText": "in that case the cache would need to define the semantics of what we do when the cache load fails if the data is not present or there is a transient error.\nthis keeps the cache semantics cleaner and abstracted away from what the callers may load into it and how they deal with different errors.", "url": "https://github.com/pravega/pravega/pull/4992#discussion_r465515426", "createdAt": "2020-08-05T07:01:46Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/Cache.java", "diffHunk": "@@ -10,53 +10,42 @@\n package io.pravega.controller.store.stream;\n \n import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n import io.pravega.controller.store.VersionedMetadata;\n \n-import javax.annotation.ParametersAreNonnullByDefault;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n \n /**\n  * Cache for asynchronously retrieving and loading records from underlying store using the supplied loader.\n  * This uses Guava's loading cache and takes a loader function for loading entries into the cache. \n- * This class caches Futures which hold the metadata record with version. The cache is untyped and the CompletableFutures\n+ * This class caches Futures which hold the metadata record with version. The cache  \n  * can hold any value under the VersionedMetadata wrapper.\n  * The values are by default held for 2 minutes after creation unless invalidated explicitly.\n  * The maximum number of records that can be held in the cache is 10000. \n  */\n public class Cache {\n     private static final int MAX_CACHE_SIZE = 10000;\n     \n-    private final LoadingCache<CacheKey, CompletableFuture<VersionedMetadata<?>>> cache;\n+    private final com.google.common.cache.Cache<CacheKey, VersionedMetadata<?>> cache;\n \n-    public Cache(final Function<CacheKey, CompletableFuture<VersionedMetadata<?>>> loader) {\n+    public Cache() {\n         cache = CacheBuilder.newBuilder()\n                             .maximumSize(MAX_CACHE_SIZE)\n                             .expireAfterAccess(2, TimeUnit.MINUTES)\n-                            .build(new CacheLoader<CacheKey, CompletableFuture<VersionedMetadata<?>>>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NjUxNw=="}, "originalCommit": {"oid": "deea8b20c80a204b9316820078fad78073eea34c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyMDk0NQ==", "bodyText": "Ok.", "url": "https://github.com/pravega/pravega/pull/4992#discussion_r465520945", "createdAt": "2020-08-05T07:13:58Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/Cache.java", "diffHunk": "@@ -10,53 +10,42 @@\n package io.pravega.controller.store.stream;\n \n import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n import io.pravega.controller.store.VersionedMetadata;\n \n-import javax.annotation.ParametersAreNonnullByDefault;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n \n /**\n  * Cache for asynchronously retrieving and loading records from underlying store using the supplied loader.\n  * This uses Guava's loading cache and takes a loader function for loading entries into the cache. \n- * This class caches Futures which hold the metadata record with version. The cache is untyped and the CompletableFutures\n+ * This class caches Futures which hold the metadata record with version. The cache  \n  * can hold any value under the VersionedMetadata wrapper.\n  * The values are by default held for 2 minutes after creation unless invalidated explicitly.\n  * The maximum number of records that can be held in the cache is 10000. \n  */\n public class Cache {\n     private static final int MAX_CACHE_SIZE = 10000;\n     \n-    private final LoadingCache<CacheKey, CompletableFuture<VersionedMetadata<?>>> cache;\n+    private final com.google.common.cache.Cache<CacheKey, VersionedMetadata<?>> cache;\n \n-    public Cache(final Function<CacheKey, CompletableFuture<VersionedMetadata<?>>> loader) {\n+    public Cache() {\n         cache = CacheBuilder.newBuilder()\n                             .maximumSize(MAX_CACHE_SIZE)\n                             .expireAfterAccess(2, TimeUnit.MINUTES)\n-                            .build(new CacheLoader<CacheKey, CompletableFuture<VersionedMetadata<?>>>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NjUxNw=="}, "originalCommit": {"oid": "deea8b20c80a204b9316820078fad78073eea34c"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4826, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}