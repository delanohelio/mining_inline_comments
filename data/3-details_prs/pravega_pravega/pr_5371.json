{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2NjkzNjU1", "number": 5371, "title": "Data recovery commands in CLI Tool", "bodyText": "Change log description\n\nAdded durableLog-recovery <root> and list-segments <root> commands and their implementations.\n\nPurpose of the change\nAdds data recovery feature to the CLI tool.\nWhat the code does\n\nInvokes list-segments API to enumerate all segments stored in the LTS\nTier1-recovery command recovers all the segments from the storage and restores the Tier1.\n\nHow to verify it\nCommand should be able to list segments and perform recovery.", "createdAt": "2020-11-24T19:04:09Z", "url": "https://github.com/pravega/pravega/pull/5371", "merged": true, "mergeCommit": {"oid": "06b621620cf8fa79de781e3a11e462179d6a9c77"}, "closed": true, "closedAt": "2020-12-11T03:25:12Z", "author": {"login": "ManishKumarKeshri"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfMqDggH2gAyNTI2NjkzNjU1OjcyODM3NWRkMDkwNjM0YmFhZjIwMjBiODkxZTA0Y2Y2NDZiNDRjMmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkoU3RAFqTU0ODczMDI5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "728375dd090634baaf2020b891e04cf646b44c2b", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/728375dd090634baaf2020b891e04cf646b44c2b", "committedDate": "2020-11-23T03:33:41Z", "message": "dr cli commands.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ab24e9f35488a05b0ed39f1a8e842b64f1af847", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/6ab24e9f35488a05b0ed39f1a8e842b64f1af847", "committedDate": "2020-11-24T04:59:53Z", "message": "Updating storage.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c2adc8f811e74866a71bef07dc4a1b94c036492", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/4c2adc8f811e74866a71bef07dc4a1b94c036492", "committedDate": "2020-11-24T05:02:11Z", "message": "Updating properties file.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/e47695e3a970facb5c1ae8875b79e3bf376c1023", "committedDate": "2020-11-24T05:04:27Z", "message": "Removing update attributes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2621c304bc03cb2b0e84075d9095d9455beb50ec", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/2621c304bc03cb2b0e84075d9095d9455beb50ec", "committedDate": "2020-11-24T20:32:07Z", "message": "Without update attributes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}, "afterCommit": {"oid": "0246589b1c8e1fe9ed210a010cf8ffe2281a2f08", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/0246589b1c8e1fe9ed210a010cf8ffe2281a2f08", "committedDate": "2020-11-24T20:51:00Z", "message": "Removing update attributes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "846d412252532c438b0846883f02fab878197449", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/846d412252532c438b0846883f02fab878197449", "committedDate": "2020-11-25T11:47:20Z", "message": "Updating stf4j.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}, "afterCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/e47695e3a970facb5c1ae8875b79e3bf376c1023", "committedDate": "2020-11-24T05:04:27Z", "message": "Removing update attributes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDk1NDg4", "url": "https://github.com/pravega/pravega/pull/5371#pullrequestreview-541095488", "createdAt": "2020-11-30T16:47:02Z", "commit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjo0NzowMlrOH8D9sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzowNjowN1rOH8E1IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0MTU1Mw==", "bodyText": "Why can't we do this in the constructor? You get all your args there anyway and that way you can make your logger final.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532741553", "createdAt": "2020-11-30T16:47:02Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DataRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommand;\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.segmentstore.server.host.StorageLoader;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+\n+import java.io.File;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.FINER;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.SEVERE;\n+\n+/**\n+ * Base for any data recovery related commands.\n+ */\n+public abstract class DataRecoveryCommand extends AdminCommand {\n+    protected final static String COMPONENT = \"storage\";\n+    protected Logger logger;\n+\n+    /**\n+     * Creates a new instance of the DataRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    DataRecoveryCommand(CommandArgs args) {\n+        super(args);\n+    }\n+\n+    /**\n+     * Creates the {@link StorageFactory} instance by reading the config values.\n+     *\n+     * @param executorService   A thread pool for execution.\n+     * @return                  A newly created {@link StorageFactory} instance.\n+     */\n+    StorageFactory createStorageFactory(ScheduledExecutorService executorService) {\n+        ServiceBuilder.ConfigSetupHelper configSetupHelper = new ServiceBuilder.ConfigSetupHelper(getCommandArgs().getState().getConfigBuilder().build());\n+        StorageLoader loader = new StorageLoader();\n+        return loader.load(configSetupHelper, getServiceConfig().getStorageImplementation().toString(),\n+                getServiceConfig().getStorageLayout(), executorService);\n+    }\n+\n+    /**\n+     * Creates logging directory and file for the command to be run. The path to the directory can be supplied on the\n+     * command run. By default, the path is set as current user path.\n+     *\n+     * @param commandName   The name of the command to be run.\n+     * @return              The path to the directory created.\n+     * @throws Exception    In case of a failure in creating the directory or the file.\n+     */\n+    String setLogging(String commandName) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0MjM2OA==", "bodyText": "/ is also some system-level constant. I believe you can find it in Paths or Path.\nFix it below too.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532742368", "createdAt": "2020-11-30T16:48:10Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DataRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommand;\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.segmentstore.server.host.StorageLoader;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+\n+import java.io.File;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.FINER;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.SEVERE;\n+\n+/**\n+ * Base for any data recovery related commands.\n+ */\n+public abstract class DataRecoveryCommand extends AdminCommand {\n+    protected final static String COMPONENT = \"storage\";\n+    protected Logger logger;\n+\n+    /**\n+     * Creates a new instance of the DataRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    DataRecoveryCommand(CommandArgs args) {\n+        super(args);\n+    }\n+\n+    /**\n+     * Creates the {@link StorageFactory} instance by reading the config values.\n+     *\n+     * @param executorService   A thread pool for execution.\n+     * @return                  A newly created {@link StorageFactory} instance.\n+     */\n+    StorageFactory createStorageFactory(ScheduledExecutorService executorService) {\n+        ServiceBuilder.ConfigSetupHelper configSetupHelper = new ServiceBuilder.ConfigSetupHelper(getCommandArgs().getState().getConfigBuilder().build());\n+        StorageLoader loader = new StorageLoader();\n+        return loader.load(configSetupHelper, getServiceConfig().getStorageImplementation().toString(),\n+                getServiceConfig().getStorageLayout(), executorService);\n+    }\n+\n+    /**\n+     * Creates logging directory and file for the command to be run. The path to the directory can be supplied on the\n+     * command run. By default, the path is set as current user path.\n+     *\n+     * @param commandName   The name of the command to be run.\n+     * @return              The path to the directory created.\n+     * @throws Exception    In case of a failure in creating the directory or the file.\n+     */\n+    String setLogging(String commandName) throws Exception {\n+        logger = Logger.getLogger(commandName);\n+        logger.setUseParentHandlers(false);\n+\n+        String fileSuffix = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n+        String fileName = commandName + fileSuffix + \".log\";\n+\n+        String filePath = System.getProperty(\"user.dir\") + \"/\" + commandName + \"_\" + fileSuffix;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0MjYyNw==", "bodyText": "Checkstyle.\nAre you trying to get the file name? If so, there may be a method for that in Paths.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532742627", "createdAt": "2020-11-30T16:48:32Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DataRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommand;\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.segmentstore.server.host.StorageLoader;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+\n+import java.io.File;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.FINER;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.SEVERE;\n+\n+/**\n+ * Base for any data recovery related commands.\n+ */\n+public abstract class DataRecoveryCommand extends AdminCommand {\n+    protected final static String COMPONENT = \"storage\";\n+    protected Logger logger;\n+\n+    /**\n+     * Creates a new instance of the DataRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    DataRecoveryCommand(CommandArgs args) {\n+        super(args);\n+    }\n+\n+    /**\n+     * Creates the {@link StorageFactory} instance by reading the config values.\n+     *\n+     * @param executorService   A thread pool for execution.\n+     * @return                  A newly created {@link StorageFactory} instance.\n+     */\n+    StorageFactory createStorageFactory(ScheduledExecutorService executorService) {\n+        ServiceBuilder.ConfigSetupHelper configSetupHelper = new ServiceBuilder.ConfigSetupHelper(getCommandArgs().getState().getConfigBuilder().build());\n+        StorageLoader loader = new StorageLoader();\n+        return loader.load(configSetupHelper, getServiceConfig().getStorageImplementation().toString(),\n+                getServiceConfig().getStorageLayout(), executorService);\n+    }\n+\n+    /**\n+     * Creates logging directory and file for the command to be run. The path to the directory can be supplied on the\n+     * command run. By default, the path is set as current user path.\n+     *\n+     * @param commandName   The name of the command to be run.\n+     * @return              The path to the directory created.\n+     * @throws Exception    In case of a failure in creating the directory or the file.\n+     */\n+    String setLogging(String commandName) throws Exception {\n+        logger = Logger.getLogger(commandName);\n+        logger.setUseParentHandlers(false);\n+\n+        String fileSuffix = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n+        String fileName = commandName + fileSuffix + \".log\";\n+\n+        String filePath = System.getProperty(\"user.dir\") + \"/\" + commandName + \"_\" + fileSuffix;\n+        if (getArgCount() >= 1) {\n+            filePath = getCommandArgs().getArgs().get(0);\n+            if (filePath.endsWith(\"/\")) {\n+                filePath = filePath.substring(0, filePath.length()-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0Mjc3Mw==", "bodyText": "same here", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532742773", "createdAt": "2020-11-30T16:48:45Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DataRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommand;\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.segmentstore.server.host.StorageLoader;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+\n+import java.io.File;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.FINER;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.SEVERE;\n+\n+/**\n+ * Base for any data recovery related commands.\n+ */\n+public abstract class DataRecoveryCommand extends AdminCommand {\n+    protected final static String COMPONENT = \"storage\";\n+    protected Logger logger;\n+\n+    /**\n+     * Creates a new instance of the DataRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    DataRecoveryCommand(CommandArgs args) {\n+        super(args);\n+    }\n+\n+    /**\n+     * Creates the {@link StorageFactory} instance by reading the config values.\n+     *\n+     * @param executorService   A thread pool for execution.\n+     * @return                  A newly created {@link StorageFactory} instance.\n+     */\n+    StorageFactory createStorageFactory(ScheduledExecutorService executorService) {\n+        ServiceBuilder.ConfigSetupHelper configSetupHelper = new ServiceBuilder.ConfigSetupHelper(getCommandArgs().getState().getConfigBuilder().build());\n+        StorageLoader loader = new StorageLoader();\n+        return loader.load(configSetupHelper, getServiceConfig().getStorageImplementation().toString(),\n+                getServiceConfig().getStorageLayout(), executorService);\n+    }\n+\n+    /**\n+     * Creates logging directory and file for the command to be run. The path to the directory can be supplied on the\n+     * command run. By default, the path is set as current user path.\n+     *\n+     * @param commandName   The name of the command to be run.\n+     * @return              The path to the directory created.\n+     * @throws Exception    In case of a failure in creating the directory or the file.\n+     */\n+    String setLogging(String commandName) throws Exception {\n+        logger = Logger.getLogger(commandName);\n+        logger.setUseParentHandlers(false);\n+\n+        String fileSuffix = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n+        String fileName = commandName + fileSuffix + \".log\";\n+\n+        String filePath = System.getProperty(\"user.dir\") + \"/\" + commandName + \"_\" + fileSuffix;\n+        if (getArgCount() >= 1) {\n+            filePath = getCommandArgs().getArgs().get(0);\n+            if (filePath.endsWith(\"/\")) {\n+                filePath = filePath.substring(0, filePath.length()-1);\n+            }\n+        }\n+\n+        // Create a directory for storing files.\n+        File dir = new File(filePath);\n+        if (!dir.exists()) {\n+            dir.mkdir();\n+        }\n+\n+        FileHandler fh = new FileHandler(filePath + \"/\" + commandName + fileSuffix + \".log\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0MzQyNg==", "bodyText": "You don't have to do this. When you set you logger, you can configure it to have a FileAppender and a ConsoleAppender. That will do all the work for you", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532743426", "createdAt": "2020-11-30T16:49:35Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DataRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommand;\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.segmentstore.server.host.StorageLoader;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+\n+import java.io.File;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.FINER;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.SEVERE;\n+\n+/**\n+ * Base for any data recovery related commands.\n+ */\n+public abstract class DataRecoveryCommand extends AdminCommand {\n+    protected final static String COMPONENT = \"storage\";\n+    protected Logger logger;\n+\n+    /**\n+     * Creates a new instance of the DataRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    DataRecoveryCommand(CommandArgs args) {\n+        super(args);\n+    }\n+\n+    /**\n+     * Creates the {@link StorageFactory} instance by reading the config values.\n+     *\n+     * @param executorService   A thread pool for execution.\n+     * @return                  A newly created {@link StorageFactory} instance.\n+     */\n+    StorageFactory createStorageFactory(ScheduledExecutorService executorService) {\n+        ServiceBuilder.ConfigSetupHelper configSetupHelper = new ServiceBuilder.ConfigSetupHelper(getCommandArgs().getState().getConfigBuilder().build());\n+        StorageLoader loader = new StorageLoader();\n+        return loader.load(configSetupHelper, getServiceConfig().getStorageImplementation().toString(),\n+                getServiceConfig().getStorageLayout(), executorService);\n+    }\n+\n+    /**\n+     * Creates logging directory and file for the command to be run. The path to the directory can be supplied on the\n+     * command run. By default, the path is set as current user path.\n+     *\n+     * @param commandName   The name of the command to be run.\n+     * @return              The path to the directory created.\n+     * @throws Exception    In case of a failure in creating the directory or the file.\n+     */\n+    String setLogging(String commandName) throws Exception {\n+        logger = Logger.getLogger(commandName);\n+        logger.setUseParentHandlers(false);\n+\n+        String fileSuffix = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n+        String fileName = commandName + fileSuffix + \".log\";\n+\n+        String filePath = System.getProperty(\"user.dir\") + \"/\" + commandName + \"_\" + fileSuffix;\n+        if (getArgCount() >= 1) {\n+            filePath = getCommandArgs().getArgs().get(0);\n+            if (filePath.endsWith(\"/\")) {\n+                filePath = filePath.substring(0, filePath.length()-1);\n+            }\n+        }\n+\n+        // Create a directory for storing files.\n+        File dir = new File(filePath);\n+        if (!dir.exists()) {\n+            dir.mkdir();\n+        }\n+\n+        FileHandler fh = new FileHandler(filePath + \"/\" + commandName + fileSuffix + \".log\");\n+        fh.setLevel(FINER);\n+        DataRecoveryLogFormatter drFormatter = new DataRecoveryLogFormatter();\n+        fh.setFormatter(drFormatter);\n+        logger.addHandler(fh);\n+\n+        output(FINER, \"Logs are written to file '%s'\", filePath + \"/\" + fileName);\n+        return filePath;\n+    }\n+\n+    /**\n+     * Outputs the message to the console as well as to the log file.\n+     *\n+     * @param level             The log level of the message.\n+     * @param messageTemplate   The message.\n+     * @param args              The arguments with the message.\n+     */\n+    protected void output(Level level, String messageTemplate, Object... args) {\n+        if (INFO.equals(level)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0MzY1NA==", "bodyText": "Plus the String.format format is different than the log format, so this won't work.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532743654", "createdAt": "2020-11-30T16:49:56Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DataRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommand;\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.segmentstore.server.host.StorageLoader;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+\n+import java.io.File;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.FINER;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.SEVERE;\n+\n+/**\n+ * Base for any data recovery related commands.\n+ */\n+public abstract class DataRecoveryCommand extends AdminCommand {\n+    protected final static String COMPONENT = \"storage\";\n+    protected Logger logger;\n+\n+    /**\n+     * Creates a new instance of the DataRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    DataRecoveryCommand(CommandArgs args) {\n+        super(args);\n+    }\n+\n+    /**\n+     * Creates the {@link StorageFactory} instance by reading the config values.\n+     *\n+     * @param executorService   A thread pool for execution.\n+     * @return                  A newly created {@link StorageFactory} instance.\n+     */\n+    StorageFactory createStorageFactory(ScheduledExecutorService executorService) {\n+        ServiceBuilder.ConfigSetupHelper configSetupHelper = new ServiceBuilder.ConfigSetupHelper(getCommandArgs().getState().getConfigBuilder().build());\n+        StorageLoader loader = new StorageLoader();\n+        return loader.load(configSetupHelper, getServiceConfig().getStorageImplementation().toString(),\n+                getServiceConfig().getStorageLayout(), executorService);\n+    }\n+\n+    /**\n+     * Creates logging directory and file for the command to be run. The path to the directory can be supplied on the\n+     * command run. By default, the path is set as current user path.\n+     *\n+     * @param commandName   The name of the command to be run.\n+     * @return              The path to the directory created.\n+     * @throws Exception    In case of a failure in creating the directory or the file.\n+     */\n+    String setLogging(String commandName) throws Exception {\n+        logger = Logger.getLogger(commandName);\n+        logger.setUseParentHandlers(false);\n+\n+        String fileSuffix = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n+        String fileName = commandName + fileSuffix + \".log\";\n+\n+        String filePath = System.getProperty(\"user.dir\") + \"/\" + commandName + \"_\" + fileSuffix;\n+        if (getArgCount() >= 1) {\n+            filePath = getCommandArgs().getArgs().get(0);\n+            if (filePath.endsWith(\"/\")) {\n+                filePath = filePath.substring(0, filePath.length()-1);\n+            }\n+        }\n+\n+        // Create a directory for storing files.\n+        File dir = new File(filePath);\n+        if (!dir.exists()) {\n+            dir.mkdir();\n+        }\n+\n+        FileHandler fh = new FileHandler(filePath + \"/\" + commandName + fileSuffix + \".log\");\n+        fh.setLevel(FINER);\n+        DataRecoveryLogFormatter drFormatter = new DataRecoveryLogFormatter();\n+        fh.setFormatter(drFormatter);\n+        logger.addHandler(fh);\n+\n+        output(FINER, \"Logs are written to file '%s'\", filePath + \"/\" + fileName);\n+        return filePath;\n+    }\n+\n+    /**\n+     * Outputs the message to the console as well as to the log file.\n+     *\n+     * @param level             The log level of the message.\n+     * @param messageTemplate   The message.\n+     * @param args              The arguments with the message.\n+     */\n+    protected void output(Level level, String messageTemplate, Object... args) {\n+        if (INFO.equals(level)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0MzQyNg=="}, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NDEwOQ==", "bodyText": "We use Slf4j everywhere. Why use this type of logging here?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532744109", "createdAt": "2020-11-30T16:50:30Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DataRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommand;\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.segmentstore.server.host.StorageLoader;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+\n+import java.io.File;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.FileHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NDkzOA==", "bodyText": "Use ExecutorServiceHelpers to create the executor.\nWhere are you closing this executor???", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532744938", "createdAt": "2020-11-30T16:51:40Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/StorageListSegmentsCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.segment.SegmentToContainerMapper;\n+import lombok.Cleanup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.Level;\n+\n+/**\n+ * Lists all non-shadow segments from there from the storage. The storage is loaded using the config properties.\n+ */\n+public class StorageListSegmentsCommand extends DataRecoveryCommand {\n+    /**\n+     * Header line for writing segments' details to csv files.\n+     */\n+    private static final List<String> HEADER = Arrays.asList(\"Sealed Status\", \"Length\", \"Segment Name\");\n+    private static final int CONTAINER_EPOCH = 1;\n+    private final int containerCount;\n+    private final ScheduledExecutorService scheduledExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(10,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NTIwMg==", "bodyText": "What is this field? Why can't it be final?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532745202", "createdAt": "2020-11-30T16:52:03Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/StorageListSegmentsCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.segment.SegmentToContainerMapper;\n+import lombok.Cleanup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.Level;\n+\n+/**\n+ * Lists all non-shadow segments from there from the storage. The storage is loaded using the config properties.\n+ */\n+public class StorageListSegmentsCommand extends DataRecoveryCommand {\n+    /**\n+     * Header line for writing segments' details to csv files.\n+     */\n+    private static final List<String> HEADER = Arrays.asList(\"Sealed Status\", \"Length\", \"Segment Name\");\n+    private static final int CONTAINER_EPOCH = 1;\n+    private final int containerCount;\n+    private final ScheduledExecutorService scheduledExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(10,\n+            \"listSegmentsProcessor\");\n+    private final SegmentToContainerMapper segToConMapper;\n+    private final StorageFactory storageFactory;\n+    private final FileWriter[] csvWriters;\n+    private String filePath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NjQ0OQ==", "bodyText": "If you see my comment in the above class, you can set this field in the constructor.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532746449", "createdAt": "2020-11-30T16:53:35Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/StorageListSegmentsCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.segment.SegmentToContainerMapper;\n+import lombok.Cleanup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.Level;\n+\n+/**\n+ * Lists all non-shadow segments from there from the storage. The storage is loaded using the config properties.\n+ */\n+public class StorageListSegmentsCommand extends DataRecoveryCommand {\n+    /**\n+     * Header line for writing segments' details to csv files.\n+     */\n+    private static final List<String> HEADER = Arrays.asList(\"Sealed Status\", \"Length\", \"Segment Name\");\n+    private static final int CONTAINER_EPOCH = 1;\n+    private final int containerCount;\n+    private final ScheduledExecutorService scheduledExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(10,\n+            \"listSegmentsProcessor\");\n+    private final SegmentToContainerMapper segToConMapper;\n+    private final StorageFactory storageFactory;\n+    private final FileWriter[] csvWriters;\n+    private String filePath;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NTIwMg=="}, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NzM2NA==", "bodyText": "output supports formatted text. Use that as it will make your file more readable.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532747364", "createdAt": "2020-11-30T16:54:37Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/StorageListSegmentsCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.segment.SegmentToContainerMapper;\n+import lombok.Cleanup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.Level;\n+\n+/**\n+ * Lists all non-shadow segments from there from the storage. The storage is loaded using the config properties.\n+ */\n+public class StorageListSegmentsCommand extends DataRecoveryCommand {\n+    /**\n+     * Header line for writing segments' details to csv files.\n+     */\n+    private static final List<String> HEADER = Arrays.asList(\"Sealed Status\", \"Length\", \"Segment Name\");\n+    private static final int CONTAINER_EPOCH = 1;\n+    private final int containerCount;\n+    private final ScheduledExecutorService scheduledExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(10,\n+            \"listSegmentsProcessor\");\n+    private final SegmentToContainerMapper segToConMapper;\n+    private final StorageFactory storageFactory;\n+    private final FileWriter[] csvWriters;\n+    private String filePath;\n+\n+    /**\n+     * Creates an instance of StorageListSegmentsCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public StorageListSegmentsCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.segToConMapper = new SegmentToContainerMapper(this.containerCount);\n+        this.storageFactory = createStorageFactory(scheduledExecutorService);\n+        this.csvWriters = new FileWriter[this.containerCount];\n+    }\n+\n+    /**\n+     * Creates a csv file for each container. All segments belonging to a containerId have their details written to the\n+     * csv file for that container.\n+     *\n+     * @throws Exception   When failed to create/delete file(s).\n+     */\n+    private void createCSVFiles() throws Exception {\n+        for (int containerId = 0; containerId < this.containerCount; containerId++) {\n+            File f = new File(this.filePath + \"/\" + \"Container_\" + containerId + \".csv\");\n+            if (f.exists()) {\n+                output(Level.FINE, \"File '%s' already exists.\", f.getAbsolutePath());\n+                if (!f.delete()) {\n+                    output(Level.SEVERE, \"Failed to delete the file '%s'.\", f.getAbsolutePath());\n+                    throw new Exception(\"Failed to delete the file \" + f.getAbsolutePath());\n+                }\n+            }\n+            if (!f.createNewFile()) {\n+                output(Level.SEVERE, \"Failed to create file '%s'.\", f.getAbsolutePath());\n+                throw new Exception(\"Failed to create file \" + f.getAbsolutePath());\n+            }\n+            this.csvWriters[containerId] = new FileWriter(f.getName());\n+            output(Level.INFO, \"Created file '%s'\", f.getAbsolutePath());\n+            this.csvWriters[containerId].append(String.join(\",\", HEADER));\n+            this.csvWriters[containerId].append(\"\\n\");\n+        }\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        // set up logging\n+        this.filePath = setLogging(descriptor().getName());\n+\n+        output(Level.INFO, \"Container Count = %d\", this.containerCount);\n+        // Get the storage using the config.\n+        @Cleanup\n+        Storage storage = this.storageFactory.createStorageAdapter();\n+        storage.initialize(CONTAINER_EPOCH);\n+        output(Level.INFO, \"Loaded %s Storage.\", getServiceConfig().getStorageImplementation().toString());\n+\n+        // Gets total number of segments listed.\n+        int segmentsCount = 0;\n+\n+        createCSVFiles();\n+\n+        output(Level.INFO, \"Writing segments' details to the csv files...\");\n+        Iterator<SegmentProperties> segmentIterator = storage.listSegments();\n+        while (segmentIterator.hasNext()) {\n+            SegmentProperties currentSegment = segmentIterator.next();\n+\n+            // skip recovery if the segment is an attribute segment.\n+            if (NameUtils.isAttributeSegment(currentSegment.getName())) {\n+                continue;\n+            }\n+\n+            segmentsCount++;\n+            int containerId = segToConMapper.getContainerId(currentSegment.getName());\n+            output(Level.FINE, containerId + \"\\t\" + currentSegment.isSealed() + \"\\t\" + currentSegment.getLength() + \"\\t\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0Nzg4MA==", "bodyText": "same here", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532747880", "createdAt": "2020-11-30T16:55:20Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0ODI3OA==", "bodyText": "There is no such thing as Tier1 in the code. Call it DurableLogRecoveryCommand", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532748278", "createdAt": "2020-11-30T16:55:47Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0ODUyNw==", "bodyText": "Why 1KB?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532748527", "createdAt": "2020-11-30T16:56:07Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0ODg4OA==", "bodyText": "Why do you make the Attribute BTree page so small? Why made you change this from the default values?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532748888", "createdAt": "2020-11-30T16:56:36Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0OTAzMg==", "bodyText": "Same with the next line", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532749032", "createdAt": "2020-11-30T16:56:45Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0ODg4OA=="}, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0OTUxNQ==", "bodyText": "3000 will still cause a flush after writing 3000 attributes. Do you think this is large enough? What is the point of these config settings?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532749515", "createdAt": "2020-11-30T16:57:26Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)\n+            .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 1000)\n+            .build();\n+\n+    private static final WriterConfig INFREQUENT_FLUSH_WRITER_CONFIG = WriterConfig\n+            .builder()\n+            .with(WriterConfig.FLUSH_THRESHOLD_BYTES, 1024 * 1024 * 1024)\n+            .with(WriterConfig.FLUSH_ATTRIBUTES_THRESHOLD, 3000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0OTk5Ng==", "bodyText": "So you close the client, print out a stack trace, then move on. How is the rest of the code going to execute afterwards if this isn't properly initialized?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532749996", "createdAt": "2020-11-30T16:58:04Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)\n+            .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 1000)\n+            .build();\n+\n+    private static final WriterConfig INFREQUENT_FLUSH_WRITER_CONFIG = WriterConfig\n+            .builder()\n+            .with(WriterConfig.FLUSH_THRESHOLD_BYTES, 1024 * 1024 * 1024)\n+            .with(WriterConfig.FLUSH_ATTRIBUTES_THRESHOLD, 3000)\n+            .with(WriterConfig.FLUSH_THRESHOLD_MILLIS, 250000L)\n+            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+            .build();\n+    private Storage storage;\n+\n+    /**\n+     * Creates an instance of Tier1RecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public Tier1RecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+\n+        val config = getCommandArgs().getState().getConfigBuilder().build().getConfig(ContainerConfig::builder);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        val zkClient = createZKClient();\n+        this.dataLogFactory = new BookKeeperLogFactory(bkConfig, zkClient, executorService);\n+        try {\n+            this.dataLogFactory.initialize();\n+        } catch (DurableDataLogException ex) {\n+            zkClient.close();\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1MDI3Mg==", "bodyText": "You need to store this in a class-level field and close it when you close your class.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532750272", "createdAt": "2020-11-30T16:58:27Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)\n+            .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 1000)\n+            .build();\n+\n+    private static final WriterConfig INFREQUENT_FLUSH_WRITER_CONFIG = WriterConfig\n+            .builder()\n+            .with(WriterConfig.FLUSH_THRESHOLD_BYTES, 1024 * 1024 * 1024)\n+            .with(WriterConfig.FLUSH_ATTRIBUTES_THRESHOLD, 3000)\n+            .with(WriterConfig.FLUSH_THRESHOLD_MILLIS, 250000L)\n+            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+            .build();\n+    private Storage storage;\n+\n+    /**\n+     * Creates an instance of Tier1RecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public Tier1RecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+\n+        val config = getCommandArgs().getState().getConfigBuilder().build().getConfig(ContainerConfig::builder);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        val zkClient = createZKClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1MzUyMQ==", "bodyText": "Same with all other objects that need closing.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532753521", "createdAt": "2020-11-30T17:02:57Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)\n+            .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 1000)\n+            .build();\n+\n+    private static final WriterConfig INFREQUENT_FLUSH_WRITER_CONFIG = WriterConfig\n+            .builder()\n+            .with(WriterConfig.FLUSH_THRESHOLD_BYTES, 1024 * 1024 * 1024)\n+            .with(WriterConfig.FLUSH_ATTRIBUTES_THRESHOLD, 3000)\n+            .with(WriterConfig.FLUSH_THRESHOLD_MILLIS, 250000L)\n+            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+            .build();\n+    private Storage storage;\n+\n+    /**\n+     * Creates an instance of Tier1RecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public Tier1RecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+\n+        val config = getCommandArgs().getState().getConfigBuilder().build().getConfig(ContainerConfig::builder);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        val zkClient = createZKClient();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1MDI3Mg=="}, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NDAyNA==", "bodyText": "Make this final and set it in the constructor", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532754024", "createdAt": "2020-11-30T17:03:41Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)\n+            .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 1000)\n+            .build();\n+\n+    private static final WriterConfig INFREQUENT_FLUSH_WRITER_CONFIG = WriterConfig\n+            .builder()\n+            .with(WriterConfig.FLUSH_THRESHOLD_BYTES, 1024 * 1024 * 1024)\n+            .with(WriterConfig.FLUSH_ATTRIBUTES_THRESHOLD, 3000)\n+            .with(WriterConfig.FLUSH_THRESHOLD_MILLIS, 250000L)\n+            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+            .build();\n+    private Storage storage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NDQwNg==", "bodyText": "Do not check in commented out code.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532754406", "createdAt": "2020-11-30T17:04:13Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)\n+            .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 1000)\n+            .build();\n+\n+    private static final WriterConfig INFREQUENT_FLUSH_WRITER_CONFIG = WriterConfig\n+            .builder()\n+            .with(WriterConfig.FLUSH_THRESHOLD_BYTES, 1024 * 1024 * 1024)\n+            .with(WriterConfig.FLUSH_ATTRIBUTES_THRESHOLD, 3000)\n+            .with(WriterConfig.FLUSH_THRESHOLD_MILLIS, 250000L)\n+            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+            .build();\n+    private Storage storage;\n+\n+    /**\n+     * Creates an instance of Tier1RecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public Tier1RecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+\n+        val config = getCommandArgs().getState().getConfigBuilder().build().getConfig(ContainerConfig::builder);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        val zkClient = createZKClient();\n+        this.dataLogFactory = new BookKeeperLogFactory(bkConfig, zkClient, executorService);\n+        try {\n+            this.dataLogFactory.initialize();\n+        } catch (DurableDataLogException ex) {\n+            zkClient.close();\n+            ex.printStackTrace();\n+        }\n+\n+        this.operationLogFactory = new DurableLogFactory(NO_TRUNCATIONS_DURABLE_LOG_CONFIG, this.dataLogFactory, executorService);\n+        this.cacheStorage = new DirectMemoryCache(Integer.MAX_VALUE);\n+        this.cacheManager = new CacheManager(CachePolicy.INFINITE, this.cacheStorage, executorService);\n+        this.readIndexFactory = new ContainerReadIndexFactory(DEFAULT_READ_INDEX_CONFIG, this.cacheManager, executorService);\n+        this.attributeIndexFactory = new ContainerAttributeIndexFactoryImpl(DEFAULT_ATTRIBUTE_INDEX_CONFIG, this.cacheManager, executorService);\n+        this.writerFactory = new StorageWriterFactory(INFREQUENT_FLUSH_WRITER_CONFIG, executorService);\n+        this.containerFactory = new StreamSegmentContainerFactory(config, this.operationLogFactory,\n+                this.readIndexFactory, this.attributeIndexFactory, this.writerFactory, this.storageFactory,\n+                this::createContainerExtensions, executorService);\n+    }\n+\n+    private Map<Class<? extends SegmentContainerExtension>, SegmentContainerExtension> createContainerExtensions(\n+            SegmentContainer container, ScheduledExecutorService executor) {\n+        return Collections.singletonMap(ContainerTableExtension.class, new ContainerTableExtensionImpl(container, this.cacheManager, executor));\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        // set up logging\n+        setLogging(descriptor().getName());\n+        output(Level.INFO, \"Container Count = %d\", this.containerCount);\n+\n+        this.storage = this.storageFactory.createStorageAdapter();\n+        storage.initialize(CONTAINER_EPOCH);\n+        output(Level.INFO, \"Loaded %s Storage.\", getServiceConfig().getStorageImplementation().toString());\n+\n+        output(Level.INFO, \"Starting recovery...\");\n+        // create back up of metadata segments\n+        Map<Integer, String> backUpMetadataSegments = ContainerRecoveryUtils.createBackUpMetadataSegments(storage,\n+                this.containerCount, executorService, TIMEOUT);\n+\n+        // Start debug segment containers\n+        Map<Integer, DebugStreamSegmentContainer> debugStreamSegmentContainerMap = createContainers();\n+        output(Level.INFO, \"Debug segment containers started.\");\n+\n+        output(Level.INFO, \"Recovering all segments...\");\n+        ContainerRecoveryUtils.recoverAllSegments(storage, debugStreamSegmentContainerMap, executorService, TIMEOUT);\n+        output(Level.INFO, \"All segments recovered.\");\n+\n+        // Update core attributes from the backUp Metadata segments\n+        output(Level.INFO, \"Updating core attributes for segments registered.\");\n+//        ContainerRecoveryUtils.updateCoreAttributes(backUpMetadataSegments, debugStreamSegmentContainerMap, executorService,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NDgzMw==", "bodyText": "If you don't make this field final, then this may throw a NullPtrEx. Make the field final.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532754833", "createdAt": "2020-11-30T17:04:49Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/Tier1RecoveryCommand.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentInformation;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.containers.StreamSegmentContainerFactory;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.DurableDataLogFactory;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.shared.NameUtils;\n+import lombok.Cleanup;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class Tier1RecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final DurableDataLogFactory dataLogFactory;\n+    private final StreamSegmentContainerFactory containerFactory;\n+    private final OperationLogFactory operationLogFactory;\n+    private final ReadIndexFactory readIndexFactory;\n+    private final AttributeIndexFactory attributeIndexFactory;\n+    private final WriterFactory writerFactory;\n+    private final CacheStorage cacheStorage;\n+    private final CacheManager cacheManager;\n+    // DL config that can be used to simulate no DurableLog truncations.\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().with(ReadIndexConfig.STORAGE_READ_ALIGNMENT, 1024).build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig\n+            .builder()\n+            .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 2 * 1024)\n+            .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 1000)\n+            .build();\n+\n+    private static final WriterConfig INFREQUENT_FLUSH_WRITER_CONFIG = WriterConfig\n+            .builder()\n+            .with(WriterConfig.FLUSH_THRESHOLD_BYTES, 1024 * 1024 * 1024)\n+            .with(WriterConfig.FLUSH_ATTRIBUTES_THRESHOLD, 3000)\n+            .with(WriterConfig.FLUSH_THRESHOLD_MILLIS, 250000L)\n+            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+            .build();\n+    private Storage storage;\n+\n+    /**\n+     * Creates an instance of Tier1RecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public Tier1RecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+\n+        val config = getCommandArgs().getState().getConfigBuilder().build().getConfig(ContainerConfig::builder);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        val zkClient = createZKClient();\n+        this.dataLogFactory = new BookKeeperLogFactory(bkConfig, zkClient, executorService);\n+        try {\n+            this.dataLogFactory.initialize();\n+        } catch (DurableDataLogException ex) {\n+            zkClient.close();\n+            ex.printStackTrace();\n+        }\n+\n+        this.operationLogFactory = new DurableLogFactory(NO_TRUNCATIONS_DURABLE_LOG_CONFIG, this.dataLogFactory, executorService);\n+        this.cacheStorage = new DirectMemoryCache(Integer.MAX_VALUE);\n+        this.cacheManager = new CacheManager(CachePolicy.INFINITE, this.cacheStorage, executorService);\n+        this.readIndexFactory = new ContainerReadIndexFactory(DEFAULT_READ_INDEX_CONFIG, this.cacheManager, executorService);\n+        this.attributeIndexFactory = new ContainerAttributeIndexFactoryImpl(DEFAULT_ATTRIBUTE_INDEX_CONFIG, this.cacheManager, executorService);\n+        this.writerFactory = new StorageWriterFactory(INFREQUENT_FLUSH_WRITER_CONFIG, executorService);\n+        this.containerFactory = new StreamSegmentContainerFactory(config, this.operationLogFactory,\n+                this.readIndexFactory, this.attributeIndexFactory, this.writerFactory, this.storageFactory,\n+                this::createContainerExtensions, executorService);\n+    }\n+\n+    private Map<Class<? extends SegmentContainerExtension>, SegmentContainerExtension> createContainerExtensions(\n+            SegmentContainer container, ScheduledExecutorService executor) {\n+        return Collections.singletonMap(ContainerTableExtension.class, new ContainerTableExtensionImpl(container, this.cacheManager, executor));\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        // set up logging\n+        setLogging(descriptor().getName());\n+        output(Level.INFO, \"Container Count = %d\", this.containerCount);\n+\n+        this.storage = this.storageFactory.createStorageAdapter();\n+        storage.initialize(CONTAINER_EPOCH);\n+        output(Level.INFO, \"Loaded %s Storage.\", getServiceConfig().getStorageImplementation().toString());\n+\n+        output(Level.INFO, \"Starting recovery...\");\n+        // create back up of metadata segments\n+        Map<Integer, String> backUpMetadataSegments = ContainerRecoveryUtils.createBackUpMetadataSegments(storage,\n+                this.containerCount, executorService, TIMEOUT);\n+\n+        // Start debug segment containers\n+        Map<Integer, DebugStreamSegmentContainer> debugStreamSegmentContainerMap = createContainers();\n+        output(Level.INFO, \"Debug segment containers started.\");\n+\n+        output(Level.INFO, \"Recovering all segments...\");\n+        ContainerRecoveryUtils.recoverAllSegments(storage, debugStreamSegmentContainerMap, executorService, TIMEOUT);\n+        output(Level.INFO, \"All segments recovered.\");\n+\n+        // Update core attributes from the backUp Metadata segments\n+        output(Level.INFO, \"Updating core attributes for segments registered.\");\n+//        ContainerRecoveryUtils.updateCoreAttributes(backUpMetadataSegments, debugStreamSegmentContainerMap, executorService,\n+//                TIMEOUT);\n+\n+        // Waits for metadata segments to be flushed to LTS and then stops the debug segment containers\n+        stopDebugSegmentContainersPostFlush(debugStreamSegmentContainerMap);\n+\n+        output(Level.INFO, \"Segments have been recovered.\");\n+        output(Level.INFO, \"Recovery Done!\");\n+    }\n+\n+    // Closes the debug segment container instances in the given map after waiting for the metadata segment to be flushed to\n+    // the given storage.\n+    private void stopDebugSegmentContainersPostFlush(Map<Integer, DebugStreamSegmentContainer> debugStreamSegmentContainerMap)\n+            throws Exception {\n+        for (val debugSegmentContainer : debugStreamSegmentContainerMap.values()) {\n+            output(Level.FINE, \"Waiting for metadata segment of container %d to be flushed to the Long-Term storage.\",\n+                    debugSegmentContainer.getId());\n+            debugSegmentContainer.flushToStorage(TIMEOUT).join();\n+        }\n+\n+        for (val debugSegmentContainerEntry : debugStreamSegmentContainerMap.entrySet()) {\n+            Services.stopAsync(debugSegmentContainerEntry.getValue(), executorService).get(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+            output(Level.FINE, \"Stopping debug segment container %d.\", debugSegmentContainerEntry.getKey());\n+            debugSegmentContainerEntry.getValue().close();\n+        }\n+    }\n+\n+    public static CommandDescriptor descriptor() {\n+        return new CommandDescriptor(COMPONENT, \"Tier1-recovery\", \"Recover Tier1 state from the storage.\");\n+    }\n+\n+    // Creates debug segment container instances, puts them in a map and returns it.\n+    private Map<Integer, DebugStreamSegmentContainer> createContainers() {\n+        // Start a debug segment container corresponding to the given container Id and put it in the Hashmap with the Id.\n+        Map<Integer, DebugStreamSegmentContainer> debugStreamSegmentContainerMap = new HashMap<>();\n+\n+        // Create a debug segment container instances using a\n+        for (int containerId = 0; containerId < this.containerCount; containerId++) {\n+            DebugStreamSegmentContainer debugStreamSegmentContainer = (DebugStreamSegmentContainer)\n+                    this.containerFactory.createDebugStreamSegmentContainer(containerId);\n+            Services.startAsync(debugStreamSegmentContainer, executorService).join();\n+            debugStreamSegmentContainerMap.put(containerId, debugStreamSegmentContainer);\n+            output(Level.FINE, \"Container %d started.\", containerId);\n+        }\n+        return debugStreamSegmentContainerMap;\n+    }\n+\n+    @Override\n+    public void close() {\n+        this.cacheManager.close();\n+        this.cacheStorage.close();\n+        this.readIndexFactory.close();\n+        if (this.dataLogFactory != null) {\n+            this.dataLogFactory.close();\n+        }\n+        storage.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NTE5MA==", "bodyText": "Why did you change the property name?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532755190", "createdAt": "2020-11-30T17:05:19Z", "author": {"login": "andreipaduroiu"}, "path": "config/admin-cli.properties", "diffHunk": "@@ -19,11 +19,43 @@ cli.controller.grpc.uri=tcp://localhost:9090\n cli.store.metadata.backend=segmentstore\n \n # General configuration for the Pravega cluster at hand.\n-pravegaservice.cluster.name=pravega/pravega\n+pravegaservice.clusterName=pravega/bar-pravega", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NTUwOQ==", "bodyText": "Do these settings make sense or are they just for your local testing?\nSee line 29 below too.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532755509", "createdAt": "2020-11-30T17:05:45Z", "author": {"login": "andreipaduroiu"}, "path": "config/admin-cli.properties", "diffHunk": "@@ -19,11 +19,43 @@ cli.controller.grpc.uri=tcp://localhost:9090\n cli.store.metadata.backend=segmentstore\n \n # General configuration for the Pravega cluster at hand.\n-pravegaservice.cluster.name=pravega/pravega\n+pravegaservice.clusterName=pravega/bar-pravega\n pravegaservice.container.count=4\n \n # Config for Zookeeper service.\n-pravegaservice.zk.connect.uri=localhost:2181\n+pravegaservice.zk.connect.uri=zookeeper-client:2181", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NTc0NQ==", "bodyText": "This is definitely for testing purposes only", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r532755745", "createdAt": "2020-11-30T17:06:07Z", "author": {"login": "andreipaduroiu"}, "path": "config/admin-cli.properties", "diffHunk": "@@ -19,11 +19,43 @@ cli.controller.grpc.uri=tcp://localhost:9090\n cli.store.metadata.backend=segmentstore\n \n # General configuration for the Pravega cluster at hand.\n-pravegaservice.cluster.name=pravega/pravega\n+pravegaservice.clusterName=pravega/bar-pravega\n pravegaservice.container.count=4\n \n # Config for Zookeeper service.\n-pravegaservice.zk.connect.uri=localhost:2181\n+pravegaservice.zk.connect.uri=zookeeper-client:2181\n \n # Config for Bookkeeper commands.\n-bookkeeper.ledger.path=/pravega/pravega/bookkeeper/ledgers\n+bookkeeper.ledger.path=/pravega/bar-pravega/bookkeeper/ledgers\n+\n+# Config for Data recovery commands\n+# Valid values: HDFS, FILESYSTEM, EXTENDEDS3, INMEMORY.\n+pravegaservice.storage.impl.name=FILESYSTEM\n+\n+# URL where the HDFS cluster is accessible at.\n+# This value must be the same for all Pravega SegmentStore instances in this cluster.\n+# hdfs.connect.uri=localhost:9000\n+\n+# Root path in HDFS where all Pravega-related data for this cluster is located at.\n+# This value must be the same for all Pravega SegmentStore instances in this cluster.\n+# hdfs.root=\n+\n+# Root path where NFS shared directory needs to be mounted before segmentstore starts execution.\n+filesystem.root=/mnt/lts\n+\n+# Supported parameters include but are not limited to:\n+#   url: where the extended S3 cluster is accessible at, e.g. http://localhost:9020\n+#   identity: the access key to access the extended S3 cluster, e.g. identity=user\n+#   secretKey: the secret key to access the extended S3 cluster, e.g. secretKey=password\n+extendeds3.connect.config.uri=\n+\n+# Shared extended S3 bucket where the data is stored.\n+# This value must be the same for all Pravega SegmentStore instances in this cluster.\n+extendeds3.bucket=dr_tool_testing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e47695e3a970facb5c1ae8875b79e3bf376c1023"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c247aa25155ead7afed86c91cd0fda2a81a5334", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/2c247aa25155ead7afed86c91cd0fda2a81a5334", "committedDate": "2020-12-02T03:47:38Z", "message": "Updating.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2df64b36e3e2438d85b778de92e68c3ebcf69fbd", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/2df64b36e3e2438d85b778de92e68c3ebcf69fbd", "committedDate": "2020-12-02T04:01:09Z", "message": "Updating.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da40eb138c3fcaaf2f97c800ea1740627b073eb3", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/da40eb138c3fcaaf2f97c800ea1740627b073eb3", "committedDate": "2020-12-02T05:23:50Z", "message": "Fixing comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "368a5d25286dd58e1b622095c92986c868e10d21", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/368a5d25286dd58e1b622095c92986c868e10d21", "committedDate": "2020-12-02T05:41:28Z", "message": "Removing logs directory from DataRecoveryTest\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c935a17a429a2334515a95fd8ecd3a6b22acb7c9", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/c935a17a429a2334515a95fd8ecd3a6b22acb7c9", "committedDate": "2020-12-02T06:10:21Z", "message": "Minor changes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "def5bafbf7c89dccce44cee1cc750ce9d707307c", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/def5bafbf7c89dccce44cee1cc750ce9d707307c", "committedDate": "2020-12-02T06:49:20Z", "message": "Minor changes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85331e444249645b0c569b8f06813cb425b8a771", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/85331e444249645b0c569b8f06813cb425b8a771", "committedDate": "2020-12-02T17:01:28Z", "message": "Updating dr test with new command name.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9867c311fee3b26408fc787fdfec7e40e164e280", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/9867c311fee3b26408fc787fdfec7e40e164e280", "committedDate": "2020-12-02T17:12:54Z", "message": "Removing unnecessary file.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NDAwOTEz", "url": "https://github.com/pravega/pravega/pull/5371#pullrequestreview-544400913", "createdAt": "2020-12-03T20:31:48Z", "commit": {"oid": "9867c311fee3b26408fc787fdfec7e40e164e280"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozMTo0OVrOH-w6wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozMTo0OVrOH-w6wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU3NTIzMw==", "bodyText": "@andreipaduroiu @sachin-j-joshi  Should I remove this? This method was included for testing purpose to verify if the attributes for each of the segment is correctly updated or not?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r535575233", "createdAt": "2020-12-03T20:31:49Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -441,4 +443,106 @@ public static void updateCoreAttributes(Map<Integer, String> backUpMetadataSegme\n         Futures.allOf(futures).get(timeout.toMillis(), TimeUnit.MILLISECONDS);\n         return backUpMetadataSegments;\n     }\n+\n+    public static boolean matchAttributes(Map<Integer, String> backUpMetadataSegments,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9867c311fee3b26408fc787fdfec7e40e164e280"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dab0ebcc9fcf9d9252d23dd54c776bd00b69992", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/4dab0ebcc9fcf9d9252d23dd54c776bd00b69992", "committedDate": "2020-12-03T21:32:36Z", "message": "Removing match attributes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e45b4b6684402aee3ca376d4e785229db155e0f", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/7e45b4b6684402aee3ca376d4e785229db155e0f", "committedDate": "2020-12-03T22:01:54Z", "message": "Some checkstyle fails.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3791cc8325db5126254b303ac0fb2e7a1559b075", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/3791cc8325db5126254b303ac0fb2e7a1559b075", "committedDate": "2020-12-03T22:11:23Z", "message": "Removing unnecessary parts.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c87aca72068e2676924a7c35af8b5d1f706328d", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/7c87aca72068e2676924a7c35af8b5d1f706328d", "committedDate": "2020-12-04T02:26:15Z", "message": "Updating file path.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7772ced295c870f581960fd16a51c1020c72134e", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/7772ced295c870f581960fd16a51c1020c72134e", "committedDate": "2020-12-04T05:14:20Z", "message": "Updating properties file.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/0a79b063b0ce3a48135dd878c4ade2bec390c6a6", "committedDate": "2020-12-04T05:15:56Z", "message": "Updating properties file.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzI0Njcw", "url": "https://github.com/pravega/pravega/pull/5371#pullrequestreview-547724670", "createdAt": "2020-12-08T23:38:52Z", "commit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzozODo1MlrOIB7XUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo1MDowN1rOIB7pyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MjExMw==", "bodyText": "Do you really need 100 threads? Are 10 enough?\nThe entire segment store runs on 30 threads...", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538892113", "createdAt": "2020-12-08T23:38:52Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DurableLogRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerFactory;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import lombok.Cleanup;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class DurableLogRecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig.builder().build();\n+\n+    private static final ContainerConfig DEFAULT_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, 10 * 60)\n+            .build();\n+\n+    private static final ContainerConfig CONTAINER_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, (int) DEFAULT_CONFIG.getSegmentMetadataExpiration().getSeconds())\n+            .build();\n+\n+    private static final WriterConfig WRITER_CONFIG = WriterConfig.builder().build();\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MjMyNw==", "bodyText": "cleanup the data log factory if you get an error here", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538892327", "createdAt": "2020-12-08T23:39:25Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DurableLogRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerFactory;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import lombok.Cleanup;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class DurableLogRecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig.builder().build();\n+\n+    private static final ContainerConfig DEFAULT_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, 10 * 60)\n+            .build();\n+\n+    private static final ContainerConfig CONTAINER_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, (int) DEFAULT_CONFIG.getSegmentMetadataExpiration().getSeconds())\n+            .build();\n+\n+    private static final WriterConfig WRITER_CONFIG = WriterConfig.builder().build();\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final CuratorFramework zkClient;\n+    private final Storage storage;\n+    private BookKeeperLogFactory dataLogFactory = null;\n+\n+    /**\n+     * Creates an instance of DurableLogRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public DurableLogRecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+        this.storage = this.storageFactory.createStorageAdapter();\n+        this.zkClient = createZKClient();\n+    }\n+\n+\n+    @Override\n+    public void execute() throws Exception {\n+        outputInfo(\"Container Count = %d\", this.containerCount);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        this.dataLogFactory = new BookKeeperLogFactory(bkConfig, this.zkClient, executorService);\n+        try {\n+            this.dataLogFactory.initialize();\n+        } catch (DurableDataLogException ex) {\n+            this.zkClient.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MjYyOA==", "bodyText": "Why don't you create this in the constructor? That's where you create everything else and you have everything else you need.\nYou can leave the initialization here.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538892628", "createdAt": "2020-12-08T23:40:09Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DurableLogRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerFactory;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import lombok.Cleanup;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class DurableLogRecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig.builder().build();\n+\n+    private static final ContainerConfig DEFAULT_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, 10 * 60)\n+            .build();\n+\n+    private static final ContainerConfig CONTAINER_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, (int) DEFAULT_CONFIG.getSegmentMetadataExpiration().getSeconds())\n+            .build();\n+\n+    private static final WriterConfig WRITER_CONFIG = WriterConfig.builder().build();\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final CuratorFramework zkClient;\n+    private final Storage storage;\n+    private BookKeeperLogFactory dataLogFactory = null;\n+\n+    /**\n+     * Creates an instance of DurableLogRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public DurableLogRecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+        this.storage = this.storageFactory.createStorageAdapter();\n+        this.zkClient = createZKClient();\n+    }\n+\n+\n+    @Override\n+    public void execute() throws Exception {\n+        outputInfo(\"Container Count = %d\", this.containerCount);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        this.dataLogFactory = new BookKeeperLogFactory(bkConfig, this.zkClient, executorService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MjcwMg==", "bodyText": "This is not needed.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538892702", "createdAt": "2020-12-08T23:40:20Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DurableLogRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerFactory;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import lombok.Cleanup;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class DurableLogRecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig.builder().build();\n+\n+    private static final ContainerConfig DEFAULT_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, 10 * 60)\n+            .build();\n+\n+    private static final ContainerConfig CONTAINER_CONFIG = ContainerConfig\n+            .builder()\n+            .with(ContainerConfig.SEGMENT_METADATA_EXPIRATION_SECONDS, (int) DEFAULT_CONFIG.getSegmentMetadataExpiration().getSeconds())\n+            .build();\n+\n+    private static final WriterConfig WRITER_CONFIG = WriterConfig.builder().build();\n+\n+    private final ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(100, \"recoveryProcessor\");\n+    private final int containerCount;\n+    private final StorageFactory storageFactory;\n+    private final CuratorFramework zkClient;\n+    private final Storage storage;\n+    private BookKeeperLogFactory dataLogFactory = null;\n+\n+    /**\n+     * Creates an instance of DurableLogRecoveryCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public DurableLogRecoveryCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.storageFactory = createStorageFactory(executorService);\n+        this.storage = this.storageFactory.createStorageAdapter();\n+        this.zkClient = createZKClient();\n+    }\n+\n+\n+    @Override\n+    public void execute() throws Exception {\n+        outputInfo(\"Container Count = %d\", this.containerCount);\n+\n+        // Start a zk client and create a bookKeeperLogFactory\n+        val bkConfig = getCommandArgs().getState().getConfigBuilder()\n+                .include(BookKeeperConfig.builder().with(BookKeeperConfig.ZK_ADDRESS, getServiceConfig().getZkURL()))\n+                .build().getConfig(BookKeeperConfig::builder);\n+\n+        this.dataLogFactory = new BookKeeperLogFactory(bkConfig, this.zkClient, executorService);\n+        try {\n+            this.dataLogFactory.initialize();\n+        } catch (DurableDataLogException ex) {\n+            this.zkClient.close();\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NDAxNQ==", "bodyText": "In your close method, you need to close all the (non-null) writers in this array.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538894015", "createdAt": "2020-12-08T23:43:32Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/StorageListSegmentsCommand.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.segment.SegmentToContainerMapper;\n+import org.apache.hadoop.fs.Path;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.text.SimpleDateFormat;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Lists all non-shadow segments from there from the storage. The storage is loaded using the config properties.\n+ */\n+public class StorageListSegmentsCommand extends DataRecoveryCommand implements AutoCloseable {\n+    /**\n+     * Header line for writing segments' details to csv files.\n+     */\n+    private static final List<String> HEADER = Arrays.asList(\"Sealed Status\", \"Length\", \"Segment Name\");\n+    private static final int CONTAINER_EPOCH = 1;\n+    private final int containerCount;\n+    private final ScheduledExecutorService scheduledExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(10,\n+            \"listSegmentsProcessor\");\n+    private final SegmentToContainerMapper segToConMapper;\n+    private final StorageFactory storageFactory;\n+    private final Storage storage;\n+    private final FileWriter[] csvWriters;\n+    private String filePath;\n+\n+    /**\n+     * Creates an instance of StorageListSegmentsCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public StorageListSegmentsCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.segToConMapper = new SegmentToContainerMapper(this.containerCount);\n+        this.storageFactory = createStorageFactory(scheduledExecutorService);\n+        this.storage = this.storageFactory.createStorageAdapter();\n+        this.csvWriters = new FileWriter[this.containerCount];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NDYzNA==", "bodyText": "Please inherit from ThreadPooledTestSuite for any unit test suites that require an executor. That will create an executor (of your desired size - override the method) and you don't need to worry about shutting it down .", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538894634", "createdAt": "2020-12-08T23:44:57Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NDg3Ng==", "bodyText": "It is a best practice to keep your tearDown next to your setUp methods. That way you can clearly see what you create and what you cleanup.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538894876", "createdAt": "2020-12-08T23:45:34Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");\n+    private final ScalingPolicy scalingPolicy = ScalingPolicy.fixed(1);\n+    private final StreamConfiguration config = StreamConfiguration.builder().scalingPolicy(scalingPolicy).build();\n+\n+    /**\n+     * A directory for FILESYSTEM storage as LTS.\n+     */\n+    private File baseDir = null;\n+    private FileSystemStorageConfig adapterConfig;\n+    private StorageFactory storageFactory = null;\n+\n+    /**\n+     * A directory for storing logs and CSV files generated during the test..\n+     */\n+    private File logsDir = null;\n+    private BookKeeperLogFactory factory = null;\n+\n+    @Before\n+    public void setUp() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NTIwMw==", "bodyText": "wait, why is there a capital D in this command? I thought all commands were lowercase.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538895203", "createdAt": "2020-12-08T23:46:22Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");\n+    private final ScalingPolicy scalingPolicy = ScalingPolicy.fixed(1);\n+    private final StreamConfiguration config = StreamConfiguration.builder().scalingPolicy(scalingPolicy).build();\n+\n+    /**\n+     * A directory for FILESYSTEM storage as LTS.\n+     */\n+    private File baseDir = null;\n+    private FileSystemStorageConfig adapterConfig;\n+    private StorageFactory storageFactory = null;\n+\n+    /**\n+     * A directory for storing logs and CSV files generated during the test..\n+     */\n+    private File logsDir = null;\n+    private BookKeeperLogFactory factory = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseDir = Files.createTempDirectory(\"TestDataRecovery\").toFile().getAbsoluteFile();\n+        this.logsDir = Files.createTempDirectory(\"DataRecovery\").toFile().getAbsoluteFile();\n+        this.adapterConfig = FileSystemStorageConfig.builder()\n+                .with(FileSystemStorageConfig.ROOT, this.baseDir.getAbsolutePath())\n+                .with(FileSystemStorageConfig.REPLACE_ENABLED, true)\n+                .build();\n+\n+        this.storageFactory = new FileSystemStorageFactory(adapterConfig, this.executor);\n+    }\n+\n+    // Creates the given scope and stream using the given controller instance.\n+    private void createScopeStream(Controller controller, String scopeName, String streamName) {\n+        ClientConfig clientConfig = ClientConfig.builder().build();\n+        try (ConnectionPool cp = new ConnectionPoolImpl(clientConfig, new SocketConnectionFactoryImpl(clientConfig));\n+             StreamManager streamManager = new StreamManagerImpl(controller, cp)) {\n+            //create scope\n+            Boolean createScopeStatus = streamManager.createScope(scopeName);\n+            log.info(\"Create scope status {}\", createScopeStatus);\n+            //create stream\n+            Boolean createStreamStatus = streamManager.createStream(scopeName, streamName, config);\n+            log.info(\"Create stream status {}\", createStreamStatus);\n+        }\n+    }\n+\n+    /**\n+     * Tests DurableLog recovery command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testDataRecoveryCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testDataRecoveryCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // start a new BookKeeper and ZooKeeper.\n+        pravegaRunner.bookKeeperRunner = new BookKeeperRunner(instanceId++, bookieCount);\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        pravegaProperties.setProperty(\"pravegaservice.zk.connect.uri\", \"localhost:\" + pravegaRunner.bookKeeperRunner.bkPort);\n+        pravegaProperties.setProperty(\"bookkeeper.ledger.path\", pravegaRunner.bookKeeperRunner.ledgerPath);\n+        pravegaProperties.setProperty(\"bookkeeper.zk.metadata.path\", pravegaRunner.bookKeeperRunner.logMetaNamespace);\n+        pravegaProperties.setProperty(\"pravegaservice.clusterName\", pravegaRunner.bookKeeperRunner.baseNamespace);\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Command under test\n+        TestUtils.executeCommand(\"storage DurableLog-recovery\", STATE.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NTM2OA==", "bodyText": "@Cleanup\nThat will guarantee it's closed even if your test fails.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538895368", "createdAt": "2020-12-08T23:46:48Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");\n+    private final ScalingPolicy scalingPolicy = ScalingPolicy.fixed(1);\n+    private final StreamConfiguration config = StreamConfiguration.builder().scalingPolicy(scalingPolicy).build();\n+\n+    /**\n+     * A directory for FILESYSTEM storage as LTS.\n+     */\n+    private File baseDir = null;\n+    private FileSystemStorageConfig adapterConfig;\n+    private StorageFactory storageFactory = null;\n+\n+    /**\n+     * A directory for storing logs and CSV files generated during the test..\n+     */\n+    private File logsDir = null;\n+    private BookKeeperLogFactory factory = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseDir = Files.createTempDirectory(\"TestDataRecovery\").toFile().getAbsoluteFile();\n+        this.logsDir = Files.createTempDirectory(\"DataRecovery\").toFile().getAbsoluteFile();\n+        this.adapterConfig = FileSystemStorageConfig.builder()\n+                .with(FileSystemStorageConfig.ROOT, this.baseDir.getAbsolutePath())\n+                .with(FileSystemStorageConfig.REPLACE_ENABLED, true)\n+                .build();\n+\n+        this.storageFactory = new FileSystemStorageFactory(adapterConfig, this.executor);\n+    }\n+\n+    // Creates the given scope and stream using the given controller instance.\n+    private void createScopeStream(Controller controller, String scopeName, String streamName) {\n+        ClientConfig clientConfig = ClientConfig.builder().build();\n+        try (ConnectionPool cp = new ConnectionPoolImpl(clientConfig, new SocketConnectionFactoryImpl(clientConfig));\n+             StreamManager streamManager = new StreamManagerImpl(controller, cp)) {\n+            //create scope\n+            Boolean createScopeStatus = streamManager.createScope(scopeName);\n+            log.info(\"Create scope status {}\", createScopeStatus);\n+            //create stream\n+            Boolean createStreamStatus = streamManager.createStream(scopeName, streamName, config);\n+            log.info(\"Create stream status {}\", createStreamStatus);\n+        }\n+    }\n+\n+    /**\n+     * Tests DurableLog recovery command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testDataRecoveryCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testDataRecoveryCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // start a new BookKeeper and ZooKeeper.\n+        pravegaRunner.bookKeeperRunner = new BookKeeperRunner(instanceId++, bookieCount);\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        pravegaProperties.setProperty(\"pravegaservice.zk.connect.uri\", \"localhost:\" + pravegaRunner.bookKeeperRunner.bkPort);\n+        pravegaProperties.setProperty(\"bookkeeper.ledger.path\", pravegaRunner.bookKeeperRunner.ledgerPath);\n+        pravegaProperties.setProperty(\"bookkeeper.zk.metadata.path\", pravegaRunner.bookKeeperRunner.logMetaNamespace);\n+        pravegaProperties.setProperty(\"pravegaservice.clusterName\", pravegaRunner.bookKeeperRunner.baseNamespace);\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Command under test\n+        TestUtils.executeCommand(\"storage DurableLog-recovery\", STATE.get());\n+\n+        // Start a new segment store and controller\n+        this.factory = new BookKeeperLogFactory(pravegaRunner.bookKeeperRunner.bkConfig.get(), pravegaRunner.bookKeeperRunner.zkClient.get(),\n+                executor);\n+        pravegaRunner.restartControllerAndSegmentStore(this.storageFactory, this.factory);\n+        log.info(\"Started a controller and segment store.\");\n+        // Create the client with new controller.\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Try reading all events to verify that the recovery was successful.\n+            readAllEvents(streamName, clientRunner.clientFactory, clientRunner.readerGroupManager, \"RG\", \"R\");\n+            log.info(\"Read all events again to verify that segments were recovered.\");\n+        }\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    /**\n+     * Tests list segments command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testListSegmentsCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testListSegmentsCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Execute the command for list segments\n+        TestUtils.executeCommand(\"storage list-segments \" + this.logsDir.getAbsolutePath(), STATE.get());\n+        // There should be a csv file created for storing segments in Container 0\n+        Assert.assertTrue(new File(this.logsDir.getAbsolutePath(), \"Container_0.csv\").exists());\n+        // Check if the file has segments listed in it\n+        Path path = Paths.get(this.logsDir.getAbsolutePath() + \"/Container_0.csv\");\n+        long lines = Files.lines(path).count();\n+        AssertExtensions.assertGreaterThan(\"There should be at least one segment.\", 1, lines);\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException {\n+        STATE.get().close();\n+        if (this.factory != null) {\n+            this.factory.close();\n+        }\n+        FileHelpers.deleteFileOrDirectory(this.baseDir);\n+        FileHelpers.deleteFileOrDirectory(this.logsDir);\n+        ExecutorServiceHelpers.shutdown(Duration.ofSeconds(2), executor);\n+    }\n+\n+    // write events to the given stream\n+    private void writeEvents(String streamName, ClientFactoryImpl clientFactory) {\n+        EventStreamWriter<String> writer = clientFactory.createEventWriter(streamName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NTYzNQ==", "bodyText": "Same here", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538895635", "createdAt": "2020-12-08T23:47:21Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");\n+    private final ScalingPolicy scalingPolicy = ScalingPolicy.fixed(1);\n+    private final StreamConfiguration config = StreamConfiguration.builder().scalingPolicy(scalingPolicy).build();\n+\n+    /**\n+     * A directory for FILESYSTEM storage as LTS.\n+     */\n+    private File baseDir = null;\n+    private FileSystemStorageConfig adapterConfig;\n+    private StorageFactory storageFactory = null;\n+\n+    /**\n+     * A directory for storing logs and CSV files generated during the test..\n+     */\n+    private File logsDir = null;\n+    private BookKeeperLogFactory factory = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseDir = Files.createTempDirectory(\"TestDataRecovery\").toFile().getAbsoluteFile();\n+        this.logsDir = Files.createTempDirectory(\"DataRecovery\").toFile().getAbsoluteFile();\n+        this.adapterConfig = FileSystemStorageConfig.builder()\n+                .with(FileSystemStorageConfig.ROOT, this.baseDir.getAbsolutePath())\n+                .with(FileSystemStorageConfig.REPLACE_ENABLED, true)\n+                .build();\n+\n+        this.storageFactory = new FileSystemStorageFactory(adapterConfig, this.executor);\n+    }\n+\n+    // Creates the given scope and stream using the given controller instance.\n+    private void createScopeStream(Controller controller, String scopeName, String streamName) {\n+        ClientConfig clientConfig = ClientConfig.builder().build();\n+        try (ConnectionPool cp = new ConnectionPoolImpl(clientConfig, new SocketConnectionFactoryImpl(clientConfig));\n+             StreamManager streamManager = new StreamManagerImpl(controller, cp)) {\n+            //create scope\n+            Boolean createScopeStatus = streamManager.createScope(scopeName);\n+            log.info(\"Create scope status {}\", createScopeStatus);\n+            //create stream\n+            Boolean createStreamStatus = streamManager.createStream(scopeName, streamName, config);\n+            log.info(\"Create stream status {}\", createStreamStatus);\n+        }\n+    }\n+\n+    /**\n+     * Tests DurableLog recovery command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testDataRecoveryCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testDataRecoveryCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // start a new BookKeeper and ZooKeeper.\n+        pravegaRunner.bookKeeperRunner = new BookKeeperRunner(instanceId++, bookieCount);\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        pravegaProperties.setProperty(\"pravegaservice.zk.connect.uri\", \"localhost:\" + pravegaRunner.bookKeeperRunner.bkPort);\n+        pravegaProperties.setProperty(\"bookkeeper.ledger.path\", pravegaRunner.bookKeeperRunner.ledgerPath);\n+        pravegaProperties.setProperty(\"bookkeeper.zk.metadata.path\", pravegaRunner.bookKeeperRunner.logMetaNamespace);\n+        pravegaProperties.setProperty(\"pravegaservice.clusterName\", pravegaRunner.bookKeeperRunner.baseNamespace);\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Command under test\n+        TestUtils.executeCommand(\"storage DurableLog-recovery\", STATE.get());\n+\n+        // Start a new segment store and controller\n+        this.factory = new BookKeeperLogFactory(pravegaRunner.bookKeeperRunner.bkConfig.get(), pravegaRunner.bookKeeperRunner.zkClient.get(),\n+                executor);\n+        pravegaRunner.restartControllerAndSegmentStore(this.storageFactory, this.factory);\n+        log.info(\"Started a controller and segment store.\");\n+        // Create the client with new controller.\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Try reading all events to verify that the recovery was successful.\n+            readAllEvents(streamName, clientRunner.clientFactory, clientRunner.readerGroupManager, \"RG\", \"R\");\n+            log.info(\"Read all events again to verify that segments were recovered.\");\n+        }\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    /**\n+     * Tests list segments command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testListSegmentsCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testListSegmentsCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Execute the command for list segments\n+        TestUtils.executeCommand(\"storage list-segments \" + this.logsDir.getAbsolutePath(), STATE.get());\n+        // There should be a csv file created for storing segments in Container 0\n+        Assert.assertTrue(new File(this.logsDir.getAbsolutePath(), \"Container_0.csv\").exists());\n+        // Check if the file has segments listed in it\n+        Path path = Paths.get(this.logsDir.getAbsolutePath() + \"/Container_0.csv\");\n+        long lines = Files.lines(path).count();\n+        AssertExtensions.assertGreaterThan(\"There should be at least one segment.\", 1, lines);\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException {\n+        STATE.get().close();\n+        if (this.factory != null) {\n+            this.factory.close();\n+        }\n+        FileHelpers.deleteFileOrDirectory(this.baseDir);\n+        FileHelpers.deleteFileOrDirectory(this.logsDir);\n+        ExecutorServiceHelpers.shutdown(Duration.ofSeconds(2), executor);\n+    }\n+\n+    // write events to the given stream\n+    private void writeEvents(String streamName, ClientFactoryImpl clientFactory) {\n+        EventStreamWriter<String> writer = clientFactory.createEventWriter(streamName,\n+                new UTF8StringSerializer(),\n+                EventWriterConfig.builder().build());\n+        for (int i = 0; i < NUM_EVENTS;) {\n+            writer.writeEvent(\"\", EVENT).join();\n+            i++;\n+        }\n+        writer.flush();\n+        writer.close();\n+    }\n+\n+    // read all events from the given stream\n+    private void readAllEvents(String streamName, ClientFactoryImpl clientFactory, ReaderGroupManager readerGroupManager,\n+                               String readerGroupName, String readerName) {\n+        readerGroupManager.createReaderGroup(readerGroupName,\n+                ReaderGroupConfig\n+                        .builder()\n+                        .stream(Stream.of(SCOPE, streamName))\n+                        .build());\n+\n+        EventStreamReader<String> reader = clientFactory.createReader(readerName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NjI3OQ==", "bodyText": "This one can be made final.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538896279", "createdAt": "2020-12-08T23:49:00Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");\n+    private final ScalingPolicy scalingPolicy = ScalingPolicy.fixed(1);\n+    private final StreamConfiguration config = StreamConfiguration.builder().scalingPolicy(scalingPolicy).build();\n+\n+    /**\n+     * A directory for FILESYSTEM storage as LTS.\n+     */\n+    private File baseDir = null;\n+    private FileSystemStorageConfig adapterConfig;\n+    private StorageFactory storageFactory = null;\n+\n+    /**\n+     * A directory for storing logs and CSV files generated during the test..\n+     */\n+    private File logsDir = null;\n+    private BookKeeperLogFactory factory = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseDir = Files.createTempDirectory(\"TestDataRecovery\").toFile().getAbsoluteFile();\n+        this.logsDir = Files.createTempDirectory(\"DataRecovery\").toFile().getAbsoluteFile();\n+        this.adapterConfig = FileSystemStorageConfig.builder()\n+                .with(FileSystemStorageConfig.ROOT, this.baseDir.getAbsolutePath())\n+                .with(FileSystemStorageConfig.REPLACE_ENABLED, true)\n+                .build();\n+\n+        this.storageFactory = new FileSystemStorageFactory(adapterConfig, this.executor);\n+    }\n+\n+    // Creates the given scope and stream using the given controller instance.\n+    private void createScopeStream(Controller controller, String scopeName, String streamName) {\n+        ClientConfig clientConfig = ClientConfig.builder().build();\n+        try (ConnectionPool cp = new ConnectionPoolImpl(clientConfig, new SocketConnectionFactoryImpl(clientConfig));\n+             StreamManager streamManager = new StreamManagerImpl(controller, cp)) {\n+            //create scope\n+            Boolean createScopeStatus = streamManager.createScope(scopeName);\n+            log.info(\"Create scope status {}\", createScopeStatus);\n+            //create stream\n+            Boolean createStreamStatus = streamManager.createStream(scopeName, streamName, config);\n+            log.info(\"Create stream status {}\", createStreamStatus);\n+        }\n+    }\n+\n+    /**\n+     * Tests DurableLog recovery command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testDataRecoveryCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testDataRecoveryCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // start a new BookKeeper and ZooKeeper.\n+        pravegaRunner.bookKeeperRunner = new BookKeeperRunner(instanceId++, bookieCount);\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        pravegaProperties.setProperty(\"pravegaservice.zk.connect.uri\", \"localhost:\" + pravegaRunner.bookKeeperRunner.bkPort);\n+        pravegaProperties.setProperty(\"bookkeeper.ledger.path\", pravegaRunner.bookKeeperRunner.ledgerPath);\n+        pravegaProperties.setProperty(\"bookkeeper.zk.metadata.path\", pravegaRunner.bookKeeperRunner.logMetaNamespace);\n+        pravegaProperties.setProperty(\"pravegaservice.clusterName\", pravegaRunner.bookKeeperRunner.baseNamespace);\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Command under test\n+        TestUtils.executeCommand(\"storage DurableLog-recovery\", STATE.get());\n+\n+        // Start a new segment store and controller\n+        this.factory = new BookKeeperLogFactory(pravegaRunner.bookKeeperRunner.bkConfig.get(), pravegaRunner.bookKeeperRunner.zkClient.get(),\n+                executor);\n+        pravegaRunner.restartControllerAndSegmentStore(this.storageFactory, this.factory);\n+        log.info(\"Started a controller and segment store.\");\n+        // Create the client with new controller.\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Try reading all events to verify that the recovery was successful.\n+            readAllEvents(streamName, clientRunner.clientFactory, clientRunner.readerGroupManager, \"RG\", \"R\");\n+            log.info(\"Read all events again to verify that segments were recovered.\");\n+        }\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    /**\n+     * Tests list segments command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testListSegmentsCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testListSegmentsCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Execute the command for list segments\n+        TestUtils.executeCommand(\"storage list-segments \" + this.logsDir.getAbsolutePath(), STATE.get());\n+        // There should be a csv file created for storing segments in Container 0\n+        Assert.assertTrue(new File(this.logsDir.getAbsolutePath(), \"Container_0.csv\").exists());\n+        // Check if the file has segments listed in it\n+        Path path = Paths.get(this.logsDir.getAbsolutePath() + \"/Container_0.csv\");\n+        long lines = Files.lines(path).count();\n+        AssertExtensions.assertGreaterThan(\"There should be at least one segment.\", 1, lines);\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException {\n+        STATE.get().close();\n+        if (this.factory != null) {\n+            this.factory.close();\n+        }\n+        FileHelpers.deleteFileOrDirectory(this.baseDir);\n+        FileHelpers.deleteFileOrDirectory(this.logsDir);\n+        ExecutorServiceHelpers.shutdown(Duration.ofSeconds(2), executor);\n+    }\n+\n+    // write events to the given stream\n+    private void writeEvents(String streamName, ClientFactoryImpl clientFactory) {\n+        EventStreamWriter<String> writer = clientFactory.createEventWriter(streamName,\n+                new UTF8StringSerializer(),\n+                EventWriterConfig.builder().build());\n+        for (int i = 0; i < NUM_EVENTS;) {\n+            writer.writeEvent(\"\", EVENT).join();\n+            i++;\n+        }\n+        writer.flush();\n+        writer.close();\n+    }\n+\n+    // read all events from the given stream\n+    private void readAllEvents(String streamName, ClientFactoryImpl clientFactory, ReaderGroupManager readerGroupManager,\n+                               String readerGroupName, String readerName) {\n+        readerGroupManager.createReaderGroup(readerGroupName,\n+                ReaderGroupConfig\n+                        .builder()\n+                        .stream(Stream.of(SCOPE, streamName))\n+                        .build());\n+\n+        EventStreamReader<String> reader = clientFactory.createReader(readerName,\n+                readerGroupName,\n+                new UTF8StringSerializer(),\n+                ReaderConfig.builder().build());\n+\n+        for (int q = 0; q < NUM_EVENTS;) {\n+            String eventRead = reader.readNextEvent(READ_TIMEOUT.toMillis()).getEvent();\n+            Assert.assertEquals(\"Event written and read back don't match\", EVENT, eventRead);\n+            q++;\n+        }\n+        reader.close();\n+    }\n+\n+    /**\n+     * Sets up a new BookKeeper & ZooKeeper.\n+     */\n+    private static class BookKeeperRunner implements AutoCloseable {\n+        private final int bkPort;\n+        private final BookKeeperServiceRunner bookKeeperServiceRunner;\n+        private final AtomicReference<BookKeeperConfig> bkConfig = new AtomicReference<>();\n+        private final AtomicReference<CuratorFramework> zkClient = new AtomicReference<>();\n+        private final AtomicReference<BookKeeperServiceRunner> bkService = new AtomicReference<>();\n+        private final String ledgerPath;\n+        private final String logMetaNamespace;\n+        private final String baseNamespace;\n+        BookKeeperRunner(int instanceId, int bookieCount) throws Exception {\n+            this.ledgerPath = \"/pravega/bookkeeper/ledgers\" + instanceId;\n+            this.bkPort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+            val bookiePorts = new ArrayList<Integer>();\n+            for (int i = 0; i < bookieCount; i++) {\n+                bookiePorts.add(io.pravega.test.common.TestUtils.getAvailableListenPort());\n+            }\n+            this.bookKeeperServiceRunner = BookKeeperServiceRunner.builder()\n+                    .startZk(true)\n+                    .zkPort(bkPort)\n+                    .ledgersPath(ledgerPath)\n+                    .bookiePorts(bookiePorts)\n+                    .build();\n+            try {\n+                this.bookKeeperServiceRunner.startAll();\n+            } catch (Exception e) {\n+                log.error(\"Exception occurred while starting bookKeeper service.\", e);\n+                this.close();\n+                throw e;\n+            }\n+            this.bkService.set(this.bookKeeperServiceRunner);\n+\n+            // Create a ZKClient with a unique namespace.\n+            this.baseNamespace = \"pravega\" + instanceId;\n+            this.zkClient.set(CuratorFrameworkFactory\n+                    .builder()\n+                    .connectString(\"localhost:\" + bkPort)\n+                    .namespace(baseNamespace)\n+                    .retryPolicy(new ExponentialBackoffRetry(1000, 10))\n+                    .build());\n+\n+            this.zkClient.get().start();\n+\n+            logMetaNamespace = \"segmentstore/containers\" + instanceId;\n+            this.bkConfig.set(BookKeeperConfig\n+                    .builder()\n+                    .with(BookKeeperConfig.ZK_ADDRESS, \"localhost:\" + bkPort)\n+                    .with(BookKeeperConfig.ZK_METADATA_PATH, logMetaNamespace)\n+                    .with(BookKeeperConfig.BK_LEDGER_PATH, ledgerPath)\n+                    .build());\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            val process = this.bkService.getAndSet(null);\n+            if (process != null) {\n+                process.close();\n+            }\n+\n+            val bk = this.bookKeeperServiceRunner;\n+            if (bk != null) {\n+                bk.close();\n+            }\n+\n+            val zkClient = this.zkClient.getAndSet(null);\n+            if (zkClient != null) {\n+                zkClient.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a segment store.\n+     */\n+    private static class SegmentStoreRunner implements AutoCloseable {\n+        private final int servicePort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+        private final ServiceBuilder serviceBuilder;\n+        private final PravegaConnectionListener server;\n+        private final StreamSegmentStore streamSegmentStore;\n+        private final TableStore tableStore;\n+\n+        SegmentStoreRunner(StorageFactory storageFactory, BookKeeperLogFactory dataLogFactory, int containerCount)\n+                throws DurableDataLogException {\n+            ServiceBuilderConfig.Builder configBuilder = ServiceBuilderConfig\n+                    .builder()\n+                    .include(ServiceConfig.builder()\n+                            .with(ServiceConfig.CONTAINER_COUNT, containerCount))\n+                    .include(WriterConfig.builder()\n+                            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+                            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+                    );\n+            if (storageFactory != null) {\n+                if (dataLogFactory != null) {\n+                    this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(configBuilder.build())\n+                            .withStorageFactory(setup -> storageFactory)\n+                            .withDataLogFactory(setup -> dataLogFactory);\n+                } else {\n+                    this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(configBuilder.build())\n+                            .withStorageFactory(setup -> storageFactory);\n+                }\n+            } else {\n+                this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n+            }\n+            this.serviceBuilder.initialize();\n+            this.streamSegmentStore = this.serviceBuilder.createStreamSegmentService();\n+            this.tableStore = this.serviceBuilder.createTableStoreService();\n+            this.server = new PravegaConnectionListener(false, servicePort, this.streamSegmentStore, this.tableStore,\n+                    this.serviceBuilder.getLowPriorityExecutor());\n+            this.server.startListening();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.server.close();\n+            this.serviceBuilder.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a controller instance and runs it.\n+     */\n+    private static class ControllerRunner implements AutoCloseable {\n+        private final int controllerPort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+        private final String serviceHost = \"localhost\";\n+        private final ControllerWrapper controllerWrapper;\n+        private final Controller controller;\n+        private final URI controllerURI = URI.create(\"tcp://\" + serviceHost + \":\" + controllerPort);\n+\n+        ControllerRunner(int bkPort, int servicePort, int containerCount) throws InterruptedException {\n+            this.controllerWrapper = new ControllerWrapper(\"localhost:\" + bkPort, false,\n+                    controllerPort, serviceHost, servicePort, containerCount);\n+            this.controllerWrapper.awaitRunning();\n+            this.controller = controllerWrapper.getController();\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            this.controller.close();\n+            this.controllerWrapper.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a client to read and write events.\n+     */\n+    private static class ClientRunner implements AutoCloseable {\n+        private final ConnectionFactory connectionFactory;\n+        private final ClientFactoryImpl clientFactory;\n+        private final ReaderGroupManager readerGroupManager;\n+\n+        ClientRunner(ControllerRunner controllerRunner) {\n+            this.connectionFactory = new SocketConnectionFactoryImpl(ClientConfig.builder()\n+                    .controllerURI(controllerRunner.controllerURI).build());\n+            this.clientFactory = new ClientFactoryImpl(SCOPE, controllerRunner.controller, connectionFactory);\n+            this.readerGroupManager = new ReaderGroupManagerImpl(SCOPE, controllerRunner.controller, clientFactory);\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.readerGroupManager.close();\n+            this.clientFactory.close();\n+            this.connectionFactory.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a Pravega instance.\n+     */\n+    private static class PravegaRunner implements AutoCloseable {\n+        private final int containerCount;\n+        private BookKeeperRunner bookKeeperRunner;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NjczMg==", "bodyText": "Can this method be invoked multiple times? If not, then enforce it.\nIf it does, then you need to close whatever segmentStoreRunner and controllerRunner you had in your member variables before assigning them to new instances. Otherwise you'll have resource leaks.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538896732", "createdAt": "2020-12-08T23:49:52Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");\n+    private final ScalingPolicy scalingPolicy = ScalingPolicy.fixed(1);\n+    private final StreamConfiguration config = StreamConfiguration.builder().scalingPolicy(scalingPolicy).build();\n+\n+    /**\n+     * A directory for FILESYSTEM storage as LTS.\n+     */\n+    private File baseDir = null;\n+    private FileSystemStorageConfig adapterConfig;\n+    private StorageFactory storageFactory = null;\n+\n+    /**\n+     * A directory for storing logs and CSV files generated during the test..\n+     */\n+    private File logsDir = null;\n+    private BookKeeperLogFactory factory = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseDir = Files.createTempDirectory(\"TestDataRecovery\").toFile().getAbsoluteFile();\n+        this.logsDir = Files.createTempDirectory(\"DataRecovery\").toFile().getAbsoluteFile();\n+        this.adapterConfig = FileSystemStorageConfig.builder()\n+                .with(FileSystemStorageConfig.ROOT, this.baseDir.getAbsolutePath())\n+                .with(FileSystemStorageConfig.REPLACE_ENABLED, true)\n+                .build();\n+\n+        this.storageFactory = new FileSystemStorageFactory(adapterConfig, this.executor);\n+    }\n+\n+    // Creates the given scope and stream using the given controller instance.\n+    private void createScopeStream(Controller controller, String scopeName, String streamName) {\n+        ClientConfig clientConfig = ClientConfig.builder().build();\n+        try (ConnectionPool cp = new ConnectionPoolImpl(clientConfig, new SocketConnectionFactoryImpl(clientConfig));\n+             StreamManager streamManager = new StreamManagerImpl(controller, cp)) {\n+            //create scope\n+            Boolean createScopeStatus = streamManager.createScope(scopeName);\n+            log.info(\"Create scope status {}\", createScopeStatus);\n+            //create stream\n+            Boolean createStreamStatus = streamManager.createStream(scopeName, streamName, config);\n+            log.info(\"Create stream status {}\", createStreamStatus);\n+        }\n+    }\n+\n+    /**\n+     * Tests DurableLog recovery command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testDataRecoveryCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testDataRecoveryCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // start a new BookKeeper and ZooKeeper.\n+        pravegaRunner.bookKeeperRunner = new BookKeeperRunner(instanceId++, bookieCount);\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        pravegaProperties.setProperty(\"pravegaservice.zk.connect.uri\", \"localhost:\" + pravegaRunner.bookKeeperRunner.bkPort);\n+        pravegaProperties.setProperty(\"bookkeeper.ledger.path\", pravegaRunner.bookKeeperRunner.ledgerPath);\n+        pravegaProperties.setProperty(\"bookkeeper.zk.metadata.path\", pravegaRunner.bookKeeperRunner.logMetaNamespace);\n+        pravegaProperties.setProperty(\"pravegaservice.clusterName\", pravegaRunner.bookKeeperRunner.baseNamespace);\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Command under test\n+        TestUtils.executeCommand(\"storage DurableLog-recovery\", STATE.get());\n+\n+        // Start a new segment store and controller\n+        this.factory = new BookKeeperLogFactory(pravegaRunner.bookKeeperRunner.bkConfig.get(), pravegaRunner.bookKeeperRunner.zkClient.get(),\n+                executor);\n+        pravegaRunner.restartControllerAndSegmentStore(this.storageFactory, this.factory);\n+        log.info(\"Started a controller and segment store.\");\n+        // Create the client with new controller.\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Try reading all events to verify that the recovery was successful.\n+            readAllEvents(streamName, clientRunner.clientFactory, clientRunner.readerGroupManager, \"RG\", \"R\");\n+            log.info(\"Read all events again to verify that segments were recovered.\");\n+        }\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    /**\n+     * Tests list segments command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testListSegmentsCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testListSegmentsCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Execute the command for list segments\n+        TestUtils.executeCommand(\"storage list-segments \" + this.logsDir.getAbsolutePath(), STATE.get());\n+        // There should be a csv file created for storing segments in Container 0\n+        Assert.assertTrue(new File(this.logsDir.getAbsolutePath(), \"Container_0.csv\").exists());\n+        // Check if the file has segments listed in it\n+        Path path = Paths.get(this.logsDir.getAbsolutePath() + \"/Container_0.csv\");\n+        long lines = Files.lines(path).count();\n+        AssertExtensions.assertGreaterThan(\"There should be at least one segment.\", 1, lines);\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException {\n+        STATE.get().close();\n+        if (this.factory != null) {\n+            this.factory.close();\n+        }\n+        FileHelpers.deleteFileOrDirectory(this.baseDir);\n+        FileHelpers.deleteFileOrDirectory(this.logsDir);\n+        ExecutorServiceHelpers.shutdown(Duration.ofSeconds(2), executor);\n+    }\n+\n+    // write events to the given stream\n+    private void writeEvents(String streamName, ClientFactoryImpl clientFactory) {\n+        EventStreamWriter<String> writer = clientFactory.createEventWriter(streamName,\n+                new UTF8StringSerializer(),\n+                EventWriterConfig.builder().build());\n+        for (int i = 0; i < NUM_EVENTS;) {\n+            writer.writeEvent(\"\", EVENT).join();\n+            i++;\n+        }\n+        writer.flush();\n+        writer.close();\n+    }\n+\n+    // read all events from the given stream\n+    private void readAllEvents(String streamName, ClientFactoryImpl clientFactory, ReaderGroupManager readerGroupManager,\n+                               String readerGroupName, String readerName) {\n+        readerGroupManager.createReaderGroup(readerGroupName,\n+                ReaderGroupConfig\n+                        .builder()\n+                        .stream(Stream.of(SCOPE, streamName))\n+                        .build());\n+\n+        EventStreamReader<String> reader = clientFactory.createReader(readerName,\n+                readerGroupName,\n+                new UTF8StringSerializer(),\n+                ReaderConfig.builder().build());\n+\n+        for (int q = 0; q < NUM_EVENTS;) {\n+            String eventRead = reader.readNextEvent(READ_TIMEOUT.toMillis()).getEvent();\n+            Assert.assertEquals(\"Event written and read back don't match\", EVENT, eventRead);\n+            q++;\n+        }\n+        reader.close();\n+    }\n+\n+    /**\n+     * Sets up a new BookKeeper & ZooKeeper.\n+     */\n+    private static class BookKeeperRunner implements AutoCloseable {\n+        private final int bkPort;\n+        private final BookKeeperServiceRunner bookKeeperServiceRunner;\n+        private final AtomicReference<BookKeeperConfig> bkConfig = new AtomicReference<>();\n+        private final AtomicReference<CuratorFramework> zkClient = new AtomicReference<>();\n+        private final AtomicReference<BookKeeperServiceRunner> bkService = new AtomicReference<>();\n+        private final String ledgerPath;\n+        private final String logMetaNamespace;\n+        private final String baseNamespace;\n+        BookKeeperRunner(int instanceId, int bookieCount) throws Exception {\n+            this.ledgerPath = \"/pravega/bookkeeper/ledgers\" + instanceId;\n+            this.bkPort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+            val bookiePorts = new ArrayList<Integer>();\n+            for (int i = 0; i < bookieCount; i++) {\n+                bookiePorts.add(io.pravega.test.common.TestUtils.getAvailableListenPort());\n+            }\n+            this.bookKeeperServiceRunner = BookKeeperServiceRunner.builder()\n+                    .startZk(true)\n+                    .zkPort(bkPort)\n+                    .ledgersPath(ledgerPath)\n+                    .bookiePorts(bookiePorts)\n+                    .build();\n+            try {\n+                this.bookKeeperServiceRunner.startAll();\n+            } catch (Exception e) {\n+                log.error(\"Exception occurred while starting bookKeeper service.\", e);\n+                this.close();\n+                throw e;\n+            }\n+            this.bkService.set(this.bookKeeperServiceRunner);\n+\n+            // Create a ZKClient with a unique namespace.\n+            this.baseNamespace = \"pravega\" + instanceId;\n+            this.zkClient.set(CuratorFrameworkFactory\n+                    .builder()\n+                    .connectString(\"localhost:\" + bkPort)\n+                    .namespace(baseNamespace)\n+                    .retryPolicy(new ExponentialBackoffRetry(1000, 10))\n+                    .build());\n+\n+            this.zkClient.get().start();\n+\n+            logMetaNamespace = \"segmentstore/containers\" + instanceId;\n+            this.bkConfig.set(BookKeeperConfig\n+                    .builder()\n+                    .with(BookKeeperConfig.ZK_ADDRESS, \"localhost:\" + bkPort)\n+                    .with(BookKeeperConfig.ZK_METADATA_PATH, logMetaNamespace)\n+                    .with(BookKeeperConfig.BK_LEDGER_PATH, ledgerPath)\n+                    .build());\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            val process = this.bkService.getAndSet(null);\n+            if (process != null) {\n+                process.close();\n+            }\n+\n+            val bk = this.bookKeeperServiceRunner;\n+            if (bk != null) {\n+                bk.close();\n+            }\n+\n+            val zkClient = this.zkClient.getAndSet(null);\n+            if (zkClient != null) {\n+                zkClient.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a segment store.\n+     */\n+    private static class SegmentStoreRunner implements AutoCloseable {\n+        private final int servicePort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+        private final ServiceBuilder serviceBuilder;\n+        private final PravegaConnectionListener server;\n+        private final StreamSegmentStore streamSegmentStore;\n+        private final TableStore tableStore;\n+\n+        SegmentStoreRunner(StorageFactory storageFactory, BookKeeperLogFactory dataLogFactory, int containerCount)\n+                throws DurableDataLogException {\n+            ServiceBuilderConfig.Builder configBuilder = ServiceBuilderConfig\n+                    .builder()\n+                    .include(ServiceConfig.builder()\n+                            .with(ServiceConfig.CONTAINER_COUNT, containerCount))\n+                    .include(WriterConfig.builder()\n+                            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+                            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+                    );\n+            if (storageFactory != null) {\n+                if (dataLogFactory != null) {\n+                    this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(configBuilder.build())\n+                            .withStorageFactory(setup -> storageFactory)\n+                            .withDataLogFactory(setup -> dataLogFactory);\n+                } else {\n+                    this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(configBuilder.build())\n+                            .withStorageFactory(setup -> storageFactory);\n+                }\n+            } else {\n+                this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n+            }\n+            this.serviceBuilder.initialize();\n+            this.streamSegmentStore = this.serviceBuilder.createStreamSegmentService();\n+            this.tableStore = this.serviceBuilder.createTableStoreService();\n+            this.server = new PravegaConnectionListener(false, servicePort, this.streamSegmentStore, this.tableStore,\n+                    this.serviceBuilder.getLowPriorityExecutor());\n+            this.server.startListening();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.server.close();\n+            this.serviceBuilder.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a controller instance and runs it.\n+     */\n+    private static class ControllerRunner implements AutoCloseable {\n+        private final int controllerPort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+        private final String serviceHost = \"localhost\";\n+        private final ControllerWrapper controllerWrapper;\n+        private final Controller controller;\n+        private final URI controllerURI = URI.create(\"tcp://\" + serviceHost + \":\" + controllerPort);\n+\n+        ControllerRunner(int bkPort, int servicePort, int containerCount) throws InterruptedException {\n+            this.controllerWrapper = new ControllerWrapper(\"localhost:\" + bkPort, false,\n+                    controllerPort, serviceHost, servicePort, containerCount);\n+            this.controllerWrapper.awaitRunning();\n+            this.controller = controllerWrapper.getController();\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            this.controller.close();\n+            this.controllerWrapper.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a client to read and write events.\n+     */\n+    private static class ClientRunner implements AutoCloseable {\n+        private final ConnectionFactory connectionFactory;\n+        private final ClientFactoryImpl clientFactory;\n+        private final ReaderGroupManager readerGroupManager;\n+\n+        ClientRunner(ControllerRunner controllerRunner) {\n+            this.connectionFactory = new SocketConnectionFactoryImpl(ClientConfig.builder()\n+                    .controllerURI(controllerRunner.controllerURI).build());\n+            this.clientFactory = new ClientFactoryImpl(SCOPE, controllerRunner.controller, connectionFactory);\n+            this.readerGroupManager = new ReaderGroupManagerImpl(SCOPE, controllerRunner.controller, clientFactory);\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.readerGroupManager.close();\n+            this.clientFactory.close();\n+            this.connectionFactory.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a Pravega instance.\n+     */\n+    private static class PravegaRunner implements AutoCloseable {\n+        private final int containerCount;\n+        private BookKeeperRunner bookKeeperRunner;\n+        private SegmentStoreRunner segmentStoreRunner;\n+        private ControllerRunner controllerRunner;\n+\n+        PravegaRunner(int instanceId, int bookieCount, int containerCount, StorageFactory storageFactory) throws Exception {\n+            this.containerCount = containerCount;\n+            this.bookKeeperRunner = new BookKeeperRunner(instanceId, bookieCount);\n+            restartControllerAndSegmentStore(storageFactory, null);\n+        }\n+\n+        public void restartControllerAndSegmentStore(StorageFactory storageFactory, BookKeeperLogFactory dataLogFactory)\n+                throws DurableDataLogException, InterruptedException {\n+            this.segmentStoreRunner = new SegmentStoreRunner(storageFactory, dataLogFactory, this.containerCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5Njg0Mg==", "bodyText": "Why was this reverted?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r538896842", "createdAt": "2020-12-08T23:50:07Z", "author": {"login": "andreipaduroiu"}, "path": "config/admin-cli.properties", "diffHunk": "@@ -19,11 +19,43 @@ cli.controller.grpc.uri=tcp://localhost:9090\n cli.store.metadata.backend=segmentstore\n \n # General configuration for the Pravega cluster at hand.\n-pravegaservice.cluster.name=pravega/pravega\n+pravegaservice.clusterName=pravega/pravega", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62f2336396050361f306bd51fb879fa7cd55768b", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/62f2336396050361f306bd51fb879fa7cd55768b", "committedDate": "2020-12-09T09:24:15Z", "message": "Fixing comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NjQ2NjM2", "url": "https://github.com/pravega/pravega/pull/5371#pullrequestreview-548646636", "createdAt": "2020-12-09T22:00:37Z", "commit": {"oid": "62f2336396050361f306bd51fb879fa7cd55768b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjowMDozN1rOICremg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjowODo1MFrOICrv0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MDQxMA==", "bodyText": "Why do you have 2 ContainerConfigs in here ? Which one do you use?", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r539680410", "createdAt": "2020-12-09T22:00:37Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/DurableLogRecoveryCommand.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.OperationLogFactory;\n+import io.pravega.segmentstore.server.ReadIndexFactory;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerFactory;\n+import io.pravega.segmentstore.server.WriterFactory;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexConfig;\n+import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.server.attributes.ContainerAttributeIndexFactoryImpl;\n+import io.pravega.segmentstore.server.containers.ContainerConfig;\n+import io.pravega.segmentstore.server.containers.ContainerRecoveryUtils;\n+import io.pravega.segmentstore.server.containers.DebugStreamSegmentContainer;\n+import io.pravega.segmentstore.server.logs.DurableLogConfig;\n+import io.pravega.segmentstore.server.logs.DurableLogFactory;\n+import io.pravega.segmentstore.server.reading.ContainerReadIndexFactory;\n+import io.pravega.segmentstore.server.reading.ReadIndexConfig;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtension;\n+import io.pravega.segmentstore.server.tables.ContainerTableExtensionImpl;\n+import io.pravega.segmentstore.server.writer.StorageWriterFactory;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import lombok.Cleanup;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Loads the storage instance, recovers all segments from there.\n+ */\n+public class DurableLogRecoveryCommand extends DataRecoveryCommand implements AutoCloseable {\n+    private static final int CONTAINER_EPOCH = 1;\n+    private static final Duration TIMEOUT = Duration.ofMillis(100 * 1000);\n+\n+    private static final DurableLogConfig NO_TRUNCATIONS_DURABLE_LOG_CONFIG = DurableLogConfig\n+            .builder()\n+            .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 10000)\n+            .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 50000)\n+            .with(DurableLogConfig.CHECKPOINT_TOTAL_COMMIT_LENGTH, 1024 * 1024 * 1024L)\n+            .build();\n+    private static final ReadIndexConfig DEFAULT_READ_INDEX_CONFIG = ReadIndexConfig.builder().build();\n+\n+    private static final AttributeIndexConfig DEFAULT_ATTRIBUTE_INDEX_CONFIG = AttributeIndexConfig.builder().build();\n+\n+    private static final ContainerConfig DEFAULT_CONFIG = ContainerConfig", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62f2336396050361f306bd51fb879fa7cd55768b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MjI1MA==", "bodyText": "FYI you can just do for(FileWriter w : this.csvWriters) instead of this loop. It's cleaner.\nIf you change it, do it in the close method too.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r539682250", "createdAt": "2020-12-09T22:04:11Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/main/java/io/pravega/cli/admin/dataRecovery/StorageListSegmentsCommand.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.CommandArgs;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.storage.Storage;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.segment.SegmentToContainerMapper;\n+import org.apache.hadoop.fs.Path;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.text.SimpleDateFormat;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Lists all non-shadow segments from there from the storage. The storage is loaded using the config properties.\n+ */\n+public class StorageListSegmentsCommand extends DataRecoveryCommand implements AutoCloseable {\n+    /**\n+     * Header line for writing segments' details to csv files.\n+     */\n+    private static final List<String> HEADER = Arrays.asList(\"Sealed Status\", \"Length\", \"Segment Name\");\n+    private static final int CONTAINER_EPOCH = 1;\n+    private final int containerCount;\n+    private final ScheduledExecutorService scheduledExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(1,\n+            \"listSegmentsProcessor\");\n+    private final SegmentToContainerMapper segToConMapper;\n+    private final StorageFactory storageFactory;\n+    private final Storage storage;\n+    private final FileWriter[] csvWriters;\n+    private String filePath;\n+\n+    /**\n+     * Creates an instance of StorageListSegmentsCommand class.\n+     *\n+     * @param args The arguments for the command.\n+     */\n+    public StorageListSegmentsCommand(CommandArgs args) {\n+        super(args);\n+        this.containerCount = getServiceConfig().getContainerCount();\n+        this.segToConMapper = new SegmentToContainerMapper(this.containerCount);\n+        this.storageFactory = createStorageFactory(scheduledExecutorService);\n+        this.storage = this.storageFactory.createStorageAdapter();\n+        this.csvWriters = new FileWriter[this.containerCount];\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        for (int containerId = 0; containerId < this.containerCount; containerId++) {\n+            if (this.csvWriters[containerId] != null) {\n+                this.csvWriters[containerId].close();\n+            }\n+        }\n+        this.storage.close();\n+        ExecutorServiceHelpers.shutdown(Duration.ofSeconds(2), scheduledExecutorService);\n+    }\n+\n+    /**\n+     * Creates a csv file for each container. All segments belonging to a containerId have their details written to the\n+     * csv file for that container.\n+     *\n+     * @throws Exception   When failed to create/delete file(s).\n+     */\n+    private void createCSVFiles() throws Exception {\n+        String fileSuffix = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n+\n+        // Set up directory for storing csv files\n+        this.filePath = System.getProperty(\"user.dir\") + Path.SEPARATOR + descriptor().getName() + \"_\" + fileSuffix;\n+\n+        // If path given as command args, use it\n+        if (getArgCount() >= 1) {\n+            this.filePath = getCommandArgs().getArgs().get(0);\n+            if (this.filePath.endsWith(Path.SEPARATOR)) {\n+                this.filePath = this.filePath.substring(0, this.filePath.length()-1);\n+            }\n+        }\n+\n+        // Create a directory for storing files.\n+        File dir = new File(this.filePath);\n+        if (!dir.exists()) {\n+            dir.mkdir();\n+        }\n+\n+        for (int containerId = 0; containerId < this.containerCount; containerId++) {\n+            File f = new File(this.filePath + Path.SEPARATOR + \"Container_\" + containerId + \".csv\");\n+            if (f.exists()) {\n+                outputInfo(\"File '%s' already exists.\", f.getAbsolutePath());\n+                if (!f.delete()) {\n+                    outputError(\"Failed to delete the file '%s'.\", f.getAbsolutePath());\n+                    throw new Exception(\"Failed to delete the file \" + f.getAbsolutePath());\n+                }\n+            }\n+            if (!f.createNewFile()) {\n+                outputError(\"Failed to create file '%s'.\", f.getAbsolutePath());\n+                throw new Exception(\"Failed to create file \" + f.getAbsolutePath());\n+            }\n+            this.csvWriters[containerId] = new FileWriter(f.getAbsolutePath());\n+            outputInfo(\"Created file '%s'\", f.getAbsolutePath());\n+            this.csvWriters[containerId].append(String.join(\",\", HEADER));\n+            this.csvWriters[containerId].append(\"\\n\");\n+        }\n+    }\n+\n+    @Override\n+    public void execute() throws Exception {\n+        outputInfo(\"Container Count = %d\", this.containerCount);\n+\n+        // Get the storage using the config.\n+        this.storage.initialize(CONTAINER_EPOCH);\n+        outputInfo(\"Loaded %s Storage.\", getServiceConfig().getStorageImplementation().toString());\n+\n+        // Gets total number of segments listed.\n+        int segmentsCount = 0;\n+\n+        // create CSV files for listing the segments and their details\n+        createCSVFiles();\n+\n+        outputInfo(\"Writing segments' details to the csv files...\");\n+        Iterator<SegmentProperties> segmentIterator = this.storage.listSegments();\n+        while (segmentIterator.hasNext()) {\n+            SegmentProperties currentSegment = segmentIterator.next();\n+\n+            // skip, if the segment is an attribute segment.\n+            if (NameUtils.isAttributeSegment(currentSegment.getName())) {\n+                continue;\n+            }\n+\n+            segmentsCount++;\n+            int containerId = this.segToConMapper.getContainerId(currentSegment.getName());\n+            outputInfo(containerId + \"\\t\" + currentSegment.isSealed() + \"\\t\" + currentSegment.getLength() + \"\\t\" +\n+                    currentSegment.getName());\n+            this.csvWriters[containerId].append(currentSegment.isSealed() + \",\" + currentSegment.getLength() + \",\" +\n+                    currentSegment.getName() + \"\\n\");\n+        }\n+\n+        outputInfo(\"Closing all csv files...\");\n+        for (int containerId = 0; containerId < this.containerCount; containerId++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62f2336396050361f306bd51fb879fa7cd55768b"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4NDgxNw==", "bodyText": "This is a real bad practice. If you let an external class tinker with your private fields, then you are essentially breaking encapsulation, which can lead to a lot of bugs.\nI suggest you make a method on this class which will properly close the existing runner and reassign it to a new one.\nThat way nobody else will need to know to close your instances or whatever. See below. You are closing your other runners here and also in the test above. How can you track that? If you want to debug something it will be next to impossible to figure out your program flow.\nPlease respect the encapsulation rules and move all management of these runners within this class.", "url": "https://github.com/pravega/pravega/pull/5371#discussion_r539684817", "createdAt": "2020-12-09T22:08:50Z", "author": {"login": "andreipaduroiu"}, "path": "cli/admin/src/test/java/io/pravega/cli/admin/dataRecovery/DataRecoveryTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.cli.admin.dataRecovery;\n+\n+import io.pravega.cli.admin.AdminCommandState;\n+import io.pravega.cli.admin.utils.TestUtils;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.admin.impl.ReaderGroupManagerImpl;\n+import io.pravega.client.admin.impl.StreamManagerImpl;\n+import io.pravega.client.connection.impl.ConnectionFactory;\n+import io.pravega.client.connection.impl.ConnectionPool;\n+import io.pravega.client.connection.impl.ConnectionPoolImpl;\n+import io.pravega.client.connection.impl.SocketConnectionFactoryImpl;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.ClientFactoryImpl;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.io.FileHelpers;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.segmentstore.server.store.ServiceConfig;\n+import io.pravega.segmentstore.server.writer.WriterConfig;\n+import io.pravega.segmentstore.storage.DurableDataLogException;\n+import io.pravega.segmentstore.storage.StorageFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperConfig;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperLogFactory;\n+import io.pravega.segmentstore.storage.impl.bookkeeper.BookKeeperServiceRunner;\n+import io.pravega.storage.filesystem.FileSystemStorageConfig;\n+import io.pravega.storage.filesystem.FileSystemStorageFactory;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.Cleanup;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Tests Data recovery commands.\n+ */\n+@Slf4j\n+public class DataRecoveryTest {\n+    private static final Duration TIMEOUT = Duration.ofMillis(30 * 1000);\n+    private static final int NUM_EVENTS = 10;\n+    private static final String EVENT = \"12345\";\n+    private static final String SCOPE = \"testScope\";\n+    // Setup utility.\n+    private static final Duration READ_TIMEOUT = Duration.ofMillis(1000);\n+    private static final AtomicReference<AdminCommandState> STATE = new AtomicReference<>();\n+\n+    @Rule\n+    public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);\n+\n+    private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, \"Data recovery test pool\");\n+    private final ScalingPolicy scalingPolicy = ScalingPolicy.fixed(1);\n+    private final StreamConfiguration config = StreamConfiguration.builder().scalingPolicy(scalingPolicy).build();\n+\n+    /**\n+     * A directory for FILESYSTEM storage as LTS.\n+     */\n+    private File baseDir = null;\n+    private FileSystemStorageConfig adapterConfig;\n+    private StorageFactory storageFactory = null;\n+\n+    /**\n+     * A directory for storing logs and CSV files generated during the test..\n+     */\n+    private File logsDir = null;\n+    private BookKeeperLogFactory factory = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseDir = Files.createTempDirectory(\"TestDataRecovery\").toFile().getAbsoluteFile();\n+        this.logsDir = Files.createTempDirectory(\"DataRecovery\").toFile().getAbsoluteFile();\n+        this.adapterConfig = FileSystemStorageConfig.builder()\n+                .with(FileSystemStorageConfig.ROOT, this.baseDir.getAbsolutePath())\n+                .with(FileSystemStorageConfig.REPLACE_ENABLED, true)\n+                .build();\n+\n+        this.storageFactory = new FileSystemStorageFactory(adapterConfig, this.executor);\n+    }\n+\n+    // Creates the given scope and stream using the given controller instance.\n+    private void createScopeStream(Controller controller, String scopeName, String streamName) {\n+        ClientConfig clientConfig = ClientConfig.builder().build();\n+        try (ConnectionPool cp = new ConnectionPoolImpl(clientConfig, new SocketConnectionFactoryImpl(clientConfig));\n+             StreamManager streamManager = new StreamManagerImpl(controller, cp)) {\n+            //create scope\n+            Boolean createScopeStatus = streamManager.createScope(scopeName);\n+            log.info(\"Create scope status {}\", createScopeStatus);\n+            //create stream\n+            Boolean createStreamStatus = streamManager.createStream(scopeName, streamName, config);\n+            log.info(\"Create stream status {}\", createStreamStatus);\n+        }\n+    }\n+\n+    /**\n+     * Tests DurableLog recovery command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testDataRecoveryCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testDataRecoveryCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // start a new BookKeeper and ZooKeeper.\n+        pravegaRunner.bookKeeperRunner = new BookKeeperRunner(instanceId++, bookieCount);\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        pravegaProperties.setProperty(\"pravegaservice.zk.connect.uri\", \"localhost:\" + pravegaRunner.bookKeeperRunner.bkPort);\n+        pravegaProperties.setProperty(\"bookkeeper.ledger.path\", pravegaRunner.bookKeeperRunner.ledgerPath);\n+        pravegaProperties.setProperty(\"bookkeeper.zk.metadata.path\", pravegaRunner.bookKeeperRunner.logMetaNamespace);\n+        pravegaProperties.setProperty(\"pravegaservice.clusterName\", pravegaRunner.bookKeeperRunner.baseNamespace);\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Command under test\n+        TestUtils.executeCommand(\"storage DurableLog-recovery\", STATE.get());\n+\n+        // Start a new segment store and controller\n+        this.factory = new BookKeeperLogFactory(pravegaRunner.bookKeeperRunner.bkConfig.get(), pravegaRunner.bookKeeperRunner.zkClient.get(),\n+                executor);\n+        pravegaRunner.restartControllerAndSegmentStore(this.storageFactory, this.factory);\n+        log.info(\"Started a controller and segment store.\");\n+        // Create the client with new controller.\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Try reading all events to verify that the recovery was successful.\n+            readAllEvents(streamName, clientRunner.clientFactory, clientRunner.readerGroupManager, \"RG\", \"R\");\n+            log.info(\"Read all events again to verify that segments were recovered.\");\n+        }\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    /**\n+     * Tests list segments command.\n+     * @throws Exception    In case of any exception thrown while execution.\n+     */\n+    @Test\n+    public void testListSegmentsCommand() throws Exception {\n+        int instanceId = 0;\n+        int bookieCount = 3;\n+        int containerCount = 1;\n+        @Cleanup\n+        PravegaRunner pravegaRunner = new PravegaRunner(instanceId++, bookieCount, containerCount, this.storageFactory);\n+        String streamName = \"testListSegmentsCommand\";\n+\n+        createScopeStream(pravegaRunner.controllerRunner.controller, SCOPE, streamName);\n+        try (val clientRunner = new ClientRunner(pravegaRunner.controllerRunner)) {\n+            // Write events to the streams.\n+            writeEvents(streamName, clientRunner.clientFactory);\n+        }\n+        pravegaRunner.controllerRunner.close(); // Shut down the controller\n+\n+        // Flush all Tier 1 to LTS\n+        ServiceBuilder.ComponentSetup componentSetup = new ServiceBuilder.ComponentSetup(pravegaRunner.segmentStoreRunner.serviceBuilder);\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            componentSetup.getContainerRegistry().getContainer(containerId).flushToStorage(TIMEOUT).join();\n+        }\n+\n+        pravegaRunner.segmentStoreRunner.close(); // Shutdown SegmentStore\n+        pravegaRunner.bookKeeperRunner.close(); // Shutdown BookKeeper & ZooKeeper\n+\n+        // set pravega properties for the test\n+        STATE.set(new AdminCommandState());\n+        Properties pravegaProperties = new Properties();\n+        pravegaProperties.setProperty(\"pravegaservice.container.count\", \"1\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.impl.name\", \"FILESYSTEM\");\n+        pravegaProperties.setProperty(\"pravegaservice.storage.layout\", \"ROLLING_STORAGE\");\n+        pravegaProperties.setProperty(\"filesystem.root\", this.baseDir.getAbsolutePath());\n+        STATE.get().getConfigBuilder().include(pravegaProperties);\n+\n+        // Execute the command for list segments\n+        TestUtils.executeCommand(\"storage list-segments \" + this.logsDir.getAbsolutePath(), STATE.get());\n+        // There should be a csv file created for storing segments in Container 0\n+        Assert.assertTrue(new File(this.logsDir.getAbsolutePath(), \"Container_0.csv\").exists());\n+        // Check if the file has segments listed in it\n+        Path path = Paths.get(this.logsDir.getAbsolutePath() + \"/Container_0.csv\");\n+        long lines = Files.lines(path).count();\n+        AssertExtensions.assertGreaterThan(\"There should be at least one segment.\", 1, lines);\n+        Assert.assertNotNull(StorageListSegmentsCommand.descriptor());\n+    }\n+\n+    @After\n+    public void tearDown() throws IOException {\n+        STATE.get().close();\n+        if (this.factory != null) {\n+            this.factory.close();\n+        }\n+        FileHelpers.deleteFileOrDirectory(this.baseDir);\n+        FileHelpers.deleteFileOrDirectory(this.logsDir);\n+        ExecutorServiceHelpers.shutdown(Duration.ofSeconds(2), executor);\n+    }\n+\n+    // write events to the given stream\n+    private void writeEvents(String streamName, ClientFactoryImpl clientFactory) {\n+        EventStreamWriter<String> writer = clientFactory.createEventWriter(streamName,\n+                new UTF8StringSerializer(),\n+                EventWriterConfig.builder().build());\n+        for (int i = 0; i < NUM_EVENTS;) {\n+            writer.writeEvent(\"\", EVENT).join();\n+            i++;\n+        }\n+        writer.flush();\n+        writer.close();\n+    }\n+\n+    // read all events from the given stream\n+    private void readAllEvents(String streamName, ClientFactoryImpl clientFactory, ReaderGroupManager readerGroupManager,\n+                               String readerGroupName, String readerName) {\n+        readerGroupManager.createReaderGroup(readerGroupName,\n+                ReaderGroupConfig\n+                        .builder()\n+                        .stream(Stream.of(SCOPE, streamName))\n+                        .build());\n+\n+        EventStreamReader<String> reader = clientFactory.createReader(readerName,\n+                readerGroupName,\n+                new UTF8StringSerializer(),\n+                ReaderConfig.builder().build());\n+\n+        for (int q = 0; q < NUM_EVENTS;) {\n+            String eventRead = reader.readNextEvent(READ_TIMEOUT.toMillis()).getEvent();\n+            Assert.assertEquals(\"Event written and read back don't match\", EVENT, eventRead);\n+            q++;\n+        }\n+        reader.close();\n+    }\n+\n+    /**\n+     * Sets up a new BookKeeper & ZooKeeper.\n+     */\n+    private static class BookKeeperRunner implements AutoCloseable {\n+        private final int bkPort;\n+        private final BookKeeperServiceRunner bookKeeperServiceRunner;\n+        private final AtomicReference<BookKeeperConfig> bkConfig = new AtomicReference<>();\n+        private final AtomicReference<CuratorFramework> zkClient = new AtomicReference<>();\n+        private final AtomicReference<BookKeeperServiceRunner> bkService = new AtomicReference<>();\n+        private final String ledgerPath;\n+        private final String logMetaNamespace;\n+        private final String baseNamespace;\n+        BookKeeperRunner(int instanceId, int bookieCount) throws Exception {\n+            this.ledgerPath = \"/pravega/bookkeeper/ledgers\" + instanceId;\n+            this.bkPort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+            val bookiePorts = new ArrayList<Integer>();\n+            for (int i = 0; i < bookieCount; i++) {\n+                bookiePorts.add(io.pravega.test.common.TestUtils.getAvailableListenPort());\n+            }\n+            this.bookKeeperServiceRunner = BookKeeperServiceRunner.builder()\n+                    .startZk(true)\n+                    .zkPort(bkPort)\n+                    .ledgersPath(ledgerPath)\n+                    .bookiePorts(bookiePorts)\n+                    .build();\n+            try {\n+                this.bookKeeperServiceRunner.startAll();\n+            } catch (Exception e) {\n+                log.error(\"Exception occurred while starting bookKeeper service.\", e);\n+                this.close();\n+                throw e;\n+            }\n+            this.bkService.set(this.bookKeeperServiceRunner);\n+\n+            // Create a ZKClient with a unique namespace.\n+            this.baseNamespace = \"pravega\" + instanceId;\n+            this.zkClient.set(CuratorFrameworkFactory\n+                    .builder()\n+                    .connectString(\"localhost:\" + bkPort)\n+                    .namespace(baseNamespace)\n+                    .retryPolicy(new ExponentialBackoffRetry(1000, 10))\n+                    .build());\n+\n+            this.zkClient.get().start();\n+\n+            logMetaNamespace = \"segmentstore/containers\" + instanceId;\n+            this.bkConfig.set(BookKeeperConfig\n+                    .builder()\n+                    .with(BookKeeperConfig.ZK_ADDRESS, \"localhost:\" + bkPort)\n+                    .with(BookKeeperConfig.ZK_METADATA_PATH, logMetaNamespace)\n+                    .with(BookKeeperConfig.BK_LEDGER_PATH, ledgerPath)\n+                    .build());\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            val process = this.bkService.getAndSet(null);\n+            if (process != null) {\n+                process.close();\n+            }\n+\n+            val bk = this.bookKeeperServiceRunner;\n+            if (bk != null) {\n+                bk.close();\n+            }\n+\n+            val zkClient = this.zkClient.getAndSet(null);\n+            if (zkClient != null) {\n+                zkClient.close();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a segment store.\n+     */\n+    private static class SegmentStoreRunner implements AutoCloseable {\n+        private final int servicePort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+        private final ServiceBuilder serviceBuilder;\n+        private final PravegaConnectionListener server;\n+        private final StreamSegmentStore streamSegmentStore;\n+        private final TableStore tableStore;\n+\n+        SegmentStoreRunner(StorageFactory storageFactory, BookKeeperLogFactory dataLogFactory, int containerCount)\n+                throws DurableDataLogException {\n+            ServiceBuilderConfig.Builder configBuilder = ServiceBuilderConfig\n+                    .builder()\n+                    .include(ServiceConfig.builder()\n+                            .with(ServiceConfig.CONTAINER_COUNT, containerCount))\n+                    .include(WriterConfig.builder()\n+                            .with(WriterConfig.MIN_READ_TIMEOUT_MILLIS, 100L)\n+                            .with(WriterConfig.MAX_READ_TIMEOUT_MILLIS, 500L)\n+                    );\n+            if (storageFactory != null) {\n+                if (dataLogFactory != null) {\n+                    this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(configBuilder.build())\n+                            .withStorageFactory(setup -> storageFactory)\n+                            .withDataLogFactory(setup -> dataLogFactory);\n+                } else {\n+                    this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(configBuilder.build())\n+                            .withStorageFactory(setup -> storageFactory);\n+                }\n+            } else {\n+                this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n+            }\n+            this.serviceBuilder.initialize();\n+            this.streamSegmentStore = this.serviceBuilder.createStreamSegmentService();\n+            this.tableStore = this.serviceBuilder.createTableStoreService();\n+            this.server = new PravegaConnectionListener(false, servicePort, this.streamSegmentStore, this.tableStore,\n+                    this.serviceBuilder.getLowPriorityExecutor());\n+            this.server.startListening();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.server.close();\n+            this.serviceBuilder.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a controller instance and runs it.\n+     */\n+    private static class ControllerRunner implements AutoCloseable {\n+        private final int controllerPort = io.pravega.test.common.TestUtils.getAvailableListenPort();\n+        private final String serviceHost = \"localhost\";\n+        private final ControllerWrapper controllerWrapper;\n+        private final Controller controller;\n+        private final URI controllerURI = URI.create(\"tcp://\" + serviceHost + \":\" + controllerPort);\n+\n+        ControllerRunner(int bkPort, int servicePort, int containerCount) throws InterruptedException {\n+            this.controllerWrapper = new ControllerWrapper(\"localhost:\" + bkPort, false,\n+                    controllerPort, serviceHost, servicePort, containerCount);\n+            this.controllerWrapper.awaitRunning();\n+            this.controller = controllerWrapper.getController();\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            this.controller.close();\n+            this.controllerWrapper.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a client to read and write events.\n+     */\n+    private static class ClientRunner implements AutoCloseable {\n+        private final ConnectionFactory connectionFactory;\n+        private final ClientFactoryImpl clientFactory;\n+        private final ReaderGroupManager readerGroupManager;\n+\n+        ClientRunner(ControllerRunner controllerRunner) {\n+            this.connectionFactory = new SocketConnectionFactoryImpl(ClientConfig.builder()\n+                    .controllerURI(controllerRunner.controllerURI).build());\n+            this.clientFactory = new ClientFactoryImpl(SCOPE, controllerRunner.controller, connectionFactory);\n+            this.readerGroupManager = new ReaderGroupManagerImpl(SCOPE, controllerRunner.controller, clientFactory);\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.readerGroupManager.close();\n+            this.clientFactory.close();\n+            this.connectionFactory.close();\n+        }\n+    }\n+\n+    /**\n+     * Creates a Pravega instance.\n+     */\n+    private static class PravegaRunner implements AutoCloseable {\n+        private final int containerCount;\n+        private BookKeeperRunner bookKeeperRunner;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NjI3OQ=="}, "originalCommit": {"oid": "0a79b063b0ce3a48135dd878c4ade2bec390c6a6"}, "originalPosition": 466}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66550e463d6ab5550074d8d1708f88fb07de26b1", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/66550e463d6ab5550074d8d1708f88fb07de26b1", "committedDate": "2020-12-09T23:36:13Z", "message": "Fixing comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26ca74233d17b96785c7017dca1feb89d64a1c84", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/26ca74233d17b96785c7017dca1feb89d64a1c84", "committedDate": "2020-12-09T23:42:27Z", "message": "Minor changes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NzMwMjk4", "url": "https://github.com/pravega/pravega/pull/5371#pullrequestreview-548730298", "createdAt": "2020-12-10T00:37:30Z", "commit": {"oid": "26ca74233d17b96785c7017dca1feb89d64a1c84"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3762, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}