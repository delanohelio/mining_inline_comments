{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMzM5MjQ0", "number": 4687, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo0NTozNFrOD3aNCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDo1MzoxMFrOD4e2Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDI3NTkzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo0NTozNFrOGNpvkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDo1MDoxNlrOGOCqcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2ODU5NA==", "bodyText": "I thought the key family + the key had to be under 8kb. If this is true on the server, I think from a public interface perspective it makes sense to limit each to 4kb to simplify the model for users. (IE there isn't a failure mode where you change the key family, and a key that was previously ok now has an error)", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r416968594", "createdAt": "2020-04-28T22:45:34Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.stream.Serializer;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import org.apache.commons.lang3.SerializationException;\n+\n+/**\n+ * Serializer for Key-Value Table Key Families.\n+ */\n+public class KeyFamilySerializer implements Serializer<String> {\n+    @VisibleForTesting\n+    static final int MAX_KEY_FAMILY_LENGTH = 8191; // It can't be longer than TableSegment.MAX_KEY_LENGTH", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3Njg4Mw==", "bodyText": "Good catch. I actually wanted to make it more restrictive, but I forgot. I restricted this to 1KB for now. It will always be easier to increase the limit than shrink it in the future.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r417376883", "createdAt": "2020-04-29T14:50:16Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.stream.Serializer;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import org.apache.commons.lang3.SerializationException;\n+\n+/**\n+ * Serializer for Key-Value Table Key Families.\n+ */\n+public class KeyFamilySerializer implements Serializer<String> {\n+    @VisibleForTesting\n+    static final int MAX_KEY_FAMILY_LENGTH = 8191; // It can't be longer than TableSegment.MAX_KEY_LENGTH", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2ODU5NA=="}, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDI5Mjg0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableIteratorState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo1MTo1N1rOGNp5TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDo1MjoxOFrOGOCwvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTA4NA==", "bodyText": "We should probably use a normal long. Segment ids are highly probably > 2^32 and are not guarenteed to not use the full range of numbers.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r416971084", "createdAt": "2020-04-28T22:51:57Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableIteratorState.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.shared.protocol.netty.ByteBufWrapper;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Key-Value Table Key/Entry Iterator state.\n+ */\n+@Data\n+@Builder\n+class KeyValueTableIteratorState {\n+    private static final KeyValueTableIteratorStateSerializer SERIALIZER = new KeyValueTableIteratorStateSerializer();\n+    /**\n+     * Name of the Key-Value Table the iterator belongs to.\n+     */\n+    @NonNull\n+    private final String keyValueTableName;\n+    /**\n+     * Id of the Segment the Iterator is currently on.\n+     */\n+    private final long segmentId;\n+    /**\n+     * Iterator State for the Segment Iterator (this is an opaque buffer that is passed along to the {@link TableSegment}).\n+     */\n+    private final ByteBuf segmentIteratorState;\n+\n+    //region Serialization\n+\n+    @SneakyThrows(IOException.class)\n+    ByteBuffer toBytes() {\n+        return SERIALIZER.serialize(this).asByteBuffer();\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    static KeyValueTableIteratorState fromBytes(ByteBuffer serialization) {\n+        return KeyValueTableIteratorState.SERIALIZER.deserialize(new ByteBufWrapper(Unpooled.wrappedBuffer(serialization)).getReader());\n+    }\n+\n+    private static class KeyValueTableIteratorStateBuilder implements ObjectBuilder<KeyValueTableIteratorState> {\n+    }\n+\n+    static class KeyValueTableIteratorStateSerializer extends\n+            VersionedSerializer.WithBuilder<KeyValueTableIteratorState, KeyValueTableIteratorState.KeyValueTableIteratorStateBuilder> {\n+        @Override\n+        protected KeyValueTableIteratorState.KeyValueTableIteratorStateBuilder newBuilder() {\n+            return builder();\n+        }\n+\n+        @Override\n+        protected byte getWriteVersion() {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void declareVersions() {\n+            version(0).revision(0, this::write00, this::read00);\n+        }\n+\n+        private void read00(RevisionDataInput revisionDataInput, KeyValueTableIteratorState.KeyValueTableIteratorStateBuilder builder) throws IOException {\n+            builder.keyValueTableName(revisionDataInput.readUTF());\n+            builder.segmentId(revisionDataInput.readCompactLong());\n+            byte[] array = revisionDataInput.readArray();\n+            if (array != null && array.length > 0) {\n+                builder.segmentIteratorState(Unpooled.wrappedBuffer(array));\n+            }\n+        }\n+\n+        private void write00(KeyValueTableIteratorState checkpoint, RevisionDataOutput revisionDataOutput) throws IOException {\n+            revisionDataOutput.writeUTF(checkpoint.keyValueTableName);\n+            revisionDataOutput.writeCompactLong(checkpoint.segmentId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3ODQ5Mw==", "bodyText": "CompactLong goes from 0 until 2^62.\nI thought they were sequential, but if they could be arbitrary, then we should probably handle -2^63 to 2^63.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r417378493", "createdAt": "2020-04-29T14:52:18Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableIteratorState.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.shared.protocol.netty.ByteBufWrapper;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Key-Value Table Key/Entry Iterator state.\n+ */\n+@Data\n+@Builder\n+class KeyValueTableIteratorState {\n+    private static final KeyValueTableIteratorStateSerializer SERIALIZER = new KeyValueTableIteratorStateSerializer();\n+    /**\n+     * Name of the Key-Value Table the iterator belongs to.\n+     */\n+    @NonNull\n+    private final String keyValueTableName;\n+    /**\n+     * Id of the Segment the Iterator is currently on.\n+     */\n+    private final long segmentId;\n+    /**\n+     * Iterator State for the Segment Iterator (this is an opaque buffer that is passed along to the {@link TableSegment}).\n+     */\n+    private final ByteBuf segmentIteratorState;\n+\n+    //region Serialization\n+\n+    @SneakyThrows(IOException.class)\n+    ByteBuffer toBytes() {\n+        return SERIALIZER.serialize(this).asByteBuffer();\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    static KeyValueTableIteratorState fromBytes(ByteBuffer serialization) {\n+        return KeyValueTableIteratorState.SERIALIZER.deserialize(new ByteBufWrapper(Unpooled.wrappedBuffer(serialization)).getReader());\n+    }\n+\n+    private static class KeyValueTableIteratorStateBuilder implements ObjectBuilder<KeyValueTableIteratorState> {\n+    }\n+\n+    static class KeyValueTableIteratorStateSerializer extends\n+            VersionedSerializer.WithBuilder<KeyValueTableIteratorState, KeyValueTableIteratorState.KeyValueTableIteratorStateBuilder> {\n+        @Override\n+        protected KeyValueTableIteratorState.KeyValueTableIteratorStateBuilder newBuilder() {\n+            return builder();\n+        }\n+\n+        @Override\n+        protected byte getWriteVersion() {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void declareVersions() {\n+            version(0).revision(0, this::write00, this::read00);\n+        }\n+\n+        private void read00(RevisionDataInput revisionDataInput, KeyValueTableIteratorState.KeyValueTableIteratorStateBuilder builder) throws IOException {\n+            builder.keyValueTableName(revisionDataInput.readUTF());\n+            builder.segmentId(revisionDataInput.readCompactLong());\n+            byte[] array = revisionDataInput.readArray();\n+            if (array != null && array.length > 0) {\n+                builder.segmentIteratorState(Unpooled.wrappedBuffer(array));\n+            }\n+        }\n+\n+        private void write00(KeyValueTableIteratorState checkpoint, RevisionDataOutput revisionDataOutput) throws IOException {\n+            revisionDataOutput.writeUTF(checkpoint.keyValueTableName);\n+            revisionDataOutput.writeCompactLong(checkpoint.segmentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTA4NA=="}, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDMxMDI5OnYy", "diffSide": "RIGHT", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo1OToxMVrOGNqDgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxMzoyMVrOGNqXpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzY5Ng==", "bodyText": "COmplete", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r416973696", "createdAt": "2020-04-28T22:59:11Z", "author": {"login": "tkaitchuck"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration;\n+\n+import io.netty.util.ResourceLeakDetector;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import io.netty.util.internal.logging.Slf4JLoggerFactory;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.KeyValueTableFactory;\n+import io.pravega.client.admin.KeyValueTableInfo;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.netty.impl.ConnectionFactory;\n+import io.pravega.client.netty.impl.ConnectionFactoryImpl;\n+import io.pravega.client.stream.mock.MockController;\n+import io.pravega.client.tables.KeyValueTable;\n+import io.pravega.client.tables.KeyValueTableClientConfiguration;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n+import io.pravega.client.tables.impl.KeyValueTableTestBase;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.TestUtils;\n+import java.time.Duration;\n+import java.util.Collections;\n+import lombok.val;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n+ * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ */\n+public class KeyValueTableTest extends KeyValueTableTestBase {\n+    private static final String ENDPOINT = \"localhost\";\n+    private static final String SCOPE = \"Scope\";\n+    private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n+    private static final Duration TIMEOUT = Duration.ofSeconds(30);\n+    private ResourceLeakDetector.Level originalLevel;\n+    private ServiceBuilder serviceBuilder;\n+    private TableStore tableStore;\n+    private PravegaConnectionListener serverListener;\n+    private ConnectionFactory connectionFactory;\n+    private Controller controller;\n+    private KeyValueTableFactory keyValueTableFactory;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        super.setup();\n+        this.originalLevel = ResourceLeakDetector.getLevel();\n+        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);\n+        InternalLoggerFactory.setDefaultFactory(Slf4JLoggerFactory.INSTANCE);\n+        this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n+        this.serviceBuilder.initialize();\n+        this.tableStore = this.serviceBuilder.createTableStoreService();\n+        int port = TestUtils.getAvailableListenPort();\n+        this.serverListener = new PravegaConnectionListener(false, port, mock(StreamSegmentStore.class), this.tableStore);\n+        this.serverListener.startListening();\n+\n+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());\n+        this.controller = new MockController(ENDPOINT, port, this.connectionFactory, true);\n+        this.controller.createScope(SCOPE);\n+        this.keyValueTableFactory = new KeyValueTableFactoryImpl(SCOPE, this.controller, this.connectionFactory);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        this.controller.close();\n+        this.connectionFactory.close();\n+        this.serverListener.close();\n+        this.serviceBuilder.close();\n+        ResourceLeakDetector.setLevel(this.originalLevel);\n+    }\n+\n+    /**\n+     * Smoke Test. Verify that the KeyValueTable can be created and deleted.\n+     */\n+    @Test\n+    public void testCreateDeleteKeyValueTable() {\n+        val kvt = newKeyValueTableName();\n+        boolean created = this.controller.createKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName(), DEFAULT_CONFIG).join();\n+        Assert.assertTrue(created);\n+        val segments = this.controller.getCurrentSegmentsForKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join();\n+        Assert.assertEquals(DEFAULT_CONFIG.getPartitionCount(), segments.getSegments().size());\n+        for (val s : segments.getSegments()) {\n+            // We know there's nothing in these segments. But if the segments hadn't been created, then this will throw\n+            // an exception.\n+            this.tableStore.get(s.getScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT).join();\n+        }\n+\n+        // Verify re-creation does not work.\n+        Assert.assertFalse(this.controller.createKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName(), DEFAULT_CONFIG).join());\n+\n+        // Delete and verify segments have been deleted too.\n+        val deleted = this.controller.deleteKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join();\n+        Assert.assertTrue(deleted);\n+        Assert.assertFalse(this.controller.deleteKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join());\n+        for (val s : segments.getSegments()) {\n+            AssertExtensions.assertSuppliedFutureThrows(\n+                    \"Segment \" + s + \" has not been deleted.\",\n+                    () -> this.tableStore.get(s.getScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT),\n+                    ex -> ex instanceof StreamSegmentNotExistsException);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    @Ignore\n+    public void testIterators() {\n+        // TODO: iterators not yet supported server-side.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3ODg1Mg==", "bodyText": "#4656  has a branch with all the changes. I can't submit that PR until I get this one in since they clash on a few files - including this one.\nWe'll have to do them in sequence, and I chose to do this PR first. Yes, the functionality will be broken until #4656 is done, but that's why I'm pushing into a feature branch.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r416978852", "createdAt": "2020-04-28T23:13:21Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration;\n+\n+import io.netty.util.ResourceLeakDetector;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import io.netty.util.internal.logging.Slf4JLoggerFactory;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.KeyValueTableFactory;\n+import io.pravega.client.admin.KeyValueTableInfo;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.netty.impl.ConnectionFactory;\n+import io.pravega.client.netty.impl.ConnectionFactoryImpl;\n+import io.pravega.client.stream.mock.MockController;\n+import io.pravega.client.tables.KeyValueTable;\n+import io.pravega.client.tables.KeyValueTableClientConfiguration;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n+import io.pravega.client.tables.impl.KeyValueTableTestBase;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.TestUtils;\n+import java.time.Duration;\n+import java.util.Collections;\n+import lombok.val;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n+ * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ */\n+public class KeyValueTableTest extends KeyValueTableTestBase {\n+    private static final String ENDPOINT = \"localhost\";\n+    private static final String SCOPE = \"Scope\";\n+    private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n+    private static final Duration TIMEOUT = Duration.ofSeconds(30);\n+    private ResourceLeakDetector.Level originalLevel;\n+    private ServiceBuilder serviceBuilder;\n+    private TableStore tableStore;\n+    private PravegaConnectionListener serverListener;\n+    private ConnectionFactory connectionFactory;\n+    private Controller controller;\n+    private KeyValueTableFactory keyValueTableFactory;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        super.setup();\n+        this.originalLevel = ResourceLeakDetector.getLevel();\n+        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);\n+        InternalLoggerFactory.setDefaultFactory(Slf4JLoggerFactory.INSTANCE);\n+        this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n+        this.serviceBuilder.initialize();\n+        this.tableStore = this.serviceBuilder.createTableStoreService();\n+        int port = TestUtils.getAvailableListenPort();\n+        this.serverListener = new PravegaConnectionListener(false, port, mock(StreamSegmentStore.class), this.tableStore);\n+        this.serverListener.startListening();\n+\n+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());\n+        this.controller = new MockController(ENDPOINT, port, this.connectionFactory, true);\n+        this.controller.createScope(SCOPE);\n+        this.keyValueTableFactory = new KeyValueTableFactoryImpl(SCOPE, this.controller, this.connectionFactory);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        this.controller.close();\n+        this.connectionFactory.close();\n+        this.serverListener.close();\n+        this.serviceBuilder.close();\n+        ResourceLeakDetector.setLevel(this.originalLevel);\n+    }\n+\n+    /**\n+     * Smoke Test. Verify that the KeyValueTable can be created and deleted.\n+     */\n+    @Test\n+    public void testCreateDeleteKeyValueTable() {\n+        val kvt = newKeyValueTableName();\n+        boolean created = this.controller.createKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName(), DEFAULT_CONFIG).join();\n+        Assert.assertTrue(created);\n+        val segments = this.controller.getCurrentSegmentsForKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join();\n+        Assert.assertEquals(DEFAULT_CONFIG.getPartitionCount(), segments.getSegments().size());\n+        for (val s : segments.getSegments()) {\n+            // We know there's nothing in these segments. But if the segments hadn't been created, then this will throw\n+            // an exception.\n+            this.tableStore.get(s.getScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT).join();\n+        }\n+\n+        // Verify re-creation does not work.\n+        Assert.assertFalse(this.controller.createKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName(), DEFAULT_CONFIG).join());\n+\n+        // Delete and verify segments have been deleted too.\n+        val deleted = this.controller.deleteKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join();\n+        Assert.assertTrue(deleted);\n+        Assert.assertFalse(this.controller.deleteKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join());\n+        for (val s : segments.getSegments()) {\n+            AssertExtensions.assertSuppliedFutureThrows(\n+                    \"Segment \" + s + \" has not been deleted.\",\n+                    () -> this.tableStore.get(s.getScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT),\n+                    ex -> ex instanceof StreamSegmentNotExistsException);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    @Ignore\n+    public void testIterators() {\n+        // TODO: iterators not yet supported server-side.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzY5Ng=="}, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDMxMjczOnYy", "diffSide": "RIGHT", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowMDoyOVrOGNqFFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzoxNzowMVrOGOyzgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDEwMA==", "bodyText": "There is a new way you added to do this which is probably better, let's be sure when the merge is resolved we are using that.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r416974100", "createdAt": "2020-04-28T23:00:29Z", "author": {"login": "tkaitchuck"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration;\n+\n+import io.netty.util.ResourceLeakDetector;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import io.netty.util.internal.logging.Slf4JLoggerFactory;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.KeyValueTableFactory;\n+import io.pravega.client.admin.KeyValueTableInfo;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.netty.impl.ConnectionFactory;\n+import io.pravega.client.netty.impl.ConnectionFactoryImpl;\n+import io.pravega.client.stream.mock.MockController;\n+import io.pravega.client.tables.KeyValueTable;\n+import io.pravega.client.tables.KeyValueTableClientConfiguration;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n+import io.pravega.client.tables.impl.KeyValueTableTestBase;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.TestUtils;\n+import java.time.Duration;\n+import java.util.Collections;\n+import lombok.val;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n+ * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ */\n+public class KeyValueTableTest extends KeyValueTableTestBase {\n+    private static final String ENDPOINT = \"localhost\";\n+    private static final String SCOPE = \"Scope\";\n+    private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n+    private static final Duration TIMEOUT = Duration.ofSeconds(30);\n+    private ResourceLeakDetector.Level originalLevel;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3ODI3MQ==", "bodyText": "Yes, this branch is still forked off feature-key-value-tables which hasn't been updated in a long time.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r416978271", "createdAt": "2020-04-28T23:11:36Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration;\n+\n+import io.netty.util.ResourceLeakDetector;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import io.netty.util.internal.logging.Slf4JLoggerFactory;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.KeyValueTableFactory;\n+import io.pravega.client.admin.KeyValueTableInfo;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.netty.impl.ConnectionFactory;\n+import io.pravega.client.netty.impl.ConnectionFactoryImpl;\n+import io.pravega.client.stream.mock.MockController;\n+import io.pravega.client.tables.KeyValueTable;\n+import io.pravega.client.tables.KeyValueTableClientConfiguration;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n+import io.pravega.client.tables.impl.KeyValueTableTestBase;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.TestUtils;\n+import java.time.Duration;\n+import java.util.Collections;\n+import lombok.val;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n+ * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ */\n+public class KeyValueTableTest extends KeyValueTableTestBase {\n+    private static final String ENDPOINT = \"localhost\";\n+    private static final String SCOPE = \"Scope\";\n+    private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n+    private static final Duration TIMEOUT = Duration.ofSeconds(30);\n+    private ResourceLeakDetector.Level originalLevel;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDEwMA=="}, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NTYzNQ==", "bodyText": "Merged with master; this should be fixed now.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r418165635", "createdAt": "2020-04-30T17:17:01Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration;\n+\n+import io.netty.util.ResourceLeakDetector;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import io.netty.util.internal.logging.Slf4JLoggerFactory;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.KeyValueTableFactory;\n+import io.pravega.client.admin.KeyValueTableInfo;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.netty.impl.ConnectionFactory;\n+import io.pravega.client.netty.impl.ConnectionFactoryImpl;\n+import io.pravega.client.stream.mock.MockController;\n+import io.pravega.client.tables.KeyValueTable;\n+import io.pravega.client.tables.KeyValueTableClientConfiguration;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n+import io.pravega.client.tables.impl.KeyValueTableTestBase;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentStore;\n+import io.pravega.segmentstore.contracts.tables.TableStore;\n+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n+import io.pravega.segmentstore.server.store.ServiceBuilder;\n+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.TestUtils;\n+import java.time.Duration;\n+import java.util.Collections;\n+import lombok.val;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n+ * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ */\n+public class KeyValueTableTest extends KeyValueTableTestBase {\n+    private static final String ENDPOINT = \"localhost\";\n+    private static final String SCOPE = \"Scope\";\n+    private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n+    private static final Duration TIMEOUT = Duration.ofSeconds(30);\n+    private ResourceLeakDetector.Level originalLevel;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDEwMA=="}, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDMxNzQxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowMTo1OVrOGNqHjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNToyODoxMVrOGOEbnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDczMw==", "bodyText": "Ideally we could avoid this copy...", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r416974733", "createdAt": "2020-04-28T23:01:59Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.stream.Serializer;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import org.apache.commons.lang3.SerializationException;\n+\n+/**\n+ * Serializer for Key-Value Table Key Families.\n+ */\n+public class KeyFamilySerializer implements Serializer<String> {\n+    @VisibleForTesting\n+    static final int MAX_KEY_FAMILY_LENGTH = 8191; // It can't be longer than TableSegment.MAX_KEY_LENGTH\n+    @VisibleForTesting\n+    static final int PREFIX_LENGTH = 2; // [0, 65535]. First 3 bits will be empty.\n+    @VisibleForTesting\n+    static final Charset ENCODING = StandardCharsets.UTF_8;\n+\n+    @Override\n+    public ByteBuffer serialize(@Nullable String keyFamily) {\n+        ByteBuffer result;\n+        if (keyFamily == null || keyFamily.length() == 0) {\n+            result = ByteBuffer.allocate(PREFIX_LENGTH); // Prefix is 00, which is the length of the Key Family\n+        } else {\n+            ByteBuffer s = ENCODING.encode(keyFamily);\n+            Preconditions.checkArgument(s.remaining() <= MAX_KEY_FAMILY_LENGTH,\n+                    \"KeyFamily must have a %s encoding length of at most %s bytes; actual %s.\", ENCODING.name(), MAX_KEY_FAMILY_LENGTH, s.remaining());\n+            result = ByteBuffer.allocate(PREFIX_LENGTH + s.remaining());\n+            result.putShort((short) s.remaining());\n+            result.put(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwNTg1NQ==", "bodyText": "Interesting. I originally did that because I wanted to implement Serializer<String>. I didn't need that so I made this use ByteBufs.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r417405855", "createdAt": "2020-04-29T15:28:11Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.stream.Serializer;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import org.apache.commons.lang3.SerializationException;\n+\n+/**\n+ * Serializer for Key-Value Table Key Families.\n+ */\n+public class KeyFamilySerializer implements Serializer<String> {\n+    @VisibleForTesting\n+    static final int MAX_KEY_FAMILY_LENGTH = 8191; // It can't be longer than TableSegment.MAX_KEY_LENGTH\n+    @VisibleForTesting\n+    static final int PREFIX_LENGTH = 2; // [0, 65535]. First 3 bits will be empty.\n+    @VisibleForTesting\n+    static final Charset ENCODING = StandardCharsets.UTF_8;\n+\n+    @Override\n+    public ByteBuffer serialize(@Nullable String keyFamily) {\n+        ByteBuffer result;\n+        if (keyFamily == null || keyFamily.length() == 0) {\n+            result = ByteBuffer.allocate(PREFIX_LENGTH); // Prefix is 00, which is the length of the Key Family\n+        } else {\n+            ByteBuffer s = ENCODING.encode(keyFamily);\n+            Preconditions.checkArgument(s.remaining() <= MAX_KEY_FAMILY_LENGTH,\n+                    \"KeyFamily must have a %s encoding length of at most %s bytes; actual %s.\", ENCODING.name(), MAX_KEY_FAMILY_LENGTH, s.remaining());\n+            result = ByteBuffer.allocate(PREFIX_LENGTH + s.remaining());\n+            result.putShort((short) s.remaining());\n+            result.put(s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDczMw=="}, "originalCommit": {"oid": "eea443c3b4e9bd01a3c5a4e8d03df71c2b136d26"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTUyMjE1OnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/tables/impl/KeyValueTableTestBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDo1MzoxMFrOGPVcow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMTowMToyOFrOGPVoZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMzIxOQ==", "bodyText": "Just to confirm, the tests pass if this is 1 right?", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r418733219", "createdAt": "2020-05-01T20:53:10Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/tables/impl/KeyValueTableTestBase.java", "diffHunk": "@@ -0,0 +1,597 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.pravega.client.stream.Serializer;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.client.tables.BadKeyVersionException;\n+import io.pravega.client.tables.IteratorItem;\n+import io.pravega.client.tables.IteratorState;\n+import io.pravega.client.tables.KeyValueTable;\n+import io.pravega.client.tables.TableEntry;\n+import io.pravega.client.tables.TableKey;\n+import io.pravega.client.tables.Version;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.LeakDetectorTestSuite;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Cleanup;\n+import lombok.Getter;\n+import lombok.val;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Base test suite for anything testing {@link KeyValueTable}s. This covers core functionality for {@link KeyValueTable}s\n+ * and currently applies both to {@link KeyValueTableImplTests} (using mocked Controller and Segment Store) and\n+ * `io.pravega.test.integration.KeyValueTableImplTests` (using real Segment Store and Wire Protocol).\n+ */\n+public abstract class KeyValueTableTestBase extends LeakDetectorTestSuite {\n+    //region Members\n+\n+    protected static final String NULL_KEY_FAMILY = \"[NULL]\"; // Used for HashMap keys.\n+    protected static final Serializer<Integer> KEY_SERIALIZER = new IntegerSerializer();\n+    protected static final Serializer<String> VALUE_SERIALIZER = new UTF8StringSerializer();\n+    private static final int DEFAULT_SEGMENT_COUNT = 4;\n+    private static final int DEFAULT_KEY_FAMILY_COUNT = 100;\n+    private static final int DEFAULT_KEYS_PER_KEY_FAMILY = 10;\n+    @Getter(AccessLevel.PROTECTED)\n+    private List<String> keyFamilies;\n+\n+    //endregion\n+\n+    // Setup and configuration\n+\n+    @Before\n+    public void setup() throws Exception {\n+        int count = getKeyFamilyCount();\n+        this.keyFamilies = new ArrayList<>();\n+        this.keyFamilies.add(null); // No key family.\n+        for (int i = 0; i < count; i++) {\n+            this.keyFamilies.add(String.format(\"KF[%d]\", i));\n+        }\n+\n+        this.keyFamilies = Collections.unmodifiableList(this.keyFamilies);\n+    }\n+\n+    @Override\n+    protected int getThreadPoolSize() {\n+        return 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ae1a4f134fc23950bc982c7a3608f1f9b705482"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczNjIyOA==", "bodyText": "Yes they do. But the tests run somewhat faster with 3 given that at least in one implementation of this class we run the entire segment store.", "url": "https://github.com/pravega/pravega/pull/4687#discussion_r418736228", "createdAt": "2020-05-01T21:01:28Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/tables/impl/KeyValueTableTestBase.java", "diffHunk": "@@ -0,0 +1,597 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.pravega.client.stream.Serializer;\n+import io.pravega.client.stream.impl.UTF8StringSerializer;\n+import io.pravega.client.tables.BadKeyVersionException;\n+import io.pravega.client.tables.IteratorItem;\n+import io.pravega.client.tables.IteratorState;\n+import io.pravega.client.tables.KeyValueTable;\n+import io.pravega.client.tables.TableEntry;\n+import io.pravega.client.tables.TableKey;\n+import io.pravega.client.tables.Version;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.LeakDetectorTestSuite;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Cleanup;\n+import lombok.Getter;\n+import lombok.val;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Base test suite for anything testing {@link KeyValueTable}s. This covers core functionality for {@link KeyValueTable}s\n+ * and currently applies both to {@link KeyValueTableImplTests} (using mocked Controller and Segment Store) and\n+ * `io.pravega.test.integration.KeyValueTableImplTests` (using real Segment Store and Wire Protocol).\n+ */\n+public abstract class KeyValueTableTestBase extends LeakDetectorTestSuite {\n+    //region Members\n+\n+    protected static final String NULL_KEY_FAMILY = \"[NULL]\"; // Used for HashMap keys.\n+    protected static final Serializer<Integer> KEY_SERIALIZER = new IntegerSerializer();\n+    protected static final Serializer<String> VALUE_SERIALIZER = new UTF8StringSerializer();\n+    private static final int DEFAULT_SEGMENT_COUNT = 4;\n+    private static final int DEFAULT_KEY_FAMILY_COUNT = 100;\n+    private static final int DEFAULT_KEYS_PER_KEY_FAMILY = 10;\n+    @Getter(AccessLevel.PROTECTED)\n+    private List<String> keyFamilies;\n+\n+    //endregion\n+\n+    // Setup and configuration\n+\n+    @Before\n+    public void setup() throws Exception {\n+        int count = getKeyFamilyCount();\n+        this.keyFamilies = new ArrayList<>();\n+        this.keyFamilies.add(null); // No key family.\n+        for (int i = 0; i < count; i++) {\n+            this.keyFamilies.add(String.format(\"KF[%d]\", i));\n+        }\n+\n+        this.keyFamilies = Collections.unmodifiableList(this.keyFamilies);\n+    }\n+\n+    @Override\n+    protected int getThreadPoolSize() {\n+        return 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMzIxOQ=="}, "originalCommit": {"oid": "4ae1a4f134fc23950bc982c7a3608f1f9b705482"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4249, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}