{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDQ0Nzc2", "number": 4567, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDo1NTo0NFrODiGvcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo1NzowOVrODjTDIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg4NjI3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDo1NTo0NFrOFtM22A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDo1NTo0NFrOFtM22A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MDg4OA==", "bodyText": "Why aren't we using Netty ByteBufs ? There is already lot of support for composition and they support direct memory?", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r382940888", "createdAt": "2020-02-22T20:55:44Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.common.Exceptions;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * A composite, index-based array-like structure that is made up of one or more individual arrays of equal size. Each\n+ * component array maps to a contiguous offset range and is only allocated when the first index within its range needs\n+ * to be set (if unallocated, any index within its range will have a value of 0).\n+ */\n+public class CompositeByteArraySegment implements CompositeArrayView {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77a07529a4194ab9f17be27c6d94bd650ac414eb"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzM3ODczOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo1MTo1M1rOFvBuYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTo0MjoyOFrOFvCkFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTY0OQ==", "bodyText": "byte[] result = new byte[this.length];\ncopyTo(ByteBuffer.wrap(result));\nreturn result;", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384855649", "createdAt": "2020-02-27T00:51:53Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.common.Exceptions;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * A composite, index-based array-like structure that is made up of one or more individual arrays of equal size. Each\n+ * component array maps to a contiguous offset range and is only allocated when the first index within its range needs\n+ * to be set (if unallocated, any index within its range will have a value of 0).\n+ */\n+public class CompositeByteArraySegment implements CompositeArrayView {\n+    //region Members\n+    /**\n+     * Default component array size. 4KB maps to the kernel's page size.\n+     */\n+    private static final int DEFAULT_ARRAY_SIZE = 4 * 1024;\n+    /**\n+     * The offset at which the {@link CompositeByteArraySegment} begins, counted from the first block. This is helpful\n+     * for slicing a {@link CompositeByteArraySegment}. See {@link #slice}.\n+     */\n+    private final int startOffset;\n+    /**\n+     * Size of each component array.\n+     */\n+    private final int arraySize;\n+    private final Object[] arrays;\n+    @Getter\n+    private final int length;\n+    //endregion\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with a default component array size.\n+     *\n+     * @param length The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *               to use, but doesn't allocate any of them yet.\n+     */\n+    public CompositeByteArraySegment(int length) {\n+        this(length, DEFAULT_ARRAY_SIZE);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with the given component array size.\n+     *\n+     * @param length    The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *                  to use, but doesn't allocate any of them yet.\n+     * @param arraySize The component array size.\n+     */\n+    public CompositeByteArraySegment(int length, int arraySize) {\n+        Preconditions.checkArgument(length >= 0, \"length must be a non-negative number.\");\n+        Preconditions.checkArgument(arraySize > 0, \"arraySize must be a positive number.\");\n+\n+        this.length = length;\n+        this.arraySize = Math.min(length, arraySize); // No point in allocating more memory if total length is smaller than arraySize.\n+        this.startOffset = 0;\n+        int count = length / arraySize + (length % arraySize == 0 ? 0 : 1);\n+        this.arrays = new Object[count];\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class that wraps the given array. This instance\n+     * will have a single component array.\n+     *\n+     * @param source The byte array to wrap. Any changes made to this array will be reflected in this\n+     *               {@link CompositeByteArraySegment} instance and vice-versa.\n+     */\n+    @VisibleForTesting\n+    public CompositeByteArraySegment(@NonNull byte[] source) {\n+        this(new Object[]{source}, source.length, 0, source.length);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} that uses the given arguments. Useful for slicing.\n+     *\n+     * @param arrays      The array components to use.\n+     * @param arraySize   Size of each individual component.\n+     * @param startOffset Start offset.\n+     * @param length      Length of {@link CompositeByteArraySegment}.\n+     */\n+    private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffset, int length) {\n+        this.arrays = arrays;\n+        this.arraySize = arraySize;\n+        this.startOffset = startOffset;\n+        this.length = length;\n+    }\n+\n+    //region CompositeArrayView Implementation\n+\n+    @Override\n+    public byte get(int offset) {\n+        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n+        return array == null ? 0 : array[getArrayOffset(offset)];\n+    }\n+\n+    @Override\n+    public void set(int offset, byte value) {\n+        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n+        array[getArrayOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public InputStream getReader() {\n+        // Use the collector to create a list of ByteArrayInputStreams and then return them as combined.\n+        ArrayList<ByteArrayInputStream> streams = new ArrayList<>();\n+        collect((array, offset, length) -> streams.add(new ByteArrayInputStream(array, offset, length)));\n+        return new SequenceInputStream(Iterators.asEnumeration(streams.iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public CompositeArrayView slice(int offset, int length) {\n+        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n+        if (offset == 0 && length == this.length) {\n+            // Nothing to slice.\n+            return this;\n+        }\n+\n+        return new CompositeByteArraySegment(this.arrays, this.arraySize, this.startOffset + offset, length);\n+    }\n+\n+    @Override\n+    public <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray) throws ExceptionT {\n+        collect(collectArray, this.length);\n+    }\n+\n+    private <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray, int length) throws ExceptionT {\n+        if (length == 0) {\n+            // Nothing to collect.\n+            return;\n+        }\n+\n+        // We only need to process a subset of our arrays (since we may be sliced from the original array list).\n+        int startId = getArrayId(0);\n+        int endId = getArrayId(length - 1);\n+\n+        int arrayOffset = getArrayOffset(0); // The first array may need an offset, if this.startOffset > 0.\n+        for (int arrayId = startId; arrayId <= endId; arrayId++) {\n+            int arrayLength = Math.min(length, this.arraySize - arrayOffset);\n+            byte[] array = getArray(arrayId, false); // Don't allocate array if not allocated yet.\n+            if (array == null) {\n+                // Providing a dummy, empty array of the correct size is the easiest way to handle unallocated components\n+                // for all the cases this method is used for.\n+                collectArray.accept(new byte[arrayLength], 0, arrayLength);\n+            } else {\n+                collectArray.accept(array, arrayOffset, arrayLength);\n+            }\n+\n+            length -= arrayLength;\n+            arrayOffset = 0; // After processing the first array (handling this.startOffset), all other array offsets are 0.\n+        }\n+\n+        assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTM5Nw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384869397", "createdAt": "2020-02-27T01:42:28Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.common.Exceptions;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * A composite, index-based array-like structure that is made up of one or more individual arrays of equal size. Each\n+ * component array maps to a contiguous offset range and is only allocated when the first index within its range needs\n+ * to be set (if unallocated, any index within its range will have a value of 0).\n+ */\n+public class CompositeByteArraySegment implements CompositeArrayView {\n+    //region Members\n+    /**\n+     * Default component array size. 4KB maps to the kernel's page size.\n+     */\n+    private static final int DEFAULT_ARRAY_SIZE = 4 * 1024;\n+    /**\n+     * The offset at which the {@link CompositeByteArraySegment} begins, counted from the first block. This is helpful\n+     * for slicing a {@link CompositeByteArraySegment}. See {@link #slice}.\n+     */\n+    private final int startOffset;\n+    /**\n+     * Size of each component array.\n+     */\n+    private final int arraySize;\n+    private final Object[] arrays;\n+    @Getter\n+    private final int length;\n+    //endregion\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with a default component array size.\n+     *\n+     * @param length The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *               to use, but doesn't allocate any of them yet.\n+     */\n+    public CompositeByteArraySegment(int length) {\n+        this(length, DEFAULT_ARRAY_SIZE);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with the given component array size.\n+     *\n+     * @param length    The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *                  to use, but doesn't allocate any of them yet.\n+     * @param arraySize The component array size.\n+     */\n+    public CompositeByteArraySegment(int length, int arraySize) {\n+        Preconditions.checkArgument(length >= 0, \"length must be a non-negative number.\");\n+        Preconditions.checkArgument(arraySize > 0, \"arraySize must be a positive number.\");\n+\n+        this.length = length;\n+        this.arraySize = Math.min(length, arraySize); // No point in allocating more memory if total length is smaller than arraySize.\n+        this.startOffset = 0;\n+        int count = length / arraySize + (length % arraySize == 0 ? 0 : 1);\n+        this.arrays = new Object[count];\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class that wraps the given array. This instance\n+     * will have a single component array.\n+     *\n+     * @param source The byte array to wrap. Any changes made to this array will be reflected in this\n+     *               {@link CompositeByteArraySegment} instance and vice-versa.\n+     */\n+    @VisibleForTesting\n+    public CompositeByteArraySegment(@NonNull byte[] source) {\n+        this(new Object[]{source}, source.length, 0, source.length);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} that uses the given arguments. Useful for slicing.\n+     *\n+     * @param arrays      The array components to use.\n+     * @param arraySize   Size of each individual component.\n+     * @param startOffset Start offset.\n+     * @param length      Length of {@link CompositeByteArraySegment}.\n+     */\n+    private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffset, int length) {\n+        this.arrays = arrays;\n+        this.arraySize = arraySize;\n+        this.startOffset = startOffset;\n+        this.length = length;\n+    }\n+\n+    //region CompositeArrayView Implementation\n+\n+    @Override\n+    public byte get(int offset) {\n+        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n+        return array == null ? 0 : array[getArrayOffset(offset)];\n+    }\n+\n+    @Override\n+    public void set(int offset, byte value) {\n+        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n+        array[getArrayOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public InputStream getReader() {\n+        // Use the collector to create a list of ByteArrayInputStreams and then return them as combined.\n+        ArrayList<ByteArrayInputStream> streams = new ArrayList<>();\n+        collect((array, offset, length) -> streams.add(new ByteArrayInputStream(array, offset, length)));\n+        return new SequenceInputStream(Iterators.asEnumeration(streams.iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public CompositeArrayView slice(int offset, int length) {\n+        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n+        if (offset == 0 && length == this.length) {\n+            // Nothing to slice.\n+            return this;\n+        }\n+\n+        return new CompositeByteArraySegment(this.arrays, this.arraySize, this.startOffset + offset, length);\n+    }\n+\n+    @Override\n+    public <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray) throws ExceptionT {\n+        collect(collectArray, this.length);\n+    }\n+\n+    private <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray, int length) throws ExceptionT {\n+        if (length == 0) {\n+            // Nothing to collect.\n+            return;\n+        }\n+\n+        // We only need to process a subset of our arrays (since we may be sliced from the original array list).\n+        int startId = getArrayId(0);\n+        int endId = getArrayId(length - 1);\n+\n+        int arrayOffset = getArrayOffset(0); // The first array may need an offset, if this.startOffset > 0.\n+        for (int arrayId = startId; arrayId <= endId; arrayId++) {\n+            int arrayLength = Math.min(length, this.arraySize - arrayOffset);\n+            byte[] array = getArray(arrayId, false); // Don't allocate array if not allocated yet.\n+            if (array == null) {\n+                // Providing a dummy, empty array of the correct size is the easiest way to handle unallocated components\n+                // for all the cases this method is used for.\n+                collectArray.accept(new byte[arrayLength], 0, arrayLength);\n+            } else {\n+                collectArray.accept(array, arrayOffset, arrayLength);\n+            }\n+\n+            length -= arrayLength;\n+            arrayOffset = 0; // After processing the first array (handling this.startOffset), all other array offsets are 0.\n+        }\n+\n+        assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTY0OQ=="}, "originalCommit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzM4ODQ4OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/Write.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo1NzowOVrOFvB0Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTo0NDozNVrOFvCmQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzE3NA==", "bodyText": "Is this the best place for this method?", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384857174", "createdAt": "2020-02-27T00:57:09Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/Write.java", "diffHunk": "@@ -60,12 +68,19 @@\n         this.beginAttemptTimer = new AtomicReference<>();\n     }\n \n+    private ByteBuf convertData(CompositeArrayView data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTk1Mw==", "bodyText": "This method converts a CompositeByteArraySegment to a Netty ByteBuf. CompositeByteArraySegment is in common which doesn't have a dependency on Netty, so I can't do that there.\nThis is the main reason why I added the collect method in CompositeArrayView, so that I can essentially convert it to anything else without having to add extra dependencies in it.", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384869953", "createdAt": "2020-02-27T01:44:35Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/Write.java", "diffHunk": "@@ -60,12 +68,19 @@\n         this.beginAttemptTimer = new AtomicReference<>();\n     }\n \n+    private ByteBuf convertData(CompositeArrayView data) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzE3NA=="}, "originalCommit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4429, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}