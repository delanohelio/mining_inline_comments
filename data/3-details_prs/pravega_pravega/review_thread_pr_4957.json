{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MDE3OTMy", "number": 4957, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDoxNDo0OVrOERYzhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo1Mjo1NVrOERZhUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjY3NjUyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDoxNDo0OVrOG2EY4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDoxNDo0OVrOG2EY4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0ODE5NA==", "bodyText": "The AuthContext if..else block could be expressed more concisely using a ternary operator as done in listKeyValueTables :\n\n  \n    \n      pravega/controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java\n    \n    \n         Line 158\n      in\n      bf961c4\n    \n    \n    \n    \n\n        \n          \n           final AuthContext ctx = this.grpcAuthHelper.isAuthEnabled() ? AuthContext.current() : null;", "url": "https://github.com/pravega/pravega/pull/4957#discussion_r459348194", "createdAt": "2020-07-23T10:14:49Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -696,49 +696,65 @@ public void listStreamsInScope(Controller.StreamsInScopeRequest request, StreamO\n         } else {\n             ctx = null;\n         }\n-\n-        authenticateExecuteAndProcessResults(\n-                () -> {\n-                        String result = this.grpcAuthHelper.checkAuthorization(\n-                                AuthResourceRepresentation.ofScope(scopeName),\n-                                AuthHandler.Permissions.READ,\n-                                ctx);\n-                        log.debug(\"Result of authorization for [{}] and READ permission is: [{}]\",\n-                            AuthResourceRepresentation.ofScope(scopeName), result);\n-                        return result;\n-                },\n-                delegationToken -> controllerService\n-                        .listStreams(scopeName, request.getContinuationToken().getToken(), pageLimit)\n+        Function<String, CompletableFuture<Controller.StreamsInScopeResponse>> streamsFn = delegationToken ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf961c4e3b39353b9881dbe60252bfbd1fbdae66"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjY4OTgyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDoxOTowNFrOG2EgqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDoxOTowNFrOG2EgqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1MDE4NQ==", "bodyText": "Passing streamsFn as an argument to authenticateExecuteAndProcessResults is a much cleaner way to organize code. Could we also do the same for listKeyValueTablesInScope?", "url": "https://github.com/pravega/pravega/pull/4957#discussion_r459350185", "createdAt": "2020-07-23T10:19:04Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -696,49 +696,65 @@ public void listStreamsInScope(Controller.StreamsInScopeRequest request, StreamO\n         } else {\n             ctx = null;\n         }\n-\n-        authenticateExecuteAndProcessResults(\n-                () -> {\n-                        String result = this.grpcAuthHelper.checkAuthorization(\n-                                AuthResourceRepresentation.ofScope(scopeName),\n-                                AuthHandler.Permissions.READ,\n-                                ctx);\n-                        log.debug(\"Result of authorization for [{}] and READ permission is: [{}]\",\n-                            AuthResourceRepresentation.ofScope(scopeName), result);\n-                        return result;\n-                },\n-                delegationToken -> controllerService\n-                        .listStreams(scopeName, request.getContinuationToken().getToken(), pageLimit)\n+        Function<String, CompletableFuture<Controller.StreamsInScopeResponse>> streamsFn = delegationToken ->\n+                listStreamsInternal(scopeName, request.getContinuationToken().getToken(), pageLimit, ctx)\n                         .handle((response, ex) -> {\n                             if (ex != null) {\n                                 if (Exceptions.unwrap(ex) instanceof StoreException.DataNotFoundException) {\n-                                    return Controller.StreamsInScopeResponse.newBuilder().setStatus(Controller.StreamsInScopeResponse.Status.SCOPE_NOT_FOUND).build();\n+                                    return Controller.StreamsInScopeResponse\n+                                            .newBuilder().setStatus(Controller.StreamsInScopeResponse.Status.SCOPE_NOT_FOUND).build();\n                                 } else {\n                                     throw new CompletionException(ex);\n                                 }\n                             } else {\n-                                log.debug(\"All streams in scope with continuation token: {}\", response);\n-                                List<StreamInfo> streams = response\n-                                        .getKey().stream()\n-                                        .filter(streamName -> {\n-                                            String streamAuthResource =\n-                                                    AuthResourceRepresentation.ofStreamInScope(scopeName, streamName);\n-\n-                                            boolean isAuthorized = grpcAuthHelper.isAuthorized(streamAuthResource,\n-                                                    AuthHandler.Permissions.READ, ctx);\n-                                            log.debug(\"Authorization for [{}] for READ permission was [{}]\",\n-                                                    streamAuthResource, isAuthorized);\n-                                            return isAuthorized;\n-                                        })\n-                                        .map(m -> StreamInfo.newBuilder().setScope(scopeName).setStream(m).build())\n-                                        .collect(Collectors.toList());\n                                 return Controller.StreamsInScopeResponse\n-                                        .newBuilder().addAllStreams(streams)\n-                                        .setContinuationToken(Controller.ContinuationToken.newBuilder()\n-                                                                .setToken(response.getValue()).build())\n+                                        .newBuilder().addAllStreams(response.getKey())\n+                                        .setContinuationToken(Controller.ContinuationToken.newBuilder().setToken(response.getValue()).build())\n                                         .setStatus(Controller.StreamsInScopeResponse.Status.SUCCESS).build();\n                             }\n-                        }), responseObserver, requestTag);\n+                        });\n+\n+        authenticateExecuteAndProcessResults(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf961c4e3b39353b9881dbe60252bfbd1fbdae66"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Njc2NTEzOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo0MzoyM1rOG2FN_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo0MzoyM1rOG2FN_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2MTc5MA==", "bodyText": "We could do with an AtomicBoolean here instead of Integer.... all we need to know is if something got filtered out or no...", "url": "https://github.com/pravega/pravega/pull/4957#discussion_r459361790", "createdAt": "2020-07-23T10:43:23Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -696,49 +696,65 @@ public void listStreamsInScope(Controller.StreamsInScopeRequest request, StreamO\n         } else {\n             ctx = null;\n         }\n-\n-        authenticateExecuteAndProcessResults(\n-                () -> {\n-                        String result = this.grpcAuthHelper.checkAuthorization(\n-                                AuthResourceRepresentation.ofScope(scopeName),\n-                                AuthHandler.Permissions.READ,\n-                                ctx);\n-                        log.debug(\"Result of authorization for [{}] and READ permission is: [{}]\",\n-                            AuthResourceRepresentation.ofScope(scopeName), result);\n-                        return result;\n-                },\n-                delegationToken -> controllerService\n-                        .listStreams(scopeName, request.getContinuationToken().getToken(), pageLimit)\n+        Function<String, CompletableFuture<Controller.StreamsInScopeResponse>> streamsFn = delegationToken ->\n+                listStreamsInternal(scopeName, request.getContinuationToken().getToken(), pageLimit, ctx)\n                         .handle((response, ex) -> {\n                             if (ex != null) {\n                                 if (Exceptions.unwrap(ex) instanceof StoreException.DataNotFoundException) {\n-                                    return Controller.StreamsInScopeResponse.newBuilder().setStatus(Controller.StreamsInScopeResponse.Status.SCOPE_NOT_FOUND).build();\n+                                    return Controller.StreamsInScopeResponse\n+                                            .newBuilder().setStatus(Controller.StreamsInScopeResponse.Status.SCOPE_NOT_FOUND).build();\n                                 } else {\n                                     throw new CompletionException(ex);\n                                 }\n                             } else {\n-                                log.debug(\"All streams in scope with continuation token: {}\", response);\n-                                List<StreamInfo> streams = response\n-                                        .getKey().stream()\n-                                        .filter(streamName -> {\n-                                            String streamAuthResource =\n-                                                    AuthResourceRepresentation.ofStreamInScope(scopeName, streamName);\n-\n-                                            boolean isAuthorized = grpcAuthHelper.isAuthorized(streamAuthResource,\n-                                                    AuthHandler.Permissions.READ, ctx);\n-                                            log.debug(\"Authorization for [{}] for READ permission was [{}]\",\n-                                                    streamAuthResource, isAuthorized);\n-                                            return isAuthorized;\n-                                        })\n-                                        .map(m -> StreamInfo.newBuilder().setScope(scopeName).setStream(m).build())\n-                                        .collect(Collectors.toList());\n                                 return Controller.StreamsInScopeResponse\n-                                        .newBuilder().addAllStreams(streams)\n-                                        .setContinuationToken(Controller.ContinuationToken.newBuilder()\n-                                                                .setToken(response.getValue()).build())\n+                                        .newBuilder().addAllStreams(response.getKey())\n+                                        .setContinuationToken(Controller.ContinuationToken.newBuilder().setToken(response.getValue()).build())\n                                         .setStatus(Controller.StreamsInScopeResponse.Status.SUCCESS).build();\n                             }\n-                        }), responseObserver, requestTag);\n+                        });\n+\n+        authenticateExecuteAndProcessResults(\n+                () -> {\n+                        String result = this.grpcAuthHelper.checkAuthorization(\n+                                AuthResourceRepresentation.ofScope(scopeName),\n+                                AuthHandler.Permissions.READ,\n+                                ctx);\n+                        log.debug(\"Result of authorization for [{}] and READ permission is: [{}]\",\n+                            AuthResourceRepresentation.ofScope(scopeName), result);\n+                        return result;\n+                }, streamsFn, responseObserver, requestTag);\n+    }\n+\n+    private CompletableFuture<Pair<List<StreamInfo>, String>> listStreamsInternal(String scope, String continuationToken, int limit, AuthContext ctx) {\n+        List<StreamInfo> streams = new ArrayList<>();\n+        return controllerService.listStreams(scope, continuationToken, limit)\n+                                .thenCompose(response -> {\n+                                    log.debug(\"All streams in scope with continuation token: {}\", response);\n+                                    // filter unauthorized scopes. \n+                                    // fetch recursively if scopes are filtered out.\n+                                    AtomicInteger filteredCount = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf961c4e3b39353b9881dbe60252bfbd1fbdae66"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Njc3MTkyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/PravegaTablesStoreHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo0NTozNFrOG2FSDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMToxMTozOVrOG2GAFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2MjgyOA==", "bodyText": "What is this for?", "url": "https://github.com/pravega/pravega/pull/4957#discussion_r459362828", "createdAt": "2020-07-23T10:45:34Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/PravegaTablesStoreHelper.java", "diffHunk": "@@ -428,13 +430,15 @@ public void invalidateCache(String table, String key) {\n                                      List<String> items = result.getItems().stream().map(x -> new String(getArray(x.getKey()), Charsets.UTF_8))\n                                                                 .collect(Collectors.toList());\n                                      log.trace(\"get keys paginated on table {} returned items {}\", tableName, items);\n-                                     return new AbstractMap.SimpleEntry<>(Unpooled.wrappedBuffer(result.getState().toBytes()), items);\n+                                     // if the returned token and result are empty, return the incoming token so that \n+                                     // callers can resume from that token. \n+                                     return new AbstractMap.SimpleEntry<>(getNextToken(continuationToken, result), items);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf961c4e3b39353b9881dbe60252bfbd1fbdae66"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM3NDYxMg==", "bodyText": "The promise of controller vis a vis the continuation token is that it is an artifact from which if you make a query to read next set of items, it will retrieve them from the store and if there are no more results to be found, it would return empty list but the same token.\nBasically token indicates the position till which the results have been consumed.\nif they have exhausted the whole result set, this should point to the last element in the set.\nhowever, the read all keys/entries api on segment store doesnt return the same token back, instead it returns an empty token if there are no more items to return.\nfor example: if you issue readAllKeys(empty) and get {List<Keys>, Token} .. lets say all keys are read.. now if you issue readAllKeys(token), segment store returns {empty List, empty token}`\nSo the change here makes sure we return the same token back instead so that any time user makes a subsequent call from the token, it gets a response from which it can continue without reading the whole result again.", "url": "https://github.com/pravega/pravega/pull/4957#discussion_r459374612", "createdAt": "2020-07-23T11:11:39Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/PravegaTablesStoreHelper.java", "diffHunk": "@@ -428,13 +430,15 @@ public void invalidateCache(String table, String key) {\n                                      List<String> items = result.getItems().stream().map(x -> new String(getArray(x.getKey()), Charsets.UTF_8))\n                                                                 .collect(Collectors.toList());\n                                      log.trace(\"get keys paginated on table {} returned items {}\", tableName, items);\n-                                     return new AbstractMap.SimpleEntry<>(Unpooled.wrappedBuffer(result.getState().toBytes()), items);\n+                                     // if the returned token and result are empty, return the incoming token so that \n+                                     // callers can resume from that token. \n+                                     return new AbstractMap.SimpleEntry<>(getNextToken(continuationToken, result), items);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2MjgyOA=="}, "originalCommit": {"oid": "bf961c4e3b39353b9881dbe60252bfbd1fbdae66"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Njc5Mzc4OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo1Mjo1NVrOG2FfIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo1Mjo1NVrOG2FfIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2NjE3OQ==", "bodyText": "Perhaps putting it this way may make it easier to read and we also won't need the Atomic variable\nList<String> streamNames = response.getKey().stream().filter(x -> grpcAuthHelper.isAuthorized(AuthResourceRepresentation.ofStreamInScope(scope, x), AuthHandler.Permissions.READ, ctx)).collect(Collectors.toList())\nif (streamNames.size() < response.getKey()) {\n//recurse...\n} else {\n//return ...\n}", "url": "https://github.com/pravega/pravega/pull/4957#discussion_r459366179", "createdAt": "2020-07-23T10:52:55Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -696,49 +696,65 @@ public void listStreamsInScope(Controller.StreamsInScopeRequest request, StreamO\n         } else {\n             ctx = null;\n         }\n-\n-        authenticateExecuteAndProcessResults(\n-                () -> {\n-                        String result = this.grpcAuthHelper.checkAuthorization(\n-                                AuthResourceRepresentation.ofScope(scopeName),\n-                                AuthHandler.Permissions.READ,\n-                                ctx);\n-                        log.debug(\"Result of authorization for [{}] and READ permission is: [{}]\",\n-                            AuthResourceRepresentation.ofScope(scopeName), result);\n-                        return result;\n-                },\n-                delegationToken -> controllerService\n-                        .listStreams(scopeName, request.getContinuationToken().getToken(), pageLimit)\n+        Function<String, CompletableFuture<Controller.StreamsInScopeResponse>> streamsFn = delegationToken ->\n+                listStreamsInternal(scopeName, request.getContinuationToken().getToken(), pageLimit, ctx)\n                         .handle((response, ex) -> {\n                             if (ex != null) {\n                                 if (Exceptions.unwrap(ex) instanceof StoreException.DataNotFoundException) {\n-                                    return Controller.StreamsInScopeResponse.newBuilder().setStatus(Controller.StreamsInScopeResponse.Status.SCOPE_NOT_FOUND).build();\n+                                    return Controller.StreamsInScopeResponse\n+                                            .newBuilder().setStatus(Controller.StreamsInScopeResponse.Status.SCOPE_NOT_FOUND).build();\n                                 } else {\n                                     throw new CompletionException(ex);\n                                 }\n                             } else {\n-                                log.debug(\"All streams in scope with continuation token: {}\", response);\n-                                List<StreamInfo> streams = response\n-                                        .getKey().stream()\n-                                        .filter(streamName -> {\n-                                            String streamAuthResource =\n-                                                    AuthResourceRepresentation.ofStreamInScope(scopeName, streamName);\n-\n-                                            boolean isAuthorized = grpcAuthHelper.isAuthorized(streamAuthResource,\n-                                                    AuthHandler.Permissions.READ, ctx);\n-                                            log.debug(\"Authorization for [{}] for READ permission was [{}]\",\n-                                                    streamAuthResource, isAuthorized);\n-                                            return isAuthorized;\n-                                        })\n-                                        .map(m -> StreamInfo.newBuilder().setScope(scopeName).setStream(m).build())\n-                                        .collect(Collectors.toList());\n                                 return Controller.StreamsInScopeResponse\n-                                        .newBuilder().addAllStreams(streams)\n-                                        .setContinuationToken(Controller.ContinuationToken.newBuilder()\n-                                                                .setToken(response.getValue()).build())\n+                                        .newBuilder().addAllStreams(response.getKey())\n+                                        .setContinuationToken(Controller.ContinuationToken.newBuilder().setToken(response.getValue()).build())\n                                         .setStatus(Controller.StreamsInScopeResponse.Status.SUCCESS).build();\n                             }\n-                        }), responseObserver, requestTag);\n+                        });\n+\n+        authenticateExecuteAndProcessResults(\n+                () -> {\n+                        String result = this.grpcAuthHelper.checkAuthorization(\n+                                AuthResourceRepresentation.ofScope(scopeName),\n+                                AuthHandler.Permissions.READ,\n+                                ctx);\n+                        log.debug(\"Result of authorization for [{}] and READ permission is: [{}]\",\n+                            AuthResourceRepresentation.ofScope(scopeName), result);\n+                        return result;\n+                }, streamsFn, responseObserver, requestTag);\n+    }\n+\n+    private CompletableFuture<Pair<List<StreamInfo>, String>> listStreamsInternal(String scope, String continuationToken, int limit, AuthContext ctx) {\n+        List<StreamInfo> streams = new ArrayList<>();\n+        return controllerService.listStreams(scope, continuationToken, limit)\n+                                .thenCompose(response -> {\n+                                    log.debug(\"All streams in scope with continuation token: {}\", response);\n+                                    // filter unauthorized scopes. \n+                                    // fetch recursively if scopes are filtered out.\n+                                    AtomicInteger filteredCount = new AtomicInteger();\n+\n+                                    response.getKey().stream().filter(x -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf961c4e3b39353b9881dbe60252bfbd1fbdae66"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4798, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}