{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NjA1NzU4", "number": 5283, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzoyMToxN1rOExeo4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDoyNzo1MVrOExj8Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzE3NjY3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzoyMToxN1rOHnpNOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozMzoxMlrOHoVUEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMTY0MA==", "bodyText": "I believe this method does the same thing without the wrapping:\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#equals(byte%5B%5D,int,int,byte%5B%5D,int,int)", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511331640", "createdAt": "2020-10-24T07:21:17Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -171,44 +172,28 @@ public void copyTo(OutputStream stream) throws IOException {\n     }\n \n     @Override\n-    @SneakyThrows(IOException.class)\n     public boolean equals(BufferView other) {\n         if (this.length != other.getLength()) {\n             return false;\n         } else if (other instanceof ArrayView) {\n-            return equals((ArrayView) other);\n+            // ByteBuffer-optimized equality check.\n+            return this.asByteBuffer().equals(((ArrayView) other).asByteBuffer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a26f79f47330887572948e41eaf18fcbf998b730"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDI5MA==", "bodyText": "That method is not available in JDK8. This class is part of common so it must compile with JDK8 APIs.\nHowever, instances of this class may be used in JRE11 environments (such as Segment store) where the updated ByteBuffer.equals will be used.", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512054290", "createdAt": "2020-10-26T15:33:12Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -171,44 +172,28 @@ public void copyTo(OutputStream stream) throws IOException {\n     }\n \n     @Override\n-    @SneakyThrows(IOException.class)\n     public boolean equals(BufferView other) {\n         if (this.length != other.getLength()) {\n             return false;\n         } else if (other instanceof ArrayView) {\n-            return equals((ArrayView) other);\n+            // ByteBuffer-optimized equality check.\n+            return this.asByteBuffer().equals(((ArrayView) other).asByteBuffer());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMTY0MA=="}, "originalCommit": {"oid": "a26f79f47330887572948e41eaf18fcbf998b730"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDAzMzc1OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDoyMDoyMFrOHnxmXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozMDo1MlrOHoSQ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ2OTE1MQ==", "bodyText": "I am not sure that using the underscore is a good practice.\nWhat about common.server?", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511469151", "createdAt": "2020-10-24T14:20:20Z", "author": {"login": "eolivelli"}, "path": "build.gradle", "diffHunk": "@@ -377,6 +398,7 @@ project ('bindings') {\n project('segmentstore:server') {\n     dependencies {\n         compile project(':common')\n+        compile project(':common_server')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNDM0MQ==", "bodyText": "That was my first choice too. However Gradle completely refused to accept that. Having common and common:server (which means common:server must be in a direct sudirectory of common) prevented me from being able to access the packages in common:server (that is, when adding a reference in segmentstore:server to common:server, Gradle complained about a circular dependency and Intellij Idea refused to see those packages. Moving this code to a top-level package (like it is now) did not have this issues.\nI couldn't figure out what was wrong there since I did nothing special. We do use that pattern before (segmentstore:server and segmentstore:server:host) albeit with slight differences - the only difference I could tell was the both common and common:server share the same root package name io.pravega.common. I didn't want to create new/sub packages for this code.", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512004341", "createdAt": "2020-10-26T14:30:52Z", "author": {"login": "andreipaduroiu"}, "path": "build.gradle", "diffHunk": "@@ -377,6 +398,7 @@ project ('bindings') {\n project('segmentstore:server') {\n     dependencies {\n         compile project(':common')\n+        compile project(':common_server')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ2OTE1MQ=="}, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDAzOTQyOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDoyNDowM1rOHnxp8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozMzozM1rOHoSZXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDA2Nw==", "bodyText": "Why AtomicInteger? What about using some simpler int holder without concurrency support?", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511470067", "createdAt": "2020-10-24T14:24:03Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -183,6 +185,31 @@ public CompositeArrayView slice(int offset, int length) {\n         assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n     }\n \n+    @Override\n+    public Iterator<ByteBuffer> iterateBuffers() {\n+        if (this.length == 0) {\n+            return Collections.emptyIterator();\n+        }\n+\n+        AtomicInteger arrayOffset = new AtomicInteger(getArrayOffset(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjQ5NQ==", "bodyText": "Because I need to use this in a lambda just below which doesn't like me fiddling around with the variable contents (it needs to be immutable).\nThe reason for a lambda is because this method needs to return an iterator, and the simplest way to make one on-the-fly is by using Arrays.stream()... and then doing some mapping, hence the need for lambda.", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512006495", "createdAt": "2020-10-26T14:33:33Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -183,6 +185,31 @@ public CompositeArrayView slice(int offset, int length) {\n         assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n     }\n \n+    @Override\n+    public Iterator<ByteBuffer> iterateBuffers() {\n+        if (this.length == 0) {\n+            return Collections.emptyIterator();\n+        }\n+\n+        AtomicInteger arrayOffset = new AtomicInteger(getArrayOffset(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDA2Nw=="}, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDA0Mjk3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDoyNjowMlrOHnxsFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozNjozNFrOHoSjJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDYxNQ==", "bodyText": "Does is make sense to have a simpler handling in case of wrapping only 2 buffers?\nProbably we can save a few cpu cycles and memory allocations, but I am not sure it is worth", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511470615", "createdAt": "2020-10-24T14:26:02Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -183,6 +185,31 @@ public CompositeArrayView slice(int offset, int length) {\n         assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n     }\n \n+    @Override\n+    public Iterator<ByteBuffer> iterateBuffers() {\n+        if (this.length == 0) {\n+            return Collections.emptyIterator();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwODk5Nw==", "bodyText": "I tried to optimize both this and CompositeBufferView based on when they have only one (or two) buffers. The difference I saw was measured in fractions of nanoseconds so not worth it in my POV.\nFYI, CompositeByteArraySegment is only used in one place (currently). When we generate writes to BookKeeper, we need to write at most 1MB, but we do not know how much in advance to allocate. To give the impression of an array, this class creates a \"sparse array\" made of smaller arrays which are only allocated when first written to.\nMost of the time this will have just 1 element (up to 128KB).", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512008997", "createdAt": "2020-10-26T14:36:34Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -183,6 +185,31 @@ public CompositeArrayView slice(int offset, int length) {\n         assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n     }\n \n+    @Override\n+    public Iterator<ByteBuffer> iterateBuffers() {\n+        if (this.length == 0) {\n+            return Collections.emptyIterator();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDYxNQ=="}, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDA0NTM1OnYy", "diffSide": "RIGHT", "path": "common_server/src/main/java/io/pravega/common/util/BufferViewComparator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDoyNzo1MVrOHnxtew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozNzo1N1rOHoSnnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDk3MQ==", "bodyText": "What about using multirelease jars? It will be more simpler at runtime and less error prone", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511470971", "createdAt": "2020-10-24T14:27:51Z", "author": {"login": "eolivelli"}, "path": "common_server/src/main/java/io/pravega/common/util/BufferViewComparator.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+\n+/**\n+ * Performs a lexicographic bitwise comparison of {@link BufferView} instances (and of implemented classes).\n+ * <p>\n+ * Lexicographic bitwise comparison for {@link BufferView}s of the same length:\n+ * - Consider two {@link BufferView}s A and B, with each having L bits (L is a multiple of 8).\n+ * - Define A{n} and B{n} as the bit at position n in A and B, respectively. This can be either 0 or 1.\n+ * - A precedes B if there exists bit position i such that for all bit positions j smaller than i,\n+ * then A{j} is equal to B{j}, A{i} is 0 and B{i} is 1.\n+ * - A is equal to B if the values of all bit positions in both {@link BufferView}s match.\n+ * <p>\n+ * Lexicographic bitwise comparison for {@link BufferView}s of different lengths:\n+ * - Consider two {@link BufferView}s A and B, with A having LA bits and B having LB bits (LA, LB are multiples of 8).\n+ * - We do a Lexicographic bitwise comparison of the prefixes of A and B of lengths Min(LA, LB).\n+ * - If the prefixes are equal, then the shorter of A and B precedes the longer of A and B.\n+ * -- If LA &lt; LB, then A is before B; if LA &gt; LB, then A is after B.\n+ * - If the prefixes are not equal, then the result from the prefix comparison is used to order A and B (see above).\n+ * <p>\n+ * Lexicographic bitwise comparison matches the natural order of numbers when serialized as unsigned (i.e., using the\n+ * specialized methods in {@link BitConverter}) since they avoid the complications involved with interpreting individual\n+ * bytes with the first bit set to 1 using 2's complement (128 is before 127 if we used signed bytes).\n+ * <p>\n+ * For example:\n+ * - Consider any two Longs L1 and L2.\n+ * - Let S1 be the result of {@link BitConverter#writeUnsignedLong} when applied to L1, and S2 the result when applied to L2.\n+ * - Then {@link Long#compare} applied to (L1, L2) is equal to {@link #compare} applied to (S1, S2).\n+ * - This equality would not hold should L1 and L2 be serialized using {@link BitConverter#writeLong} or if we used plain\n+ * (signed) byte comparison internally.\n+ */\n+public abstract class BufferViewComparator implements Comparator<byte[]>, Serializable {\n+    /**\n+     * The minimum byte value for this comparison. Since we use unsigned bytes, this is 0-based.\n+     */\n+    public static final byte MIN_VALUE = 0;\n+    /**\n+     * The maximum byte value for this comparison. Since we use unsigned bytes, this is 0-based, hence 255.\n+     * Note that the actual value stored in Java for this is 0xFF, which is actually -1.\n+     */\n+    public static final byte MAX_VALUE = (byte) 255;\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    //region Constructor\n+\n+    /**\n+     * Determines if Intrinsic (JRE9+) array and {@link ByteBuffer} comparison is available.\n+     */\n+    private static final boolean INTRINSIC_SUPPORTED;\n+\n+    static {\n+        // Figure out if we support JRE9+ Intrinsic comparators. We do compile this code with JDK11, however this is to\n+        // have a failover in case we run with a lesser JRE.\n+        boolean intrinsicSupported = true;\n+        try {\n+            ByteBuffer bb = ByteBuffer.wrap(new byte[1]);\n+            bb.mismatch(bb);\n+        } catch (ExceptionInInitializerError | UnsatisfiedLinkError | NoClassDefFoundError e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMDE0Mw==", "bodyText": "Gradle recommends against that, so in my opinion, this is less controversial (and more deterministic - what goes where).", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512010143", "createdAt": "2020-10-26T14:37:57Z", "author": {"login": "andreipaduroiu"}, "path": "common_server/src/main/java/io/pravega/common/util/BufferViewComparator.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+\n+/**\n+ * Performs a lexicographic bitwise comparison of {@link BufferView} instances (and of implemented classes).\n+ * <p>\n+ * Lexicographic bitwise comparison for {@link BufferView}s of the same length:\n+ * - Consider two {@link BufferView}s A and B, with each having L bits (L is a multiple of 8).\n+ * - Define A{n} and B{n} as the bit at position n in A and B, respectively. This can be either 0 or 1.\n+ * - A precedes B if there exists bit position i such that for all bit positions j smaller than i,\n+ * then A{j} is equal to B{j}, A{i} is 0 and B{i} is 1.\n+ * - A is equal to B if the values of all bit positions in both {@link BufferView}s match.\n+ * <p>\n+ * Lexicographic bitwise comparison for {@link BufferView}s of different lengths:\n+ * - Consider two {@link BufferView}s A and B, with A having LA bits and B having LB bits (LA, LB are multiples of 8).\n+ * - We do a Lexicographic bitwise comparison of the prefixes of A and B of lengths Min(LA, LB).\n+ * - If the prefixes are equal, then the shorter of A and B precedes the longer of A and B.\n+ * -- If LA &lt; LB, then A is before B; if LA &gt; LB, then A is after B.\n+ * - If the prefixes are not equal, then the result from the prefix comparison is used to order A and B (see above).\n+ * <p>\n+ * Lexicographic bitwise comparison matches the natural order of numbers when serialized as unsigned (i.e., using the\n+ * specialized methods in {@link BitConverter}) since they avoid the complications involved with interpreting individual\n+ * bytes with the first bit set to 1 using 2's complement (128 is before 127 if we used signed bytes).\n+ * <p>\n+ * For example:\n+ * - Consider any two Longs L1 and L2.\n+ * - Let S1 be the result of {@link BitConverter#writeUnsignedLong} when applied to L1, and S2 the result when applied to L2.\n+ * - Then {@link Long#compare} applied to (L1, L2) is equal to {@link #compare} applied to (S1, S2).\n+ * - This equality would not hold should L1 and L2 be serialized using {@link BitConverter#writeLong} or if we used plain\n+ * (signed) byte comparison internally.\n+ */\n+public abstract class BufferViewComparator implements Comparator<byte[]>, Serializable {\n+    /**\n+     * The minimum byte value for this comparison. Since we use unsigned bytes, this is 0-based.\n+     */\n+    public static final byte MIN_VALUE = 0;\n+    /**\n+     * The maximum byte value for this comparison. Since we use unsigned bytes, this is 0-based, hence 255.\n+     * Note that the actual value stored in Java for this is 0xFF, which is actually -1.\n+     */\n+    public static final byte MAX_VALUE = (byte) 255;\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    //region Constructor\n+\n+    /**\n+     * Determines if Intrinsic (JRE9+) array and {@link ByteBuffer} comparison is available.\n+     */\n+    private static final boolean INTRINSIC_SUPPORTED;\n+\n+    static {\n+        // Figure out if we support JRE9+ Intrinsic comparators. We do compile this code with JDK11, however this is to\n+        // have a failover in case we run with a lesser JRE.\n+        boolean intrinsicSupported = true;\n+        try {\n+            ByteBuffer bb = ByteBuffer.wrap(new byte[1]);\n+            bb.mismatch(bb);\n+        } catch (ExceptionInInitializerError | UnsatisfiedLinkError | NoClassDefFoundError e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDk3MQ=="}, "originalCommit": {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4495, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}