{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNDAyNzQ4", "number": 4863, "title": "Issue 4830: Lazily instantiate Auto Scale Processor's writer ", "bodyText": "Change log description\nLazily instantiate the writer in auto scale processor when the scale signal needs to be sent.\nPurpose of the change\nFixes #4830\nWhat the code does\nIn AutoScaleProcessor, we have a writer that is created when the Autoscaleprocessor is instantiated.\nThis writer attempts to contact controller and get segments for the internal stream.\nDuring bootstrap of a cluster as controller is still coming up and attempting to create the internal stream, any requests from this writer can fail (and often does) with warn or error level client logs describing the failure in segment store process. Equivalent warn level logs are present in controller as it is unable to process the request.\nThis leads to unnecessary log pollution and people often focus on this log while facing difficulty during bootstrap.\nBy starting the writer lazily, at the time when first scale request needs to be sent out, ensures that we avoid this unnecessary error log in multiple places.\nCode changes:\n\nthe bootstrap method is replaced by getWriter method which idempotently sets writer future.\nthe isInitialized method is no longer required as the request is asynhronously chained to the getWriter future.\nAdded a protected getTimeMillis method to effectively make it testable with a clock that can be progressed without having to rely on system clock.\n\nHow to verify it\nUnit test added.\nAll integration and system tests should pass.", "createdAt": "2020-06-10T11:50:44Z", "url": "https://github.com/pravega/pravega/pull/4863", "merged": true, "mergeCommit": {"oid": "1c1d948e78470ab12838edb90d2bde05e744a6bb"}, "closed": true, "closedAt": "2020-06-16T10:03:02Z", "author": {"login": "shiveshr"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcp35VlgH2gAyNDMyNDAyNzQ4Ojc5YjQ5OTM4ZDRkYmRiZGEyNzc0YzVjYTBlZTg4NWI1NzhhNWIzYzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrpk8QgH2gAyNDMyNDAyNzQ4OmE5M2NiMjRhODE2MDYxMDMwNTYxMmZhZDg4NDM1ODdjOWQ5OGQyMzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "79b49938d4dbdbda2774c5ca0ee885b578a5b3c9", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/79b49938d4dbdbda2774c5ca0ee885b578a5b3c9", "committedDate": "2020-06-10T11:24:23Z", "message": "issue4830\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb333689a27f885ea0aa3b63a6d8de9e2a2a3b0e", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/eb333689a27f885ea0aa3b63a6d8de9e2a2a3b0e", "committedDate": "2020-06-10T11:25:47Z", "message": "Merge branch 'master' into issu4830"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c708f84df7a66dd3d756a1270147a1b3840dde9", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/3c708f84df7a66dd3d756a1270147a1b3840dde9", "committedDate": "2020-06-10T15:32:23Z", "message": "checkstyle\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "3c708f84df7a66dd3d756a1270147a1b3840dde9", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/3c708f84df7a66dd3d756a1270147a1b3840dde9", "committedDate": "2020-06-10T15:32:23Z", "message": "checkstyle\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9bf54b0774d260814336531fecadb53ca0a21ad", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/c9bf54b0774d260814336531fecadb53ca0a21ad", "committedDate": "2020-06-11T01:58:13Z", "message": "spotbug static inner class\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "c9bf54b0774d260814336531fecadb53ca0a21ad", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/c9bf54b0774d260814336531fecadb53ca0a21ad", "committedDate": "2020-06-11T01:58:13Z", "message": "spotbug static inner class\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2025f3c22dea3a605b1ed613731a51793220dc6d", "author": {"user": {"login": "shrids", "name": "Sandeep"}}, "url": "https://github.com/pravega/pravega/commit/2025f3c22dea3a605b1ed613731a51793220dc6d", "committedDate": "2020-06-11T04:27:33Z", "message": "Merge branch 'master' into issu4830"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTk3NjE1", "url": "https://github.com/pravega/pravega/pull/4863#pullrequestreview-428597615", "createdAt": "2020-06-11T05:14:37Z", "commit": {"oid": "2025f3c22dea3a605b1ed613731a51793220dc6d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNToxNDozOFrOGiOxTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNToxNDozOFrOGiOxTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU0Njc2Nw==", "bodyText": "we can use io.pravega.common.concurrent.Futures#isSuccessful here.", "url": "https://github.com/pravega/pravega/pull/4863#discussion_r438546767", "createdAt": "2020-06-11T05:14:38Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java", "diffHunk": "@@ -116,48 +122,51 @@\n                 }, executor))\n                 .build();\n \n+        this.executor = executor;\n+        \n         // Even if there is no activity, keep cleaning up the cache so that scale down can be triggered.\n         // caches do not perform clean up if there is no activity. This is because they do not maintain their\n         // own background thread.\n         this.cacheCleanup = executor.scheduleAtFixedRate(cache::cleanUp, 0, configuration.getCacheCleanup().getSeconds(), TimeUnit.SECONDS);\n-        if (clientFactory != null) {\n-            bootstrapRequestWriters(clientFactory, executor);\n-        }\n     }\n \n     @Override\n+    @Synchronized\n     public void close() {\n-        val w = this.writer.get();\n-        if (w != null) {\n-            w.close();\n-            this.writer.set(null);\n+        if (writer != null) {\n+            writer.cancel(true);\n+\n+            if (!writer.isCancelled() && !writer.isCompletedExceptionally()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2025f3c22dea3a605b1ed613731a51793220dc6d"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af960a6045dba78ecda743c2d5e6f07ab960c520", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/af960a6045dba78ecda743c2d5e6f07ab960c520", "committedDate": "2020-06-11T09:00:19Z", "message": "PR comment\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd178ff71d528c4c10b2edaac5c36915f9ee84d", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/5cd178ff71d528c4c10b2edaac5c36915f9ee84d", "committedDate": "2020-06-11T09:00:53Z", "message": "Merge branch 'issu4830' of https://github.com/shiveshr/pravega-1 into issu4830"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff35c5143598fefba2769f8a29246e7e658e1770", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/ff35c5143598fefba2769f8a29246e7e658e1770", "committedDate": "2020-06-11T09:49:36Z", "message": "illegal char\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff95784ab8bfb420a484fceb60b28f2236b3f4c1", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/ff95784ab8bfb420a484fceb60b28f2236b3f4c1", "committedDate": "2020-06-11T09:49:58Z", "message": "Merge branch 'issu4830' of https://github.com/shiveshr/pravega-1 into issu4830"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "039847398915fd9278c3d5c8cbf6adeff7ee4834", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/039847398915fd9278c3d5c8cbf6adeff7ee4834", "committedDate": "2020-06-11T13:13:47Z", "message": "coverage\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MDkwNDQx", "url": "https://github.com/pravega/pravega/pull/4863#pullrequestreview-429090441", "createdAt": "2020-06-11T16:35:39Z", "commit": {"oid": "039847398915fd9278c3d5c8cbf6adeff7ee4834"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjozNTozOVrOGilmww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjozODo1NFrOGilubw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMDg5OQ==", "bodyText": "Non-final fields make it look like something's not right. Let's see if we can make this better. Would this work?\n\nMake this final and remove the \"GuardedBy\"\nIn the getWriter method, do exactly what you're doing, but when the retry loop is done, set the result on this future, whether it be the writer or an exception. You can use Futures.completeAfter (I may forget the actual name).\n\nThis way we don't need a new lock and we can make this field final. CompletableFuture internally is thread safe so it takes care of any concurrency issues for us.", "url": "https://github.com/pravega/pravega/pull/4863#discussion_r438920899", "createdAt": "2020-06-11T16:35:39Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java", "diffHunk": "@@ -61,10 +66,12 @@\n \n     private final EventStreamClientFactory clientFactory;\n     private final Cache<String, Pair<Long, Long>> cache;\n-    private final AtomicReference<EventStreamWriter<AutoScaleEvent>> writer;\n+    @GuardedBy(\"$lock\")\n+    private CompletableFuture<EventStreamWriter<AutoScaleEvent>> writer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039847398915fd9278c3d5c8cbf6adeff7ee4834"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMTQwMQ==", "bodyText": "Writer should always be non-null.", "url": "https://github.com/pravega/pravega/pull/4863#discussion_r438921401", "createdAt": "2020-06-11T16:36:28Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java", "diffHunk": "@@ -116,48 +123,51 @@\n                 }, executor))\n                 .build();\n \n+        this.executor = executor;\n+        \n         // Even if there is no activity, keep cleaning up the cache so that scale down can be triggered.\n         // caches do not perform clean up if there is no activity. This is because they do not maintain their\n         // own background thread.\n         this.cacheCleanup = executor.scheduleAtFixedRate(cache::cleanUp, 0, configuration.getCacheCleanup().getSeconds(), TimeUnit.SECONDS);\n-        if (clientFactory != null) {\n-            bootstrapRequestWriters(clientFactory, executor);\n-        }\n     }\n \n     @Override\n+    @Synchronized\n     public void close() {\n-        val w = this.writer.get();\n-        if (w != null) {\n-            w.close();\n-            this.writer.set(null);\n+        if (writer != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039847398915fd9278c3d5c8cbf6adeff7ee4834"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMjI1OQ==", "bodyText": "This indefinite retry won't work well in case we fail to bootstrap and we decide to shut down. It will likely leave this running forever. You should include a condition that can cancel it. My recommendation would be to check this.writer.isDone (it will be true when either a writer has been set or when it got completed with an exception).", "url": "https://github.com/pravega/pravega/pull/4863#discussion_r438922259", "createdAt": "2020-06-11T16:37:55Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java", "diffHunk": "@@ -116,48 +123,51 @@\n                 }, executor))\n                 .build();\n \n+        this.executor = executor;\n+        \n         // Even if there is no activity, keep cleaning up the cache so that scale down can be triggered.\n         // caches do not perform clean up if there is no activity. This is because they do not maintain their\n         // own background thread.\n         this.cacheCleanup = executor.scheduleAtFixedRate(cache::cleanUp, 0, configuration.getCacheCleanup().getSeconds(), TimeUnit.SECONDS);\n-        if (clientFactory != null) {\n-            bootstrapRequestWriters(clientFactory, executor);\n-        }\n     }\n \n     @Override\n+    @Synchronized\n     public void close() {\n-        val w = this.writer.get();\n-        if (w != null) {\n-            w.close();\n-            this.writer.set(null);\n+        if (writer != null) {\n+            writer.cancel(true);\n+\n+            if (Futures.isSuccessful(writer)) {\n+                val w = this.writer.join();\n+                if (w != null) {\n+                    w.close();\n+                }\n+            }\n         }\n \n         this.clientFactory.close();\n         this.cacheCleanup.cancel(true);\n     }\n \n-    private void bootstrapRequestWriters(EventStreamClientFactory clientFactory, ScheduledExecutorService executor) {\n-        // Starting with initial delay, in case request stream has not been created, to give it time to start\n-        // However, we have this wrapped in consumeFailure which means the creation of writer will be retried.\n-        // We are introducing a delay to avoid exceptions in the log in case creation of writer is attempted before\n-        // creation of requeststream.\n-        executor.schedule(\n-                () -> Retry.indefinitelyWithExpBackoff(100, 10, 10000, this::handleBootstrapException)\n-                        .runInExecutor(() -> bootstrapOnce(clientFactory), executor),\n-                10, TimeUnit.SECONDS);\n+    @Synchronized\n+    private CompletableFuture<EventStreamWriter<AutoScaleEvent>> getWriter() {\n+        if (writer == null) {\n+            AtomicReference<EventStreamWriter<AutoScaleEvent>> w = new AtomicReference<>();\n+            EventWriterConfig writerConfig = EventWriterConfig.builder().build();\n+            writer = Retry.indefinitelyWithExpBackoff(100, 10, 10000, this::handleBootstrapException)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039847398915fd9278c3d5c8cbf6adeff7ee4834"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMjg2Mw==", "bodyText": "Please revert this. This will result in too much garbage in the segment store logs.", "url": "https://github.com/pravega/pravega/pull/4863#discussion_r438922863", "createdAt": "2020-06-11T16:38:54Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java", "diffHunk": "@@ -192,113 +202,99 @@ static boolean hasTlsEnabled(@NonNull final URI controllerURI) {\n         return uriScheme.equals(\"tls\") || uriScheme.equals(\"pravegas\");\n     }\n \n-    private boolean isInitialized() {\n-        return this.writer.get() != null;\n-    }\n-\n     private void triggerScaleUp(String streamSegmentName, int numOfSplits) {\n-        if (isInitialized()) {\n-            Pair<Long, Long> pair = cache.getIfPresent(streamSegmentName);\n-            long lastRequestTs = 0;\n+        Pair<Long, Long> pair = cache.getIfPresent(streamSegmentName);\n+        long lastRequestTs = 0;\n \n-            if (pair != null && pair.getKey() != null) {\n-                lastRequestTs = pair.getKey();\n-            }\n+        if (pair != null && pair.getKey() != null) {\n+            lastRequestTs = pair.getKey();\n+        }\n \n-            long timestamp = System.currentTimeMillis();\n-            long requestId = requestIdGenerator.get();\n-            if (timestamp - lastRequestTs > configuration.getMuteDuration().toMillis()) {\n-                log.info(requestId, \"sending request for scale up for {}\", streamSegmentName);\n+        long timestamp = getTimeMillis();\n+        long requestId = requestIdGenerator.get();\n+        if (timestamp - lastRequestTs > configuration.getMuteDuration().toMillis()) {\n+            log.info(requestId, \"sending request for scale up for {}\", streamSegmentName);\n \n-                Segment segment = Segment.fromScopedName(streamSegmentName);\n-                AutoScaleEvent event = new AutoScaleEvent(segment.getScope(), segment.getStreamName(), segment.getSegmentId(),\n-                        AutoScaleEvent.UP, timestamp, numOfSplits, false, requestId);\n-                // Mute scale for timestamp for both scale up and down\n-                writeRequest(event, () -> cache.put(streamSegmentName, new ImmutablePair<>(timestamp, timestamp)));\n-            }\n+            Segment segment = Segment.fromScopedName(streamSegmentName);\n+            AutoScaleEvent event = new AutoScaleEvent(segment.getScope(), segment.getStreamName(), segment.getSegmentId(),\n+                    AutoScaleEvent.UP, timestamp, numOfSplits, false, requestId);\n+            // Mute scale for timestamp for both scale up and down\n+            writeRequest(event, () -> cache.put(streamSegmentName, new ImmutablePair<>(timestamp, timestamp)));\n         }\n     }\n \n     private void triggerScaleDown(String streamSegmentName, boolean silent) {\n-        if (isInitialized()) {\n-            Pair<Long, Long> pair = cache.getIfPresent(streamSegmentName);\n-            long lastRequestTs = 0;\n+        Pair<Long, Long> pair = cache.getIfPresent(streamSegmentName);\n+        long lastRequestTs = 0;\n \n-            if (pair != null && pair.getValue() != null) {\n-                lastRequestTs = pair.getValue();\n-            }\n+        if (pair != null && pair.getValue() != null) {\n+            lastRequestTs = pair.getValue();\n+        }\n \n-            long timestamp = System.currentTimeMillis();\n-            long requestId = requestIdGenerator.get();\n-            if (timestamp - lastRequestTs > configuration.getMuteDuration().toMillis()) {\n-                log.info(requestId, \"sending request for scale down for {}\", streamSegmentName);\n-\n-                Segment segment = Segment.fromScopedName(streamSegmentName);\n-                AutoScaleEvent event = new AutoScaleEvent(segment.getScope(), segment.getStreamName(), segment.getSegmentId(),\n-                        AutoScaleEvent.DOWN, timestamp, 0, silent, requestId);\n-                writeRequest(event, () -> {\n-                    if (!silent) {\n-                        // mute only scale downs\n-                        cache.put(streamSegmentName, new ImmutablePair<>(0L, timestamp));\n-                    }\n-                });\n-            }\n+        long timestamp = getTimeMillis();\n+        long requestId = requestIdGenerator.get();\n+        if (timestamp - lastRequestTs > configuration.getMuteDuration().toMillis()) {\n+            log.info(requestId, \"sending request for scale down for {}\", streamSegmentName);\n+\n+            Segment segment = Segment.fromScopedName(streamSegmentName);\n+            AutoScaleEvent event = new AutoScaleEvent(segment.getScope(), segment.getStreamName(), segment.getSegmentId(),\n+                    AutoScaleEvent.DOWN, timestamp, 0, silent, requestId);\n+            writeRequest(event, () -> {\n+                if (!silent) {\n+                    // mute only scale downs\n+                    cache.put(streamSegmentName, new ImmutablePair<>(0L, timestamp));\n+                }\n+            });\n         }\n     }\n \n     private void writeRequest(AutoScaleEvent event, Runnable successCallback) {\n-        val writer = this.writer.get();\n-        if (writer == null) {\n-            log.warn(event.getRequestId(), \"Writer not bootstrapped; unable to post Scale Event {}.\", event);\n-        } else {\n-            writer.writeEvent(event.getKey(), event)\n+        getWriter().thenCompose(w -> w.writeEvent(event.getKey(), event)\n                     .whenComplete((r, e) -> {\n                         if (e != null) {\n                             log.error(event.getRequestId(), \"Unable to post Scale Event to RequestStream '{}'.\",\n                                     this.configuration.getInternalRequestStream(), e);\n                         } else {\n-                            log.debug(event.getRequestId(), \"Scale Event posted successfully: {}.\", event);\n+                            log.info(event.getRequestId(), \"Scale Event posted successfully: {}.\", event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039847398915fd9278c3d5c8cbf6adeff7ee4834"}, "originalPosition": 240}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85e8405e5fe2c591291190991adb81e592028f5e", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/85e8405e5fe2c591291190991adb81e592028f5e", "committedDate": "2020-06-12T07:02:12Z", "message": "PR comments\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a901ef2f428b7984db5b358b4a0463d2f77ed48", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/3a901ef2f428b7984db5b358b4a0463d2f77ed48", "committedDate": "2020-06-12T10:33:40Z", "message": "code coverage\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODAyMTEz", "url": "https://github.com/pravega/pravega/pull/4863#pullrequestreview-429802113", "createdAt": "2020-06-12T14:46:31Z", "commit": {"oid": "3a901ef2f428b7984db5b358b4a0463d2f77ed48"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzA2OTQ4", "url": "https://github.com/pravega/pravega/pull/4863#pullrequestreview-430306948", "createdAt": "2020-06-15T03:52:43Z", "commit": {"oid": "3a901ef2f428b7984db5b358b4a0463d2f77ed48"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzo1Mjo0M1rOGjidgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzo1Mjo0M1rOGjidgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkxNzk1NQ==", "bodyText": "If startInitWriter is false then we would be logging this line repeatedly.\nThis would clutter the logs with WARN messages. (including standalone) Can we avoid it?", "url": "https://github.com/pravega/pravega/pull/4863#discussion_r439917955", "createdAt": "2020-06-15T03:52:43Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java", "diffHunk": "@@ -127,35 +131,44 @@\n \n     @Override\n     public void close() {\n-        val w = this.writer.get();\n-        if (w != null) {\n-            w.close();\n-            this.writer.set(null);\n+        writer.cancel(true);\n+\n+        if (Futures.isSuccessful(writer)) {\n+            val w = this.writer.join();\n+            if (w != null) {\n+                w.close();\n+            }\n         }\n \n-        this.clientFactory.close();\n+        if (clientFactory != null) {\n+            this.clientFactory.close();\n+        }\n         this.cacheCleanup.cancel(true);\n     }\n-\n+    \n     private void bootstrapRequestWriters(EventStreamClientFactory clientFactory, ScheduledExecutorService executor) {\n-        // Starting with initial delay, in case request stream has not been created, to give it time to start\n-        // However, we have this wrapped in consumeFailure which means the creation of writer will be retried.\n-        // We are introducing a delay to avoid exceptions in the log in case creation of writer is attempted before\n-        // creation of requeststream.\n-        executor.schedule(\n-                () -> Retry.indefinitelyWithExpBackoff(100, 10, 10000, this::handleBootstrapException)\n-                        .runInExecutor(() -> bootstrapOnce(clientFactory), executor),\n-                10, TimeUnit.SECONDS);\n+        AtomicReference<EventStreamWriter<AutoScaleEvent>> w = new AtomicReference<>();\n+\n+        Futures.completeAfter(() -> Retry.indefinitelyWithExpBackoff(100, 10, 10000, this::handleBootstrapException)\n+                                         .runInExecutor(() -> bootstrapOnce(clientFactory, w), \n+                                                 executor).thenApply(v -> w.get()), writer);\n     }\n \n     private void handleBootstrapException(Throwable e) {\n         log.warn(\"Unable to create writer for requeststream: {}.\", LoggerHelpers.exceptionSummary(log, e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a901ef2f428b7984db5b358b4a0463d2f77ed48"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d42674d3064d2cb0abea06c73516b93a025537f", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/5d42674d3064d2cb0abea06c73516b93a025537f", "committedDate": "2020-06-15T04:54:08Z", "message": "PR comment\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNTAwNDYy", "url": "https://github.com/pravega/pravega/pull/4863#pullrequestreview-430500462", "createdAt": "2020-06-15T10:05:48Z", "commit": {"oid": "5d42674d3064d2cb0abea06c73516b93a025537f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6346c5d76d49895d57e8d1690f6254c076dc342", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/a6346c5d76d49895d57e8d1690f6254c076dc342", "committedDate": "2020-06-15T11:30:25Z", "message": "coverage\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a93cb24a8160610305612fad8843587c9d98d230", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a93cb24a8160610305612fad8843587c9d98d230", "committedDate": "2020-06-15T23:51:17Z", "message": "Merge branch 'master' into issu4830"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3532, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}