{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0Nzc2MDAw", "number": 4703, "title": "Issue 4702: (SegmentStore) Fixed a deadlock condition in the Read Index.", "bodyText": "Signed-off-by: Andrei Paduroiu andrei.paduroiu@emc.com\nChange log description\n\nChanged the CacheManager to reject additional concurrent cache cleanup requests if one is ongoing (as opposed from using a mutex to serialize them).\nChanged the DirectMemoryCache to use an exp backoff retry if it cannot clean up the cache after it detected the cache was full.\n\nPurpose of the change\nFixes #4702.\nWhat the code does\nSee #4702 for a description of a scenario that leads to this.\nThe problem arises if 2 concurrent Storage reads complete at about the same time, and both want to insert into a full cache at the same time. Each callback would execute on its own thread, acquire the Read Index lock associated with their segment, then acquire the Cache Manager eviction lock (whomever does it first), and the Cache Manager would attempt to clean up the index by accessing the other Read Indices (leading to a deadlock).\nThis has been fixed in 2 steps:\n\nRemoved the Cache Manager lock altogether. If another request comes in while a cache eviction is in progress, the second request will be rejected.\nChanged the Streaming Cache (DirectMemoryCache) to use an exp backoff retry in case it is unable to trigger a cache eviction\n\nPreviously it would retry immediately and give up as soon as the CM said nothing could be done.\nNow it will try up to 5 times, waiting 50-250ms in between requests.\nIf after 5 attempts it is not able to do anything, then it will throw up a CacheFullException\n\nThis is the same as before, except that now it adds the extra delays in between checks.\n\n\nOn the append path, a CacheFullException will shut down the container (this has not changed)\nOn the Storage Read Path, a CacheFullException has no effect on the request. The original request has already been ack-ed/sent to the client before the attempt to write to the cache. If we cannot write to the cache due to cache full, we will log a warning now so we can trace this in the logs.\n\n\n\nHow to verify it\nNew, specific unit test added that verifies this exact situation. The unit test would not complete if there were a deadlock.", "createdAt": "2020-04-16T21:57:32Z", "url": "https://github.com/pravega/pravega/pull/4703", "merged": true, "mergeCommit": {"oid": "729bc23b6370c2b9fb735e83ed496eec66a5991d"}, "closed": true, "closedAt": "2020-04-20T21:56:03Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYT6AQgH2gAyNDA0Nzc2MDAwOjlkZjNjODQwNWU4NzNmMDQ4OTE5MjM3ZjY0NjNlYzZlMjgxZmQ4OWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZmDZ5AFqTM5NjgyOTcxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9df3c8405e873f048919237f6463ec6e281fd89f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/9df3c8405e873f048919237f6463ec6e281fd89f", "committedDate": "2020-04-16T21:51:49Z", "message": "Fixed a deadlock condition in the Read Index.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8374b8704e523be11aa00660a8aa720998133ad", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e8374b8704e523be11aa00660a8aa720998133ad", "committedDate": "2020-04-16T21:59:31Z", "message": "Fixed a deadlock condition in the Read Index.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODIxNDU5", "url": "https://github.com/pravega/pravega/pull/4703#pullrequestreview-395821459", "createdAt": "2020-04-17T23:16:45Z", "commit": {"oid": "e8374b8704e523be11aa00660a8aa720998133ad"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMzoxNjo0NVrOGHfmhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMzoxOToxNVrOGHfoqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDk4MA==", "bodyText": "RetryPolicy in common is built to do this.", "url": "https://github.com/pravega/pravega/pull/4703#discussion_r410510980", "createdAt": "2020-04-17T23:16:45Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/cache/DirectMemoryCache.java", "diffHunk": "@@ -399,15 +403,23 @@ private DirectMemoryBuffer getNextAvailableBuffer() {\n \n             // If we get here, there are no available buffers and we have allocated all the buffers we could. Notify\n             // any upstream listeners to attempt a cleanup (if possible).\n-        } while (++attempts <= MAX_CLEANUP_ATTEMPTS && tryCleanup());\n+            attempts++;\n+            tryCleanup(attempts);\n+        }\n \n         // Unable to reuse any existing buffer or find a new one to allocate and upstream code could not free up data.\n         throw new CacheFullException(String.format(\"%s full: %s.\", DirectMemoryCache.class.getSimpleName(), getState()));\n     }\n \n-    private boolean tryCleanup() {\n+    private void tryCleanup(int attempts) {\n         val c = this.tryCleanup.get();\n-        return c != null && c.get();\n+        if (c != null && !c.get()) {\n+            // Unable to clean up the cache. Wait a bit, then try again.\n+            int sleepMillis = attempts * this.retryDelayBaseMillis.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8374b8704e523be11aa00660a8aa720998133ad"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMTUzMQ==", "bodyText": "As usual when changing from course locking to fine locking make double sure there aren't code paths that implicitly assume that another thread isn't going to change something in the mean time. For example here one might make the assumption that currentGeneration would not change in the middle of a method, or that current and oldest generation are different or that older is newer that current etc.", "url": "https://github.com/pravega/pravega/pull/4703#discussion_r410511531", "createdAt": "2020-04-17T23:19:15Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/CacheManager.java", "diffHunk": "@@ -47,17 +49,15 @@\n @ThreadSafe\n public class CacheManager extends AbstractScheduledService implements AutoCloseable {\n     //region Members\n-\n+    private static final int CACHE_FULL_RETRY_BASE_MILLIS = 50;\n     private static final String TRACE_OBJECT_ID = \"CacheManager\";\n     @GuardedBy(\"lock\")\n     private final Collection<Client> clients;\n     private final ScheduledExecutorService executorService;\n-    @GuardedBy(\"lock\")\n-    private int currentGeneration;\n-    @GuardedBy(\"lock\")\n-    private int oldestGeneration;\n-    @GuardedBy(\"lock\")\n-    private CacheState lastCacheState;\n+    private final AtomicInteger currentGeneration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8374b8704e523be11aa00660a8aa720998133ad"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODI5NzE4", "url": "https://github.com/pravega/pravega/pull/4703#pullrequestreview-396829718", "createdAt": "2020-04-20T21:34:18Z", "commit": {"oid": "e8374b8704e523be11aa00660a8aa720998133ad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3410, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}