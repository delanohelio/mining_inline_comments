{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3Nzk3ODkx", "number": 5378, "title": "Issue 5377: Support TLS-enabled clusters for integration testing", "bodyText": "Change log description\nAdd support for TLS-enabled clusters in ClusterWrapper and ControllerWrapper, which are used for running servers for integration tests.\nPurpose of the change\nResolves #5377.\nWhat the code does\n\nAdds support for TLS in ClusterWrapper and ControllerWrapper.\nModify ClusterWrapper to support construction via a builder instead of constructors. This became useful as the number of construction parameters increased. Also, a builder makes the intent of each parameter explicit in the test code.\n\nHow to verify it\nAll integration tests must pass.\nNew tests were added in ClusterWrapperTest to demonstrate the usage.", "createdAt": "2020-11-26T03:25:05Z", "url": "https://github.com/pravega/pravega/pull/5378", "merged": true, "mergeCommit": {"oid": "22996fc928d762f886265a3dee75157fac944357"}, "closed": true, "closedAt": "2020-11-30T09:45:09Z", "author": {"login": "ravisharda"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdf6wESgH2gAyNTI3Nzk3ODkxOjMwYmQ2YjJmNjY2MTE5MWYzOTgwZTEwZDE3MDE3MzI1ZDkwMjEzYzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdhgExxgH2gAyNTI3Nzk3ODkxOjI2ZjU5YzU0ZTIzNTdiZDgxZDg4NGYwNTZiNzE4MjZlZDQ2Njg1YWQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "30bd6b2f6661191f3980e10d17017325d90213c3", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/30bd6b2f6661191f3980e10d17017325d90213c3", "committedDate": "2020-11-25T09:15:53Z", "message": "Convert construction to builder\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c70e16dc7d8549e216436e235f27db7f71befc8", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/3c70e16dc7d8549e216436e235f27db7f71befc8", "committedDate": "2020-11-25T17:13:47Z", "message": "Implement TLS support\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a4ccf9af218cd0d753cbb028fd24534491ca6bd", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/3a4ccf9af218cd0d753cbb028fd24534491ca6bd", "committedDate": "2020-11-26T03:25:13Z", "message": "Merge branch 'master' into integration-tls-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4965e430dde91cd397ec7c596d73aca3de77f801", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/4965e430dde91cd397ec7c596d73aca3de77f801", "committedDate": "2020-11-26T03:50:50Z", "message": "Refine the implementation and the test\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0de92c1903dbcdf704659e60fef7cca95e65007d", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/0de92c1903dbcdf704659e60fef7cca95e65007d", "committedDate": "2020-11-26T03:51:01Z", "message": "Merge remote-tracking branch 'origin/integration-tls-support' into integration-tls-support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "committedDate": "2020-11-26T11:19:06Z", "message": "Merge branch 'master' into integration-tls-support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NDAyNTU5", "url": "https://github.com/pravega/pravega/pull/5378#pullrequestreview-539402559", "createdAt": "2020-11-26T15:21:23Z", "commit": {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNToyMToyM1rOH6foLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNToyNjowNVrOH6fy9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5NzY0NQ==", "bodyText": "It would be nice to add a single-sentence Javadoc to each of these explaining what they do. Others might find them useful in the future;", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531097645", "createdAt": "2020-11-26T15:21:23Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5ODg5Ng==", "bodyText": "This is very inefficient. If you call this in a tight loop, then this will take a long time (due to constant reinitialization). Can you have this method take another argument that indicates how many events to write? Even if you don't use it now, someone in the future might find that useful.\nPS: if you do that, no need to call .get() upon each .writeEvent. Collect the futures in a list, and use Futures.allOf(...).get().\nPS2: A timeout for that .get might be useful too to pass to this method. But your call.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531098896", "createdAt": "2020-11-26T15:23:38Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5OTQ1Mg==", "bodyText": "Same here. If you read just 1 message, this is OK. But as soon as you want to read more, then this method will be very slow.\nConsider taking a count argument and returning an (ordered) list of Strings representing the events.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531099452", "createdAt": "2020-11-26T15:24:30Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        writer.writeEvent(message1).get();\n+        log.info(\"Wrote a message to the stream {}/{}\", scope1, stream1);\n+    }\n+\n+    public static String readAMessageFromStream(String scopeName, String streamName, ClientConfig readerClientConfig,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMDA4OA==", "bodyText": "It may surprise you but on Travis, this timeout may not be sufficient. Expect this to be a root cause for random failures.\nIf the timeout expires, you won't get a TimeoutException; rather the getEvent() will return null, which will likely manifest as a NullPtrEx upstream.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531100088", "createdAt": "2020-11-26T15:25:34Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        writer.writeEvent(message1).get();\n+        log.info(\"Wrote a message to the stream {}/{}\", scope1, stream1);\n+    }\n+\n+    public static String readAMessageFromStream(String scopeName, String streamName, ClientConfig readerClientConfig,\n+                                                 String readerGroupName) {\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scopeName, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scopeName, streamName))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scopeName, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroupName, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroupName);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(\n+                \"readerId\", readerGroupName,\n+                new JavaSerializer<String>(), ReaderConfig.builder().initialAllocationDelay(0).build());\n+        log.debug(\"Created an event reader\");\n+\n+        // Keeping the read timeout large so that there is ample time for reading the event even in\n+        // case of abnormal delays in test environments.\n+        String readMessage = reader.readNextEvent(10000).getEvent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMDQwNQ==", "bodyText": "You already used SneakyThrows in this class. You might as well use it here too.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531100405", "createdAt": "2020-11-26T15:26:05Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        writer.writeEvent(message1).get();\n+        log.info(\"Wrote a message to the stream {}/{}\", scope1, stream1);\n+    }\n+\n+    public static String readAMessageFromStream(String scopeName, String streamName, ClientConfig readerClientConfig,\n+                                                 String readerGroupName) {\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scopeName, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scopeName, streamName))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scopeName, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroupName, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroupName);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(\n+                \"readerId\", readerGroupName,\n+                new JavaSerializer<String>(), ReaderConfig.builder().initialAllocationDelay(0).build());\n+        log.debug(\"Created an event reader\");\n+\n+        // Keeping the read timeout large so that there is ample time for reading the event even in\n+        // case of abnormal delays in test environments.\n+        String readMessage = reader.readNextEvent(10000).getEvent();\n+        log.info(\"Done reading event [{}]\", readMessage);\n+        return readMessage;\n+    }\n+\n+    public static List<PasswordAuthHandlerInput.Entry> preparePasswordInputFileEntries(\n+            Map<String, String> entries, String password) {\n+        StrongPasswordProcessor passwordProcessor = StrongPasswordProcessor.builder().build();\n+        try {\n+            String encryptedPassword = passwordProcessor.encryptPassword(password);\n+            List<PasswordAuthHandlerInput.Entry> result = new ArrayList<>();\n+            entries.forEach((k, v) -> result.add(PasswordAuthHandlerInput.Entry.of(k, encryptedPassword, v)));\n+            return result;\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/ded72b53028bd37f3e5ae4cbf4fa69787e1a897e", "committedDate": "2020-11-28T00:54:29Z", "message": "Address review comments and minor refactorings for reusability\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMzQxNTQw", "url": "https://github.com/pravega/pravega/pull/5378#pullrequestreview-540341540", "createdAt": "2020-11-28T04:18:23Z", "commit": {"oid": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDoxODoyM1rOH7NJFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDoxODoyM1rOH7NJFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg0MzM1MA==", "bodyText": "false is returned when the stream already exists.\nso in the idempotent case, do you want to throw the exception from here or return the boolean from this method signature to let the caller know so that they can deal with it.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531843350", "createdAt": "2020-11-28T04:18:23Z", "author": {"login": "shiveshr"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     */\n+    public static void createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scope);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streams.forEach(s -> {\n+            boolean isStreamCreated = streamManager.createStream(scope, s,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMzQxNjQ4", "url": "https://github.com/pravega/pravega/pull/5378#pullrequestreview-540341648", "createdAt": "2020-11-28T04:20:40Z", "commit": {"oid": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDoyMDo0MFrOH7NPoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDoyMDo0MFrOH7NPoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg0NTAyNQ==", "bodyText": "in case of a checkpoint event, you could get a null event.\ni think you should add event only when it is not a checkpoint event.\nor disable checkpoint in the readergroup config.\notherwise that can lead to some tests to fail.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531845025", "createdAt": "2020-11-28T04:20:40Z", "author": {"login": "shiveshr"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     */\n+    public static void createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scope);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streams.forEach(s -> {\n+            boolean isStreamCreated = streamManager.createStream(scope, s,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        List<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            futures.add(writer.writeEvent(message));\n+        }\n+        Futures.allOf(futures).join();\n+        log.info(\"Wrote {} message(s) to the stream {}/{}\", numMessages, scope, stream);\n+    }\n+\n+    /**\n+     * Returns the first message from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event message\n+     */\n+    public static String readAMessageFromStream(String scope, String stream, ClientConfig readerClientConfig,\n+                                                 String readerGroup) {\n+        List<String> messages = readDataFromStream(scope, stream, 1, readerClientConfig, readerGroup);\n+        if (messages == null || messages.size() == 0) {\n+            return null;\n+        } else {\n+            return messages.get(0);\n+        }\n+    }\n+\n+    /**\n+     * Returns the specified number of messages from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param numMessages the number of event messages to write\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event messages\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static List<String> readDataFromStream(@NonNull String scope, @NonNull String stream, int numMessages,\n+                                            @NonNull ClientConfig readerClientConfig, @NonNull String readerGroup) {\n+        Preconditions.checkArgument(numMessages > 0);\n+\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scope, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scope, stream))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scope, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroup, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroup);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(\n+                \"readerId\", readerGroup,\n+                new JavaSerializer<String>(), ReaderConfig.builder().initialAllocationDelay(0).build());\n+        log.debug(\"Created an event reader\");\n+\n+        // Keeping the read timeout large so that there is ample time for reading the event even in\n+        // case of abnormal delays in test environments.\n+        List<String> result = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            result.add(reader.readNextEvent(20000).getEvent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMzQxNjY3", "url": "https://github.com/pravega/pravega/pull/5378#pullrequestreview-540341667", "createdAt": "2020-11-28T04:21:18Z", "commit": {"oid": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4788434e05b3cafc4dfc7e2bb2c56112ab6ac2ef", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/4788434e05b3cafc4dfc7e2bb2c56112ab6ac2ef", "committedDate": "2020-11-28T05:16:22Z", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b910615c306dd84dece6c79537819b9d2931a064", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/b910615c306dd84dece6c79537819b9d2931a064", "committedDate": "2020-11-29T09:34:49Z", "message": "Merge branch 'master' into integration-tls-support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNTgxMTMz", "url": "https://github.com/pravega/pravega/pull/5378#pullrequestreview-540581133", "createdAt": "2020-11-30T03:40:09Z", "commit": {"oid": "b910615c306dd84dece6c79537819b9d2931a064"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMzo0MDowOVrOH7q9eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMzo0OTozMlrOH7rFDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzMTg5OA==", "bodyText": "we can simply use a writer.flush() here.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532331898", "createdAt": "2020-11-30T03:40:09Z", "author": {"login": "shrids"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     * @return whether all the objects (scope and each of the streams) were newly created. Returns {@code false}, if\n+     *         any of those objects were already present.\n+     */\n+    public static boolean createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean result = streamManager.createScope(scope);\n+        for (String stream: streams) {\n+            boolean isStreamCreated = streamManager.createStream(scope, stream,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            result = result && !isStreamCreated ? false : true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        List<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            futures.add(writer.writeEvent(message));\n+        }\n+        Futures.allOf(futures).join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b910615c306dd84dece6c79537819b9d2931a064"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzMzgzNw==", "bodyText": "Since the reader group is not deleted invoking readDataFromStream(..) again would cause the method to read the next events from the stream. So we should document this behaviour or perhaps invoke delete reader group or change the name of the method to convey this behaviour perhaps as readNextEvents(..)", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532333837", "createdAt": "2020-11-30T03:49:32Z", "author": {"login": "shrids"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     * @return whether all the objects (scope and each of the streams) were newly created. Returns {@code false}, if\n+     *         any of those objects were already present.\n+     */\n+    public static boolean createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean result = streamManager.createScope(scope);\n+        for (String stream: streams) {\n+            boolean isStreamCreated = streamManager.createStream(scope, stream,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            result = result && !isStreamCreated ? false : true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        List<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            futures.add(writer.writeEvent(message));\n+        }\n+        Futures.allOf(futures).join();\n+        log.info(\"Wrote {} message(s) to the stream {}/{}\", numMessages, scope, stream);\n+    }\n+\n+    /**\n+     * Returns the first message from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event message\n+     */\n+    public static String readAMessageFromStream(String scope, String stream, ClientConfig readerClientConfig,\n+                                                String readerGroup) {\n+        List<String> messages = readDataFromStream(scope, stream, 1, readerClientConfig, readerGroup);\n+        if (messages == null || messages.size() == 0) {\n+            return null;\n+        } else {\n+            return messages.get(0);\n+        }\n+    }\n+\n+    /**\n+     * Returns the specified number of messages from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param numMessages the number of event messages to write\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event messages\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static List<String> readDataFromStream(@NonNull String scope, @NonNull String stream, int numMessages,\n+                                                  @NonNull ClientConfig readerClientConfig, @NonNull String readerGroup) {\n+        Preconditions.checkArgument(numMessages > 0);\n+\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scope, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scope, stream))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scope, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroup, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroup);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b910615c306dd84dece6c79537819b9d2931a064"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd977c0ae127210e0300a10772f2bb9c9fbac082", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/cd977c0ae127210e0300a10772f2bb9c9fbac082", "committedDate": "2020-11-30T06:04:40Z", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "795d86d56d92d74c407e6c7efe857383ddd49606", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/795d86d56d92d74c407e6c7efe857383ddd49606", "committedDate": "2020-11-30T06:04:49Z", "message": "Merge remote-tracking branch 'origin/integration-tls-support' into integration-tls-support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNjIwMTUy", "url": "https://github.com/pravega/pravega/pull/5378#pullrequestreview-540620152", "createdAt": "2020-11-30T06:11:17Z", "commit": {"oid": "795d86d56d92d74c407e6c7efe857383ddd49606"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNjoxMToxN1rOH7tEWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNjoyMDoyMFrOH7tOnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2NjQyNA==", "bodyText": "typo.", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532366424", "createdAt": "2020-11-30T06:11:17Z", "author": {"login": "shrids"}, "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     * @return whether all the objects (scope and each of the streams) were newly created. Returns {@code false}, if\n+     *         any of those objects were already present.\n+     */\n+    public static boolean createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean result = streamManager.createScope(scope);\n+        for (String stream: streams) {\n+            boolean isStreamCreated = streamManager.createStream(scope, stream,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            result = result && !isStreamCreated ? false : true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        for (int i = 0; i < numMessages; i++) {\n+            writer.writeEvent(message);\n+        }\n+        writer.flush();\n+        log.info(\"Wrote {} message(s) to the stream {}/{}\", numMessages, scope, stream);\n+    }\n+\n+    /**\n+     * Returns the next unread message from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event message\n+     */\n+    public static String readNextEventMessage(String scope, String stream, ClientConfig readerClientConfig,\n+                                              String readerGroup) {\n+        List<String> messages = readNextEventMessages(scope, stream, 1, readerClientConfig, readerGroup);\n+        if (messages == null || messages.size() == 0) {\n+            return null;\n+        } else {\n+            return messages.get(0);\n+        }\n+    }\n+\n+    /**\n+     * Returns the specified number of unread messages from the given {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param numMessages the number of event messages to write", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d86d56d92d74c407e6c7efe857383ddd49606"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2ODA4NQ==", "bodyText": "new ClustuerWrapper() will ensure the defaults are not used. Should we make the default constructor private to enforce the builder pattern?", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532368085", "createdAt": "2020-11-30T06:17:18Z", "author": {"login": "shrids"}, "path": "test/integration/src/main/java/io/pravega/test/integration/demo/ClusterWrapper.java", "diffHunk": "@@ -65,52 +72,58 @@\n \n     private ServiceBuilder serviceBuilder;\n \n-    private ScheduledExecutorService executor;\n+    @Builder.Default\n+    private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n \n-    // Configuration\n-    private boolean isAuthEnabled;\n-    private String tokenSigningKeyBasis;\n-    private boolean isRGWritesWithReadPermEnabled;\n-    private int tokenTtlInSeconds;\n+    @Getter\n+    @Builder.Default\n+    private boolean authEnabled = false;\n+\n+    @Getter\n+    @Builder.Default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d86d56d92d74c407e6c7efe857383ddd49606"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2OTA1NQ==", "bodyText": "Does this @builder generate a seperate builder?", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532369055", "createdAt": "2020-11-30T06:20:20Z", "author": {"login": "shrids"}, "path": "test/integration/src/main/java/io/pravega/test/integration/demo/ControllerWrapper.java", "diffHunk": "@@ -102,6 +103,21 @@ public ControllerWrapper(final String connectionString, final boolean disableEve\n                              boolean enableAuth, String passwordAuthHandlerInputFilePath,\n                              String tokenSigningKey, boolean isRGWritesWithReadPermEnabled,\n                              int accessTokenTtlInSeconds) {\n+        this (connectionString, disableEventProcessor, disableControllerCluster, controllerPort, serviceHost,\n+                servicePort, containerCount, restPort, enableAuth, passwordAuthHandlerInputFilePath, tokenSigningKey,\n+                isRGWritesWithReadPermEnabled, accessTokenTtlInSeconds, false, \"\", \"\", \"\", \"\", false);\n+    }\n+\n+    @Builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d86d56d92d74c407e6c7efe857383ddd49606"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26f59c54e2357bd81d884f056b71826ed46685ad", "author": {"user": {"login": "ravisharda", "name": "Ravi Sharda"}}, "url": "https://github.com/pravega/pravega/commit/26f59c54e2357bd81d884f056b71826ed46685ad", "committedDate": "2020-11-30T07:18:55Z", "message": "Address review comments and remove an unnecessary config\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3766, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}