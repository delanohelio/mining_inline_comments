{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxODY2NjU3", "number": 5439, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMToyMjozNFrOFG6Txg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODowMDozNlrOFNWXKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzkxMTEwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/state/StateSynchronizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMToyMjozNFrOIIJTUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwNjo1MTowNFrOIIVLLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTkyMg==", "bodyText": "This is a public interface. If possible either add these to the impl and omit them here, or find an alternative way to obtain the information.\nIf they must be added here and made public:\n\nMake sure the names match our other public analogous apis. (IE I'm fairly sure the word \"synchronizer\" shouldn't be in there)\nThey will also need javadocs and tests.\nAdd fpj and sandeep as reviewers on the PR and tag it as an API change.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545411922", "createdAt": "2020-12-17T21:22:34Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/state/StateSynchronizer.java", "diffHunk": "@@ -45,6 +45,10 @@\n      */\n     StateT getState();\n \n+    String getSynchronizerScopeName();\n+\n+    String getSynchronizerStreamName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYwNjQ0NQ==", "bodyText": "These API's have been removed. They are not needed anymore.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545606445", "createdAt": "2020-12-18T06:51:04Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/state/StateSynchronizer.java", "diffHunk": "@@ -45,6 +45,10 @@\n      */\n     StateT getState();\n \n+    String getSynchronizerScopeName();\n+\n+    String getSynchronizerStreamName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTkyMg=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODE1NDA0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjozNDozNFrOIILfEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0NTo1OFrOIIfxug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0NzY5OA==", "bodyText": "This needs to be conditional.\nWe don't want to perform this update if:\na) It's already been completed.\nb) Another even newer config update has been completed.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545447698", "createdAt": "2020-12-17T22:34:34Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n         Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config), false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4MDE1NA==", "bodyText": "Its been made conditional.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545780154", "createdAt": "2020-12-18T11:45:58Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n         Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config), false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0NzY5OA=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODE1NDQ1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjozNDo0MFrOIILfRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxODowMDoyN1rOIQxORw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc1MQ==", "bodyText": "What if updatingConfig is already set to true?\nWhat happens in the following race:\nresetReadeGroup(a) - start\nresetReadeGroup(b) - start\nresetReadeGroup(b) - complete\nresetReadeGroup(a) - ???\nThere is no lock between here and the controller. So an order needs to be defined.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545447751", "createdAt": "2020-12-17T22:34:40Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYxMDA3Nw==", "bodyText": "that should not be a problem because the call to controller should include the generation and hence idempotent. So if RG(b) has already completed the call, RG(a) will simply repeat it with the generation that has already been included in controller.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545610077", "createdAt": "2020-12-18T07:02:34Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc1MQ=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTI2MQ==", "bodyText": "Initial config is version 0\nresetReadeGroup(a) - Sets flag to 'true'\na is assigned version 1 by the controller.\nresetReadeGroup(b)\nb is assigned version 2 by the controller.\na unsets the flag and updates the readergroupstate.\nb crashes.\nNow the controller thinks the version is 2 and the config is b. But the group says A and nobody considers the update ongoing.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546115261", "createdAt": "2020-12-18T22:12:23Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc1MQ=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIyNjkwNQ==", "bodyText": "pravega/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java\n    \n    \n         Line 207\n      in\n      3497a11\n    \n    \n    \n    \n\n        \n          \n           getThrowingException(controller.updateReaderGroup(scope, groupName, config)); \n        \n    \n  \n\n\ncontroller.updateReadergroup is conditional. it will reject the request from (b) if (a) has already incremented the generation to 1.\nand if rg finds the generation on controller ahead of generation in its local state, it should first complete the previously attempted reset and only then should it even attempt the new reset which is to call the controller again to increment the generation.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546226905", "createdAt": "2020-12-19T11:23:00Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc1MQ=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIzMTQ5OQ==", "bodyText": "Here is how resetReaderGroup() API on Client would look:\n\t1. ss.fetchUpdates();\n\t2. if (ss.updatingConfig==false) {\n\t  // this is a conditional update and so for 2 processes trying to do this update in parallel, only 1 will succeed.\n\t   2.1 val updateFlagResult = ss.updateState(ss.updatingConfig = true)\n\t   2.2 if (updateFlagResult == SUCCESS) {\n\t\t    set config.generation = ss.getConfig().generation;\n\t\t    set config.readerGroupId = ss.getConfig().readerGroupId;\n\t\t    val controllerUpdateResult = controller.updateRG(scope, rgName, config)\n\t\t    if (controllerUpdateResult == SUCCESS) {\n\t\t\t   ss.updateUnconditionally(config)\n\t\t    } \n\t\t    // we set ss.updatingConfig = false in the following cases:\n\t\t    // (i) If both update to controller and SS have succeeded\n\t\t    // (ii) update to Controller has failed, & we never tried updating SS and directly landed here\n\t\t    // (iii) in the catch block for `controller.updateRg()` call, so if it throws an exception, we again set back \"ss.updatingConfig = false\"\n\t\t    ss.updateState(ss.updatingConfig = false)\n\t     } \n\t     else {\n\t\t      // we're here because updateFlagResult==FAILED\n\t\t      // goto 1 \n\t         }\n\t} \n\telse {\n\t   // here updatingConfig==true \n\t  // goto 1 and keep retrying this reset in a while loop waiting for (updatingConfig == false) or bail out\n\t}\n}", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546231499", "createdAt": "2020-12-19T12:12:29Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc1MQ=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIzMzEyOA==", "bodyText": "Additionally, there would be a separate timer thread that would periodically check if config in SS matches with config on Controller and if it does not update SS with config copy from Controller.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546233128", "createdAt": "2020-12-19T12:30:13Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc1MQ=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1NDU5OQ==", "bodyText": "Implementing the pseudocode as described above.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554454599", "createdAt": "2021-01-09T18:00:27Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,12 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc1MQ=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODE3MTk2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjo0MDoxNlrOIILpQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNjoyOTo1NlrOIIp69Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1MDMwNw==", "bodyText": "Shouldn't this be fetchUpdatesIfNeeded()?", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545450307", "createdAt": "2020-12-17T22:40:16Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0NjM1Nw==", "bodyText": "Changed to use fetchUpdatesIfNeeded().", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545946357", "createdAt": "2020-12-18T16:29:56Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1MDMwNw=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODE4MTE4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjo0MzoxM1rOIILutw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwNjo0MToxNFrOIIU9HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1MTcwMw==", "bodyText": "Be more specific this won't actually help anyone debug a problem if there is one.\nWhich reader group? What config? Is an update actually being performed?", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545451703", "createdAt": "2020-12-17T22:43:13Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();\n+        ReaderGroupState state = sync.getState();\n+        if (!updateConfigTimer.hasRemaining() && state.isUpdatingConfig()) {\n+            log.debug(\"Update the group config\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYwMjg0NA==", "bodyText": "Made the debug statement more informative.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545602844", "createdAt": "2020-12-18T06:41:14Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();\n+        ReaderGroupState state = sync.getState();\n+        if (!updateConfigTimer.hasRemaining() && state.isUpdatingConfig()) {\n+            log.debug(\"Update the group config\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1MTcwMw=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODE4Njk2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjo0NTowM1rOIILyIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwNjo0MDowNFrOIIU7tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1MjU3Ng==", "bodyText": "This precludes cross scope reading, which is an important feature.\nDon't make assumptions about the scope and stream name here. Explicitly obtain them from the state. (Or add them as member variables to this class)", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545452576", "createdAt": "2020-12-17T22:45:03Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();\n+        ReaderGroupState state = sync.getState();\n+        if (!updateConfigTimer.hasRemaining() && state.isUpdatingConfig()) {\n+            log.debug(\"Update the group config\");\n+            ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(sync.getSynchronizerScopeName(),\n+                    sync.getSynchronizerStreamName().replace(READER_GROUP_STREAM_PREFIX, \"\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYwMjQ4NA==", "bodyText": "The scope name and readergroup name are required to make the controller call. Instead of obtaining it from the sync these are now part of the ReaderGroupStateManager. This means we wouldn't need those StateSynchronizer API's too.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545602484", "createdAt": "2020-12-18T06:40:04Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();\n+        ReaderGroupState state = sync.getState();\n+        if (!updateConfigTimer.hasRemaining() && state.isUpdatingConfig()) {\n+            log.debug(\"Update the group config\");\n+            ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(sync.getSynchronizerScopeName(),\n+                    sync.getSynchronizerStreamName().replace(READER_GROUP_STREAM_PREFIX, \"\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1MjU3Ng=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODE5NjUzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjo0ODoxN1rOIIL3lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwNjozNDowMlrOIIU0Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1Mzk3NA==", "bodyText": "This only resets the timer if a config update was actually performed. However the goal of the timer was to minimise work on a per-event bais. This prevents that because the timer will almost never be not expired if the config updates rarely.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545453974", "createdAt": "2020-12-17T22:48:17Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();\n+        ReaderGroupState state = sync.getState();\n+        if (!updateConfigTimer.hasRemaining() && state.isUpdatingConfig()) {\n+            log.debug(\"Update the group config\");\n+            ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(sync.getSynchronizerScopeName(),\n+                    sync.getSynchronizerStreamName().replace(READER_GROUP_STREAM_PREFIX, \"\")));\n+            if (state.getConfig().getGeneration() < controllerConfig.getGeneration()) {\n+                Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, controllerConfig);\n+                sync.updateStateUnconditionally(new ReaderGroupState.ReaderGroupStateInit(controllerConfig, segments, getEndSegmentsForStreams(controllerConfig), false));\n+            }\n+            updateConfigTimer.reset(UPDATE_CONFIG_WINDOW);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYwMDYxNA==", "bodyText": "As you mentioned it would only reset if an update was done. I've separated the timer check and the updatingConfig check. So irrespective of whether the update happens or not the timer will reset itself when there is no time remaining.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545600614", "createdAt": "2020-12-18T06:34:02Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +337,21 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        sync.fetchUpdates();\n+        ReaderGroupState state = sync.getState();\n+        if (!updateConfigTimer.hasRemaining() && state.isUpdatingConfig()) {\n+            log.debug(\"Update the group config\");\n+            ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(sync.getSynchronizerScopeName(),\n+                    sync.getSynchronizerStreamName().replace(READER_GROUP_STREAM_PREFIX, \"\")));\n+            if (state.getConfig().getGeneration() < controllerConfig.getGeneration()) {\n+                Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, controllerConfig);\n+                sync.updateStateUnconditionally(new ReaderGroupState.ReaderGroupStateInit(controllerConfig, segments, getEndSegmentsForStreams(controllerConfig), false));\n+            }\n+            updateConfigTimer.reset(UPDATE_CONFIG_WINDOW);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ1Mzk3NA=="}, "originalCommit": {"oid": "3497a1129e78ecbea223ed579f631d116036eabd"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTMwOTc4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwNzowNDo1MVrOIIVb6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDozODo0NFrOIIdugQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYxMDcyOQ==", "bodyText": "the problem really is \"after\" the call to controller when this code is calling synchronizer.updateState(RGStateInit).\nif RG(b) has already successfully reset, then (a) should not be repeating it, rather exit.\nso instead of blindly resetting here, we should actually check if a reset with our desired generation has already completed or not.. and if not, then we should reset, else exit.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545610729", "createdAt": "2020-12-18T07:04:51Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,14 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n         Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b6fb5ec8d2550e19b451f920f48116eea80a1a0"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0NjU2MQ==", "bodyText": "Implementing the logic as described here.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r545746561", "createdAt": "2020-12-18T10:38:44Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +201,14 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n         Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        synchronizer.updateState((state, updates) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYxMDcyOQ=="}, "originalCommit": {"oid": "0b6fb5ec8d2550e19b451f920f48116eea80a1a0"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjYwNDA0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/ReaderGroup.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMTo1NzozNVrOIIz6KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMTozMDo1NFrOIJVNcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEwOTk5Mw==", "bodyText": "This is a new public facing API and more importantly a whole new concept. How is this different from the group name? Why would a user need to call this method?\nIf it only exists because we need it, it shouldn't go here, but instead on the impl or an internal interface.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546109993", "createdAt": "2020-12-18T21:57:35Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/ReaderGroup.java", "diffHunk": "@@ -47,7 +48,14 @@\n      * @return Reader group name\n      */\n     String getGroupName();\n-    \n+\n+    /**\n+     * Returns the UUID of the group.\n+     *\n+     * @return Reader group UUID.\n+     */\n+    UUID getGroupId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMzE5Mg==", "bodyText": "There is no reason for us to expose this on the interface. also why should we use a UUID for differentiating between different iterations of RGs with the same name.\nSecondly, i am wondering if we should even have a UUID. couldnt we just use the StartingSegmentNumber on the RG stream which effectively uniquely identifies the iteration of the group.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546213192", "createdAt": "2020-12-19T08:55:35Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/ReaderGroup.java", "diffHunk": "@@ -47,7 +48,14 @@\n      * @return Reader group name\n      */\n     String getGroupName();\n-    \n+\n+    /**\n+     * Returns the UUID of the group.\n+     *\n+     * @return Reader group UUID.\n+     */\n+    UUID getGroupId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEwOTk5Mw=="}, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1NTYwMw==", "bodyText": "This method has been moved to the impl instead. It wouldn't make sense to a user so removed it from the API.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546655603", "createdAt": "2020-12-21T11:30:54Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/ReaderGroup.java", "diffHunk": "@@ -47,7 +48,14 @@\n      * @return Reader group name\n      */\n     String getGroupName();\n-    \n+\n+    /**\n+     * Returns the UUID of the group.\n+     *\n+     * @return Reader group UUID.\n+     */\n+    UUID getGroupId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEwOTk5Mw=="}, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjYxMTkxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjowMTowMlrOIIz-3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxNzo1ODoxNVrOIQxMUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMTE5Nw==", "bodyText": "Why is this call needed? Can it be combined with the previous one? (IE have it return this value)", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546111197", "createdAt": "2020-12-18T22:01:02Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +208,17 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+        ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxNjUxNg==", "bodyText": "yes, i think there is a github issue to address this.\nideally updateRG should return the generation number itself but it presently returns a boolean.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546216516", "createdAt": "2020-12-19T09:30:05Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +208,17 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+        ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMTE5Nw=="}, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1NDA5Ng==", "bodyText": "The updateRG now returns the generation number which is used to update the state too.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554454096", "createdAt": "2021-01-09T17:58:15Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +208,17 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+        ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMTE5Nw=="}, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjYyNzA2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjowNjo0NVrOII0Hmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwNDo0NDowMVrOINlboA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMzQzNQ==", "bodyText": "shouldn't it be using controllerConfig here?\nAlso, if so, then a unit test is missing.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546113435", "createdAt": "2020-12-18T22:06:45Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +208,17 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+        ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));\n         Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        synchronizer.updateState((state, updates) -> {\n+            if (state.getConfig().getGeneration() < controllerConfig.getGeneration()) {\n+                new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTExNTY4MA==", "bodyText": "This logic has been changed to make sure to account for the case you mentioned below", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551115680", "createdAt": "2021-01-04T04:44:01Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +208,17 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+        ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));\n         Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        synchronizer.updateState((state, updates) -> {\n+            if (state.getConfig().getGeneration() < controllerConfig.getGeneration()) {\n+                new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExMzQzNQ=="}, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjYzOTg3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjoxMzowNVrOII0PiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjoxMzowNVrOII0PiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTQ2NA==", "bodyText": "If the config generation is older it should still disable the flag.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r546115464", "createdAt": "2020-12-18T22:13:05Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -200,8 +208,17 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n+        synchronizer.updateState((state, updates) -> {\n+            updates.add(new UpdatingConfig(true));\n+        });\n+        getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+        ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));\n         Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        synchronizer.updateState((state, updates) -> {\n+            if (state.getConfig().getGeneration() < controllerConfig.getGeneration()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfd9c48a16fead4eb76daa1f402908fc8e13e5bb"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTcxNzAxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/ReaderGroupConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMzozNjoyNFrOIOE7aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMDoxMjoyNlrOIORatw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzMTcyMw==", "bodyText": "This is a public facing object and is immutable. I see no reason to change that.\nhttps://github.com/pravega/pravega/wiki/Contributing#threading", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551631723", "createdAt": "2021-01-04T23:36:24Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/ReaderGroupConfig.java", "diffHunk": "@@ -53,9 +54,11 @@\n \n     private final StreamDataRetention retentionType;\n \n-    private final long generation;\n+    @Setter\n+    private long generation;\n \n-    private final UUID readerGroupId;\n+    @Setter\n+    private UUID readerGroupId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzNjM0Mw==", "bodyText": "Removed the Setters", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551836343", "createdAt": "2021-01-05T10:12:26Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/ReaderGroupConfig.java", "diffHunk": "@@ -53,9 +54,11 @@\n \n     private final StreamDataRetention retentionType;\n \n-    private final long generation;\n+    @Setter\n+    private long generation;\n \n-    private final UUID readerGroupId;\n+    @Setter\n+    private UUID readerGroupId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzMTcyMw=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTczMDU5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMzozOTo1MVrOIOFEXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwOTo0MjowN1rOIO4EaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNDAxNQ==", "bodyText": "It's strange that this calls fetchUpdates. This is a blocking remote call. This is a getter so it's confusing. It is also not clear when the readerGroupId would change and what consistency is attempting to be enforced by updating first.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551634015", "createdAt": "2021-01-04T23:39:51Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -117,6 +119,16 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n                synchronizer.getState().getConfig().getRetentionType().toString());\n     }\n \n+    public UUID getGroupId() {\n+        synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ2OTYwOA==", "bodyText": "Here we do not need to call fetchUpdates for consistency as the groupId never changes.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r552469608", "createdAt": "2021-01-06T09:42:07Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -117,6 +119,16 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n                synchronizer.getState().getConfig().getRetentionType().toString());\n     }\n \n+    public UUID getGroupId() {\n+        synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNDAxNQ=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTczMTAzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMzozOTo1OVrOIOFEmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxNDo1Mzo0N1rOIQ4yig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNDA3NQ==", "bodyText": "Same here.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551634075", "createdAt": "2021-01-04T23:39:59Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -117,6 +119,16 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n                synchronizer.getState().getConfig().getRetentionType().toString());\n     }\n \n+    public UUID getGroupId() {\n+        synchronizer.fetchUpdates();\n+        return synchronizer.getState().getConfig().getReaderGroupId();\n+    }\n+\n+    public long getGeneration() {\n+        synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMyMjY4Mw==", "bodyText": "Removed fetchUpdates from here.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553322683", "createdAt": "2021-01-07T13:21:20Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -117,6 +119,16 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n                synchronizer.getState().getConfig().getRetentionType().toString());\n     }\n \n+    public UUID getGroupId() {\n+        synchronizer.fetchUpdates();\n+        return synchronizer.getState().getConfig().getReaderGroupId();\n+    }\n+\n+    public long getGeneration() {\n+        synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNDA3NQ=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIxMjYxNQ==", "bodyText": "I don't see a change. Was it pushed?", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554212615", "createdAt": "2021-01-08T21:53:06Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -117,6 +119,16 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n                synchronizer.getState().getConfig().getRetentionType().toString());\n     }\n \n+    public UUID getGroupId() {\n+        synchronizer.fetchUpdates();\n+        return synchronizer.getState().getConfig().getReaderGroupId();\n+    }\n+\n+    public long getGeneration() {\n+        synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNDA3NQ=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU3ODU3MA==", "bodyText": "When calling deleteReaderGroup on the controller end we need to pass the generation and readergroupID for which we need their latest versions, hence the fetchUpdates. I had initially thought to get the ReaderGroup and then use Impl methods to get these values as I have done above. However, since these getters for the generation and groupID are only being called at one place (in deleteReaderGroup) instead of getting the ReaderGroupImpl I make the StateSynchronizer, call fetchUpdates once and then access the latest versions of generation and groupID.\nLike so: https://github.com/anirudhkovuru/pravega/blob/00a655d3dab31bd219c2e117c7f0e36b5b11f0b5/client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java#L103-L112", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554578570", "createdAt": "2021-01-10T14:53:47Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -117,6 +119,16 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n                synchronizer.getState().getConfig().getRetentionType().toString());\n     }\n \n+    public UUID getGroupId() {\n+        synchronizer.fetchUpdates();\n+        return synchronizer.getState().getConfig().getReaderGroupId();\n+    }\n+\n+    public long getGeneration() {\n+        synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNDA3NQ=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTczOTY4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMzo0NDoxNVrOIOFJlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNToxNTowNlrOIOyM_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNTM1MA==", "bodyText": "You can use a local", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551635350", "createdAt": "2021-01-04T23:44:15Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +215,39 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                config.setGeneration(state.getConfig().getGeneration());\n+                config.setReaderGroupId(state.getConfig().getReaderGroupId());\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config), false));\n+                    });\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean stateTransition(ReaderGroupState state, ReaderGroupState.ReaderGroupStateUpdate update) {\n+        // This boolean will help know if the update actually succeeds or not.\n+        AtomicBoolean successfullyUpdated = new AtomicBoolean(true);\n+        synchronizer.updateState((s, updates) -> {\n+            // If successfullyUpdated is false then that means the current state where this update should\n+            // take place (i.e. state with updatingConfig as false) is not the state we are in so we do not\n+            // make the update.\n+            successfullyUpdated.set(s.getConfig().equals(state.getConfig()));\n+            if (successfullyUpdated.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3MzUwMw==", "bodyText": "Using local as suggested.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r552373503", "createdAt": "2021-01-06T05:15:06Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +215,39 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                config.setGeneration(state.getConfig().getGeneration());\n+                config.setReaderGroupId(state.getConfig().getReaderGroupId());\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, config));\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config), false));\n+                    });\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean stateTransition(ReaderGroupState state, ReaderGroupState.ReaderGroupStateUpdate update) {\n+        // This boolean will help know if the update actually succeeds or not.\n+        AtomicBoolean successfullyUpdated = new AtomicBoolean(true);\n+        synchronizer.updateState((s, updates) -> {\n+            // If successfullyUpdated is false then that means the current state where this update should\n+            // take place (i.e. state with updatingConfig as false) is not the state we are in so we do not\n+            // make the update.\n+            successfullyUpdated.set(s.getConfig().equals(state.getConfig()));\n+            if (successfullyUpdated.get()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNTM1MA=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTc0MTQ2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMzo0NToxNFrOIOFKqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMDoxMjowNVrOIORZ8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNTYyNw==", "bodyText": "I think what you want here is a way to create a builder from an existing config.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551635627", "createdAt": "2021-01-04T23:45:14Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +215,39 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                config.setGeneration(state.getConfig().getGeneration());\n+                config.setReaderGroupId(state.getConfig().getReaderGroupId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzNjE0NQ==", "bodyText": "Using toBuilder in the Builder annotation instead of setters.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551836145", "createdAt": "2021-01-05T10:12:05Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +215,39 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                config.setGeneration(state.getConfig().getGeneration());\n+                config.setReaderGroupId(state.getConfig().getReaderGroupId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNTYyNw=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTc1MTMwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMzo0OTozOVrOIOFQJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMDozNDozOVrOIOSH8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNzAzMA==", "bodyText": "This is making multiple calls to the controller inside of the updateState function. This doesn't work well for optimistic concurrency. Perhaps most this outside of the update state, and just rely on the if to make the update conditional on the config not having changed.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551637030", "createdAt": "2021-01-04T23:49:39Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +342,24 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        if (!updateConfigTimer.hasRemaining()) {\n+            fetchUpdatesIfNeeded();\n+            ReaderGroupState state = sync.getState();\n+            if (state.isUpdatingConfig()) {\n+                sync.updateState((s, updates) -> {\n+                    ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));\n+                    log.debug(\"Updating the readergroup {} with the new config {} obtained from the controller\", groupName, controllerConfig);\n+                    if (s.getConfig().getGeneration() < controllerConfig.getGeneration()) {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, controllerConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg0NzkyMQ==", "bodyText": "Moved the controller calls outside the update state.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551847921", "createdAt": "2021-01-05T10:34:39Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +342,24 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        if (!updateConfigTimer.hasRemaining()) {\n+            fetchUpdatesIfNeeded();\n+            ReaderGroupState state = sync.getState();\n+            if (state.isUpdatingConfig()) {\n+                sync.updateState((s, updates) -> {\n+                    ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));\n+                    log.debug(\"Updating the readergroup {} with the new config {} obtained from the controller\", groupName, controllerConfig);\n+                    if (s.getConfig().getGeneration() < controllerConfig.getGeneration()) {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, controllerConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNzAzMA=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTc1MTY4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMzo0OTo1MlrOIOFQZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMDozNDo1N1rOIOSIeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNzA5Mg==", "bodyText": "Same here. (see below)", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551637092", "createdAt": "2021-01-04T23:49:52Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +342,24 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        if (!updateConfigTimer.hasRemaining()) {\n+            fetchUpdatesIfNeeded();\n+            ReaderGroupState state = sync.getState();\n+            if (state.isUpdatingConfig()) {\n+                sync.updateState((s, updates) -> {\n+                    ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg0ODA1OA==", "bodyText": "Moved them outside", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r551848058", "createdAt": "2021-01-05T10:34:57Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -330,6 +342,24 @@ private void fetchUpdatesIfNeeded() {\n             compactIfNeeded();\n         }\n     }\n+\n+    void updateConfigIfNeeded() {\n+        if (!updateConfigTimer.hasRemaining()) {\n+            fetchUpdatesIfNeeded();\n+            ReaderGroupState state = sync.getState();\n+            if (state.isUpdatingConfig()) {\n+                sync.updateState((s, updates) -> {\n+                    ReaderGroupConfig controllerConfig = getThrowingException(controller.getReaderGroupConfig(scope, groupName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzNzA5Mg=="}, "originalCommit": {"oid": "50cc856212b3aebed41879a344ec861ce949ace5"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDQ4Nzg5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjozODo0MFrOIPYclw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNjo1NzoxNFrOIPhFwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMDA4Nw==", "bodyText": "State is only used for config. So make the parameter 'config' instead. This would also minorly simplify the caller.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553000087", "createdAt": "2021-01-06T22:38:40Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(state.getConfig().getReaderGroupId())\n+                        .generation(state.getConfig().getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(newConfig), false));\n+                    });\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean stateTransition(ReaderGroupState state, ReaderGroupState.ReaderGroupStateUpdate update) {\n+        // This boolean will help know if the update actually succeeds or not.\n+        AtomicBoolean successfullyUpdated = new AtomicBoolean(true);\n+        synchronizer.updateState((s, updates) -> {\n+            // If successfullyUpdated is false then that means the current state where this update should\n+            // take place (i.e. state with updatingConfig as false) is not the state we are in so we do not\n+            // make the update.\n+            boolean updated = s.getConfig().equals(state.getConfig());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0MTY5OA==", "bodyText": "Using config instead.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553141698", "createdAt": "2021-01-07T06:57:14Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(state.getConfig().getReaderGroupId())\n+                        .generation(state.getConfig().getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(newConfig), false));\n+                    });\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean stateTransition(ReaderGroupState state, ReaderGroupState.ReaderGroupStateUpdate update) {\n+        // This boolean will help know if the update actually succeeds or not.\n+        AtomicBoolean successfullyUpdated = new AtomicBoolean(true);\n+        synchronizer.updateState((s, updates) -> {\n+            // If successfullyUpdated is false then that means the current state where this update should\n+            // take place (i.e. state with updatingConfig as false) is not the state we are in so we do not\n+            // make the update.\n+            boolean updated = s.getConfig().equals(state.getConfig());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMDA4Nw=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDQ5MjIxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo0MDo0MVrOIPYfKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxNzo1NjoyMFrOIQxLXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMDc0Nw==", "bodyText": "The update function in stateTransition will do this.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553000747", "createdAt": "2021-01-06T22:40:41Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEwODUwMw==", "bodyText": "The while loop in resetReaderGroup is so that we can retry in case the stateTransition fails.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553108503", "createdAt": "2021-01-07T04:54:38Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMDc0Nw=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU1MjA0OA==", "bodyText": "I think you misunderstand:\nCalling update on a state synchronizer will be retried can cause the update function to be re-run if it is not up to date. So it is not necessary to call fetchUpdates between calls to update in a loop because by definition the state will be up to date. That is the contract of the update function. So you can simply remove the fetchUpdates call.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553552048", "createdAt": "2021-01-07T19:49:38Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMDc0Nw=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1Mzg1Mw==", "bodyText": "I've moved the synchronizer.fetchUpdates to outside the while loop so its called once before the while loop. Then within the while loop update will allow for the state to be up to date.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554453853", "createdAt": "2021-01-09T17:56:20Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMDc0Nw=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDQ5ODc3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo0Mzo0NFrOIPYjHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNjo1NzoyN1rOIPhGCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMTc1OQ==", "bodyText": "getSegmentsForStreams is making an RPC to the controller. Please move this out of the updateState block.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553001759", "createdAt": "2021-01-06T22:43:44Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(state.getConfig().getReaderGroupId())\n+                        .generation(state.getConfig().getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0MTc2OQ==", "bodyText": "Moved out.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553141769", "createdAt": "2021-01-07T06:57:27Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(state.getConfig().getReaderGroupId())\n+                        .generation(state.getConfig().getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMTc1OQ=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDQ5OTg1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo0NDowOVrOIPYjtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxNzo0Mjo1OFrOIQxGJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMTkxMQ==", "bodyText": "Doesn't the generation need to change somewhere?", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553001911", "createdAt": "2021-01-06T22:44:09Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(state.getConfig().getReaderGroupId())\n+                        .generation(state.getConfig().getGeneration()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzExODA3MA==", "bodyText": "The generation is updated on the controller. We update the config's generation on to the controller using the periodic update that we have on the ReaderGroupStateManager.\nhttps://github.com/anirudhkovuru/pravega/blob/c4c85c732154321d1e598018f6ba4c5de1ee727b/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java#L346-L362", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553118070", "createdAt": "2021-01-07T05:34:10Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(state.getConfig().getReaderGroupId())\n+                        .generation(state.getConfig().getGeneration()).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMTkxMQ=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1MjUxNg==", "bodyText": "The generation that is written into the StateSynchronizer is the one returned after controller.updateReaderGroup has been called.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554452516", "createdAt": "2021-01-09T17:42:58Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val state = synchronizer.getState();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(state, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(state.getConfig().getReaderGroupId())\n+                        .generation(state.getConfig().getGeneration()).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMTkxMQ=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDUxNDY3OnYy", "diffSide": "RIGHT", "path": "test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndReaderGroupTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo1MDo0NlrOIPYsTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNjowMToyMVrOIS2i2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNDEwOA==", "bodyText": "For these tests, can we also add an assertion that advancing the reader group will correctly result in data being truncated?", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553004108", "createdAt": "2021-01-06T22:50:46Z", "author": {"login": "tkaitchuck"}, "path": "test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndReaderGroupTest.java", "diffHunk": "@@ -153,6 +156,92 @@ public void testDeleteReaderGroup() throws Exception {\n         assertEquals(\"data1\", eventRead.getEvent());\n     }\n \n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjYzODkzNg==", "bodyText": "Added tests for the case.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r556638936", "createdAt": "2021-01-13T16:01:21Z", "author": {"login": "anirudhkovuru"}, "path": "test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndReaderGroupTest.java", "diffHunk": "@@ -153,6 +156,92 @@ public void testDeleteReaderGroup() throws Exception {\n         assertEquals(\"data1\", eventRead.getEvent());\n     }\n \n+    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNDEwOA=="}, "originalCommit": {"oid": "c4c85c732154321d1e598018f6ba4c5de1ee727b"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MjI0NDc0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMTowODozMlrOIPobwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMzoxNDoxMFrOIPr6_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI2MjAxNw==", "bodyText": "getSegmentsForStreams  should be inside the if (success) block since it is not needed if controller.updateReaderGroup() has failed.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553262017", "createdAt": "2021-01-07T11:08:32Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val currentConfig = synchronizer.getState().getConfig();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(currentConfig, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(currentConfig.getReaderGroupId())\n+                        .generation(currentConfig.getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1df2d67b294499e21d6ad2090b985bc0418034"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMxOTE2Ng==", "bodyText": "It is inside the if block", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553319166", "createdAt": "2021-01-07T13:14:10Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val currentConfig = synchronizer.getState().getConfig();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(currentConfig, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(currentConfig.getReaderGroupId())\n+                        .generation(currentConfig.getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI2MjAxNw=="}, "originalCommit": {"oid": "6d1df2d67b294499e21d6ad2090b985bc0418034"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MjI3MDQ4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMToxNzowMFrOIPorGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjoxNjoxOFrOIQYEBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI2NTk0NA==", "bodyText": "I don't see equals() and hashcode() overridden in ReaderGroupConfig, so this would do a reference comparison. That does not look right to me.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553265944", "createdAt": "2021-01-07T11:17:00Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val currentConfig = synchronizer.getState().getConfig();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(currentConfig, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(currentConfig.getReaderGroupId())\n+                        .generation(currentConfig.getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(newConfig), false));\n+                    });\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean stateTransition(ReaderGroupConfig config, ReaderGroupState.ReaderGroupStateUpdate update) {\n+        // This boolean will help know if the update actually succeeds or not.\n+        AtomicBoolean successfullyUpdated = new AtomicBoolean(true);\n+        synchronizer.updateState((state, updates) -> {\n+            // If successfullyUpdated is false then that means the current state where this update should\n+            // take place (i.e. state with updatingConfig as false) is not the state we are in so we do not\n+            // make the update.\n+            boolean updated = state.getConfig().equals(config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1df2d67b294499e21d6ad2090b985bc0418034"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA0MjM3NQ==", "bodyText": "Since ReaderGroupConfig has Lombok annotation @DaTa that takes care of implementing equals and hashcode", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554042375", "createdAt": "2021-01-08T16:16:18Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +214,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val currentConfig = synchronizer.getState().getConfig();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(currentConfig, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(currentConfig.getReaderGroupId())\n+                        .generation(currentConfig.getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);\n+                if (success) {\n+                    synchronizer.updateState((s, updates) -> {\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(newConfig), false));\n+                    });\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean stateTransition(ReaderGroupConfig config, ReaderGroupState.ReaderGroupStateUpdate update) {\n+        // This boolean will help know if the update actually succeeds or not.\n+        AtomicBoolean successfullyUpdated = new AtomicBoolean(true);\n+        synchronizer.updateState((state, updates) -> {\n+            // If successfullyUpdated is false then that means the current state where this update should\n+            // take place (i.e. state with updatingConfig as false) is not the state we are in so we do not\n+            // make the update.\n+            boolean updated = state.getConfig().equals(config);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI2NTk0NA=="}, "originalCommit": {"oid": "6d1df2d67b294499e21d6ad2090b985bc0418034"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDI4MjExOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMDo0NzoxMFrOIP7xnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMDo0NzoxMFrOIP7xnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU3ODkwOA==", "bodyText": "This should not be public. The fact that there is a state synchronizer internal to this class should not be known to the caller. Otherwise it violates encapsulation.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553578908", "createdAt": "2021-01-07T20:47:10Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -117,6 +119,18 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n                synchronizer.getState().getConfig().getRetentionType().toString());\n     }\n \n+    public void fetchUpdates() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfb7b5c09a4bc8db223b4df481350235e493218"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDg4NDY3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMDozMzoxOVrOIQBdfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxNzozNzo1N1rOIQxETQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY3MjA2MA==", "bodyText": "This is storing config which was passed as a parameter. It does not appear to have a generation set on it.\nWhat I see happening now is that resetReaderGroup is called with a config provided by the user. Presumably they don't set the generation. (Should that method be private?) So the default value of -1 is passed. The call ends up here and it passes the config into the state init. But in updateConfigIfNeeded it pulls from the controller which updates the generation id every time. So it will always return a new config. Thus we end up reinitializing the group state twice.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r553672060", "createdAt": "2021-01-08T00:33:19Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +217,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val currentConfig = synchronizer.getState().getConfig();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(currentConfig, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(currentConfig.getReaderGroupId())\n+                        .generation(currentConfig.getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                if (success) {\n+                    Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);\n+                    synchronizer.updateState((s, updates) -> {\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(newConfig), false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfb7b5c09a4bc8db223b4df481350235e493218"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI4OTAyOA==", "bodyText": "controller.updateReaderGroup now returns the updated generation( See PR: #5462), which should be written to StateSynchronizer, but I don't see that happening here.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554289028", "createdAt": "2021-01-09T04:25:28Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +217,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val currentConfig = synchronizer.getState().getConfig();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(currentConfig, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(currentConfig.getReaderGroupId())\n+                        .generation(currentConfig.getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                if (success) {\n+                    Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);\n+                    synchronizer.updateState((s, updates) -> {\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(newConfig), false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY3MjA2MA=="}, "originalCommit": {"oid": "3bfb7b5c09a4bc8db223b4df481350235e493218"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1MjA0NQ==", "bodyText": "I have made it such that the updated generation is returned. That generation is what is written into the StateSynchronizer.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r554452045", "createdAt": "2021-01-09T17:37:57Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -203,8 +217,41 @@ private Checkpoint completeCheckpoint(String checkpointName) {\n \n     @Override\n     public void resetReaderGroup(ReaderGroupConfig config) {\n-        Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, config);\n-        synchronizer.updateStateUnconditionally(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(config)));\n+        while (true) {\n+            synchronizer.fetchUpdates();\n+            val currentConfig = synchronizer.getState().getConfig();\n+            // We only move into the block if the state transition has happened successfully.\n+            if (stateTransition(currentConfig, new UpdatingConfig(true))) {\n+                // Use the latest generation and reader group Id.\n+                ReaderGroupConfig newConfig = config.toBuilder()\n+                        .readerGroupId(currentConfig.getReaderGroupId())\n+                        .generation(currentConfig.getGeneration()).build();\n+                boolean success = Futures.getThrowingException(controller.updateReaderGroup(scope, groupName, newConfig));\n+                if (success) {\n+                    Map<SegmentWithRange, Long> segments = getSegmentsForStreams(controller, newConfig);\n+                    synchronizer.updateState((s, updates) -> {\n+                        updates.add(new ReaderGroupStateInit(config, segments, getEndSegmentsForStreams(newConfig), false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY3MjA2MA=="}, "originalCommit": {"oid": "3bfb7b5c09a4bc8db223b4df481350235e493218"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTQyMTg0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODowMDozNlrOIRhCRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxNjowMDo0M1rOIS2hHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzNzk1OQ==", "bodyText": "Javadoc needs to be updated.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r555237959", "createdAt": "2021-01-11T18:00:36Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -141,7 +141,7 @@\n      * @return A future which will throw if the operation fails, otherwise returning a boolean to\n      *         indicate that the subscriber was updated in Stream Metadata.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf326a15e459236d5c0db0313c0b84e757cf640"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjYzODQ5Mw==", "bodyText": "Javadoc is updated accordingly.", "url": "https://github.com/pravega/pravega/pull/5439#discussion_r556638493", "createdAt": "2021-01-13T16:00:43Z", "author": {"login": "anirudhkovuru"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -141,7 +141,7 @@\n      * @return A future which will throw if the operation fails, otherwise returning a boolean to\n      *         indicate that the subscriber was updated in Stream Metadata.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIzNzk1OQ=="}, "originalCommit": {"oid": "7cf326a15e459236d5c0db0313c0b84e757cf640"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4626, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}