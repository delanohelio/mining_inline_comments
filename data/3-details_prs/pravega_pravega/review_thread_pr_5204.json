{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MzkwMjc5", "number": 5204, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDo0NjowMVrOEoBhUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoyNjo1N1rOEzkovg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDAzNDEwOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDo0NjowMVrOHY4PIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDo1NTo0NVrOHY4hpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0OTI1MQ==", "bodyText": "do you need to add a subscriber asynchronously? that can be done inline for the call as it should be a single metadata update -- a new subscriber id as a record in some table, right?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r495849251", "createdAt": "2020-09-28T10:46:01Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "diffHunk": "@@ -156,6 +158,8 @@ public ControllerEventProcessors(final String host,\n                 new SealStreamTask(streamMetadataTasks, streamTransactionMetadataTasks, streamMetadataStore, executor),\n                 new DeleteStreamTask(streamMetadataTasks, streamMetadataStore, bucketStore, executor),\n                 new TruncateStreamTask(streamMetadataTasks, streamMetadataStore, executor),\n+                new AddSubscriberTask(streamMetadataTasks, streamMetadataStore, executor),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a930f49f78b4deea60eb11b46906a57dd1c3fd94"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1Mzk5MQ==", "bodyText": "Removed code for asynchronous processing of add/removeSubscriber operations, as discussed and made it synchronous with retries.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r495853991", "createdAt": "2020-09-28T10:55:45Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "diffHunk": "@@ -156,6 +158,8 @@ public ControllerEventProcessors(final String host,\n                 new SealStreamTask(streamMetadataTasks, streamTransactionMetadataTasks, streamMetadataStore, executor),\n                 new DeleteStreamTask(streamMetadataTasks, streamMetadataStore, bucketStore, executor),\n                 new TruncateStreamTask(streamMetadataTasks, streamMetadataStore, executor),\n+                new AddSubscriberTask(streamMetadataTasks, streamMetadataStore, executor),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0OTI1MQ=="}, "originalCommit": {"oid": "a930f49f78b4deea60eb11b46906a57dd1c3fd94"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjUxMjc2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTo0MToxM1rOHcOOAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMToxMzowNlrOHiCwHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTEzOQ==", "bodyText": "should we throw a checked exception so that users can handle it and choose to retry?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499355139", "createdAt": "2020-10-05T05:41:13Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyNzIwMw==", "bodyText": "This throws ControllerFailureException in line with other APIs that also throw the same exception on getting a FAILURE status.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499527203", "createdAt": "2020-10-05T11:25:43Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMDc3NA==", "bodyText": "ok, but we need better exception handling for these cases. A pravega user is not expected to be aware of controller and controller failure exceptions. typically any exception can be propagated to the user apis and if they are actionable, then they should be specific, and perhaps even checked. I agree that we havent done this consistently across APIs. But we have the opportunity here to evaluate what is right behaviour for this API. it really depends on how the error is translated when its presented to the user, esp if we expect them to handle the error in a meaningful way.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505430774", "createdAt": "2020-10-15T10:22:17Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ1ODcxNw==", "bodyText": "sure. can take up as part of a separate refactoring issue. Filed issue: #5262 for this.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505458717", "createdAt": "2020-10-15T11:13:06Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjUxODc4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTo0NDo1MFrOHcORWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzoyOTo1OVrOHkOaGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw==", "bodyText": "IMO this should be idempotent case and non error case.. if you want to throw an exception, should this be something other than illegalargument", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499355993", "createdAt": "2020-10-05T05:44:50Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyNzc2OQ==", "bodyText": "2 unrelated users could try to add the same subscriber name and if we just return success on each addition they'll never know they are overwriting each other's data.\nSo it is important to error out if the subscriber already exists.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499527769", "createdAt": "2020-10-05T11:26:41Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMjM4Mw==", "bodyText": "i see your point. however let me ask a counter question - is the subscriber id same as readergroup id or is it chosen by the user?\nif its former, then it doesnt matter if two users were attempting to perform this action simultaneously.\nHowever, if its implicit and handled at a readergroup level,", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505432383", "createdAt": "2020-10-15T10:25:02Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDM2MA==", "bodyText": "I would expect it to be same as readergroup id - it is fine for 2 users to call addSubscriber() with same Id simultaneously, but only 1 would succeed and the other would fail.... a subsequent getSubscribers() can be used to determine if the subscriber actually got added.....", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505460360", "createdAt": "2020-10-15T11:16:10Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ1MzQ2MA==", "bodyText": "i am not convinced if we should throw an exception in this case, because its not an exceptional but idempotent case. return a boolean to indicate if it exists.. throwing illegal argument is certainly misleading.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507453460", "createdAt": "2020-10-19T04:47:39Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0Njg0Mg==", "bodyText": "changed return status for SUBSCRIBER_EXISTS to false instead of throwing exception.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507746842", "createdAt": "2020-10-19T13:29:59Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjUxOTc3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTo0NToyM1rOHcOR6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzoyOTozMVrOHkOYqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjEzOQ==", "bodyText": "idempotent case, should be treated as success perhaps", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499356139", "createdAt": "2020-10-05T05:45:23Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyNzk1MA==", "bodyText": "same as above", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499527950", "createdAt": "2020-10-05T11:26:59Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMjkyOQ==", "bodyText": "remove is different from above case. since we are not doing conditional remove, but is predicated on the subscriber's name. it should perhaps not throw the exception.\nin fact i would say that this should not even be a response code for remove api from idempotent case's perspective.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505432929", "createdAt": "2020-10-15T10:25:58Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0NjQ3Mw==", "bodyText": "Ok changed return status for SUBSCRIBER_NOT_FOUND to false.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507746473", "createdAt": "2020-10-19T13:29:31Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjUyMzg3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTo0NzozNVrOHcOUHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNDo1MjoyM1rOHim37g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjcwMg==", "bodyText": "do you want to include SCopeNotFound and StreamNotFound error cases for this as well?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499356702", "createdAt": "2020-10-05T05:47:35Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Subscriber does not exist: \" + subscriber);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully removed subscriber {} from stream: {}/{}\", subscriber, scope, streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"removeSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"removeSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String streamName) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(scope, \"scopeName\");\n+        Preconditions.checkNotNull(streamName, \"stream\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"getSubscribersForStream\", streamName);\n+        final CompletableFuture<StreamSubscribers> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<StreamSubscribers> callback = new RPCAsyncCallback<>(requestId, \"getSubscribersForStream\", scope, streamName);\n+            client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS).getSubscribersForStream(ModelHelper.createStreamInfo(scope, streamName), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(subscribers -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwMjUyNQ==", "bodyText": "Other similar APIs ...getSegments(), getEpochSegments(), getCurrentSegments() also return empty result in case of any errors... actually it would be tricky to return both a status and a value... so just saying consistent with existing APIs here...", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r504002525", "createdAt": "2020-10-13T14:32:55Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Subscriber does not exist: \" + subscriber);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully removed subscriber {} from stream: {}/{}\", subscriber, scope, streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"removeSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"removeSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String streamName) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(scope, \"scopeName\");\n+        Preconditions.checkNotNull(streamName, \"stream\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"getSubscribersForStream\", streamName);\n+        final CompletableFuture<StreamSubscribers> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<StreamSubscribers> callback = new RPCAsyncCallback<>(requestId, \"getSubscribersForStream\", scope, streamName);\n+            client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS).getSubscribersForStream(ModelHelper.createStreamInfo(scope, streamName), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(subscribers -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjcwMg=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNjY2OA==", "bodyText": "the response structure for this api is a defined as a new protobuf message. so you have the opportunity to include a status and a response list.\nand you have pointed out an important thing -- that the pattern for streamnotfound is not consistently followed across apis stream apis.. please create a new issue in backlog for these (unrelated to current change set) to include a status with each such api where we can set the appropriate status or make use of grpc status runtime to indicate such failures..", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505436668", "createdAt": "2020-10-15T10:32:15Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Subscriber does not exist: \" + subscriber);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully removed subscriber {} from stream: {}/{}\", subscriber, scope, streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"removeSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"removeSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String streamName) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(scope, \"scopeName\");\n+        Preconditions.checkNotNull(streamName, \"stream\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"getSubscribersForStream\", streamName);\n+        final CompletableFuture<StreamSubscribers> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<StreamSubscribers> callback = new RPCAsyncCallback<>(requestId, \"getSubscribersForStream\", scope, streamName);\n+            client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS).getSubscribersForStream(ModelHelper.createStreamInfo(scope, streamName), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(subscribers -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjcwMg=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1MDU0Mg==", "bodyText": "Sure filed : #5261 for this", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r506050542", "createdAt": "2020-10-16T04:52:23Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Subscriber does not exist: \" + subscriber);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully removed subscriber {} from stream: {}/{}\", subscriber, scope, streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"removeSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"removeSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String streamName) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(scope, \"scopeName\");\n+        Preconditions.checkNotNull(streamName, \"stream\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"getSubscribersForStream\", streamName);\n+        final CompletableFuture<StreamSubscribers> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<StreamSubscribers> callback = new RPCAsyncCallback<>(requestId, \"getSubscribersForStream\", scope, streamName);\n+            client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS).getSubscribersForStream(ModelHelper.createStreamInfo(scope, streamName), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(subscribers -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjcwMg=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzE3MzE3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToxODowNVrOHcUX3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwOToxNzowNlrOHc9X1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTk2NQ==", "bodyText": "nit: preconditions for scope and stream as well.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499455965", "createdAt": "2020-10-05T09:18:05Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -324,6 +325,21 @@ public static final StreamConfig decode(String scope, String streamName, final S\n         return builder.build();\n     }\n \n+    /**\n+     * Converts StreamConfiguration into StreamConfig.\n+     *\n+     * @param scope the stream's scope\n+     * @param streamName The Stream Name\n+     * @param subscriberId Id of the subscriber for this stream.\n+     * @return StreamSubscriberInfo instance.\n+     */\n+    public static final StreamSubscriberInfo decode(String scope, String streamName, final String subscriberId) {\n+        Preconditions.checkNotNull(subscriberId, \"subscriber\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyODM0Mg==", "bodyText": "sure, will add these.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499528342", "createdAt": "2020-10-05T11:27:47Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -324,6 +325,21 @@ public static final StreamConfig decode(String scope, String streamName, final S\n         return builder.build();\n     }\n \n+    /**\n+     * Converts StreamConfiguration into StreamConfig.\n+     *\n+     * @param scope the stream's scope\n+     * @param streamName The Stream Name\n+     * @param subscriberId Id of the subscriber for this stream.\n+     * @return StreamSubscriberInfo instance.\n+     */\n+    public static final StreamSubscriberInfo decode(String scope, String streamName, final String subscriberId) {\n+        Preconditions.checkNotNull(subscriberId, \"subscriber\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTk2NQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyNzcwMA==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r500127700", "createdAt": "2020-10-06T09:17:06Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -324,6 +325,21 @@ public static final StreamConfig decode(String scope, String streamName, final S\n         return builder.build();\n     }\n \n+    /**\n+     * Converts StreamConfiguration into StreamConfig.\n+     *\n+     * @param scope the stream's scope\n+     * @param streamName The Stream Name\n+     * @param subscriberId Id of the subscriber for this stream.\n+     * @return StreamSubscriberInfo instance.\n+     */\n+    public static final StreamSubscriberInfo decode(String scope, String streamName, final String subscriberId) {\n+        Preconditions.checkNotNull(subscriberId, \"subscriber\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTk2NQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzE3NDgzOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToxODoyOVrOHcUY3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMToyODo0OVrOHcY00A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NjIyMQ==", "bodyText": "nit: revert this please", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499456221", "createdAt": "2020-10-05T09:18:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java", "diffHunk": "@@ -14,40 +14,7 @@\n import java.time.Duration;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE;\n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.OPEN_TRANSACTIONS;\n-import static io.pravega.shared.MetricsNames.RETENTION_FREQUENCY;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_MERGES;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_SPLITS;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE;\n-import static io.pravega.shared.MetricsNames.KVTABLE_SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE_FAILED;\n-import static io.pravega.shared.MetricsNames.globalMetricName;\n+import static io.pravega.shared.MetricsNames.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyODkxMg==", "bodyText": "wonder why checkstyle did not complain here... will revert....", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499528912", "createdAt": "2020-10-05T11:28:49Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java", "diffHunk": "@@ -14,40 +14,7 @@\n import java.time.Duration;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE;\n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.OPEN_TRANSACTIONS;\n-import static io.pravega.shared.MetricsNames.RETENTION_FREQUENCY;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_MERGES;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_SPLITS;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE;\n-import static io.pravega.shared.MetricsNames.KVTABLE_SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE_FAILED;\n-import static io.pravega.shared.MetricsNames.globalMetricName;\n+import static io.pravega.shared.MetricsNames.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NjIyMQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzE3OTIyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToxOToyOVrOHcUbWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNTozNDo1NVrOHinkDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1Njg1Ng==", "bodyText": "do you still need to route it through stream metadata tasks? you can perhaps directly write using the store apis.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499456856", "createdAt": "2020-10-05T09:19:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -158,6 +160,37 @@\n                 }, executor);\n     }\n \n+    public CompletableFuture<AddSubscriberStatus> addSubscriber(String scope, String stream, final String subscriber) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+        Preconditions.checkNotNull(subscriber, \"subscriber is null\");\n+        Timer timer = new Timer();\n+        return streamMetadataTasks.addSubscriber(scope, stream, subscriber, null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MTgzNg==", "bodyText": "I'd prefer encapsulating the various steps like checking for streamExists etc inside StreamMetadataTasks..", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r506061836", "createdAt": "2020-10-16T05:34:55Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -158,6 +160,37 @@\n                 }, executor);\n     }\n \n+    public CompletableFuture<AddSubscriberStatus> addSubscriber(String scope, String stream, final String subscriber) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+        Preconditions.checkNotNull(subscriber, \"subscriber is null\");\n+        Timer timer = new Timer();\n+        return streamMetadataTasks.addSubscriber(scope, stream, subscriber, null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1Njg1Ng=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzE4MDI3OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToxOTo0MFrOHcUb8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToxOTo0MFrOHcUb8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NzAxMQ==", "bodyText": "same here", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499457011", "createdAt": "2020-10-05T09:19:40Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -158,6 +160,37 @@\n                 }, executor);\n     }\n \n+    public CompletableFuture<AddSubscriberStatus> addSubscriber(String scope, String stream, final String subscriber) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+        Preconditions.checkNotNull(subscriber, \"subscriber is null\");\n+        Timer timer = new Timer();\n+        return streamMetadataTasks.addSubscriber(scope, stream, subscriber, null)\n+                .thenApplyAsync(status -> {\n+                    reportAddSubscriberMetrics(scope, stream, status, timer.getElapsed());\n+                    return AddSubscriberStatus.newBuilder().setStatus(status).build();\n+                }, executor);\n+    }\n+\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+\n+        return streamMetadataTasks.getSubscribersForStream(scope, stream, null);\n+    }\n+\n+    public CompletableFuture<RemoveSubscriberStatus> removeSubscriber(String scope, String stream, final String subscriber) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+        Preconditions.checkNotNull(subscriber, \"subscriber is null\");\n+        Timer timer = new Timer();\n+        return streamMetadataTasks.removeSubscriber(scope, stream, subscriber, null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzE4ODY5OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyMTozM1rOHcUg2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTozMToxMFrOHcY53Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1ODI2Ng==", "bodyText": "please implement or throw notimplemented exception", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499458266", "createdAt": "2020-10-05T09:21:33Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "diffHunk": "@@ -823,6 +824,21 @@ private void handleStreamMetadataExists(final long timestamp, CompletableFuture<\n         return result;\n     }\n \n+    @Override\n+    CompletableFuture<Void> createSubscribersDataIfAbsent(StreamSubscribersRecord data) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzMDIwNQ==", "bodyText": "ok... this got missed. will implement.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499530205", "createdAt": "2020-10-05T11:31:10Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "diffHunk": "@@ -823,6 +824,21 @@ private void handleStreamMetadataExists(final long timestamp, CompletableFuture<\n         return result;\n     }\n \n+    @Override\n+    CompletableFuture<Void> createSubscribersDataIfAbsent(StreamSubscribersRecord data) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1ODI2Ng=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzE4OTc4OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyMTo1MFrOHcUhjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTozMToyOFrOHcY6XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1ODQ0Ng==", "bodyText": "here and everywhere else in this class.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499458446", "createdAt": "2020-10-05T09:21:50Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "diffHunk": "@@ -823,6 +824,21 @@ private void handleStreamMetadataExists(final long timestamp, CompletableFuture<\n         return result;\n     }\n \n+    @Override\n+    CompletableFuture<Void> createSubscribersDataIfAbsent(StreamSubscribersRecord data) {\n+        return null;\n+    }\n+\n+    @Override\n+    CompletableFuture<VersionedMetadata<StreamSubscribersRecord>> getSubscribersData(boolean ignoreCached) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzMDMzMg==", "bodyText": "will do", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499530332", "createdAt": "2020-10-05T11:31:28Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "diffHunk": "@@ -823,6 +824,21 @@ private void handleStreamMetadataExists(final long timestamp, CompletableFuture<\n         return result;\n     }\n \n+    @Override\n+    CompletableFuture<Void> createSubscribersDataIfAbsent(StreamSubscribersRecord data) {\n+        return null;\n+    }\n+\n+    @Override\n+    CompletableFuture<VersionedMetadata<StreamSubscribersRecord>> getSubscribersData(boolean ignoreCached) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1ODQ0Ng=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzE5NDk5OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyMjo1NlrOHcUkcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTozMzo1OVrOHcY_lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1OTE4NQ==", "bodyText": "we can maybe always create this subscriber record for a stream as part of stream creation..\nthat way it only needs to be updated if a subscriber registers or unregisters.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499459185", "createdAt": "2020-10-05T09:22:56Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -156,6 +158,50 @@ public String getScopeName() {\n         return deleteStream();\n     }\n \n+    /**\n+     * Create a subscribersRecord with provided subscriber for this Stream.\n+     * @return future of operation.\n+     */\n+    @Override\n+    public CompletableFuture<Void> createSubscribersRecord(String subscriber) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzMTY3MA==", "bodyText": "The reason I did not want to do it is because a lot of Streams may never need CBR, in which case that additional metadata is an unnecessary overhead that they can do without.\nAlso for existing Pravega deployments, that move to the new version with CBR this metadata would need to be explicitly added when the Stream moves to CBR.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499531670", "createdAt": "2020-10-05T11:33:59Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -156,6 +158,50 @@ public String getScopeName() {\n         return deleteStream();\n     }\n \n+    /**\n+     * Create a subscribersRecord with provided subscriber for this Stream.\n+     * @return future of operation.\n+     */\n+    @Override\n+    public CompletableFuture<Void> createSubscribersRecord(String subscriber) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1OTE4NQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzIwMDExOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyNDowMFrOHcUnXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTozNDowN1rOHcY_0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1OTkzMw==", "bodyText": "please add javadoc.. also mention that it can throw write conflict exceptions.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499459933", "createdAt": "2020-10-05T09:24:00Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -156,6 +158,50 @@ public String getScopeName() {\n         return deleteStream();\n     }\n \n+    /**\n+     * Create a subscribersRecord with provided subscriber for this Stream.\n+     * @return future of operation.\n+     */\n+    @Override\n+    public CompletableFuture<Void> createSubscribersRecord(String subscriber) {\n+        ImmutableMap<String, SubscriberConfiguration> subscribers\n+                = new ImmutableMap.Builder<String, SubscriberConfiguration>()\n+                .put(subscriber, SubscriberConfiguration.EMPTY).build();\n+        return createSubscribersDataIfAbsent(new StreamSubscribersRecord(subscribers));\n+    }\n+\n+    public CompletableFuture<Void> updateSubscribers(final String subscriber,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzMTcyOQ==", "bodyText": "ok. sure", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499531729", "createdAt": "2020-10-05T11:34:07Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -156,6 +158,50 @@ public String getScopeName() {\n         return deleteStream();\n     }\n \n+    /**\n+     * Create a subscribersRecord with provided subscriber for this Stream.\n+     * @return future of operation.\n+     */\n+    @Override\n+    public CompletableFuture<Void> createSubscribersRecord(String subscriber) {\n+        ImmutableMap<String, SubscriberConfiguration> subscribers\n+                = new ImmutableMap.Builder<String, SubscriberConfiguration>()\n+                .put(subscriber, SubscriberConfiguration.EMPTY).build();\n+        return createSubscribersDataIfAbsent(new StreamSubscribersRecord(subscribers));\n+    }\n+\n+    public CompletableFuture<Void> updateSubscribers(final String subscriber,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1OTkzMw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzIxMzg5OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/StreamMetadataStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyNjo0OVrOHcUvYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyNjo0OVrOHcUvYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MTk4Ng==", "bodyText": "nit: create.\nalso store can expose AddSubscriber and RemoveSubscriber apis.\ninternally the subscriber record can be created at the time of stream creation and is updated whenver a new subscriber is added/removed by doing a get and set.\nand this can fail with write conflict to the caller may need to handle and retry the operation.\nwe follow optimistic concurrency.. the assumption here is that subscriber registration is a rare occurrence and there will not be many conflicts.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499461986", "createdAt": "2020-10-05T09:26:49Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/StreamMetadataStore.java", "diffHunk": "@@ -287,6 +289,67 @@\n                                                                                            final OperationContext context,\n                                                                                            final Executor executor);\n \n+\n+    /**\n+     * Updates the subscribers metadata for an existing stream.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzIyMjg3OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/records/StreamSubscribersRecord.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyODo1MFrOHcU0hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDozMjo0MVrOHggMHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzMwMw==", "bodyText": "nit: remove commented code", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499463303", "createdAt": "2020-10-05T09:28:50Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/StreamSubscribersRecord.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Data class for storing information about stream's subscribers.\n+ */\n+@Data\n+@Slf4j\n+public class StreamSubscribersRecord {\n+    public static final SubscribersRecordSerializer SERIALIZER = new SubscribersRecordSerializer();\n+    public static final StreamSubscribersRecord EMPTY = new StreamSubscribersRecord(ImmutableMap.of());\n+\n+    private final ImmutableMap<String, SubscriberConfiguration> streamSubscribers;\n+\n+    @Builder\n+    public StreamSubscribersRecord(@NonNull ImmutableMap<String, SubscriberConfiguration> streamSubcribers) {\n+        this.streamSubscribers = streamSubcribers;\n+    }\n+\n+    public boolean contains(String subscriber) {\n+        Preconditions.checkArgument(streamSubscribers != null, \"Null subscribers for Stream\");\n+        return streamSubscribers.containsKey(subscriber);\n+    }\n+\n+    public static StreamSubscribersRecord update(ImmutableMap<String, SubscriberConfiguration> existingSubscribers,\n+                                                 String newSubscriber, SubscriberConfiguration config) {\n+        Map<String, SubscriberConfiguration> streamSubscribers = new HashMap<String, SubscriberConfiguration>();\n+        streamSubscribers.putAll(existingSubscribers);\n+        streamSubscribers.put(newSubscriber, config);\n+        return new StreamSubscribersRecord(ImmutableMap.copyOf(streamSubscribers));\n+    }\n+\n+    public static StreamSubscribersRecord remove(ImmutableMap<String, SubscriberConfiguration> existingSubscribers,\n+                                                 String subscriber) {\n+        Map<String, SubscriberConfiguration> streamSubscribers = existingSubscribers.entrySet().stream()\n+                                                                .filter(e -> !e.getKey().equals(subscriber))\n+                                                                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));\n+        return new StreamSubscribersRecord(ImmutableMap.copyOf(streamSubscribers));\n+    }\n+\n+    private static class StreamSubscribersRecordBuilder implements ObjectBuilder<StreamSubscribersRecord> {\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    public static StreamSubscribersRecord fromBytes(final byte[] record) {\n+        //InputStream inputStream = new ByteArrayInputStream(record, 0, record.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg0Mzg2OQ==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r503843869", "createdAt": "2020-10-13T10:32:41Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/StreamSubscribersRecord.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Data class for storing information about stream's subscribers.\n+ */\n+@Data\n+@Slf4j\n+public class StreamSubscribersRecord {\n+    public static final SubscribersRecordSerializer SERIALIZER = new SubscribersRecordSerializer();\n+    public static final StreamSubscribersRecord EMPTY = new StreamSubscribersRecord(ImmutableMap.of());\n+\n+    private final ImmutableMap<String, SubscriberConfiguration> streamSubscribers;\n+\n+    @Builder\n+    public StreamSubscribersRecord(@NonNull ImmutableMap<String, SubscriberConfiguration> streamSubcribers) {\n+        this.streamSubscribers = streamSubcribers;\n+    }\n+\n+    public boolean contains(String subscriber) {\n+        Preconditions.checkArgument(streamSubscribers != null, \"Null subscribers for Stream\");\n+        return streamSubscribers.containsKey(subscriber);\n+    }\n+\n+    public static StreamSubscribersRecord update(ImmutableMap<String, SubscriberConfiguration> existingSubscribers,\n+                                                 String newSubscriber, SubscriberConfiguration config) {\n+        Map<String, SubscriberConfiguration> streamSubscribers = new HashMap<String, SubscriberConfiguration>();\n+        streamSubscribers.putAll(existingSubscribers);\n+        streamSubscribers.put(newSubscriber, config);\n+        return new StreamSubscribersRecord(ImmutableMap.copyOf(streamSubscribers));\n+    }\n+\n+    public static StreamSubscribersRecord remove(ImmutableMap<String, SubscriberConfiguration> existingSubscribers,\n+                                                 String subscriber) {\n+        Map<String, SubscriberConfiguration> streamSubscribers = existingSubscribers.entrySet().stream()\n+                                                                .filter(e -> !e.getKey().equals(subscriber))\n+                                                                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));\n+        return new StreamSubscribersRecord(ImmutableMap.copyOf(streamSubscribers));\n+    }\n+\n+    private static class StreamSubscribersRecordBuilder implements ObjectBuilder<StreamSubscribersRecord> {\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    public static StreamSubscribersRecord fromBytes(final byte[] record) {\n+        //InputStream inputStream = new ByteArrayInputStream(record, 0, record.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzMwMw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzIyNzAwOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyOTo0NFrOHcU23Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNDoyOToxOFrOHhBydA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzkwMQ==", "bodyText": "why do we need this?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499463901", "createdAt": "2020-10-05T09:29:44Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEzMzQ3MA==", "bodyText": "'SubscriberConfiguration' encapsulates all and any data that needs to be stored about a Stream Subscriber. Today it has only the truncation StreamCut but could have more stuff in the future.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r500133470", "createdAt": "2020-10-06T09:26:27Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzkwMQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5NDM1Ng==", "bodyText": "removed now. fixed.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r504394356", "createdAt": "2020-10-14T04:29:18Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzkwMQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzI1ODkyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOTozNzoxNlrOHcVJxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDozMjo1NlrOHggMkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2ODc0MA==", "bodyText": "please dont put the position/streamcut inside the subscriber record. since this record is actually written under the StreamSubscribersRecord this will be problematic on two dimensions:\n\nwith large number of subscribers, the size of this record can exceed the 1mb limit of kvt record if there are large number of segments in the streamcut. its better to divide and rule.\nthis will mean StreamSubscribersRecord is upadted with every \"report\" from a subscriber which means the write conflicts can occur lot more whereby making optimistic concurrency undesirable.\n\nmy suggestion is to do as follows:\n\nStreamSubscribersRecord should only contain a list of subscriber ids.\ncreate separate record for each subscriber for their reported position.\n\naddSubscriber/removeSubscriber updates the StreamSubscribersRecord with the subscriber's id.\nthen for each subscriber there is a separate key called say subscriber_<subscriberId>.\nwhen subscriber with id reports its streamcut, its streamcut is updated in subscriber_id record.\ngetSubscribers will first fetch the StreamSubscribersRecord  and then fetch all their individual records corresponding to their last reported positions.\nremovesubscriber can perform batch update of StreamSubscribersRecord and subscriber_id record by updating the former and removing the later via an atomic kvt update.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499468740", "createdAt": "2020-10-05T09:37:16Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;\n+    /**\n+     * Time when this configuration was updated.\n+     */\n+    private final long updateTime;\n+\n+    /**\n+     * Truncation Stream cut published by this subscriber\n+     */\n+    private final ImmutableMap<Long, Long> streamCut;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE2ODE5NQ==", "bodyText": "with large number of subscribers, the size of this record can exceed the 1mb limit of kvt record if there are large number of segments in the streamcut. its better to divide and rule.\n\n\nThe 1 MB limit would be exceeded even when we maintain separate records for subscribers and truncation stream-cuts. Assuming each 'Subscriber --> SC' map entry takes up 100 bytes, it would take 10K subscribers to hit that limit....which is a pretty large number.... Having Subscriber name as part of the same record only marginally impacts the table segment record limitation.....\n\n\nthis will mean StreamSubscribersRecord is updated with every \"report\" from a subscriber which means the write conflicts can occur lot more whereby making optimistic concurrency undesirable.\n\n\nThe downside of maintaining 2 separate records is the need to maintain consistency between them.\nOptimistic concurrency concerns due to frequent update of truncation stream-cuts are very valid, but it has nothing to do with Subscribers being part of the same metadata, as subscriber addition is a much infrequent operation.\nOne way to deal with this can be to have a separate record in Stream Metadata per subscriber and update just that record on stream-cut updates.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r500168195", "createdAt": "2020-10-06T10:26:36Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;\n+    /**\n+     * Time when this configuration was updated.\n+     */\n+    private final long updateTime;\n+\n+    /**\n+     * Truncation Stream cut published by this subscriber\n+     */\n+    private final ImmutableMap<Long, Long> streamCut;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2ODc0MA=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg0Mzk4Nw==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r503843987", "createdAt": "2020-10-13T10:32:56Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;\n+    /**\n+     * Time when this configuration was updated.\n+     */\n+    private final long updateTime;\n+\n+    /**\n+     * Truncation Stream cut published by this subscriber\n+     */\n+    private final ImmutableMap<Long, Long> streamCut;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2ODc0MA=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTkwNDc5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxMjo1OFrOHiAuiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzozMTo0NFrOHkOe_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTU0Nw==", "bodyText": "why is it a boolean? is boolean helpful to user if the subscriber was already present?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505425547", "createdAt": "2020-10-15T10:12:58Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ1NDM4OA==", "bodyText": "The ControllerImpl implementation returns a true/false for every operation based on weather the operation was succeeded or failed/skipped.\nFor \"addSubscriber\" the operation is successful if subscriber was not present and got added, in every other case its a failure....", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505454388", "createdAt": "2020-10-15T11:04:42Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTU0Nw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ1NDUyOQ==", "bodyText": "semantics of true false and error cases could be consistent with create stream api:\ntrue - if its newly created\nfalse - if it already exists\nexception - specific to the error occurred.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507454529", "createdAt": "2020-10-19T04:49:58Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTU0Nw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0ODA5NQ==", "bodyText": "Changed as per createStream.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507748095", "createdAt": "2020-10-19T13:31:44Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTU0Nw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTkxNDAwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxNTozOFrOHiA0ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMTowNzowN1rOHiCj7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNzA1MA==", "bodyText": "same question: what is the reason to return a boolean here?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505427050", "createdAt": "2020-10-15T10:15:38Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ1NTU5Nw==", "bodyText": "I think it would be nice to adhere to the same contract as other APIs for a consistent user experience.\nOnly the getXXX operations return non-boolean values which is also the case with getSubscribersForStream.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505455597", "createdAt": "2020-10-15T11:07:07Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNzA1MA=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTkyMDc4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxNzozNFrOHiA4sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzowNTozMFrOHiRn_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyODE0NQ==", "bodyText": "nit: since this api is in the context of a subscriber, the name should reflect it.. perhaps a better name for this API would be reportSubscriberStreamCut or reportSubscriberPosition.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505428145", "createdAt": "2020-10-15T10:17:34Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> updateTruncationStreamCut(final String scope, final String streamName, final String subscriber, final StreamCut streamCut);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwMjM5Nw==", "bodyText": "Ok. changed this.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505702397", "createdAt": "2020-10-15T17:05:30Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> updateTruncationStreamCut(final String scope, final String streamName, final String subscriber, final StreamCut streamCut);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyODE0NQ=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTkyMjE0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxNzo1NlrOHiA5hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMTowNzo1NVrOHiClsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyODM1OA==", "bodyText": "nit: subscriber's position was updated", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505428358", "createdAt": "2020-10-15T10:17:56Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ1NjA0OQ==", "bodyText": "sure will fix.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505456049", "createdAt": "2020-10-15T11:07:55Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyODM1OA=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTk3ODk5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDozMzoyMFrOHiBcfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzowNzo1OFrOHiRuqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNzMwOA==", "bodyText": "also add \"throws\" javadoc for exceptions that can be thrown from this if user needs to handle those exceptions. for instance - stream cut not valid should be propagated to the user.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505437308", "createdAt": "2020-10-15T10:33:20Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> updateTruncationStreamCut(final String scope, final String streamName, final String subscriber, final StreamCut streamCut);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNDEwNQ==", "bodyText": "Added for all new APIs", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505704105", "createdAt": "2020-10-15T17:07:58Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> updateTruncationStreamCut(final String scope, final String streamName, final String subscriber, final StreamCut streamCut);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNzMwOA=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTk5NjIyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDozODowNlrOHiBmtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNDo1MTozNVrOHj8nbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzOTkyNQ==", "bodyText": "why return empty subscriber list when there is an exception?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505439925", "createdAt": "2020-10-15T10:38:06Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ3Mzc0Ng==", "bodyText": "The DataNotFoundException here indicates there is no subscriber data present for this Stream, which can happen if users query subscriber data for a Stream that does not have \"subscribers\". So this is not really an exceptional case and hence returning empty list here.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505473746", "createdAt": "2020-10-15T11:41:23Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzOTkyNQ=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ1NTM0MA==", "bodyText": "but can empty list also be returned if the stream did not exist?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507455340", "createdAt": "2020-10-19T04:51:35Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzOTkyNQ=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NjAwMTYyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDozOTozOFrOHiBqLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMzozMTozMlrOHo8SiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MDgxMw==", "bodyText": "we should also make use of \"greater\" than property to see if the new streamcut is strictly greater than equal to previously reported truncation streamcut for the given subscriber so that it always move ahead.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505440813", "createdAt": "2020-10-15T10:39:38Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;\n+                              }\n+                          });\n+                  }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateTruncationStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateTruncationStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    // 1. check Stream exists\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                    }\n+                    // 2. check if StreamCut is valid\n+                    return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ3NDg1NQ==", "bodyText": "There may be \"recovery\" scenarios where a Reader Group restarts from an earlier Stream-Cut and hence publishes an older StreamCut as a truncation Stream-Cut later.... so I would not want to add that check here...", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505474855", "createdAt": "2020-10-15T11:43:32Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;\n+                              }\n+                          });\n+                  }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateTruncationStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateTruncationStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    // 1. check Stream exists\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                    }\n+                    // 2. check if StreamCut is valid\n+                    return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MDgxMw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ1NjkwMA==", "bodyText": "but can stream cut be \"reset\" back to an older streamcut?\nwhat if controller had already used the more recent one for truncation.\nwe should strictly move the streamcuts forward..\nit also takes care of scenarios where multiple different controllers received different requests and if newer update is already set, the stale value should not override it.\ntake for example:\nT0: rg ->SC1 -> controller1\nt1: connection failure\nt2: rg ->SC2 -> controller2\ncontroller1 is attempting to update SC1 to segment store and controller 2 is attempting to update SC2..\nif SC2 is updated, we should reject SC1.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507456900", "createdAt": "2020-10-19T04:54:27Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;\n+                              }\n+                          });\n+                  }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateTruncationStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateTruncationStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    // 1. check Stream exists\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                    }\n+                    // 2. check if StreamCut is valid\n+                    return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MDgxMw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNzg4OQ==", "bodyText": "The validation you are suggesting can be added at a later point, if needed. I'm a little wary of adding validations that can adversely impact basic valid functionality usecases.\nDo we do this check with manual truncation API today?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507637889", "createdAt": "2020-10-19T10:25:33Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;\n+                              }\n+                          });\n+                  }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateTruncationStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateTruncationStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    // 1. check Stream exists\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                    }\n+                    // 2. check if StreamCut is valid\n+                    return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MDgxMw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMxNDQxMA==", "bodyText": "yes we do, we check that the streamcut is actually moving forward.\nfor each range, if segment number in one streamcut is same or higher, then that stream cut is greater than.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r508314410", "createdAt": "2020-10-20T08:37:17Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;\n+                              }\n+                          });\n+                  }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateTruncationStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateTruncationStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    // 1. check Stream exists\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                    }\n+                    // 2. check if StreamCut is valid\n+                    return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MDgxMw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5Mjg3Mg==", "bodyText": "Added this validation.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r512692872", "createdAt": "2020-10-27T13:31:32Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;\n+                              }\n+                          });\n+                  }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateTruncationStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateTruncationStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    // 1. check Stream exists\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                    }\n+                    // 2. check if StreamCut is valid\n+                    return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MDgxMw=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NjAxOTI3OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/PravegaTablesStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDo0NTowMFrOHiB1cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDoyOTowMVrOHkH4KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MzY5OQ==", "bodyText": "although this approach is fine, but should we put the list of subscribers in the stream metadata table itself? I mean in principle it would be better if we avoid creating an additional table segment for each stream.\nfor example:\nkey: subscribers value: List\nkey: subscriber- value: \nthat way we avoid creating a separate table. and with this model, we dont necessarily need to iterate over entries in a separate table.. instead use two queries - 1 to get list of subscribers and then the streamcut for each subscriber while performing the truncation.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505443699", "createdAt": "2020-10-15T10:45:00Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PravegaTablesStream.java", "diffHunk": "@@ -212,10 +224,12 @@ private String getWritersTableName(String id) {\n             String metadataTable = getMetadataTableName(id);\n             String epochWithTxnTable = getEpochsWithTransactionsTableName(id);\n             String writersPositionsTable = getWritersTableName(id);\n+            String subscribersTable = getSubscribersTableName(id);\n             return CompletableFuture.allOf(storeHelper.createTable(metadataTable),\n-                    storeHelper.createTable(epochWithTxnTable), storeHelper.createTable(writersPositionsTable))\n-                                    .thenAccept(v -> log.debug(\"stream {}/{} metadata tables {}, {} & {} created\", getScope(), getName(), metadataTable,\n-                                            epochWithTxnTable, writersPositionsTable));\n+                    storeHelper.createTable(epochWithTxnTable), storeHelper.createTable(writersPositionsTable),\n+                    storeHelper.createTable(subscribersTable))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzOTg0OQ==", "bodyText": "Fixed this and added new keys to existing stream metadata table:\nK                            --->    V\nSUBSCRIBERS        ----> sub1, sub2, sub3.... subn\nSUBSCRIBER_sub1 ----> sub1, ts1, StreamCut1\nSUBSCRIBER_sub2 -----> sub2, ts2, StreamCut2\n. . .", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r507639849", "createdAt": "2020-10-19T10:29:01Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PravegaTablesStream.java", "diffHunk": "@@ -212,10 +224,12 @@ private String getWritersTableName(String id) {\n             String metadataTable = getMetadataTableName(id);\n             String epochWithTxnTable = getEpochsWithTransactionsTableName(id);\n             String writersPositionsTable = getWritersTableName(id);\n+            String subscribersTable = getSubscribersTableName(id);\n             return CompletableFuture.allOf(storeHelper.createTable(metadataTable),\n-                    storeHelper.createTable(epochWithTxnTable), storeHelper.createTable(writersPositionsTable))\n-                                    .thenAccept(v -> log.debug(\"stream {}/{} metadata tables {}, {} & {} created\", getScope(), getName(), metadataTable,\n-                                            epochWithTxnTable, writersPositionsTable));\n+                    storeHelper.createTable(epochWithTxnTable), storeHelper.createTable(writersPositionsTable),\n+                    storeHelper.createTable(subscribersTable))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MzY5OQ=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NjAzMTMwOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDo0ODoxOFrOHiB8qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMTozMzo1MVrOHiDa-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0NTU0NA==", "bodyText": "Please throw NotImplementedException or UnsupportedException", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505445544", "createdAt": "2020-10-15T10:48:18Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "diffHunk": "@@ -237,7 +241,32 @@\n         return getId().thenCompose(id -> store.getCachedData(creationPath, id, x -> BitConverter.readLong(x, 0))\n                 .thenApply(VersionedMetadata::getObject));\n     }\n-    \n+\n+    @Override\n+    public CompletableFuture<Void> createSubscriber(String subscriber) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2OTY5MQ==", "bodyText": "ok. will do", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505469691", "createdAt": "2020-10-15T11:33:51Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "diffHunk": "@@ -237,7 +241,32 @@\n         return getId().thenCompose(id -> store.getCachedData(creationPath, id, x -> BitConverter.readLong(x, 0))\n                 .thenApply(VersionedMetadata::getObject));\n     }\n-    \n+\n+    @Override\n+    public CompletableFuture<Void> createSubscriber(String subscriber) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0NTU0NA=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NjAzMTcyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDo0ODoyOVrOHiB8-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNTo1ODowMFrOHin_ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0NTYyNg==", "bodyText": "same for all apis in this class", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505445626", "createdAt": "2020-10-15T10:48:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "diffHunk": "@@ -237,7 +241,32 @@\n         return getId().thenCompose(id -> store.getCachedData(creationPath, id, x -> BitConverter.readLong(x, 0))\n                 .thenApply(VersionedMetadata::getObject));\n     }\n-    \n+\n+    @Override\n+    public CompletableFuture<Void> createSubscriber(String subscriber) {\n+        return null;\n+    }\n+\n+    @Override\n+    public CompletableFuture<VersionedMetadata<StreamSubscriber>> getSubscriber(String subscriber) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2ODgzNg==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r506068836", "createdAt": "2020-10-16T05:58:00Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "diffHunk": "@@ -237,7 +241,32 @@\n         return getId().thenCompose(id -> store.getCachedData(creationPath, id, x -> BitConverter.readLong(x, 0))\n                 .thenApply(VersionedMetadata::getObject));\n     }\n-    \n+\n+    @Override\n+    public CompletableFuture<Void> createSubscriber(String subscriber) {\n+        return null;\n+    }\n+\n+    @Override\n+    public CompletableFuture<VersionedMetadata<StreamSubscriber>> getSubscriber(String subscriber) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0NTYyNg=="}, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTEwNzQ1OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoyMjoyMlrOHq3yJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjoxMjoxNFrOHrCaCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxNjE5OQ==", "bodyText": "we dont necessarily need a public method here. this can be done as part of precondition check for updating a subscriber streamcut internally. that will allow for get and update post validation.\notherwise you are validating. and then refetchng subscriber's record and updating it which may mean the condition may have changed.\nthough this method is slightly unoptimized as it is validating and then computing streamcut span, which can both be done in a single pass followed by comparison.\nalso, we can compute spans for both stream cuts in parallel.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514716199", "createdAt": "2020-10-30T02:22:22Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -671,6 +672,20 @@ private long findSegmentSplitsMerges(List<StreamSegmentRecord> referenceSegments\n                       });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> isStreamCutValidForTruncation(final Map<Long, Long> streamCut, Map<Long, Long> previousStreamCut) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc0NDgwOA==", "bodyText": "i am making the change in my PR to make the optimization to this method and its invocation in streamMetadataTasks.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514744808", "createdAt": "2020-10-30T02:52:01Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -671,6 +672,20 @@ private long findSegmentSplitsMerges(List<StreamSegmentRecord> referenceSegments\n                       });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> isStreamCutValidForTruncation(final Map<Long, Long> streamCut, Map<Long, Long> previousStreamCut) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxNjE5OQ=="}, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NjI5Ng==", "bodyText": "Ok", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514876296", "createdAt": "2020-10-30T05:23:11Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -671,6 +672,20 @@ private long findSegmentSplitsMerges(List<StreamSegmentRecord> referenceSegments\n                       });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> isStreamCutValidForTruncation(final Map<Long, Long> streamCut, Map<Long, Long> previousStreamCut) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxNjE5OQ=="}, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5MDI0OA==", "bodyText": "changed this to a private method", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514890248", "createdAt": "2020-10-30T06:12:14Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -671,6 +672,20 @@ private long findSegmentSplitsMerges(List<StreamSegmentRecord> referenceSegments\n                       });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> isStreamCutValidForTruncation(final Map<Long, Long> streamCut, Map<Long, Long> previousStreamCut) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxNjE5OQ=="}, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTEzMDg2OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoyNjo1N1rOHq4DLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNToyMzoxOFrOHrBj1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyMDU1OA==", "bodyText": "here you are fetching subscriber record, checking its validity and then updating the subscriber record but the update is not predicated on previous subscriber record that you had fetched. this could mean if the  subscriber record was updated while you performed the check, it could get overwritten incorrectly.\nthis check should be done in the storage layer where you do a get followed by a check and then conditional update using the entity tag from the previous record.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514720558", "createdAt": "2020-10-30T02:26:57Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,205 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. If SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        return streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor)\n+                                .thenApply(v -> AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<DeleteSubscriberStatus.Status> deleteSubscriber(String scope, String stream,\n+                                                                             String subscriber,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(DeleteSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.deleteSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> DeleteSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return DeleteSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return DeleteSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+\n+    public CompletableFuture<SubscribersResponse> listSubscribers(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"listSubscribers\", scope, stream);\n+        return streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(SubscribersResponse.newBuilder()\n+                                .setStatus(SubscribersResponse.Status.STREAM_NOT_FOUND).build());\n+                    }\n+                  // 2. get subscribers\n+                  return streamMetadataStore.listSubscribers(scope, stream, context, executor)\n+                          .thenApply(result -> SubscribersResponse.newBuilder()\n+                                     .setStatus(SubscribersResponse.Status.SUCCESS)\n+                                     .addAllSubscribers(result).build())\n+                            .exceptionally(ex -> {\n+                                log.warn(requestId, \"Exception trying to get list of Stream subscribers. {}\",\n+                                        ex.getMessage());\n+                                Throwable cause = Exceptions.unwrap(ex);\n+                                if (cause instanceof TimeoutException) {\n+                                    throw new CompletionException(cause);\n+                                } else {\n+                                    log.warn(requestId, \"listSubscribers failed due to {}\", ex.getMessage());\n+                                    return SubscribersResponse.newBuilder()\n+                                            .setStatus(SubscribersResponse.Status.FAILURE).build();\n+                                }\n+                            });\n+                });\n+\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateSubscriberStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateSubscriberStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                            // 1. check Stream exists\n+                            if (!exists) {\n+                                return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                            }\n+                            // 2. check if StreamCut is valid\n+                            return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, subscriber, contextOpt, executor),\n+                                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                                    .thenCompose(subscriberRecord -> {\n+                                        if (subscriberRecord == null) {\n+                                            return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND);\n+                                        } else {\n+                                            if (subscriberRecord.getObject().getTruncationStreamCut().isEmpty()) {\n+                                                return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)\n+                                                        .thenCompose( isValid -> {\n+                                                         if (isValid) {\n+                                                           return updateStreamCut(scope, stream, subscriber, truncationStreamCut, context, requestId);\n+                                                         } else {\n+                                                           return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAMCUT_NOT_VALID);\n+                                                         }\n+                                                 });\n+                                            } else {\n+                                                return streamMetadataStore.isStreamCutValidForTruncation(scope, stream, truncationStreamCut,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyNTEyNw==", "bodyText": "I;m fetching the subscriberRecord again in the StorageLayer and only then updating the streamcut on top. But I agree  this double fetch can be avoided.\nWill change this as suggested", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514725127", "createdAt": "2020-10-30T02:31:42Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,205 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. If SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        return streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor)\n+                                .thenApply(v -> AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<DeleteSubscriberStatus.Status> deleteSubscriber(String scope, String stream,\n+                                                                             String subscriber,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(DeleteSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.deleteSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> DeleteSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return DeleteSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return DeleteSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+\n+    public CompletableFuture<SubscribersResponse> listSubscribers(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"listSubscribers\", scope, stream);\n+        return streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(SubscribersResponse.newBuilder()\n+                                .setStatus(SubscribersResponse.Status.STREAM_NOT_FOUND).build());\n+                    }\n+                  // 2. get subscribers\n+                  return streamMetadataStore.listSubscribers(scope, stream, context, executor)\n+                          .thenApply(result -> SubscribersResponse.newBuilder()\n+                                     .setStatus(SubscribersResponse.Status.SUCCESS)\n+                                     .addAllSubscribers(result).build())\n+                            .exceptionally(ex -> {\n+                                log.warn(requestId, \"Exception trying to get list of Stream subscribers. {}\",\n+                                        ex.getMessage());\n+                                Throwable cause = Exceptions.unwrap(ex);\n+                                if (cause instanceof TimeoutException) {\n+                                    throw new CompletionException(cause);\n+                                } else {\n+                                    log.warn(requestId, \"listSubscribers failed due to {}\", ex.getMessage());\n+                                    return SubscribersResponse.newBuilder()\n+                                            .setStatus(SubscribersResponse.Status.FAILURE).build();\n+                                }\n+                            });\n+                });\n+\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateSubscriberStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateSubscriberStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                            // 1. check Stream exists\n+                            if (!exists) {\n+                                return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                            }\n+                            // 2. check if StreamCut is valid\n+                            return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, subscriber, contextOpt, executor),\n+                                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                                    .thenCompose(subscriberRecord -> {\n+                                        if (subscriberRecord == null) {\n+                                            return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND);\n+                                        } else {\n+                                            if (subscriberRecord.getObject().getTruncationStreamCut().isEmpty()) {\n+                                                return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)\n+                                                        .thenCompose( isValid -> {\n+                                                         if (isValid) {\n+                                                           return updateStreamCut(scope, stream, subscriber, truncationStreamCut, context, requestId);\n+                                                         } else {\n+                                                           return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAMCUT_NOT_VALID);\n+                                                         }\n+                                                 });\n+                                            } else {\n+                                                return streamMetadataStore.isStreamCutValidForTruncation(scope, stream, truncationStreamCut,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyMDU1OA=="}, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NjM3Mw==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514876373", "createdAt": "2020-10-30T05:23:18Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,205 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. If SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        return streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor)\n+                                .thenApply(v -> AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<DeleteSubscriberStatus.Status> deleteSubscriber(String scope, String stream,\n+                                                                             String subscriber,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(DeleteSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.deleteSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> DeleteSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return DeleteSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return DeleteSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+\n+    public CompletableFuture<SubscribersResponse> listSubscribers(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"listSubscribers\", scope, stream);\n+        return streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(SubscribersResponse.newBuilder()\n+                                .setStatus(SubscribersResponse.Status.STREAM_NOT_FOUND).build());\n+                    }\n+                  // 2. get subscribers\n+                  return streamMetadataStore.listSubscribers(scope, stream, context, executor)\n+                          .thenApply(result -> SubscribersResponse.newBuilder()\n+                                     .setStatus(SubscribersResponse.Status.SUCCESS)\n+                                     .addAllSubscribers(result).build())\n+                            .exceptionally(ex -> {\n+                                log.warn(requestId, \"Exception trying to get list of Stream subscribers. {}\",\n+                                        ex.getMessage());\n+                                Throwable cause = Exceptions.unwrap(ex);\n+                                if (cause instanceof TimeoutException) {\n+                                    throw new CompletionException(cause);\n+                                } else {\n+                                    log.warn(requestId, \"listSubscribers failed due to {}\", ex.getMessage());\n+                                    return SubscribersResponse.newBuilder()\n+                                            .setStatus(SubscribersResponse.Status.FAILURE).build();\n+                                }\n+                            });\n+                });\n+\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateSubscriberStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateSubscriberStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                            // 1. check Stream exists\n+                            if (!exists) {\n+                                return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                            }\n+                            // 2. check if StreamCut is valid\n+                            return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, subscriber, contextOpt, executor),\n+                                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                                    .thenCompose(subscriberRecord -> {\n+                                        if (subscriberRecord == null) {\n+                                            return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND);\n+                                        } else {\n+                                            if (subscriberRecord.getObject().getTruncationStreamCut().isEmpty()) {\n+                                                return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)\n+                                                        .thenCompose( isValid -> {\n+                                                         if (isValid) {\n+                                                           return updateStreamCut(scope, stream, subscriber, truncationStreamCut, context, requestId);\n+                                                         } else {\n+                                                           return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAMCUT_NOT_VALID);\n+                                                         }\n+                                                 });\n+                                            } else {\n+                                                return streamMetadataStore.isStreamCutValidForTruncation(scope, stream, truncationStreamCut,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyMDU1OA=="}, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 214}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4713, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}