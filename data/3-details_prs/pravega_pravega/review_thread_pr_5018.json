{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMjg0Mjkw", "number": 5018, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzowMzowMFrOEUr0kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODoxMjo1M1rOEUtUvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTI0OTQ1OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzowMzowMFrOG7Ba-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzo1Nzo1NFrOG7DUyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0MjQ1OA==", "bodyText": "Nit:  The new name is now - ChunkedSegmentStorage", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464542458", "createdAt": "2020-08-03T17:03:00Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -771,13 +837,39 @@ public void close() {\n \n         private class TestStorage extends AsyncStorageWrapper {\n             private final SyncStorage wrappedStorage;\n+            private final Map<String, Long> startOffsets;\n             private WriteInterceptor writeInterceptor;\n             private SealInterceptor sealInterceptor;\n             private ReadInterceptor readInterceptor;\n \n             TestStorage(SyncStorage syncStorage, Executor executor) {\n                 super(syncStorage, executor);\n                 this.wrappedStorage = syncStorage;\n+                this.startOffsets = new ConcurrentHashMap<>();\n+            }\n+\n+            @Override\n+            public CompletableFuture<Void> truncate(SegmentHandle handle, long offset, Duration timeout) {\n+                // We need to simulate the ChunkStorageProvider (correct) behavior for truncating segments. While the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ce2ebab10ebb12df081ed796169c92bca7e31c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MzY0Mw==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464573643", "createdAt": "2020-08-03T17:57:54Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -771,13 +837,39 @@ public void close() {\n \n         private class TestStorage extends AsyncStorageWrapper {\n             private final SyncStorage wrappedStorage;\n+            private final Map<String, Long> startOffsets;\n             private WriteInterceptor writeInterceptor;\n             private SealInterceptor sealInterceptor;\n             private ReadInterceptor readInterceptor;\n \n             TestStorage(SyncStorage syncStorage, Executor executor) {\n                 super(syncStorage, executor);\n                 this.wrappedStorage = syncStorage;\n+                this.startOffsets = new ConcurrentHashMap<>();\n+            }\n+\n+            @Override\n+            public CompletableFuture<Void> truncate(SegmentHandle handle, long offset, Duration timeout) {\n+                // We need to simulate the ChunkStorageProvider (correct) behavior for truncating segments. While the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0MjQ1OA=="}, "originalCommit": {"oid": "45ce2ebab10ebb12df081ed796169c92bca7e31c"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTMwNjA2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzoxOTo0MlrOG7B89Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzoyODoxN1rOG7COqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1MTE1Nw==", "bodyText": "Shall we add something like 'this is usually not a problem' ?\nIf this is not a problem then probably we could log it at info  level", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464551157", "createdAt": "2020-08-03T17:19:42Z", "author": {"login": "eolivelli"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -466,7 +466,20 @@ private long deserializeValue(ByteArraySegment value) {\n \n         return this.storage.getStreamSegmentInfo(handle.getSegmentName(), timeout)\n                 .thenApply(segmentInfo -> {\n+                    // Get the root pointer from the Segment's Core Attributes.\n                     long rootPointer = this.segmentMetadata.getAttributes().getOrDefault(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, BTreeIndex.IndexInfo.EMPTY.getRootPointer());\n+                    if (rootPointer != BTreeIndex.IndexInfo.EMPTY.getRootPointer() && rootPointer < segmentInfo.getStartOffset()) {\n+                        // The Root Pointer is invalid as it points to an offset prior to the Attribute Segment's Start Offset.\n+                        // The Attribute Segment is updated in 3 sequential steps: 1) Write new BTree pages, 2) Truncate and\n+                        // 3) Update root Pointer.\n+                        // The purpose of the Root Pointer is to provide a location of a consistently written update in case\n+                        // step 1) above fails (it is not atomic). However, if both 1) and 2) complete but 3) doesn't, then\n+                        // it's possible that the existing Root Pointer has been truncated out. In this case, it should be\n+                        // safe to ignore it and let the BTreeIndex read the file from the end (as it does in this case).\n+                        log.warn(\"{}: Root Pointer ({}) is below Attribute Segment's StartOffset ({}). Ignoring.\", this.traceObjectId, rootPointer, segmentInfo.getStartOffset());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ce2ebab10ebb12df081ed796169c92bca7e31c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTY5MQ==", "bodyText": "Good point. Making it info.", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464555691", "createdAt": "2020-08-03T17:28:17Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -466,7 +466,20 @@ private long deserializeValue(ByteArraySegment value) {\n \n         return this.storage.getStreamSegmentInfo(handle.getSegmentName(), timeout)\n                 .thenApply(segmentInfo -> {\n+                    // Get the root pointer from the Segment's Core Attributes.\n                     long rootPointer = this.segmentMetadata.getAttributes().getOrDefault(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, BTreeIndex.IndexInfo.EMPTY.getRootPointer());\n+                    if (rootPointer != BTreeIndex.IndexInfo.EMPTY.getRootPointer() && rootPointer < segmentInfo.getStartOffset()) {\n+                        // The Root Pointer is invalid as it points to an offset prior to the Attribute Segment's Start Offset.\n+                        // The Attribute Segment is updated in 3 sequential steps: 1) Write new BTree pages, 2) Truncate and\n+                        // 3) Update root Pointer.\n+                        // The purpose of the Root Pointer is to provide a location of a consistently written update in case\n+                        // step 1) above fails (it is not atomic). However, if both 1) and 2) complete but 3) doesn't, then\n+                        // it's possible that the existing Root Pointer has been truncated out. In this case, it should be\n+                        // safe to ignore it and let the BTreeIndex read the file from the end (as it does in this case).\n+                        log.warn(\"{}: Root Pointer ({}) is below Attribute Segment's StartOffset ({}). Ignoring.\", this.traceObjectId, rootPointer, segmentInfo.getStartOffset());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1MTE1Nw=="}, "originalCommit": {"oid": "45ce2ebab10ebb12df081ed796169c92bca7e31c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTMzNjA2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzoyODo0NFrOG7CPZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNzozMTo1NVrOG7CWHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTg3OA==", "bodyText": "A comment explaining how root pointer is always set to a previous value to simulate scenario and where truncation happens would be helpful.", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464555878", "createdAt": "2020-08-03T17:28:44Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -627,6 +631,68 @@ public void testRecoveryAfterIncompleteUpdate() {\n         checkIndex(idx2, expectedValues);\n     }\n \n+    /**\n+     * Tests the ability of the Attribute Index to recover correctly after an update has been successfully written to Storage,\n+     * but the previous value of the {@link Attributes#ATTRIBUTE_SEGMENT_ROOT_POINTER} has been truncated out without\n+     * having the new value persisted (most likely due to a system crash).\n+     * In this case, the {@link Attributes#ATTRIBUTE_SEGMENT_ROOT_POINTER} value should be ignored and the index should\n+     * be attempted to be read from Storage without providing hints to where to start reading from.\n+     */\n+    @Test\n+    public void testTruncatedRootPointer() {\n+        val attributeSegmentName = NameUtils.getAttributeSegmentName(SEGMENT_NAME);\n+        val config = AttributeIndexConfig\n+                .builder()\n+                .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 1024)\n+                .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 8)\n+                .build();\n+        final int attributeCount = 20;\n+        val attributes = IntStream.range(0, attributeCount).mapToObj(i -> new UUID(i, i)).collect(Collectors.toList());\n+        @Cleanup\n+        val context = new TestContext(config);\n+        populateSegments(context);\n+\n+        // 1. Populate and verify first index.\n+        val expectedValues = new HashMap<UUID, Long>();\n+        long nextValue = 0;\n+        long previousRootPointer = -1;\n+        boolean invalidRootPointer = false;\n+        for (UUID attributeId : attributes) {\n+            val idx = context.index.forSegment(SEGMENT_ID, TIMEOUT).join();\n+\n+            val value = nextValue++;\n+            expectedValues.put(attributeId, value);\n+            val updateBatch = Collections.singletonMap(attributeId, value);\n+\n+            val rootPointer = idx.update(updateBatch, TIMEOUT).join();\n+            val startOffset = context.storage.getStreamSegmentInfo(attributeSegmentName, TIMEOUT).join().getStartOffset();\n+            if (previousRootPointer >= 0) {\n+                context.containerMetadata.getStreamSegmentMetadata(SEGMENT_ID)\n+                        .updateAttributes(Collections.singletonMap(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, previousRootPointer));\n+                invalidRootPointer |= previousRootPointer < startOffset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45ce2ebab10ebb12df081ed796169c92bca7e31c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NzU5OQ==", "bodyText": "Thanks for adding comment.", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464557599", "createdAt": "2020-08-03T17:31:55Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -627,6 +631,68 @@ public void testRecoveryAfterIncompleteUpdate() {\n         checkIndex(idx2, expectedValues);\n     }\n \n+    /**\n+     * Tests the ability of the Attribute Index to recover correctly after an update has been successfully written to Storage,\n+     * but the previous value of the {@link Attributes#ATTRIBUTE_SEGMENT_ROOT_POINTER} has been truncated out without\n+     * having the new value persisted (most likely due to a system crash).\n+     * In this case, the {@link Attributes#ATTRIBUTE_SEGMENT_ROOT_POINTER} value should be ignored and the index should\n+     * be attempted to be read from Storage without providing hints to where to start reading from.\n+     */\n+    @Test\n+    public void testTruncatedRootPointer() {\n+        val attributeSegmentName = NameUtils.getAttributeSegmentName(SEGMENT_NAME);\n+        val config = AttributeIndexConfig\n+                .builder()\n+                .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 1024)\n+                .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 8)\n+                .build();\n+        final int attributeCount = 20;\n+        val attributes = IntStream.range(0, attributeCount).mapToObj(i -> new UUID(i, i)).collect(Collectors.toList());\n+        @Cleanup\n+        val context = new TestContext(config);\n+        populateSegments(context);\n+\n+        // 1. Populate and verify first index.\n+        val expectedValues = new HashMap<UUID, Long>();\n+        long nextValue = 0;\n+        long previousRootPointer = -1;\n+        boolean invalidRootPointer = false;\n+        for (UUID attributeId : attributes) {\n+            val idx = context.index.forSegment(SEGMENT_ID, TIMEOUT).join();\n+\n+            val value = nextValue++;\n+            expectedValues.put(attributeId, value);\n+            val updateBatch = Collections.singletonMap(attributeId, value);\n+\n+            val rootPointer = idx.update(updateBatch, TIMEOUT).join();\n+            val startOffset = context.storage.getStreamSegmentInfo(attributeSegmentName, TIMEOUT).join().getStartOffset();\n+            if (previousRootPointer >= 0) {\n+                context.containerMetadata.getStreamSegmentMetadata(SEGMENT_ID)\n+                        .updateAttributes(Collections.singletonMap(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, previousRootPointer));\n+                invalidRootPointer |= previousRootPointer < startOffset;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTg3OA=="}, "originalCommit": {"oid": "45ce2ebab10ebb12df081ed796169c92bca7e31c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTQ5NTY3OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODoxMjo1M1rOG7DyVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODoxMjo1M1rOG7DyVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTIwNg==", "bodyText": "ChunkStorageProvide  ->  ChunkedSegmentStorage", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464581206", "createdAt": "2020-08-03T18:12:53Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -771,13 +841,39 @@ public void close() {\n \n         private class TestStorage extends AsyncStorageWrapper {\n             private final SyncStorage wrappedStorage;\n+            private final Map<String, Long> startOffsets;\n             private WriteInterceptor writeInterceptor;\n             private SealInterceptor sealInterceptor;\n             private ReadInterceptor readInterceptor;\n \n             TestStorage(SyncStorage syncStorage, Executor executor) {\n                 super(syncStorage, executor);\n                 this.wrappedStorage = syncStorage;\n+                this.startOffsets = new ConcurrentHashMap<>();\n+            }\n+\n+            @Override\n+            public CompletableFuture<Void> truncate(SegmentHandle handle, long offset, Duration timeout) {\n+                // We need to simulate the ChunkedSegmentStorage (correct) behavior for truncating segments. While the\n+                // legacy RollingStorage would approximate a StartOffset to an offset at most equal to the requested\n+                // Truncation Offset, the ChunkedSegmentStorage is very strict about that, so it will deny any read prior\n+                // to that offset. In addition, the ChunkStorageProvide also returns the correct StartOffset as part of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1229aad00c44e6ec18461b17192c5019465e8bd3"}, "originalPosition": 114}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4842, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}