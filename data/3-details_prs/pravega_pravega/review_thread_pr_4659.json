{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NTc5Mjcy", "number": 4659, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMDo1OTo0NlrODtVugg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMTo1OTo1NVrODtWVUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODY4NDgyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableClientConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMDo1OTo0NlrOF-tU1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo1MzoxNVrOF_EeTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5ODY0Nw==", "bodyText": "By default this results in only retrying for ~10s. Is this intended?", "url": "https://github.com/pravega/pravega/pull/4659#discussion_r401298647", "createdAt": "2020-04-01T00:59:46Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableClientConfiguration.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Preconditions;\n+import java.io.Serializable;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+/**\n+ * Configuration for the {@link KeyValueTable} client.\n+ */\n+@Beta\n+@Data\n+@Builder\n+public class KeyValueTableClientConfiguration implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+    private final int initialBackoffMillis;\n+    private final int maxBackoffMillis;\n+    private final int retryAttempts;\n+    private final int backoffMultiple;\n+\n+    public static final class KeyValueTableClientConfigurationBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdc9fe91814982b24e2300d5a2e7f29cee25e1a7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3NzkwMg==", "bodyText": "The maximum retry wait is 10s (10ms * 2^10). But it will try 10ms, 20ms, 40ms, ...., 1s, 2.5s, 5s, 10s.\nThat still looks too frequent. I changed the multiplier to 4; that should stagger it a bit.", "url": "https://github.com/pravega/pravega/pull/4659#discussion_r401677902", "createdAt": "2020-04-01T14:53:15Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableClientConfiguration.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Preconditions;\n+import java.io.Serializable;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+/**\n+ * Configuration for the {@link KeyValueTable} client.\n+ */\n+@Beta\n+@Data\n+@Builder\n+public class KeyValueTableClientConfiguration implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+    private final int initialBackoffMillis;\n+    private final int maxBackoffMillis;\n+    private final int retryAttempts;\n+    private final int backoffMultiple;\n+\n+    public static final class KeyValueTableClientConfigurationBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5ODY0Nw=="}, "originalCommit": {"oid": "fdc9fe91814982b24e2300d5a2e7f29cee25e1a7"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODc3ODMzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentIterator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMTo1NjoyOVrOF-uMZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo1NDozOVrOF_EiuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxMjg2OQ==", "bodyText": "These two operations being non-atomic leads to a bazar possibility of passing the closed check at the top and getting an NPE on 46 if calling getNext from multiple threads concurrently.\nI am also not sure it makes sense to call getNext concurrently. It seems like the fetchNext function should not be invoked multiple times in parallel. (Though multiple times before the futures return does make sense)", "url": "https://github.com/pravega/pravega/pull/4659#discussion_r401312869", "createdAt": "2020-04-01T01:56:29Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentIterator.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.pravega.client.tables.IteratorItem;\n+import io.pravega.client.tables.IteratorState;\n+import io.pravega.common.ObjectClosedException;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import lombok.NonNull;\n+\n+/**\n+ * Iterator over Table Segment Keys or Values.\n+ *\n+ * @param <T> Type of item iterated over. Usually {@link TableSegmentKey} or {@link TableSegmentEntry}.\n+ */\n+class TableSegmentIterator<T> implements AsyncIterator<IteratorItem<T>> {\n+    private final Function<IteratorState, CompletableFuture<IteratorItem<T>>> fetchNext;\n+    private final AtomicReference<IteratorState> state;\n+    private final AtomicBoolean closed;\n+\n+    TableSegmentIterator(@NonNull Function<IteratorState, CompletableFuture<IteratorItem<T>>> fetchNext, IteratorState initialState) {\n+        this.fetchNext = fetchNext;\n+        this.state = new AtomicReference<>(initialState);\n+        this.closed = new AtomicBoolean(false);\n+    }\n+\n+    @Override\n+    public CompletableFuture<IteratorItem<T>> getNext() {\n+        if (this.closed.get()) {\n+            // We are done.\n+            return CompletableFuture.completedFuture(null);\n+        }\n+\n+        CompletableFuture<IteratorItem<T>> result = this.fetchNext.apply(this.state.get())\n+                .thenApply(r -> {\n+                    if (r == null) {\n+                        // We are done.\n+                        this.state.set(null);\n+                        this.closed.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdc9fe91814982b24e2300d5a2e7f29cee25e1a7"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3OTAzMg==", "bodyText": "This implements AsyncIterator which provides an asSequential wrapper (built-in) that guarantees getNext cannot be executed concurrently (if invoked concurrently, the executions will be serialized).\nSo no worries here.", "url": "https://github.com/pravega/pravega/pull/4659#discussion_r401679032", "createdAt": "2020-04-01T14:54:39Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentIterator.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.pravega.client.tables.IteratorItem;\n+import io.pravega.client.tables.IteratorState;\n+import io.pravega.common.ObjectClosedException;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import lombok.NonNull;\n+\n+/**\n+ * Iterator over Table Segment Keys or Values.\n+ *\n+ * @param <T> Type of item iterated over. Usually {@link TableSegmentKey} or {@link TableSegmentEntry}.\n+ */\n+class TableSegmentIterator<T> implements AsyncIterator<IteratorItem<T>> {\n+    private final Function<IteratorState, CompletableFuture<IteratorItem<T>>> fetchNext;\n+    private final AtomicReference<IteratorState> state;\n+    private final AtomicBoolean closed;\n+\n+    TableSegmentIterator(@NonNull Function<IteratorState, CompletableFuture<IteratorItem<T>>> fetchNext, IteratorState initialState) {\n+        this.fetchNext = fetchNext;\n+        this.state = new AtomicReference<>(initialState);\n+        this.closed = new AtomicBoolean(false);\n+    }\n+\n+    @Override\n+    public CompletableFuture<IteratorItem<T>> getNext() {\n+        if (this.closed.get()) {\n+            // We are done.\n+            return CompletableFuture.completedFuture(null);\n+        }\n+\n+        CompletableFuture<IteratorItem<T>> result = this.fetchNext.apply(this.state.get())\n+                .thenApply(r -> {\n+                    if (r == null) {\n+                        // We are done.\n+                        this.state.set(null);\n+                        this.closed.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxMjg2OQ=="}, "originalCommit": {"oid": "fdc9fe91814982b24e2300d5a2e7f29cee25e1a7"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODc4NDE2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMTo1OTo1NVrOF-uPxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo1NjoxOVrOF_Enpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxMzczMg==", "bodyText": "This is a primitive right?", "url": "https://github.com/pravega/pravega/pull/4659#discussion_r401313732", "createdAt": "2020-04-01T01:59:55Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentKey.java", "diffHunk": "@@ -98,4 +98,13 @@ public static TableSegmentKey notExists(byte[] key) {\n     }\n \n     //endregion\n+\n+    /**\n+     * Gets a value indicating whether this key exists/should exist.\n+     *\n+     * @return True if the key exists/should exist, false otherwise.\n+     */\n+    boolean exists() {\n+        return getVersion().getSegmentVersion() != TableSegmentKeyVersion.NOT_EXISTS.getSegmentVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdc9fe91814982b24e2300d5a2e7f29cee25e1a7"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY4MDI5NA==", "bodyText": "I don't understand. What do you mean by primitive?\nDo you mean the special values for NOT_EXISTS and NO_VERSION? Those are drawn from WireCommands.TableKey.NOT_EXISTS/NO_VERSION, which are sync-ed with the server-side values.", "url": "https://github.com/pravega/pravega/pull/4659#discussion_r401680294", "createdAt": "2020-04-01T14:56:19Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentKey.java", "diffHunk": "@@ -98,4 +98,13 @@ public static TableSegmentKey notExists(byte[] key) {\n     }\n \n     //endregion\n+\n+    /**\n+     * Gets a value indicating whether this key exists/should exist.\n+     *\n+     * @return True if the key exists/should exist, false otherwise.\n+     */\n+    boolean exists() {\n+        return getVersion().getSegmentVersion() != TableSegmentKeyVersion.NOT_EXISTS.getSegmentVersion();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxMzczMg=="}, "originalCommit": {"oid": "fdc9fe91814982b24e2300d5a2e7f29cee25e1a7"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4477, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}