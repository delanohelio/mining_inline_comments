{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMjQ4MTc2", "number": 5402, "title": "Issue 5401: Fixing resource leaks in tests", "bodyText": "Change log description\n\nModified ExecutorServiceHelpers to accept a mode where it can track ExecutorServices it creates that are reclaimed by the GC prior to being shut down.\nCleaning up all ExecutorService instances that we create, which were found using the above method.\nAdded @Cleanup to several places in tests where they should have been before.\n\nPurpose of the change\nFixes #5401.\nWhat the code does\n\nExecutorServiceHelpers delegates new thread pool creation to ExecutorServiceFactory\nExecutorServiceFactory\n\nDefines a \"thread leak detection level\" which is automatically picked from System Properties.\n\nNone: No detection. All thread pools are the ones that come from the JDK\nLight: Returns a thread pool derived from the JDK one that overrides the finalize method. If the thread pool is still running when this method is invoked (i.e., GC is culling it), it logs a WARN message with a stack trace indicating where the thread pool was created from.\nAggressive: Same as Light, but additionally shuts down the VM when a thread leak is detected (see below for more details)\n\n\n\n\nbuild.gradle\n\nSetting ThreadPoolLeakDetectionLevel to Aggressive for all builds (and only for builds). This will ensure that future changes will not reintroduce new such leaks.\n\n\nMore details and thoughts:\n\nThe point of Aggressive shutting down the VM is to stop (fail) the build if such a leak is detected in unit or integration tests. Since the finalize method is run on the GC threads, it is impossible to raise an AssertionError that would bubble up to some test (the test that caused it may have even finished long before). To prevent a simple WARN from being lost (and ignored), this option stops the VM and the developer will need to inspect the last few lines of logs to figure out the source of the leak.\n\nThis method has been used in this PR to hunt down all leaks reported by the build.\n\n\nThe thread leak detection level is turned off by default, so production code will not be affected. No code path in this case can even come near the System.exit(99) code that halts the VM.\nIn case we want to check for such leaks in production, we can enable the Light detection and then watch out for WARNS. Again, there is no risk in this case that the VM will halt (unit tests have been written to ensure this), and this method is non-invasive, so it may be preferred in various functional, system and longevity tests.\n\n\n\nHow to verify it\nBuild must pass.", "createdAt": "2020-12-04T02:54:20Z", "url": "https://github.com/pravega/pravega/pull/5402", "merged": true, "mergeCommit": {"oid": "945329ea6530a5f66855de97a0c637594b763bf1"}, "closed": true, "closedAt": "2020-12-08T21:30:53Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiupFTAH2gAyNTMyMjQ4MTc2OjU2MjgwYzM5MTE2ZDZkYTRmOTEyOGQ5NWZmMzcwYjBmMjE2YzM1Y2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkVlgegFqTU0Nzc5NTI5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "56280c39116d6da4f9128d95ff370b0f216c35ca", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/56280c39116d6da4f9128d95ff370b0f216c35ca", "committedDate": "2020-12-04T02:51:10Z", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31f4f12088b81e94b95052aaead8ab2f1a6f969f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/31f4f12088b81e94b95052aaead8ab2f1a6f969f", "committedDate": "2020-12-04T02:51:50Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5401-leaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e13a9b5adf4e099bf82bc0aa9c63b789043e4e7", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/7e13a9b5adf4e099bf82bc0aa9c63b789043e4e7", "committedDate": "2020-12-04T15:58:00Z", "message": "Merge branch 'master' into issue-5401-leaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "808c8639aaa85dcb2bd262d71f0541e6307a50c6", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/808c8639aaa85dcb2bd262d71f0541e6307a50c6", "committedDate": "2020-12-04T17:56:48Z", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eceac8e181d33f08971d6d0507cd3259f882913b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/eceac8e181d33f08971d6d0507cd3259f882913b", "committedDate": "2020-12-04T17:56:58Z", "message": "Merge remote-tracking branch 'ap/issue-5401-leaks' into issue-5401-leaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c6822524f655e6c79e57c65f371b26c0e9b6e1f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/4c6822524f655e6c79e57c65f371b26c0e9b6e1f", "committedDate": "2020-12-04T19:18:49Z", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28f1bfecd5e313a392dbeb0ea6b322bdc5f3e20c", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/28f1bfecd5e313a392dbeb0ea6b322bdc5f3e20c", "committedDate": "2020-12-04T21:37:33Z", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a9a4b48a022492891d25e01f10f8e2602f4ee83", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/9a9a4b48a022492891d25e01f10f8e2602f4ee83", "committedDate": "2020-12-05T01:49:01Z", "message": "Reverting debug settings.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3467ff699cfeb2b8702e132d6b678e7a68b7591b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/3467ff699cfeb2b8702e132d6b678e7a68b7591b", "committedDate": "2020-12-05T21:58:59Z", "message": "Debugging leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1048e4034b42ee225020b909ce284b0f9aa92dd4", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/1048e4034b42ee225020b909ce284b0f9aa92dd4", "committedDate": "2020-12-06T03:18:47Z", "message": "Trying to clean more stuff.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efb02ac7b323deb05782d41083c4973d03c88e56", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/efb02ac7b323deb05782d41083c4973d03c88e56", "committedDate": "2020-12-06T03:51:52Z", "message": "Trying to clean more stuff.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b63c9945581f703f05c992285bdc66591bbec3f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/2b63c9945581f703f05c992285bdc66591bbec3f", "committedDate": "2020-12-06T18:37:57Z", "message": "Handling controller client shutdown exceptions that would prevent subsequent resources from being cleaned up.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "632e22a01706fe7231e55c65c282c9f9e48fe9d0", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/632e22a01706fe7231e55c65c282c9f9e48fe9d0", "committedDate": "2020-12-06T19:17:58Z", "message": "Merge branch 'master' into issue-5401-leaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "787780c50aa566e87a4f305156150f364f374d85", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/787780c50aa566e87a4f305156150f364f374d85", "committedDate": "2020-12-07T16:28:13Z", "message": "Merge branch 'master' into issue-5401-leaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MzM5Mjkw", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-546339290", "createdAt": "2020-12-07T16:51:34Z", "commit": {"oid": "787780c50aa566e87a4f305156150f364f374d85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjo1MTozNFrOIAwR5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjo1MTozNFrOIAwR5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MTkyNQ==", "bodyText": "Should all callers of close() use this invokeSafely() helper? Such as KeyValueTableManagerImpl above?", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537661925", "createdAt": "2020-12-07T16:51:34Z", "author": {"login": "derekm"}, "path": "client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java", "diffHunk": "@@ -208,7 +207,7 @@ public StreamInfo getStreamInfo(String scopeName, String streamName) {\n     @Override\n     public void close() {\n         if (this.controller != null) {\n-            this.controller.close();\n+            Callbacks.invokeSafely(this.controller::close, ex -> log.error(\"Unable to close Controller client.\", ex));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "787780c50aa566e87a4f305156150f364f374d85"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MzQxNjcw", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-546341670", "createdAt": "2020-12-07T16:54:10Z", "commit": {"oid": "787780c50aa566e87a4f305156150f364f374d85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjo1NDoxMFrOIAwZrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjo1NDoxMFrOIAwZrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MzkxOA==", "bodyText": "Is this close() redundant to the @Cleanup annotation a few lines above?", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537663918", "createdAt": "2020-12-07T16:54:10Z", "author": {"login": "derekm"}, "path": "client/src/test/java/io/pravega/client/stream/impl/ClientFactoryTest.java", "diffHunk": "@@ -105,8 +106,10 @@ public void testEventWriterSealedStream() {\n                 .thenReturn(CompletableFuture.completedFuture(currentSegments));\n \n         EventWriterConfig writerConfig = EventWriterConfig.builder().build();\n+        @Cleanup\n         EventStreamWriter<String> writer = clientFactory.createEventWriter(stream, new JavaSerializer<String>(), writerConfig);\n         assertEquals(writerConfig, writer.getConfig());\n+        writer.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "787780c50aa566e87a4f305156150f364f374d85"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/99fdf51000e6e49355c1b74d382156716a76aadc", "committedDate": "2020-12-07T18:03:44Z", "message": "Unit test coverage.\nRemoving debugging code.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61b665232694f5bee424f87de637d2c36836633e", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/61b665232694f5bee424f87de637d2c36836633e", "committedDate": "2020-12-07T20:30:41Z", "message": "Merge branch 'master' into issue-5401-leaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDYwOTIy", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-546460922", "createdAt": "2020-12-07T19:21:49Z", "commit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOToyMTo0OVrOIA2ogw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTozMToyMFrOIA3Abg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NjAxOQ==", "bodyText": "Maybe something should be printed to standard error in addition to the system exit.", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537766019", "createdAt": "2020-12-07T19:21:49Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceFactory.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Creates Thread Pools for use within Pravega codebase.\n+ */\n+@Slf4j\n+final class ExecutorServiceFactory {\n+    //region Members\n+\n+    @VisibleForTesting\n+    static final String DETECTION_LEVEL_PROPERTY_NAME = \"ThreadLeakDetectionLevel\";\n+    @VisibleForTesting\n+    private final ThreadLeakDetectionLevel detectionLevel;\n+    private final CreateScheduledExecutor createScheduledExecutor;\n+    private final CreateShrinkingExecutor createShrinkingExecutor;\n+    private final Runnable onLeakDetected;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory} which extracts the {@link ThreadLeakDetectionLevel}\n+     * from system properties and halts the VM if a leak is detected and {@link ThreadLeakDetectionLevel} is set to\n+     * {@link ThreadLeakDetectionLevel#Aggressive}.\n+     */\n+    ExecutorServiceFactory() {\n+        this(getDetectionLevel(), () -> System.exit(99));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTI4NA==", "bodyText": "We probably only want to capture this stack trace if the level is not \"none\".", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537769284", "createdAt": "2020-12-07T19:27:00Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceFactory.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Creates Thread Pools for use within Pravega codebase.\n+ */\n+@Slf4j\n+final class ExecutorServiceFactory {\n+    //region Members\n+\n+    @VisibleForTesting\n+    static final String DETECTION_LEVEL_PROPERTY_NAME = \"ThreadLeakDetectionLevel\";\n+    @VisibleForTesting\n+    private final ThreadLeakDetectionLevel detectionLevel;\n+    private final CreateScheduledExecutor createScheduledExecutor;\n+    private final CreateShrinkingExecutor createShrinkingExecutor;\n+    private final Runnable onLeakDetected;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory} which extracts the {@link ThreadLeakDetectionLevel}\n+     * from system properties and halts the VM if a leak is detected and {@link ThreadLeakDetectionLevel} is set to\n+     * {@link ThreadLeakDetectionLevel#Aggressive}.\n+     */\n+    ExecutorServiceFactory() {\n+        this(getDetectionLevel(), () -> System.exit(99));\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory}.\n+     *\n+     * @param level          The {@link ThreadLeakDetectionLevel} to use.\n+     * @param onLeakDetected A {@link Runnable} that will be invoked if {@link ThreadLeakDetectionLevel} is set to\n+     *                       {@link ThreadLeakDetectionLevel#Aggressive} and a leak is detected.\n+     */\n+    @VisibleForTesting\n+    ExecutorServiceFactory(@NonNull ThreadLeakDetectionLevel level, @NonNull Runnable onLeakDetected) {\n+        this.detectionLevel = level;\n+        this.onLeakDetected = onLeakDetected;\n+\n+        // In all of the below, the ThreadFactory is created in this class, and its toString() returns the pool name.\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.None) {\n+            this.createScheduledExecutor = (size, factory) -> new ScheduledThreadPoolExecutor(size, factory, new CallerRuns(factory.toString()));\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) ->\n+                    new ThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                            new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+        } else {\n+            // Light and Aggressive need a special executor that overrides the finalize() method.\n+            this.createScheduledExecutor = (size, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorScheduledExecutorService(size, factory, new CallerRuns(factory.toString()));\n+            };\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                        new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+            };\n+        }\n+    }\n+\n+    /**\n+     * Gets the {@link ThreadLeakDetectionLevel} from System Properties (Key = {@link #DETECTION_LEVEL_PROPERTY_NAME}).\n+     *\n+     * @return The {@link ThreadLeakDetectionLevel}, or {@link ThreadLeakDetectionLevel#None} if not defined in System\n+     * Properties.\n+     * @throws IllegalArgumentException If the system property defines a value is not valid.\n+     */\n+    @VisibleForTesting\n+    static ThreadLeakDetectionLevel getDetectionLevel() {\n+        return ThreadLeakDetectionLevel.valueOf(\n+                System.getProperty(\"ThreadLeakDetectionLevel\", ThreadLeakDetectionLevel.None.name()));\n+    }\n+\n+    //endregion\n+\n+    //region Factory Methods\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix.\n+     *\n+     * @param groupName the name of the threads\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName) {\n+        return getThreadFactory(groupName, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix and thread priority.\n+     *\n+     * @param groupName the name of the threads\n+     * @param priority  the priority to be assigned to the thread.\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName, int priority) {\n+        return new ThreadFactory() {\n+            final AtomicInteger threadCount = new AtomicInteger();\n+\n+            @Override\n+            public String toString() {\n+                return groupName;\n+            }\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r, groupName + \"-\" + threadCount.incrementAndGet());\n+                thread.setUncaughtExceptionHandler(new LogUncaughtExceptions());\n+                thread.setDaemon(true);\n+                thread.setPriority(priority);\n+                return thread;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a new ScheduledExecutorService that will use daemon threads with specified priority and names.\n+     *\n+     * @param size           The number of threads in the threadpool\n+     * @param poolName       The name of the pool (this will be printed in logs)\n+     * @param threadPriority The priority to be assigned to the threads\n+     * @return A new executor service.\n+     */\n+    ScheduledExecutorService newScheduledThreadPool(int size, String poolName, int threadPriority) {\n+        ThreadFactory threadFactory = getThreadFactory(poolName, threadPriority);\n+\n+        // Caller runs only occurs after shutdown, as queue size is unbounded.\n+        ScheduledThreadPoolExecutor result = this.createScheduledExecutor.apply(size, threadFactory);\n+\n+        // Do not execute any periodic tasks after shutdown.\n+        result.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n+\n+        // Do not execute any delayed tasks after shutdown.\n+        result.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+\n+        // Remove tasks from the executor once they are done executing. By default, even when canceled, these tasks are\n+        // not removed; if this setting is not enabled we could end up with leaked (and obsolete) tasks.\n+        result.setRemoveOnCancelPolicy(true);\n+        return result;\n+    }\n+\n+    /**\n+     * Operates like Executors.cachedThreadPool but with a custom thread timeout and pool name.\n+     *\n+     * @param maxThreadCount The maximum number of threads to allow in the pool.\n+     * @param threadTimeout  the number of milliseconds that a thread should sit idle before shutting down.\n+     * @param poolName       The name of the threadpool.\n+     * @return A new threadPool\n+     */\n+    ThreadPoolExecutor newShrinkingExecutor(int maxThreadCount, int threadTimeout, String poolName) {\n+        ThreadFactory factory = getThreadFactory(poolName);\n+        return this.createShrinkingExecutor.apply(maxThreadCount, threadTimeout, factory);\n+    }\n+\n+    //endregion\n+\n+    //region ThreadFactory Helper Classes\n+\n+    private static final class LogUncaughtExceptions implements Thread.UncaughtExceptionHandler {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+            log.error(\"Exception thrown out of root of thread: \" + t.getName(), e);\n+        }\n+    }\n+\n+    @Data\n+    private static class CallerRuns implements RejectedExecutionHandler {\n+        private final String poolName;\n+\n+        @Override\n+        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n+            log.debug(\"Caller to executor: \" + poolName + \" rejected and run in the caller.\");\n+            r.run();\n+        }\n+    }\n+\n+    //endregion\n+\n+    //region Leak Detection Pools\n+\n+    private class LeakDetectorScheduledExecutorService extends ScheduledThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorScheduledExecutorService(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, threadFactory, handler);\n+            this.stackTraceEx = new Exception();\n+        }\n+\n+        protected void finalize() {\n+            checkThreadPoolLeak(this, this.stackTraceEx);\n+            super.finalize();\n+        }\n+    }\n+\n+    private class LeakDetectorThreadPoolExecutor extends ThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,\n+                                       ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n+            this.stackTraceEx = new Exception();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MDkyNA==", "bodyText": "It's a bit odd that onLeakDetected is defined elsewhere given that it is only invoked in this Agressive code path. I think this can reasonably be inlined.", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537770924", "createdAt": "2020-12-07T19:29:26Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceFactory.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Creates Thread Pools for use within Pravega codebase.\n+ */\n+@Slf4j\n+final class ExecutorServiceFactory {\n+    //region Members\n+\n+    @VisibleForTesting\n+    static final String DETECTION_LEVEL_PROPERTY_NAME = \"ThreadLeakDetectionLevel\";\n+    @VisibleForTesting\n+    private final ThreadLeakDetectionLevel detectionLevel;\n+    private final CreateScheduledExecutor createScheduledExecutor;\n+    private final CreateShrinkingExecutor createShrinkingExecutor;\n+    private final Runnable onLeakDetected;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory} which extracts the {@link ThreadLeakDetectionLevel}\n+     * from system properties and halts the VM if a leak is detected and {@link ThreadLeakDetectionLevel} is set to\n+     * {@link ThreadLeakDetectionLevel#Aggressive}.\n+     */\n+    ExecutorServiceFactory() {\n+        this(getDetectionLevel(), () -> System.exit(99));\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory}.\n+     *\n+     * @param level          The {@link ThreadLeakDetectionLevel} to use.\n+     * @param onLeakDetected A {@link Runnable} that will be invoked if {@link ThreadLeakDetectionLevel} is set to\n+     *                       {@link ThreadLeakDetectionLevel#Aggressive} and a leak is detected.\n+     */\n+    @VisibleForTesting\n+    ExecutorServiceFactory(@NonNull ThreadLeakDetectionLevel level, @NonNull Runnable onLeakDetected) {\n+        this.detectionLevel = level;\n+        this.onLeakDetected = onLeakDetected;\n+\n+        // In all of the below, the ThreadFactory is created in this class, and its toString() returns the pool name.\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.None) {\n+            this.createScheduledExecutor = (size, factory) -> new ScheduledThreadPoolExecutor(size, factory, new CallerRuns(factory.toString()));\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) ->\n+                    new ThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                            new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+        } else {\n+            // Light and Aggressive need a special executor that overrides the finalize() method.\n+            this.createScheduledExecutor = (size, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorScheduledExecutorService(size, factory, new CallerRuns(factory.toString()));\n+            };\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                        new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+            };\n+        }\n+    }\n+\n+    /**\n+     * Gets the {@link ThreadLeakDetectionLevel} from System Properties (Key = {@link #DETECTION_LEVEL_PROPERTY_NAME}).\n+     *\n+     * @return The {@link ThreadLeakDetectionLevel}, or {@link ThreadLeakDetectionLevel#None} if not defined in System\n+     * Properties.\n+     * @throws IllegalArgumentException If the system property defines a value is not valid.\n+     */\n+    @VisibleForTesting\n+    static ThreadLeakDetectionLevel getDetectionLevel() {\n+        return ThreadLeakDetectionLevel.valueOf(\n+                System.getProperty(\"ThreadLeakDetectionLevel\", ThreadLeakDetectionLevel.None.name()));\n+    }\n+\n+    //endregion\n+\n+    //region Factory Methods\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix.\n+     *\n+     * @param groupName the name of the threads\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName) {\n+        return getThreadFactory(groupName, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix and thread priority.\n+     *\n+     * @param groupName the name of the threads\n+     * @param priority  the priority to be assigned to the thread.\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName, int priority) {\n+        return new ThreadFactory() {\n+            final AtomicInteger threadCount = new AtomicInteger();\n+\n+            @Override\n+            public String toString() {\n+                return groupName;\n+            }\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r, groupName + \"-\" + threadCount.incrementAndGet());\n+                thread.setUncaughtExceptionHandler(new LogUncaughtExceptions());\n+                thread.setDaemon(true);\n+                thread.setPriority(priority);\n+                return thread;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a new ScheduledExecutorService that will use daemon threads with specified priority and names.\n+     *\n+     * @param size           The number of threads in the threadpool\n+     * @param poolName       The name of the pool (this will be printed in logs)\n+     * @param threadPriority The priority to be assigned to the threads\n+     * @return A new executor service.\n+     */\n+    ScheduledExecutorService newScheduledThreadPool(int size, String poolName, int threadPriority) {\n+        ThreadFactory threadFactory = getThreadFactory(poolName, threadPriority);\n+\n+        // Caller runs only occurs after shutdown, as queue size is unbounded.\n+        ScheduledThreadPoolExecutor result = this.createScheduledExecutor.apply(size, threadFactory);\n+\n+        // Do not execute any periodic tasks after shutdown.\n+        result.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n+\n+        // Do not execute any delayed tasks after shutdown.\n+        result.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+\n+        // Remove tasks from the executor once they are done executing. By default, even when canceled, these tasks are\n+        // not removed; if this setting is not enabled we could end up with leaked (and obsolete) tasks.\n+        result.setRemoveOnCancelPolicy(true);\n+        return result;\n+    }\n+\n+    /**\n+     * Operates like Executors.cachedThreadPool but with a custom thread timeout and pool name.\n+     *\n+     * @param maxThreadCount The maximum number of threads to allow in the pool.\n+     * @param threadTimeout  the number of milliseconds that a thread should sit idle before shutting down.\n+     * @param poolName       The name of the threadpool.\n+     * @return A new threadPool\n+     */\n+    ThreadPoolExecutor newShrinkingExecutor(int maxThreadCount, int threadTimeout, String poolName) {\n+        ThreadFactory factory = getThreadFactory(poolName);\n+        return this.createShrinkingExecutor.apply(maxThreadCount, threadTimeout, factory);\n+    }\n+\n+    //endregion\n+\n+    //region ThreadFactory Helper Classes\n+\n+    private static final class LogUncaughtExceptions implements Thread.UncaughtExceptionHandler {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+            log.error(\"Exception thrown out of root of thread: \" + t.getName(), e);\n+        }\n+    }\n+\n+    @Data\n+    private static class CallerRuns implements RejectedExecutionHandler {\n+        private final String poolName;\n+\n+        @Override\n+        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n+            log.debug(\"Caller to executor: \" + poolName + \" rejected and run in the caller.\");\n+            r.run();\n+        }\n+    }\n+\n+    //endregion\n+\n+    //region Leak Detection Pools\n+\n+    private class LeakDetectorScheduledExecutorService extends ScheduledThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorScheduledExecutorService(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, threadFactory, handler);\n+            this.stackTraceEx = new Exception();\n+        }\n+\n+        protected void finalize() {\n+            checkThreadPoolLeak(this, this.stackTraceEx);\n+            super.finalize();\n+        }\n+    }\n+\n+    private class LeakDetectorThreadPoolExecutor extends ThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,\n+                                       ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n+            this.stackTraceEx = new Exception();\n+        }\n+\n+        protected void finalize() {\n+            checkThreadPoolLeak(this, this.stackTraceEx);\n+            super.finalize();\n+        }\n+    }\n+\n+    private void logNewThreadPoolCreated(String poolName) {\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.Light) {\n+            log.debug(\"Created Thread Pool '{}' with leak detection level set to '{}'.\", poolName, this.detectionLevel);\n+        } else if (this.detectionLevel == ThreadLeakDetectionLevel.Aggressive) {\n+            log.warn(\"Created Thread Pool '{}' with leak detection level set to '{}'. THE VM WILL BE HALTED IF A LEAK IS DETECTED. DO NOT USE IN PRODUCTION.\", poolName, this.detectionLevel);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    void checkThreadPoolLeak(ThreadPoolExecutor e, Exception stackTraceEx) {\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.None) {\n+            // Not doing anything in this case.\n+            return;\n+        }\n+\n+        if (!e.isShutdown() || !e.isTerminated()) {\n+            log.warn(\"THREAD POOL LEAK: {} (ShutDown={}, Terminated={}) finalized without being properly shut down.\",\n+                    e.getThreadFactory(), e.isShutdown(), e.isTerminated(), stackTraceEx);\n+            if (this.detectionLevel == ThreadLeakDetectionLevel.Aggressive) {\n+                // Not pretty, but outputting this stack trace on System.err helps with those unit tests that turned off\n+                // logging.\n+                stackTraceEx.printStackTrace(System.err);\n+                log.error(\"THREAD POOL LEAK DETECTED WITH LEVEL SET TO {}. SHUTTING DOWN.\", ThreadLeakDetectionLevel.Aggressive);\n+                this.onLeakDetected.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MjE0Mg==", "bodyText": "This call does not block on the GC actually being performed. It merely sets a flag saying it should be done.\nI don't think there is a way to get this to do what you want.", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537772142", "createdAt": "2020-12-07T19:31:20Z", "author": {"login": "tkaitchuck"}, "path": "common/src/test/java/io/pravega/common/concurrent/ExecutorServiceFactoryTests.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import io.pravega.test.common.IntentionalException;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import lombok.Cleanup;\n+import lombok.val;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Unit tests for the {@link ExecutorServiceFactory} class.\n+ */\n+public class ExecutorServiceFactoryTests {\n+    @After\n+    public void tearDown() {\n+        // Invoke GC and finalization - this will make sure that we catch any leftover thread pools\n+        System.gc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjYzMzg4", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-546663388", "createdAt": "2020-12-08T00:57:29Z", "commit": {"oid": "61b665232694f5bee424f87de637d2c36836633e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a479a0bfeb546fc10eb53a0820e96657208d2dc4", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a479a0bfeb546fc10eb53a0820e96657208d2dc4", "committedDate": "2020-12-08T04:13:19Z", "message": "More cleanup.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ff23a05e6da1db87fbbc3e46cd5d9c1b2139646", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/8ff23a05e6da1db87fbbc3e46cd5d9c1b2139646", "committedDate": "2020-12-08T04:13:36Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5401-leaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzQ1ODA0", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-546745804", "createdAt": "2020-12-08T04:58:26Z", "commit": {"oid": "8ff23a05e6da1db87fbbc3e46cd5d9c1b2139646"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDo1ODoyNlrOIBHGFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDo1ODoyNlrOIBHGFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzNTczNA==", "bodyText": "serviceBuilder needs to be closed in the @after method.", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r538035734", "createdAt": "2020-12-08T04:58:26Z", "author": {"login": "shrids"}, "path": "test/integration/src/test/java/io/pravega/test/integration/controller/server/EventProcessorTest.java", "diffHunk": "@@ -94,8 +93,12 @@\n     private ServiceBuilder serviceBuilder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ff23a05e6da1db87fbbc3e46cd5d9c1b2139646"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDEyNzE1", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-546412715", "createdAt": "2020-12-07T18:18:11Z", "commit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoxODoxMVrOIA0FjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoxODoxMVrOIA0FjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNDMwMA==", "bodyText": "Was the close() order relevant to release resources in this test?", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537724300", "createdAt": "2020-12-07T18:18:11Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/admin/impl/KeyValueTableManagerImpl.java", "diffHunk": "@@ -80,17 +80,17 @@ public KeyValueTableManagerImpl(@NonNull ClientConfig clientConfig) {\n     @Override\n     public void close() {\n         if (this.closed.compareAndSet(false, true)) {\n-            if (this.controller != null) {\n-                this.controller.close();\n-            }\n-\n             if (this.connectionFactory != null) {\n                 this.connectionFactory.close();\n             }\n \n             if (this.executor != null) {\n                 ExecutorServiceHelpers.shutdown(this.executor);\n             }\n+\n+            if (this.controller != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edadf133dab66ffcceef19abf2ba3d9c3208f21b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/edadf133dab66ffcceef19abf2ba3d9c3208f21b", "committedDate": "2020-12-08T14:30:52Z", "message": "More cleanup.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3MzQ5ODM2", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-547349836", "createdAt": "2020-12-08T15:32:52Z", "commit": {"oid": "edadf133dab66ffcceef19abf2ba3d9c3208f21b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2c87785e2d4d04ad866d0c912203b46f28d1fef", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a2c87785e2d4d04ad866d0c912203b46f28d1fef", "committedDate": "2020-12-08T15:40:25Z", "message": "Merge branch 'master' into issue-5401-leaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Nzk1Mjk4", "url": "https://github.com/pravega/pravega/pull/5402#pullrequestreview-547795298", "createdAt": "2020-12-09T02:47:29Z", "commit": {"oid": "a2c87785e2d4d04ad866d0c912203b46f28d1fef"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3782, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}