{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NDEwOTY5", "number": 4525, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0MjowMlrODbaQWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0NDozOVrODbaSQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDY4MzE1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/EventSegmentReaderImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0MjowMlrOFi4c6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo0MDozM1rOFi_AMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyMDgwOA==", "bodyText": "This seems really aggressive. I don't see any reason this should be more aggressive than or different from RevisionedStreamClientImpl.READ_TIMEOUT_MS. In both cases we know the server has data and we are waiting to receive it.", "url": "https://github.com/pravega/pravega/pull/4525#discussion_r372120808", "createdAt": "2020-01-28T23:42:02Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/EventSegmentReaderImpl.java", "diffHunk": "@@ -28,6 +29,10 @@\n @ToString\n class EventSegmentReaderImpl implements EventSegmentReader {\n \n+    /* Partial data timeout. This timeout is the maximum amount of time the reader will wait in the case of\n+     * partial data being received by the client. After this timeout the client will resend the request. */\n+    static final long READ_TIMEOUT_MS = 500;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28332cf08c730ef8202df5cbea8a8c1b1559994"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyODE0Nw==", "bodyText": "ok.Changed it to 30 seconds.", "url": "https://github.com/pravega/pravega/pull/4525#discussion_r372228147", "createdAt": "2020-01-29T07:40:33Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/segment/impl/EventSegmentReaderImpl.java", "diffHunk": "@@ -28,6 +29,10 @@\n @ToString\n class EventSegmentReaderImpl implements EventSegmentReader {\n \n+    /* Partial data timeout. This timeout is the maximum amount of time the reader will wait in the case of\n+     * partial data being received by the client. After this timeout the client will resend the request. */\n+    static final long READ_TIMEOUT_MS = 500;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyMDgwOA=="}, "originalCommit": {"oid": "a28332cf08c730ef8202df5cbea8a8c1b1559994"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDY4NTY4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/EventSegmentReaderImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0MzoyNlrOFi4ecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0MzoyNlrOFi4ecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyMTIwMg==", "bodyText": "I think this can be simplified to: in.setOffset(originalOffset, timeout);", "url": "https://github.com/pravega/pravega/pull/4525#discussion_r372121202", "createdAt": "2020-01-28T23:43:26Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/EventSegmentReaderImpl.java", "diffHunk": "@@ -54,30 +59,44 @@ public long getOffset() {\n      */\n     @Override\n     @Synchronized\n-    public ByteBuffer read(long timeout) throws EndOfSegmentException, SegmentTruncatedException {\n+    public ByteBuffer read(long firstByteTimeoutMillis) throws EndOfSegmentException, SegmentTruncatedException {\n         long originalOffset = in.getOffset();\n-        long traceId = LoggerHelpers.traceEnter(log, \"read\", in.getSegmentId(), originalOffset, timeout);\n+        long traceId = LoggerHelpers.traceEnter(log, \"read\", in.getSegmentId(), originalOffset, firstByteTimeoutMillis);\n         boolean success = false;\n+        boolean timeout = false;\n         try {\n-            ByteBuffer result = readEvent(timeout);\n+            ByteBuffer result = readEvent(firstByteTimeoutMillis);\n             success = true;\n             return result;\n+        } catch (TimeoutException e) {\n+            timeout = true;\n+            log.warn(\"Timeout observed while trying to read data from Segment store, the read request will be retransmitted. Details: {}\", e.getMessage());\n+            return null;\n         } finally {\n-            LoggerHelpers.traceLeave(log, \"read\", traceId, in.getSegmentId(), originalOffset, timeout, success);\n+            LoggerHelpers.traceLeave(log, \"read\", traceId, in.getSegmentId(), originalOffset, firstByteTimeoutMillis, success);\n             if (!success) {\n-                in.setOffset(originalOffset);\n+                if (timeout) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28332cf08c730ef8202df5cbea8a8c1b1559994"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDY4ODAyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/EventSegmentReaderImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0NDozOVrOFi4f4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzo0NDozOVrOFi4f4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyMTU2OA==", "bodyText": "Given three instances of this if and throw, it probably makes sense to have a private method.", "url": "https://github.com/pravega/pravega/pull/4525#discussion_r372121568", "createdAt": "2020-01-28T23:44:39Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/EventSegmentReaderImpl.java", "diffHunk": "@@ -54,30 +59,44 @@ public long getOffset() {\n      */\n     @Override\n     @Synchronized\n-    public ByteBuffer read(long timeout) throws EndOfSegmentException, SegmentTruncatedException {\n+    public ByteBuffer read(long firstByteTimeoutMillis) throws EndOfSegmentException, SegmentTruncatedException {\n         long originalOffset = in.getOffset();\n-        long traceId = LoggerHelpers.traceEnter(log, \"read\", in.getSegmentId(), originalOffset, timeout);\n+        long traceId = LoggerHelpers.traceEnter(log, \"read\", in.getSegmentId(), originalOffset, firstByteTimeoutMillis);\n         boolean success = false;\n+        boolean timeout = false;\n         try {\n-            ByteBuffer result = readEvent(timeout);\n+            ByteBuffer result = readEvent(firstByteTimeoutMillis);\n             success = true;\n             return result;\n+        } catch (TimeoutException e) {\n+            timeout = true;\n+            log.warn(\"Timeout observed while trying to read data from Segment store, the read request will be retransmitted. Details: {}\", e.getMessage());\n+            return null;\n         } finally {\n-            LoggerHelpers.traceLeave(log, \"read\", traceId, in.getSegmentId(), originalOffset, timeout, success);\n+            LoggerHelpers.traceLeave(log, \"read\", traceId, in.getSegmentId(), originalOffset, firstByteTimeoutMillis, success);\n             if (!success) {\n-                in.setOffset(originalOffset);\n+                if (timeout) {\n+                    in.setOffset(originalOffset, true);\n+                } else {\n+                    in.setOffset(originalOffset);\n+                }\n             }\n         }\n     }\n         \n-    public ByteBuffer readEvent(long timeout) throws EndOfSegmentException, SegmentTruncatedException {\n+    public ByteBuffer readEvent(long firstByteTimeoutMillis) throws EndOfSegmentException, SegmentTruncatedException, TimeoutException {\n         headerReadingBuffer.clear();\n-        int read = in.read(headerReadingBuffer, timeout);\n+        int read = in.read(headerReadingBuffer, firstByteTimeoutMillis);\n         if (read == 0) {\n+            // a resend will not be triggered in-case of a firstByteTimeout.\n             return null;\n         }\n         while (headerReadingBuffer.hasRemaining()) {\n-            in.read(headerReadingBuffer, Long.MAX_VALUE);\n+            if (in.read(headerReadingBuffer, READ_TIMEOUT_MS) == 0) {\n+                log.warn(\"Timeout out while trying to read WireCommand header during read of segment {} at offset {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28332cf08c730ef8202df5cbea8a8c1b1559994"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4409, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}