{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMjU3OTQ3", "number": 4867, "title": "Issue 4677: Offset/Version Table Entry Iteration", "bodyText": "Change log description\n\nImplement the iteration based APIs for position based TableSegment reads.\nThis adds a new iterator which starts at a given offset/position in a TableSegment, and deserializes these reads into TableEntries (as apposed to the TableBucket approach that currently exists).\n\nPurpose of the change\nCloses #4677.\nWhat the code does\nIn addition to the change log description, the new entryIterator has the following semantics:\n\nIf the start position provided in the ReadTableEntriesDelta wire command proceeds the COMPACTION_OFFSET, we begin starting at the COMPACTION_OFFSET.\nAt the time the newIterator is constructed, the current segment length is read, which will act as our upper bound. Meaning that even if other entries are appended, we will still consider this point as our segment end.\nThe TableEntryIterator also uses the same MAX_READ_SIZE from the PravegaRequestProcessor.\n\nThree new classes (related to iteration) are introduced: TableEntryIterator, EntryIteratorItemImpl and EntryIteratorState. When designing these classes, one of the central goals was to closely follow the general design of the previous key/entryIterator that already exist. I believe this may introduce some inefficiencies with you will likely want to address:\nAreas of concern\nPravegaRequestProcessor.readTableEntriesDelta: Conforming to the existing iterator structure, I introduce a potentially redundant packing/unpacking of our EntryIteratorState object for every TableEntry in the iteration.\nEntryIteratorItemImpl: Unlike a TableBucket which may map to mutliple TableEntrys, each iteration will always return just one TableEntry. Again, using these existing structures, the entries field in our EntryIteratorItem is always a singletonList.\nTesting\nBesides the standard test classes for each of these new iteration classes that were introduced, you will notice two new classes: TableContext and ContainerMock. These classes were parsed out of ContainerTableExtensionImplTests to promote reusability.\nThe TableEntryIterator very much requires some TableSegment to add to and iterate over to ensure correctness.\nIn Progress\nYou will notice that I do not have any tests directly testing the new methods in the PravegaRequestProcessor. Following troubles with setting up the mocks, it is still in progress.\nHow to verify it\n(Optional: steps to verify that the changes are effective)\nRun the unit tests. More involved testing is forth coming.", "createdAt": "2020-06-11T18:24:03Z", "url": "https://github.com/pravega/pravega/pull/4867", "merged": true, "mergeCommit": {"oid": "6e882cf4f7d4c02eeddc612870488a507d10d516"}, "closed": true, "closedAt": "2020-07-18T00:59:18Z", "author": {"login": "co-jo"}, "timelineItems": {"totalCount": 73, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGUXgKAH2gAyNDMzMjU3OTQ3OjA4NjAxYWZkMTE0NjNiZjcwMGE2ZDBhZjNmMzNkY2I1M2Y5MzVlMDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc18pi2gFqTQ1MTAwNTU0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "08601afd11463bf700a6d0af3f33dcb53f935e09", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/08601afd11463bf700a6d0af3f33dcb53f935e09", "committedDate": "2020-02-21T00:13:24Z", "message": "Update K8 client APIs to use their 5.0.0 counterparts.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25a165d0293c34ee8703fff764e55cf8fda413dd", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/25a165d0293c34ee8703fff764e55cf8fda413dd", "committedDate": "2020-02-21T18:42:03Z", "message": "Merge pull request #1 from co-jo/issue-4464-update-kubernetes-client-version\n\nIssue 4464 update kubernetes client version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cc2dd2be26feed2953258ff055c1657aeb57019", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/8cc2dd2be26feed2953258ff055c1657aeb57019", "committedDate": "2020-02-23T04:43:09Z", "message": "Run system tests using alternative flag value.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3fcbd2e627f9fc0a0f6bad7e42667db4439e092", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/c3fcbd2e627f9fc0a0f6bad7e42667db4439e092", "committedDate": "2020-03-10T22:21:32Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5f808cc42831892aeb8e7824c22d499a1f9fa03", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/f5f808cc42831892aeb8e7824c22d499a1f9fa03", "committedDate": "2020-03-18T18:44:10Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7901435dc1127bed1c46845bbaf8024477e2078f", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/7901435dc1127bed1c46845bbaf8024477e2078f", "committedDate": "2020-04-02T18:49:59Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d59b3e33f6d5bd90264753caadcea7ed7bbfe06c", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/d59b3e33f6d5bd90264753caadcea7ed7bbfe06c", "committedDate": "2020-04-16T20:22:05Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa090cad1d88812f2a88e9debacdb04df585adbf", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/aa090cad1d88812f2a88e9debacdb04df585adbf", "committedDate": "2020-04-18T20:15:50Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e328bcb38239fdc32f866980ee1103c93dff522d", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/e328bcb38239fdc32f866980ee1103c93dff522d", "committedDate": "2020-05-11T22:25:21Z", "message": "Merge branch 'master' of https://github.com/co-jo/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd02180986f49a42002c7fd2ef28885d1f701af9", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/cd02180986f49a42002c7fd2ef28885d1f701af9", "committedDate": "2020-05-11T22:25:27Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df6ddaa58fded6128bad5fc35ddcd1ec817a29d5", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/df6ddaa58fded6128bad5fc35ddcd1ec817a29d5", "committedDate": "2020-05-12T18:17:19Z", "message": "Initial API proposal on offset based TableSegment reads.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e4e548363b9d4b5fd627e402fdef73d32a6693e", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/1e4e548363b9d4b5fd627e402fdef73d32a6693e", "committedDate": "2020-05-12T20:54:44Z", "message": "Fix misordered writes.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5f07d793d7b2c9ed6986cdcdd8260553f335d02", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/f5f07d793d7b2c9ed6986cdcdd8260553f335d02", "committedDate": "2020-05-12T21:33:15Z", "message": "Add basic unit tests for new WireCommands.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "672a07692f3a654dd6d4615c914df412ccbe2d38", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/672a07692f3a654dd6d4615c914df412ccbe2d38", "committedDate": "2020-05-14T19:34:49Z", "message": "Add checks if a tableSegmentOffset was provided.\nCreates a constant value signifying no offset was provided.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85d2ba3d13d42ef345f72ee84d169b87f3d9b8b0", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/85d2ba3d13d42ef345f72ee84d169b87f3d9b8b0", "committedDate": "2020-05-18T14:31:13Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac2a2d330241f403ff5961115779847f580a9f29", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/ac2a2d330241f403ff5961115779847f580a9f29", "committedDate": "2020-05-18T19:30:16Z", "message": "Add meaningful default value to the UpdateTableEntries calls in PravegaRequestProcessorTest.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f52d0b1fc19a195c692889f3b1542176a082e0e", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/3f52d0b1fc19a195c692889f3b1542176a082e0e", "committedDate": "2020-05-18T20:42:17Z", "message": "Merge branch 'issue-4677-offset-table-reads' of https://github.com/co-jo/pravega into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1408d7527ec73f1645418df04aea4aa1120b39e7", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/1408d7527ec73f1645418df04aea4aa1120b39e7", "committedDate": "2020-05-18T20:48:16Z", "message": "Merge branch 'master' of https://github.com/co-jo/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2719517850f39bce3e5f2c92f04c8c24122a520", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/e2719517850f39bce3e5f2c92f04c8c24122a520", "committedDate": "2020-05-20T18:59:36Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92dbe1a241144b155a2885f4ea30a7b52aa46ed7", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/92dbe1a241144b155a2885f4ea30a7b52aa46ed7", "committedDate": "2020-06-10T02:19:30Z", "message": "* Implement offset/version based TableEntry iteration.\n* Add new API to appropriate classes implementing TableStore and Request/ReplyProcessor interfaces.\n* New Iterator/IteratorState classes to support non-bucket based iteration of TableSegments.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad83fc68fe8f2cc64b5a3ce5008f002183b80197", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/ad83fc68fe8f2cc64b5a3ce5008f002183b80197", "committedDate": "2020-06-10T04:20:14Z", "message": "* Update files with missing copyright statements.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cbca9e3c1f51e158ac7d04bd4b2e244be2fcca7", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/7cbca9e3c1f51e158ac7d04bd4b2e244be2fcca7", "committedDate": "2020-06-10T07:35:38Z", "message": "* Make overloaded 'newIterator' methods adjacent.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8adc68accb9ac6b12895478033734bfe3cd01fe", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/d8adc68accb9ac6b12895478033734bfe3cd01fe", "committedDate": "2020-06-10T18:42:23Z", "message": "* Adhere to proper checkstyle guidelines.c\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d722048e0449da0ba24822ef5cb0f47da146ef1a", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/d722048e0449da0ba24822ef5cb0f47da146ef1a", "committedDate": "2020-06-11T18:33:23Z", "message": "* Update API parameter name.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/686552bf45b447f07c9670d16d7c2ec2f044dd77", "committedDate": "2020-06-11T19:58:51Z", "message": "* Fix checkstyle issues.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODAzMzgw", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-429803380", "createdAt": "2020-06-12T14:48:04Z", "commit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNDo0ODowNFrOGjGzWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNToxOToxMFrOGjH8IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NDc5Mw==", "bodyText": "Iterator -> {@link AsyncIterator}", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439464793", "createdAt": "2020-06-12T14:48:04Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NTkzMA==", "bodyText": "I know we discussed this offline, but let's be consistent now. In the description you said \"offset\", but here you say fromPosition and then \"offset/version\".\nLet's keep everything as \"position\", at least in the contracts and associated Javadoc.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439465930", "createdAt": "2020-06-12T14:49:56Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.\n+     *\n+     * Please refer to {@link #keyIterator} for notes about consistency and the ability to resume.\n+     *\n+     * @param segmentName       The name of the Table Segment to iterate over.\n+     * @param fromPosition      The offset/version to begin iteration at.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjI5Mw==", "bodyText": "Is this what this method is returning?", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439466293", "createdAt": "2020-06-12T14:50:26Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.\n+     *\n+     * Please refer to {@link #keyIterator} for notes about consistency and the ability to resume.\n+     *\n+     * @param segmentName       The name of the Table Segment to iterate over.\n+     * @param fromPosition      The offset/version to begin iteration at.\n+     * @param fetchTimeout      Timeout for each invocation to {@link AsyncIterator#getNext()}.\n+     * @return A CompletableFuture that, when completed, will return a {@link List} of {@link TableEntry}, occuring after", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2OTA5NA==", "bodyText": "Just a heads up that we'll need to rework this after #4842 is merged in. It improved a number of things, mostly around in how this class reads data from the Table Segment.\n(No need to worry or do anything right now, just be a on the lookout on when that PR is merged in as your subsequent merge from master will need to resolve a number of conflicts.)", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439469094", "createdAt": "2020-06-12T14:54:17Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -838,6 +840,77 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n                   }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n     }\n \n+    @Override\n+    public void readTableEntriesDelta(WireCommands.ReadTableEntriesDelta readTableEntriesDelta) {\n+        final String segment = readTableEntriesDelta.getSegment();\n+        final String operation = \"readTableEntriesDelta\";\n+\n+        if (!verifyToken(segment, readTableEntriesDelta.getRequestId(), readTableEntriesDelta.getDelegationToken(), operation)) {\n+            return;\n+        }\n+\n+        final int suggestedEntryCount = readTableEntriesDelta.getSuggestedEntryCount();\n+        final long fromPosition = readTableEntriesDelta.getFromPosition();\n+\n+        log.info(readTableEntriesDelta.getRequestId(), \"Fetching keys from {}.\", readTableEntriesDelta);\n+\n+        final AtomicInteger msgSize = new AtomicInteger(0);\n+        final Map<ArrayView, TableEntry> entries = new HashMap<>();\n+        final AtomicReference<EntryIteratorState> lastState = new AtomicReference<>();\n+        val timer = new Timer();\n+        tableStore.entryIterator(segment, fromPosition, TIMEOUT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2OTI3Nw==", "bodyText": "Nice one.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439469277", "createdAt": "2020-06-12T14:54:37Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/DirectSegmentAccess.java", "diffHunk": "@@ -22,7 +22,7 @@\n /**\n  * Defines an API that can be used to get direct access to a Segment. This can be used instead of the SegmentContainer API\n  * for short periods of time if a rapid sequence of operations is desired (since it caches the locations of the Segment and\n- * it does not need to all the usual SegmentContainer and StreamSegment lookups on every invocation).\n+ * it does not need to call the usual SegmentContainer and StreamSegment lookups on every invocation).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MDY2Ng==", "bodyText": "I would really name this something different since it has different semantics than entryIterator. entryIterator will iterate through all the entries that are still present in the index, while this method will give you the latest state from a given offset, which may include deletions.\nConsider naming this entryDeltaIterator  (or deltaEntryIterator) - the term \"delta\" is key here.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439470666", "createdAt": "2020-06-12T14:56:51Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, byte[] serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new Iterator over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.\n+     *\n+     * Please refer to {@link #keyIterator} for notes about consistency and the ability to resume.\n+     *\n+     * @param segmentName       The name of the Table Segment to iterate over.\n+     * @param fromPosition      The offset/version to begin iteration at.\n+     * @param fetchTimeout      Timeout for each invocation to {@link AsyncIterator#getNext()}.\n+     * @return A CompletableFuture that, when completed, will return a {@link List} of {@link TableEntry}, occuring after\n+     * the given . If the operation failed, the Future will be failed with the\n+     * causing exception. Notable exceptions:\n+     * <ul>\n+     * <li>{@link StreamSegmentNotExistsException} If the Table Segment does not exist.\n+     * <li>{@link BadSegmentTypeException} If segmentName refers to a non-Table Segment.\n+     * </ul>\n+     * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n+     */\n+    CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, long fromPosition, Duration fetchTimeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MDk3OA==", "bodyText": "Same here about \"delta\".", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439470978", "createdAt": "2020-06-12T14:57:22Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -315,9 +322,40 @@ protected int getMaxCompactionSize() {\n         return segment.append(new ByteArraySegment(s), null, timeout);\n     }\n \n-    private <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newIterator(@NonNull String segmentName, byte[] serializedState,\n-                                                                              @NonNull Duration fetchTimeout,\n-                                                                              @NonNull GetBucketReader<T> createBucketReader) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newIterator(@NonNull String segmentName, long fromPosition, @NonNull Duration fetchTimeout) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MTE0MQ==", "bodyText": "I can't tell from the diff. Why is this needed?", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439471141", "createdAt": "2020-06-12T14:57:37Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -315,9 +322,40 @@ protected int getMaxCompactionSize() {\n         return segment.append(new ByteArraySegment(s), null, timeout);\n     }\n \n-    private <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newIterator(@NonNull String segmentName, byte[] serializedState,\n-                                                                              @NonNull Duration fetchTimeout,\n-                                                                              @NonNull GetBucketReader<T> createBucketReader) {\n+    @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MzAwNQ==", "bodyText": "Is there really no way to unify this with IteratorItemImpl?", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439473005", "createdAt": "2020-06-12T15:00:49Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -466,6 +504,29 @@ public String toString() {\n         }\n     }\n \n+    // endregion\n+\n+    // region EntryIteratorItemImpl\n+\n+    @RequiredArgsConstructor\n+    private class EntryIteratorItemImpl<T> implements IteratorItem<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3Mzg2Ng==", "bodyText": "Tip: If all you need toString for is for debugging (watching), consider using Lombok's @ToString annotation which will auto-generate this for you (you can even pick the fields you want to include).", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439473866", "createdAt": "2020-06-12T15:02:15Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/EntryIteratorState.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+public class EntryIteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+\n+    private static final int BOOLEAN_BYTES = 1;\n+\n+    @Getter\n+    private final long position;\n+\n+    @Getter\n+    private final boolean reachedEnd;\n+\n+    @Getter\n+    private final boolean shouldClear;\n+\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.\n+     *\n+     * @param position The position of the TableEntry\n+     * @param reachedEnd If the Entry is at the end of the segment (more recently appended).\n+     * @param shouldClear Marks if the client should clear their state (provided start position has been truncated).\n+     * @param deletionRecord The Entry read is marked for deletion.\n+     */\n+    EntryIteratorState(long position, boolean reachedEnd, boolean shouldClear, boolean deletionRecord) {\n+        Preconditions.checkArgument(isValid(position), \"Position must be at least 0 (a non-negative integer).\");\n+        this.position = position;\n+        this.reachedEnd = reachedEnd;\n+        this.shouldClear = shouldClear;\n+        this.deletionRecord = deletionRecord;\n+    }\n+\n+    boolean isValid(long position) {\n+        return position >= 0;\n+    }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NDQ1NA==", "bodyText": "You don't need to specify these fields in here. The @Builder annotation will take care of this for you. The only reason we need to declare this class is because we want it to implement ObjectBuilder<>.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439474454", "createdAt": "2020-06-12T15:03:15Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/EntryIteratorState.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+public class EntryIteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+\n+    private static final int BOOLEAN_BYTES = 1;\n+\n+    @Getter\n+    private final long position;\n+\n+    @Getter\n+    private final boolean reachedEnd;\n+\n+    @Getter\n+    private final boolean shouldClear;\n+\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.\n+     *\n+     * @param position The position of the TableEntry\n+     * @param reachedEnd If the Entry is at the end of the segment (more recently appended).\n+     * @param shouldClear Marks if the client should clear their state (provided start position has been truncated).\n+     * @param deletionRecord The Entry read is marked for deletion.\n+     */\n+    EntryIteratorState(long position, boolean reachedEnd, boolean shouldClear, boolean deletionRecord) {\n+        Preconditions.checkArgument(isValid(position), \"Position must be at least 0 (a non-negative integer).\");\n+        this.position = position;\n+        this.reachedEnd = reachedEnd;\n+        this.shouldClear = shouldClear;\n+        this.deletionRecord = deletionRecord;\n+    }\n+\n+    boolean isValid(long position) {\n+        return position >= 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Position = %s Reached End = %s Should Clear = %s\", this.position, this.reachedEnd, this.shouldClear);\n+    }\n+\n+    //region Serialization\n+\n+    /**\n+     * Creates a new instance of the IteratorState class from the given array.\n+     *\n+     * @param data A byte array containing the serialization of an IteratorState. This must have been generated using\n+     *             {@link #serialize()}.\n+     * @return As new instance of the IteratorState class.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public static EntryIteratorState deserialize(byte[] data) {\n+        return SERIALIZER.deserialize(data);\n+    }\n+\n+    /**\n+     * Serializes this IteratorState instance into an {@link ArrayView}.\n+     *\n+     * @return The {@link ArrayView} that was used for serialization.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public ArrayView serialize() {\n+        return SERIALIZER.serialize(this);\n+    }\n+\n+    private static class IteratorStateBuilder implements ObjectBuilder<EntryIteratorState> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NTY4NQ==", "bodyText": "Just a heads up that CompactLong can only serialize up to 2^62 (and no negatives). This sounds OK for now, since we do not expect negative offsets and 2^62 is still a huge number.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439475685", "createdAt": "2020-06-12T15:05:21Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/EntryIteratorState.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+public class EntryIteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+\n+    private static final int BOOLEAN_BYTES = 1;\n+\n+    @Getter\n+    private final long position;\n+\n+    @Getter\n+    private final boolean reachedEnd;\n+\n+    @Getter\n+    private final boolean shouldClear;\n+\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.\n+     *\n+     * @param position The position of the TableEntry\n+     * @param reachedEnd If the Entry is at the end of the segment (more recently appended).\n+     * @param shouldClear Marks if the client should clear their state (provided start position has been truncated).\n+     * @param deletionRecord The Entry read is marked for deletion.\n+     */\n+    EntryIteratorState(long position, boolean reachedEnd, boolean shouldClear, boolean deletionRecord) {\n+        Preconditions.checkArgument(isValid(position), \"Position must be at least 0 (a non-negative integer).\");\n+        this.position = position;\n+        this.reachedEnd = reachedEnd;\n+        this.shouldClear = shouldClear;\n+        this.deletionRecord = deletionRecord;\n+    }\n+\n+    boolean isValid(long position) {\n+        return position >= 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Position = %s Reached End = %s Should Clear = %s\", this.position, this.reachedEnd, this.shouldClear);\n+    }\n+\n+    //region Serialization\n+\n+    /**\n+     * Creates a new instance of the IteratorState class from the given array.\n+     *\n+     * @param data A byte array containing the serialization of an IteratorState. This must have been generated using\n+     *             {@link #serialize()}.\n+     * @return As new instance of the IteratorState class.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public static EntryIteratorState deserialize(byte[] data) {\n+        return SERIALIZER.deserialize(data);\n+    }\n+\n+    /**\n+     * Serializes this IteratorState instance into an {@link ArrayView}.\n+     *\n+     * @return The {@link ArrayView} that was used for serialization.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public ArrayView serialize() {\n+        return SERIALIZER.serialize(this);\n+    }\n+\n+    private static class IteratorStateBuilder implements ObjectBuilder<EntryIteratorState> {\n+        private long position;\n+        private boolean reachedEnd;\n+        private boolean shouldClear;\n+        private boolean deletionRecord;\n+\n+        @Override\n+        public EntryIteratorState build() {\n+            return new EntryIteratorState(position, reachedEnd, shouldClear, deletionRecord);\n+        }\n+    }\n+\n+    private static class Serializer extends VersionedSerializer.WithBuilder<EntryIteratorState, IteratorStateBuilder> {\n+        @Override\n+        protected IteratorStateBuilder newBuilder() {\n+            return new IteratorStateBuilder();\n+        }\n+\n+        @Override\n+        protected byte getWriteVersion() {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void declareVersions() {\n+            version(0).revision(0, this::write00, this::read00);\n+        }\n+\n+        private void read00(RevisionDataInput revisionDataInput, IteratorStateBuilder builder) throws IOException {\n+            builder.position = revisionDataInput.readCompactLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NjAwNw==", "bodyText": "TableEntryDeltaIterator", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439476007", "createdAt": "2020-06-12T15:05:56Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NzQxMA==", "bodyText": "Nit: either use this. for all private fields or for none. Try to be consistent.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439477410", "createdAt": "2020-06-12T15:08:26Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3Nzc4Mg==", "bodyText": "this.currentBatchOffset is Guarded By this but you don't use a synchronized block here.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439477782", "createdAt": "2020-06-12T15:09:06Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NzQxMA=="}, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODI3NA==", "bodyText": "Tip: use val to avoid having to write long type names (i.e val next = this.currentEntry.next())", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439478274", "createdAt": "2020-06-12T15:09:57Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<EntryIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<EntryIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            Map.Entry<EntryIteratorState, TableEntry> next = this.currentEntry.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3OTYxMQ==", "bodyText": "Tip: if you declare a variable that you do not expect (or want) to change throughout your method, add the final modifier or declare it with val (which makes it final). This way the compiler will catch any attempt you make to modify it, which can, in turn, prevent bugs from developing.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439479611", "createdAt": "2020-06-12T15:12:19Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<EntryIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<EntryIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            Map.Entry<EntryIteratorState, TableEntry> next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();\n+                    } else {\n+                        this.currentEntry = null;\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<List<Map.Entry<EntryIteratorState, TableEntry>>> toEntries(long startOffset) {\n+        TimeoutTimer timer = new TimeoutTimer(this.fetchTimeout);\n+        int length = Math.min(maxLength, MAX_READ_SIZE);\n+\n+        if (endOfSegment()) {\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        ReadResult result = this.segment.read(startOffset, length, timer.getRemaining());\n+        return AsyncReadResultProcessor.processAll(result, this.executor, timer.getRemaining())\n+                .thenApply(data -> parseEntries(data, startOffset, length));\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    private List<Map.Entry<EntryIteratorState, TableEntry>> parseEntries(BufferView data, long startOffset, int readLength) {\n+\n+        long maxOffset = startOffset + readLength;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MTI3MQ==", "bodyText": "You don't need to declare this class. Adding @Builder will do it for you.\nThe reason I did it \"manually\" in TableIterator was because build() had to do a significant amount of custom work, so the @Builder annotation wouldn't have helped.\nIn your case, however, this is plain boilerplate code so that annotation will save you from having to do that.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439481271", "createdAt": "2020-06-12T15:15:15Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryIterator.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.AccessLevel;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+@ThreadSafe\n+class TableEntryIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<EntryIteratorState, TableEntry>> currentEntry = null;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+    //endregion\n+\n+    private TableEntryIterator<T> setCurrentBatchOffset(long currentBatchOffset) {\n+        this.currentBatchOffset = currentBatchOffset;\n+        return this;\n+    }\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public boolean endOfSegment() {\n+        return this.currentBatchOffset >= (startOffset + maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<EntryIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<EntryIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            Map.Entry<EntryIteratorState, TableEntry> next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();\n+                    } else {\n+                        this.currentEntry = null;\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<List<Map.Entry<EntryIteratorState, TableEntry>>> toEntries(long startOffset) {\n+        TimeoutTimer timer = new TimeoutTimer(this.fetchTimeout);\n+        int length = Math.min(maxLength, MAX_READ_SIZE);\n+\n+        if (endOfSegment()) {\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        ReadResult result = this.segment.read(startOffset, length, timer.getRemaining());\n+        return AsyncReadResultProcessor.processAll(result, this.executor, timer.getRemaining())\n+                .thenApply(data -> parseEntries(data, startOffset, length));\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    private List<Map.Entry<EntryIteratorState, TableEntry>> parseEntries(BufferView data, long startOffset, int readLength) {\n+\n+        long maxOffset = startOffset + readLength;\n+        long currentOffset = startOffset;\n+\n+        InputStream input = data.getReader();\n+        List<Map.Entry<EntryIteratorState, TableEntry>> entries = new ArrayList<>();\n+        try {\n+            while (currentOffset < maxOffset) {\n+                val entry = AsyncTableEntryReader.readEntryComponents(input, currentOffset, this.entrySerializer);\n+                boolean reachedEnd = currentOffset + entry.getHeader().getTotalLength() >= maxLength + startOffset;\n+                // We must preserve deletions to accurately construct a delta.\n+                byte[] value = entry.getValue() == null ? new byte[0] : entry.getValue();\n+                entries.add(new AbstractMap.SimpleEntry<>(\n+                        new EntryIteratorState(currentOffset, reachedEnd, shouldClear, entry.getHeader().isDeletion()),\n+                        TableEntry.versioned(new ByteArraySegment(entry.getKey()), new ByteArraySegment(value), entry.getVersion())));\n+                currentOffset += entry.getHeader().getTotalLength();\n+            }\n+\n+        } catch (EOFException ex) {\n+            input.close();\n+        }\n+        this.currentBatchOffset = currentOffset;\n+\n+        return entries;\n+    }\n+\n+    /**\n+     * Creates a new {@link TableIterator} that contains no elements.\n+     *\n+     * @param <T> Type of elements returned at each iteration.\n+     * @return A new instance of the {@link TableIterator.Builder} class.\n+     */\n+    static <T> TableEntryIterator<T> empty() {\n+        return new TableEntryIterator<>(\n+                null,\n+                0L,\n+                0,\n+                false,\n+                Duration.ofMillis(0),\n+                new EntrySerializer(),\n+                ignored -> CompletableFuture.completedFuture(null),\n+                ForkJoinPool.commonPool());\n+    }\n+\n+    //endregion\n+\n+    //region Builder\n+\n+    /**\n+     * Creates a new {@link TableIterator.Builder} that can be used to construct {@link TableIterator} instances.\n+     *\n+     * @param <T> Type of the elements returned at each iteration.\n+     * @return A new instance of the {@link TableIterator.Builder} class.\n+     */\n+    static <T> Builder<T> builder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Builder for the {@link TableIterator} class.\n+     */\n+    static class Builder<T> {\n+\n+        private int maxLength = MAX_READ_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MjM3MA==", "bodyText": "Please add a quick Javadoc on this class explaining its purpose. I know it's in the test package, but since you took it out of the class it was originally in, we need to explain what it should be used for.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439482370", "createdAt": "2020-06-12T15:17:13Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/TableContext.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.segmentstore.server.CacheManager;\n+import io.pravega.segmentstore.server.CachePolicy;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.containers.StreamSegmentMetadata;\n+import io.pravega.segmentstore.storage.cache.CacheStorage;\n+import io.pravega.segmentstore.storage.cache.DirectMemoryCache;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledExecutorService;\n+import lombok.val;\n+\n+public class TableContext implements AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MjgxNQ==", "bodyText": "Is there a reason why this mock class got taken out of the TableContext class?", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439482815", "createdAt": "2020-06-12T15:18:02Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerMock.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.util.concurrent.Service;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.MergeStreamSegmentResult;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.StreamSegmentExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+import io.pravega.segmentstore.server.SegmentContainer;\n+import io.pravega.segmentstore.server.SegmentContainerExtension;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import org.junit.Assert;\n+\n+public class ContainerMock implements SegmentContainer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MzQyNQ==", "bodyText": "I think you can remove this TODO now.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439483425", "createdAt": "2020-06-12T15:19:10Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2182,6 +2190,79 @@ public boolean isFailure() {\n         }\n     }\n \n+    @Data\n+    public static final class ReadTableEntriesDelta implements Request, WireCommand {\n+        final WireCommandType type = WireCommandType.READ_TABLE_ENTRIES_DELTA;\n+        final long requestId;\n+        final String segment;\n+        @ToString.Exclude\n+        final String delegationToken;\n+        final long fromPosition;\n+        final int suggestedEntryCount;\n+\n+        @Override\n+        public void process(RequestProcessor cp) {\n+            cp.readTableEntriesDelta(this);\n+        }\n+\n+        @Override\n+        public void writeFields(DataOutput out) throws IOException {\n+            out.writeLong(requestId);\n+            out.writeUTF(segment);\n+            out.writeUTF(delegationToken == null ? \"\" : delegationToken);\n+            out.writeLong(fromPosition);\n+            out.writeInt(suggestedEntryCount);\n+        }\n+\n+        public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n+            long requestId = in.readLong();\n+            String segment = in.readUTF();\n+            String delegationToken = in.readUTF();\n+            long fromPosition = in.readLong();\n+            int suggestedEntryCount = in.readInt();\n+\n+            return new ReadTableEntriesDelta(requestId, segment, delegationToken, fromPosition, suggestedEntryCount);\n+        }\n+    }\n+\n+    @Data\n+    public static final class TableEntriesDeltaRead implements Reply, WireCommand {\n+        final WireCommandType type = WireCommandType.TABLE_ENTRIES_DELTA_READ;\n+        final long requestId;\n+        final String segment;\n+        final TableEntries tableEntries;\n+        final boolean shouldClear;\n+        final boolean reachedEnd;\n+        final long lastPosition;\n+\n+        // TODO: Will be implemented as apart of: https://github.com/pravega/pravega/issues/4677", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686552bf45b447f07c9670d16d7c2ec2f044dd77"}, "originalPosition": 251}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63586e44866c0b7c2a2e6604418b2c2110894a48", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/63586e44866c0b7c2a2e6604418b2c2110894a48", "committedDate": "2020-06-12T18:29:03Z", "message": "* Initial test for the PravegaRequestProcessor.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5OTU1Nzk0", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-429955794", "createdAt": "2020-06-12T18:30:47Z", "commit": {"oid": "63586e44866c0b7c2a2e6604418b2c2110894a48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODozMDo0OFrOGjN3qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODozMDo0OFrOGjN3qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MDU4NA==", "bodyText": "Note: processor.readTableEntriesDelta does not wait to the call to finish. This test is copied verbatim from testGetTableEntires, with the exception of readTableEntriesDelta being called instead of readTableEntries.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r439580584", "createdAt": "2020-06-12T18:30:48Z", "author": {"login": "co-jo"}, "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java", "diffHunk": "@@ -985,6 +986,115 @@ public void testGetTableEntries() throws Exception {\n         assertTrue(keyVersions.containsAll(getTableEntriesIteratorsResp.getEntries().getEntries().stream().map(e -> e.getKey().getKeyVersion()).collect(Collectors.toList())));\n     }\n \n+    @Test\n+    public void testReadTableEntriesDelta() throws Exception {\n+        // Set up PravegaRequestProcessor instance to execute requests against\n+        val rnd = new Random(0);\n+        String tableSegmentName = \"testReadTableEntriesDelta\";\n+\n+        @Cleanup\n+        ServiceBuilder serviceBuilder = newInlineExecutionInMemoryBuilder(getBuilderConfig());\n+        serviceBuilder.initialize();\n+        StreamSegmentStore store = serviceBuilder.createStreamSegmentService();\n+        TableStore tableStore = serviceBuilder.createTableStoreService();\n+        ServerConnection connection = mock(ServerConnection.class);\n+        InOrder order = inOrder(connection);\n+        val recorderMock = mock(TableSegmentStatsRecorder.class);\n+        PravegaRequestProcessor processor = new PravegaRequestProcessor(store, tableStore, connection, SegmentStatsRecorder.noOp(),\n+                recorderMock, new PassingTokenVerifier(), false);\n+\n+        // Generate keys.\n+        ArrayList<HashedArray> keys = generateKeys(3, rnd);\n+        HashedArray testValue = generateValue(rnd);\n+        TableEntry e1 = TableEntry.unversioned(keys.get(0), testValue);\n+        TableEntry e2 = TableEntry.unversioned(keys.get(1), testValue);\n+        TableEntry e3 = TableEntry.unversioned(keys.get(2), testValue);\n+\n+        // Create a table segment and add data.\n+        processor.createTableSegment(new WireCommands.CreateTableSegment(1, tableSegmentName, \"\"));\n+        order.verify(connection).send(new WireCommands.SegmentCreated(1, tableSegmentName));\n+        verify(recorderMock).createTableSegment(eq(tableSegmentName), any());\n+        processor.updateTableEntries(new WireCommands.UpdateTableEntries(2, tableSegmentName, \"\",\n+                getTableEntries(asList(e1, e2, e3)), WireCommands.NULL_TABLE_SEGMENT_OFFSET));\n+        verify(recorderMock).updateEntries(eq(tableSegmentName), eq(3), eq(false), any());\n+\n+        // 1. Now read the table entries where suggestedEntryCount is equal to number of entries in the Table Store.\n+        processor.readTableEntriesDelta(new WireCommands.ReadTableEntriesDelta(3, tableSegmentName, \"\", 0, 3));\n+        // Does not work without some delay.\n+        TimeUnit.SECONDS.sleep(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63586e44866c0b7c2a2e6604418b2c2110894a48"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24159ad4fcf95473821f9c657c643ab323e27122", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/24159ad4fcf95473821f9c657c643ab323e27122", "committedDate": "2020-06-13T02:34:10Z", "message": "* Addresses most feedback from draft PR.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d2ef90af7c18f98e9d183bc9d8c352463b361bd", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/4d2ef90af7c18f98e9d183bc9d8c352463b361bd", "committedDate": "2020-06-15T03:19:58Z", "message": "* Refactor 'ContainerMock' back into 'TableContext'.\n* Fix @Builder annotation on TableEntryDeltaIterator.\n* Address other feedback.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e75c0a03dbeb6c27857257da292f1ab09d5c94c", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/6e75c0a03dbeb6c27857257da292f1ab09d5c94c", "committedDate": "2020-06-15T18:13:46Z", "message": "* Properly pass down the ExecutorService (this fixes our testing issue in PravegaRequestProcessorTest).\n* Change the position field of the DeltaIteratorState class.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1d3648dd2c28a161dab520a48bf4bf657f9d14d", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/b1d3648dd2c28a161dab520a48bf4bf657f9d14d", "committedDate": "2020-06-15T18:43:02Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78ff6324b40431e17d655d738a4174b2b634ecba", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/78ff6324b40431e17d655d738a4174b2b634ecba", "committedDate": "2020-06-17T18:04:56Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d68b68b60ad46a154cfa9e8b07c5160494ef9216", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/d68b68b60ad46a154cfa9e8b07c5160494ef9216", "committedDate": "2020-06-17T18:13:06Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads\n\n# Conflicts:\n#\tsegmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java\n#\tsegmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java\n#\tshared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1baa07c38f3f293e786ecc3689700ffa1241473e", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/1baa07c38f3f293e786ecc3689700ffa1241473e", "committedDate": "2020-06-17T20:21:31Z", "message": "* Fix error in testing code.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16d3331ab414a75619214f3ad9c6402f1998385d", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/16d3331ab414a75619214f3ad9c6402f1998385d", "committedDate": "2020-06-22T19:03:02Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d18e63f214a2ed82b45ab637ac276e42e4d91dac", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/d18e63f214a2ed82b45ab637ac276e42e4d91dac", "committedDate": "2020-06-23T21:15:18Z", "message": "* Merge with master.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb74ccf264c78ba725759061acf9d4395f56cca6", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/fb74ccf264c78ba725759061acf9d4395f56cca6", "committedDate": "2020-06-23T21:23:40Z", "message": "Merge missed file.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e43a8e00d250a3ca3464f6a66836f0a55ccda43", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/4e43a8e00d250a3ca3464f6a66836f0a55ccda43", "committedDate": "2020-06-23T22:51:10Z", "message": "* Use proper key.\n* Fix deletion condition.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93aeef87fc7da5a29708027bc1a5835343e75390", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/93aeef87fc7da5a29708027bc1a5835343e75390", "committedDate": "2020-06-23T23:21:36Z", "message": "* Remove setSizeBytes method.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f6b8c19ed217af47a72270bce387ba0dc904b3e", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/5f6b8c19ed217af47a72270bce387ba0dc904b3e", "committedDate": "2020-06-24T00:57:28Z", "message": "* Fix checkstyle errors.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b73de22a5a35634a204e6ddbbb71cc9f5fbe0aa8", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/b73de22a5a35634a204e6ddbbb71cc9f5fbe0aa8", "committedDate": "2020-06-24T21:27:10Z", "message": "* Add check to make sure iteration done by both 'entryIterator' and 'entryDeltaIterator' are equivalent.\n* When building the diff in PravegaRequestProcessor, add only the entry with the newer (greater) version.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/b551e1c40dc2a059f80bb5d7361498952356457b", "committedDate": "2020-06-25T02:14:53Z", "message": "* Add coverage for both branches of the delta entry set.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MzY2OTA1", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-438366905", "createdAt": "2020-06-26T14:58:24Z", "commit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDo1ODoyNFrOGpkHlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNToxODozMlrOGpk0tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzNjU2NA==", "bodyText": "No need for public here.\nAlso please add a Javadoc to this method.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446236564", "createdAt": "2020-06-26T14:58:24Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/IteratorState.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.contracts.tables;\n+\n+import io.pravega.common.util.ArrayView;\n+\n+/**\n+ * {@link IteratorState} encapsulates classes that will need to capture and pass state during iteration of a TableSegment.\n+ */\n+public interface IteratorState {\n+\n+    public ArrayView serialize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzNzM3NQ==", "bodyText": "offset -> position.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446237375", "createdAt": "2020-06-26T14:59:44Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, BufferView serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new {@link AsyncIterator} over all the {@link TableEntry} instances in the given Table Segment starting from a given offset.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzODQ0Mw==", "bodyText": "Can we add a log.debug here (just like the other iterator methods) to indicate that we are sending something back. Feel free to follow the message pattern used for the other iterators.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446238443", "createdAt": "2020-06-26T15:01:34Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -815,6 +821,62 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n                 }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n     }\n \n+    @Override\n+    public void readTableEntriesDelta(WireCommands.ReadTableEntriesDelta readTableEntriesDelta) {\n+        final String segment = readTableEntriesDelta.getSegment();\n+        final String operation = \"readTableEntriesDelta\";\n+\n+        if (!verifyToken(segment, readTableEntriesDelta.getRequestId(), readTableEntriesDelta.getDelegationToken(), operation)) {\n+            return;\n+        }\n+\n+        final int suggestedEntryCount = readTableEntriesDelta.getSuggestedEntryCount();\n+        final long fromPosition = readTableEntriesDelta.getFromPosition();\n+\n+        log.info(readTableEntriesDelta.getRequestId(), \"Fetching keys from {}.\", readTableEntriesDelta);\n+\n+        val timer = new Timer();\n+        val result = new DeltaIteratorResult<BufferView, Map.Entry<WireCommands.TableKey, WireCommands.TableValue>, DeltaIteratorState>(\n+                segment.getBytes().length + WireCommands.TableEntriesRead.HEADER_BYTES);\n+        tableStore.entryDeltaIterator(segment, fromPosition, TIMEOUT)\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {\n+                            if (result.getItemCount() >= suggestedEntryCount || result.getSizeBytes() >= MAX_READ_SIZE) {\n+                                return  false;\n+                            }\n+                            TableEntry entry = e.getEntries().iterator().next();\n+                            DeltaIteratorState state = DeltaIteratorState.deserialize(e.getState().array());\n+                            // Store all TableEntries.\n+                            val k = new WireCommands.TableKey(toByteBuf(entry.getKey().getKey()), entry.getKey().getVersion());\n+                            val v = new WireCommands.TableValue(toByteBuf(entry.getValue()));\n+                            if (state.isDeletionRecord()) {\n+                                result.remove(entry.getKey().getKey(), k.size() + v.size());\n+                            } else {\n+                                Map.Entry<WireCommands.TableKey, WireCommands.TableValue> old = result.getItem(entry.getKey().getKey());\n+                                if (old != null && old.getKey().getKeyVersion() < entry.getKey().getVersion()) {\n+                                    int sizeBytes = (k.size() + v.size()) - (old.getKey().size() + old.getValue().size());\n+                                    result.add(entry.getKey().getKey(), new AbstractMap.SimpleImmutableEntry<>(k, v), sizeBytes);\n+                                } else {\n+                                    result.add(entry.getKey().getKey(), new AbstractMap.SimpleImmutableEntry<>(k, v), k.size() + v.size());\n+                                }\n+                            }\n+                            result.setState(state);\n+                            // Update total read data.\n+                            return true;\n+                        }))\n+                .thenAccept(v -> {\n+                    connection.send(new WireCommands.TableEntriesDeltaRead(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzOTM2NQ==", "bodyText": "This complex calculation could be simplified in the following way:\n\nJust invoke .add on the DeltaIteratorState.\nInside DeltaIteratorState.add, when you invoke put on the map, that method will actually return the existing (replaced) value, or null if no such value existed. If you get such a value, then subtract its size from the size tracker.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446239365", "createdAt": "2020-06-26T15:03:05Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -815,6 +821,62 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n                 }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n     }\n \n+    @Override\n+    public void readTableEntriesDelta(WireCommands.ReadTableEntriesDelta readTableEntriesDelta) {\n+        final String segment = readTableEntriesDelta.getSegment();\n+        final String operation = \"readTableEntriesDelta\";\n+\n+        if (!verifyToken(segment, readTableEntriesDelta.getRequestId(), readTableEntriesDelta.getDelegationToken(), operation)) {\n+            return;\n+        }\n+\n+        final int suggestedEntryCount = readTableEntriesDelta.getSuggestedEntryCount();\n+        final long fromPosition = readTableEntriesDelta.getFromPosition();\n+\n+        log.info(readTableEntriesDelta.getRequestId(), \"Fetching keys from {}.\", readTableEntriesDelta);\n+\n+        val timer = new Timer();\n+        val result = new DeltaIteratorResult<BufferView, Map.Entry<WireCommands.TableKey, WireCommands.TableValue>, DeltaIteratorState>(\n+                segment.getBytes().length + WireCommands.TableEntriesRead.HEADER_BYTES);\n+        tableStore.entryDeltaIterator(segment, fromPosition, TIMEOUT)\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {\n+                            if (result.getItemCount() >= suggestedEntryCount || result.getSizeBytes() >= MAX_READ_SIZE) {\n+                                return  false;\n+                            }\n+                            TableEntry entry = e.getEntries().iterator().next();\n+                            DeltaIteratorState state = DeltaIteratorState.deserialize(e.getState().array());\n+                            // Store all TableEntries.\n+                            val k = new WireCommands.TableKey(toByteBuf(entry.getKey().getKey()), entry.getKey().getVersion());\n+                            val v = new WireCommands.TableValue(toByteBuf(entry.getValue()));\n+                            if (state.isDeletionRecord()) {\n+                                result.remove(entry.getKey().getKey(), k.size() + v.size());\n+                            } else {\n+                                Map.Entry<WireCommands.TableKey, WireCommands.TableValue> old = result.getItem(entry.getKey().getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzOTYwMA==", "bodyText": "entryDeltaIterator", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446239600", "createdAt": "2020-06-26T15:03:32Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -292,6 +294,12 @@ public void close() {\n         return newIterator(segmentName, serializedState, fetchTimeout, TableBucketReader::entry);\n     }\n \n+    @Override\n+    public CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryDeltaIterator(String segmentName, long fromPosition, Duration fetchTimeout) {\n+        logRequest(\"entryIterator\", segmentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MDI5MA==", "bodyText": "\"resumable delta iterator\"\nLet's differentiate between IteratorState and DeltaIteratorState. The Javadoc should explain what is different about this one.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446240290", "createdAt": "2020-06-26T15:04:51Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/DeltaIteratorState.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import io.pravega.segmentstore.contracts.tables.IteratorState;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+import lombok.ToString;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MTAzMw==", "bodyText": "DeltaIteratorState", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446241033", "createdAt": "2020-06-26T15:06:11Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/DeltaIteratorState.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import io.pravega.common.util.ArrayView;\n+import io.pravega.segmentstore.contracts.tables.IteratorState;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+import lombok.ToString;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents the state of a resumable iterator.\n+ */\n+@ToString\n+@Builder\n+public class DeltaIteratorState implements IteratorState {\n+    private static final Serializer SERIALIZER = new Serializer();\n+    private static final int BOOLEAN_BYTES = 1;\n+    @Getter\n+    private final long fromPosition;\n+    @Getter\n+    private final boolean reachedEnd;\n+    @Getter\n+    private final boolean shouldClear;\n+    @Getter\n+    private final boolean deletionRecord;\n+\n+    /**\n+     * Creates a new instance of the EntryIteratorState class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MjE0Ng==", "bodyText": "extra space after implements", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446242146", "createdAt": "2020-06-26T15:08:14Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/IteratorStateImpl.java", "diffHunk": "@@ -25,7 +26,7 @@\n /**\n  * Represents the state of a resumable iterator.\n  */\n-class IteratorState {\n+class IteratorStateImpl implements  IteratorState {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0MzUyNQ==", "bodyText": "You are assigning currentEntry outside of declared guards. This is not thread safe.\nDoesn't Intellij highlight this as a warning? It should be enabled by default.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446243525", "createdAt": "2020-06-26T15:10:38Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryDeltaIterator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.Builder;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@ThreadSafe\n+@Builder\n+class TableEntryDeltaIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<DeltaIteratorState, TableEntry>> currentEntry;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+\n+    //endregion\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public synchronized boolean endOfSegment() {\n+        return this.currentBatchOffset >= (this.startOffset + this.maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<DeltaIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<DeltaIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            val next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0NDcxNQ==", "bodyText": "I believe I know why you are silently ignoring this exception, but please add a comment explaining why.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446244715", "createdAt": "2020-06-26T15:12:38Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryDeltaIterator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.Builder;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+/**\n+ * Iterates through {@link TableBucket}s in a Segment.\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@ThreadSafe\n+@Builder\n+class TableEntryDeltaIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    private final long startOffset;\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<DeltaIteratorState, TableEntry>> currentEntry;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+\n+    //endregion\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {\n+        // Verify no other call to getNext() is currently executing.\n+        return getNextEntry()\n+                .thenCompose(entry -> {\n+                    if (entry == null) {\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return this.resultConverter.apply(entry);\n+                    }\n+                });\n+    }\n+\n+    public synchronized boolean endOfSegment() {\n+        return this.currentBatchOffset >= (this.startOffset + this.maxLength);\n+    }\n+\n+    private CompletableFuture<Map.Entry<DeltaIteratorState, TableEntry>> getNextEntry() {\n+        val entry = getNextEntryFromBatch();\n+        if (entry != null) {\n+            return CompletableFuture.completedFuture(entry);\n+        }\n+\n+        return fetchNextTableEntriesBatch().thenApply(val -> getNextEntryFromBatch());\n+    }\n+\n+    private synchronized Map.Entry<DeltaIteratorState, TableEntry> getNextEntryFromBatch() {\n+        if (this.currentEntry != null) {\n+            val next = this.currentEntry.next();\n+            if (!this.currentEntry.hasNext()) {\n+                this.currentEntry = null;\n+            }\n+            return next;\n+        }\n+\n+        return null;\n+    }\n+\n+    private CompletableFuture<Void> fetchNextTableEntriesBatch() {\n+        return toEntries(currentBatchOffset)\n+                .thenAccept(entries -> {\n+                    if (!entries.isEmpty()) {\n+                        this.currentEntry = entries.iterator();\n+                    } else {\n+                        this.currentEntry = null;\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<List<Map.Entry<DeltaIteratorState, TableEntry>>> toEntries(long startOffset) {\n+        TimeoutTimer timer = new TimeoutTimer(this.fetchTimeout);\n+        int length = Math.min(maxLength, MAX_READ_SIZE);\n+\n+        if (endOfSegment()) {\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        ReadResult result = this.segment.read(startOffset, length, timer.getRemaining());\n+        return AsyncReadResultProcessor.processAll(result, this.executor, timer.getRemaining())\n+                .thenApply(data -> parseEntries(data, startOffset, length));\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    private List<Map.Entry<DeltaIteratorState, TableEntry>> parseEntries(BufferView data, long startOffset, int readLength) {\n+\n+        long currentOffset = startOffset;\n+        final long maxOffset = startOffset + readLength;\n+\n+        BufferView.Reader input = data.getBufferViewReader();\n+        List<Map.Entry<DeltaIteratorState, TableEntry>> entries = new ArrayList<>();\n+        try {\n+            while (currentOffset < maxOffset) {\n+                val entry = AsyncTableEntryReader.readEntryComponents(input, currentOffset, this.entrySerializer);\n+                boolean reachedEnd = currentOffset + entry.getHeader().getTotalLength() >= this.maxLength + startOffset;\n+                // We must preserve deletions to accurately construct a delta.\n+                BufferView value = entry.getValue() == null ? BufferView.empty() : entry.getValue();\n+                currentOffset += entry.getHeader().getTotalLength();\n+                entries.add(new AbstractMap.SimpleEntry<>(\n+                        new DeltaIteratorState(currentOffset, reachedEnd, this.shouldClear, entry.getHeader().isDeletion()),\n+                        TableEntry.versioned(entry.getKey(), value, entry.getVersion())));\n+            }\n+\n+        } catch (BufferView.Reader.OutOfBoundsException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0NDk5OA==", "bodyText": "get -> entryDeltaIterator", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446244998", "createdAt": "2020-06-26T15:13:01Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableService.java", "diffHunk": "@@ -109,6 +109,13 @@ public TableService(SegmentContainerRegistry segmentContainerRegistry, SegmentTo\n                 \"get\", segmentName, serializedState != null, fetchTimeout);\n     }\n \n+    @Override\n+    public CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryDeltaIterator(String segmentName, long fromPosition, Duration fetchTimeout) {\n+        return invokeExtension(segmentName,\n+                e -> e.entryDeltaIterator(segmentName, fromPosition, fetchTimeout),\n+                \"get\", segmentName, fromPosition, fetchTimeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI0ODExOQ==", "bodyText": "you need to add .requireRelease() before returning this object. See the changes that were made to TableEntriesRead ,for example.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r446248119", "createdAt": "2020-06-26T15:18:32Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2238,31 +2238,31 @@ public boolean isFailure() {\n         final String segment;\n         @ToString.Exclude\n         final String delegationToken;\n-        final long fromVersion;\n+        final long fromPosition;\n         final int suggestedEntryCount;\n \n         @Override\n         public void process(RequestProcessor cp) {\n-\n+            cp.readTableEntriesDelta(this);\n         }\n \n         @Override\n         public void writeFields(DataOutput out) throws IOException {\n             out.writeLong(requestId);\n             out.writeUTF(segment);\n             out.writeUTF(delegationToken == null ? \"\" : delegationToken);\n-            out.writeLong(fromVersion);\n+            out.writeLong(fromPosition);\n             out.writeInt(suggestedEntryCount);\n         }\n \n         public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n             long requestId = in.readLong();\n             String segment = in.readUTF();\n             String delegationToken = in.readUTF();\n-            long fromVersion = in.readLong();\n+            long fromPosition = in.readLong();\n             int suggestedEntryCount = in.readInt();\n \n-            return new ReadTableEntriesDelta(requestId, segment, delegationToken, fromVersion, suggestedEntryCount);\n+            return new ReadTableEntriesDelta(requestId, segment, delegationToken, fromPosition, suggestedEntryCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b551e1c40dc2a059f80bb5d7361498952356457b"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "720cefe147a5a013d42eecad357c969c5480de86", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/720cefe147a5a013d42eecad357c969c5480de86", "committedDate": "2020-06-29T19:41:18Z", "message": "* Addresses feedback from PR.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6615136824e0c79e4c2c7b0ca8e7cf99c4f4f7d8", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/6615136824e0c79e4c2c7b0ca8e7cf99c4f4f7d8", "committedDate": "2020-06-29T20:34:54Z", "message": "* Add debug logs to readTableEntriesDelta.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dd70593b07d84f5914acaab5009faea8b420fb7", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/8dd70593b07d84f5914acaab5009faea8b420fb7", "committedDate": "2020-06-29T22:31:50Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTQ5Njky", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-439549692", "createdAt": "2020-06-29T22:37:43Z", "commit": {"oid": "8dd70593b07d84f5914acaab5009faea8b420fb7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMjozNzo0NFrOGqk-JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMjozNzo0NFrOGqk-JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI5OTEwOQ==", "bodyText": "This is where you need to add it. See other cases in this class for examples how to do it.\nIf you want to know what, then follow through the .release call at line 2308 and see which ByteBufs get released. Without invoking that (and requiring it), those buffers will stick around for a long time and lead to memory leaks).", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r447299109", "createdAt": "2020-06-29T22:37:44Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2299,14 +2298,14 @@ public static WireCommand readFrom(EnhancedByteBufInputStream in, int length) th\n             TableEntries entries = TableEntries.readFrom(in, in.available());\n             boolean shouldClear = in.readBoolean();\n             boolean reachedEnd = in.readBoolean();\n-            long lastVersion = in.readLong();\n+            long lastPosition = in.readLong();\n \n-            return new TableEntriesDeltaRead(requestId, segment, entries, shouldClear, reachedEnd, lastVersion);\n+            return new TableEntriesDeltaRead(requestId, segment, entries, shouldClear, reachedEnd, lastPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dd70593b07d84f5914acaab5009faea8b420fb7"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75fde4ba492edc0ad20688475a01dec477386994", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/75fde4ba492edc0ad20688475a01dec477386994", "committedDate": "2020-06-30T21:13:26Z", "message": "* Add release requirement to TableEntriesDelta read command.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14187411742aeae7d394f99030f8770c658cbb7c", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/14187411742aeae7d394f99030f8770c658cbb7c", "committedDate": "2020-06-30T21:14:07Z", "message": "Merge remote-tracking branch 'origin/issue-4677-offset-table-reads' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d7a68def78ac1aa93994b120190a31729550096", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/9d7a68def78ac1aa93994b120190a31729550096", "committedDate": "2020-07-01T16:13:54Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "964d971e4feb8c4addb1d77ffae75bdfc906b8fa", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/964d971e4feb8c4addb1d77ffae75bdfc906b8fa", "committedDate": "2020-07-01T20:37:49Z", "message": "* Remove redundant extension.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29725a2a49fc498254d2ea213c86d6a539fb0740", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/29725a2a49fc498254d2ea213c86d6a539fb0740", "committedDate": "2020-07-01T20:38:32Z", "message": "Merge remote-tracking branch 'origin/issue-4677-offset-table-reads' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjM5ODgz", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-441239883", "createdAt": "2020-07-01T22:39:37Z", "commit": {"oid": "29725a2a49fc498254d2ea213c86d6a539fb0740"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTM2OTU4", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-444136958", "createdAt": "2020-07-07T18:14:27Z", "commit": {"oid": "29725a2a49fc498254d2ea213c86d6a539fb0740"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxODoxNDoyN1rOGuKLWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToyOToyNFrOGuQSMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NDQyNg==", "bodyText": "This needs to be explained in more depth.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r451054426", "createdAt": "2020-07-07T18:14:27Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -231,4 +231,23 @@ default int maximumValueLength() {\n      * @throws IllegalDataFormatException If serializedState is not null and cannot be deserialized.\n      */\n     CompletableFuture<AsyncIterator<IteratorItem<TableEntry>>> entryIterator(String segmentName, BufferView serializedState, Duration fetchTimeout);\n+\n+    /**\n+     * Creates a new {@link AsyncIterator} over all the {@link TableEntry} instances in the given Table Segment starting from a given position.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29725a2a49fc498254d2ea213c86d6a539fb0740"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NzI0OQ==", "bodyText": "I don't see this being sent back in the return value. Is it actually used for anything?", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r451057249", "createdAt": "2020-07-07T18:19:42Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -1001,5 +1067,45 @@ synchronized BufferView getContinuationToken() {\n         }\n     }\n \n+    private static class DeltaIteratorResult<K, V, S> {\n+        @Getter\n+        @Setter\n+        @GuardedBy(\"this\")\n+        private S state;\n+        @GuardedBy(\"this\")\n+        private final Map<K, V> items = new HashMap<>();\n+        @Getter\n+        @GuardedBy(\"this\")\n+        private int sizeBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29725a2a49fc498254d2ea213c86d6a539fb0740"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NDQ4MA==", "bodyText": "It says this is thread safe, but I am not clear on the semantics of this method being called in parallel.\nIn particular getNextEntry could have two calls to getNextEntryFromBatch in parallel both get null and hence end up calling fetchNextTableEntriesBatch twice. When if those calls had been ordered it would have only resulted to one call to fetchNextTableEntriesBatch", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r451154480", "createdAt": "2020-07-07T21:29:24Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableEntryDeltaIterator.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.util.AsyncIterator;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.segmentstore.contracts.ReadResult;\n+import io.pravega.segmentstore.contracts.tables.TableEntry;\n+import io.pravega.segmentstore.server.DirectSegmentAccess;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+import io.pravega.segmentstore.server.reading.AsyncReadResultProcessor;\n+import lombok.Builder;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+/**\n+ * Iterates through a {@link DirectSegmentAccess}, deserializing {@link TableEntry} from a {@link BufferView} in linear fashion.\n+ *\n+ * @param <T> Type of the final, converted result.\n+ */\n+@Slf4j\n+@ThreadSafe\n+@Builder\n+class TableEntryDeltaIterator<T> implements AsyncIterator<T> {\n+    //region Members\n+\n+    // The maximum size (in bytes) of each read to perform on the segment.\n+    private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n+\n+    private final DirectSegmentAccess segment;\n+    // The offset to being iteration at.\n+    private final long startOffset;\n+    // Maximum length of the TableSegment we want to read until.\n+    private final int maxLength;\n+    private final boolean shouldClear;\n+    private final Duration fetchTimeout;\n+    private final EntrySerializer entrySerializer;\n+    private final ConvertResult<T> resultConverter;\n+    private final Executor executor;\n+\n+    @GuardedBy(\"this\")\n+    private Iterator<Map.Entry<DeltaIteratorState, TableEntry>> currentEntry;\n+    @GuardedBy(\"this\")\n+    private long currentBatchOffset;\n+\n+    //endregion\n+\n+    //region AsyncIterator Implementation\n+\n+    @Override\n+    public CompletableFuture<T> getNext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29725a2a49fc498254d2ea213c86d6a539fb0740"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57c266dbf42f093e1df6ea262c460f21b38efcf4", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/57c266dbf42f093e1df6ea262c460f21b38efcf4", "committedDate": "2020-07-09T18:20:08Z", "message": "* Fix possible race condition.\n* Improve documentation for TableStore.entryDeltaIterator.\n* Rename tests class.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0391c923f5f22c47767cfa6e363bb598b2a65fe8", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/0391c923f5f22c47767cfa6e363bb598b2a65fe8", "committedDate": "2020-07-09T18:47:06Z", "message": "* Change solution for potential race condition.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3437025a1696ebf736fbecc5d947c0a8856d7b5", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/f3437025a1696ebf736fbecc5d947c0a8856d7b5", "committedDate": "2020-07-09T18:57:28Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4677-offset-table-reads\n\n\u0001 Conflicts:\n\u0001\tsegmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java\n\u0001\tsegmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java\n\u0001\tsegmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java\n\u0001\tsegmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/TableServiceTests.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e217c0fcb7297626e4c161005708e61fc38bc62", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/6e217c0fcb7297626e4c161005708e61fc38bc62", "committedDate": "2020-07-09T19:24:25Z", "message": "* Fix merge conflicts.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c163927faf73d41fbcb20ed660cde5ab054223b0", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/c163927faf73d41fbcb20ed660cde5ab054223b0", "committedDate": "2020-07-09T19:30:27Z", "message": "* Fix merge issue.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "575c090be7ecb83217b7a5fa4f5b54b1e8dc2f7f", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/575c090be7ecb83217b7a5fa4f5b54b1e8dc2f7f", "committedDate": "2020-07-09T23:33:11Z", "message": "* Fix invalid method call.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20237d641268a4b416046c49d54d74db18c5317d", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/20237d641268a4b416046c49d54d74db18c5317d", "committedDate": "2020-07-14T10:20:10Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9be2b6820ef674f1fa86793e2741531735f28d2", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e9be2b6820ef674f1fa86793e2741531735f28d2", "committedDate": "2020-07-14T17:41:57Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDIyNDI3", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-449422427", "createdAt": "2020-07-16T00:05:03Z", "commit": {"oid": "e9be2b6820ef674f1fa86793e2741531735f28d2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eb88f730ad9e4b848064112f5410b9d068214f0", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/3eb88f730ad9e4b848064112f5410b9d068214f0", "committedDate": "2020-07-16T00:18:43Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "535ec5786f0aab9e8c137877ef0c93708af13619", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/535ec5786f0aab9e8c137877ef0c93708af13619", "committedDate": "2020-07-16T19:20:10Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd4811be8d1079b6b7e5205101ba840e8f9c60e3", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/fd4811be8d1079b6b7e5205101ba840e8f9c60e3", "committedDate": "2020-07-16T20:34:13Z", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4677-offset-table-reads\n\n\u0001 Conflicts:\n\u0001\tsegmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java\n\u0001\tsegmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImplTests.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8127f135018b7585ce498754c46416bf00674d6a", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/8127f135018b7585ce498754c46416bf00674d6a", "committedDate": "2020-07-16T21:10:42Z", "message": "* Merge conflicts.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74ea516eaf44c8e0b0c589d13721c097045117dc", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/74ea516eaf44c8e0b0c589d13721c097045117dc", "committedDate": "2020-07-16T21:14:48Z", "message": "Merge remote-tracking branch 'origin/issue-4677-offset-table-reads' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzAzODc0", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-450303874", "createdAt": "2020-07-17T00:40:02Z", "commit": {"oid": "74ea516eaf44c8e0b0c589d13721c097045117dc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMDo0MDowMlrOGzBdmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMDo0MDowMlrOGzBdmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE1NDUyMA==", "bodyText": "It just occurred to me that this will not work on sorted table segments. It does not have to.\nLet's add a check here (it's an attribute stored in the SegmentProperties) whether this is a sorted table segment. If it is, we should be throwing/returning an UnsupportedOperationException explaining why.", "url": "https://github.com/pravega/pravega/pull/4867#discussion_r456154520", "createdAt": "2020-07-17T00:40:02Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImpl.java", "diffHunk": "@@ -457,13 +463,48 @@ protected int getMaxCompactionSize() {\n                 });\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public <T> CompletableFuture<AsyncIterator<IteratorItem<T>>> newDeltaIterator(@NonNull String segmentName, long fromPosition, @NonNull Duration fetchTimeout) {\n+        return this.segmentContainer\n+                .forSegment(segmentName, fetchTimeout)\n+                .thenComposeAsync(segment -> {\n+                    SegmentProperties properties = segment.getInfo();\n+                    long compactionOffset = properties.getAttributes().getOrDefault(TableAttributes.COMPACTION_OFFSET, 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74ea516eaf44c8e0b0c589d13721c097045117dc"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e75cfbf24f2bb93089acf6cae0c58c48d399c95", "author": {"user": {"login": "co-jo", "name": "Colin Hryniowski"}}, "url": "https://github.com/pravega/pravega/commit/5e75cfbf24f2bb93089acf6cae0c58c48d399c95", "committedDate": "2020-07-17T22:15:13Z", "message": "* Add guards to prevent a delta iterator being used on a sorted TableSegment.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc56ebfc4bef1b09be771924cfc9aea7fe9879b1", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/bc56ebfc4bef1b09be771924cfc9aea7fe9879b1", "committedDate": "2020-07-17T23:43:26Z", "message": "Merge branch 'master' into issue-4677-offset-table-reads"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDA1NTQx", "url": "https://github.com/pravega/pravega/pull/4867#pullrequestreview-451005541", "createdAt": "2020-07-17T23:43:45Z", "commit": {"oid": "bc56ebfc4bef1b09be771924cfc9aea7fe9879b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3537, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}