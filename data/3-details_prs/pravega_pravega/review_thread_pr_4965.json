{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NDA2NDk4", "number": 4965, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNTowMTo0NlrOERTdvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQwNDo1MzozMlrOFat-jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTgwMTU5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNTowMTo0NlrOG18SIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoyMToxMlrOG2SCeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNTM5Mg==", "bodyText": "Are  you sure that the JVM (or even javac) won't drop this block? AFAIK the JVM is quite aggressive in skipping useless stuff and monitor related code", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r459215392", "createdAt": "2020-07-23T05:01:46Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        if (sealedSegmentQueue.isEmpty()) {\n+            synchronized (writeSealLock) {\n+                // Nothing needs to be done here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d14dfa610d3117229684e149ee671d2f0dbc8ad"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNzg2OA==", "bodyText": "Yeah this could be a possibility.\nCould we try to use a ReusableLatch here or some Semaphore (or any other synchronization primitive)?", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r459517868", "createdAt": "2020-07-23T15:02:33Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        if (sealedSegmentQueue.isEmpty()) {\n+            synchronized (writeSealLock) {\n+                // Nothing needs to be done here.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNTM5Mg=="}, "originalCommit": {"oid": "1d14dfa610d3117229684e149ee671d2f0dbc8ad"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxOTk4OA==", "bodyText": "probably if you add a metric here (just a counter that counts how many times we fall into this case) the JVM will be happy as it thinks that we are doing something useful", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r459519988", "createdAt": "2020-07-23T15:05:33Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        if (sealedSegmentQueue.isEmpty()) {\n+            synchronized (writeSealLock) {\n+                // Nothing needs to be done here.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNTM5Mg=="}, "originalCommit": {"oid": "1d14dfa610d3117229684e149ee671d2f0dbc8ad"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTgzMg==", "bodyText": "I think SpotBugs doesn't like this either. The build failed due to that.", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r459571832", "createdAt": "2020-07-23T16:21:12Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        if (sealedSegmentQueue.isEmpty()) {\n+            synchronized (writeSealLock) {\n+                // Nothing needs to be done here.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNTM5Mg=="}, "originalCommit": {"oid": "1d14dfa610d3117229684e149ee671d2f0dbc8ad"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTg2OTU3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNDoyNDo0MlrOG2iw5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxNDoyN1rOG2qNNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0NTg2Mw==", "bodyText": "Is 100ms too high? This change implies that no new writes can happen via the EventStreamWriter for a max of  100ms since it holds the writeFlushLock.", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r459845863", "createdAt": "2020-07-24T04:24:42Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,33 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        if (sealedSegmentQueue.isEmpty()) {\n+            synchronized (writeSealLock) {\n+                // Nothing needs to be done here.\n+                // When the lock is released the sealing should be complete.\n+                log.debug(\"Segment sealing completed, retrying flush.\");\n+            }\n+        } else {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(100));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c30331d509fe593b7b349779b38000a0672a3bb4"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2MzM4MA==", "bodyText": "@shrids you mean no writes to \"any\" segment can happen while the sleep is executed? If so, this would be quite disruptive for write performance when scales are frequent. And the fact of making the sleep lower I don't know if is going to improve much the situation, right? Could the \"sleep\" be out of the synchronized block so writes to other segments can make progress?", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r459963380", "createdAt": "2020-07-24T10:03:43Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,33 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        if (sealedSegmentQueue.isEmpty()) {\n+            synchronized (writeSealLock) {\n+                // Nothing needs to be done here.\n+                // When the lock is released the sealing should be complete.\n+                log.debug(\"Segment sealing completed, retrying flush.\");\n+            }\n+        } else {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(100));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0NTg2Mw=="}, "originalCommit": {"oid": "c30331d509fe593b7b349779b38000a0672a3bb4"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2Nzc5Nw==", "bodyText": "Yes, if at time t0 the sleep is invoked then writes can happen only at timet0 + 100ms when the writeFlushLock is released. This is the case even if the sealed segment handling is completed at t0 + 1ms.", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r459967797", "createdAt": "2020-07-24T10:14:27Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,33 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        if (sealedSegmentQueue.isEmpty()) {\n+            synchronized (writeSealLock) {\n+                // Nothing needs to be done here.\n+                // When the lock is released the sealing should be complete.\n+                log.debug(\"Segment sealing completed, retrying flush.\");\n+            }\n+        } else {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(100));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0NTg2Mw=="}, "originalCommit": {"oid": "c30331d509fe593b7b349779b38000a0672a3bb4"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODQxOTYyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODo0Mjo0NFrOHuRSUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMDoxNTozM1rOIls8tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3OTc2Mw==", "bodyText": "A clarification question: what would we need to do to wait on the processing of the sealed segment rather than set a fixed amount of time to wait in each loop iteration?", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r518279763", "createdAt": "2020-11-05T18:42:44Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        while (!sealedSegmentQueue.isEmpty()) {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(10));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf78317130d7689fa16b2c7a1a7b779e736e51f3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQwNDY2Mw==", "bodyText": "This loop is blocking on the sealedSegmentQueue becoming empty. Once the queue is empty and the writeSealLock is released we should return. However there is no built in way to block on a queue becoming empty. Hence it is polling. We could make a custom data structure to provide this capability if we want.", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r576404663", "createdAt": "2021-02-15T20:15:33Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -224,12 +224,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        while (!sealedSegmentQueue.isEmpty()) {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3OTc2Mw=="}, "originalCommit": {"oid": "bf78317130d7689fa16b2c7a1a7b779e736e51f3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNTU5MTc1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQwNDo0NjoxN1rOIl1mXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwMDowNTo0OFrOIoBMBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjU0NjM5Ng==", "bodyText": "The same issue can happen during the invocation of io.pravega.client.stream.impl.EventStreamWriterImpl#close", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r576546396", "createdAt": "2021-02-16T04:46:17Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -250,12 +250,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef8204210deb8a0a8677a534f069fd637ba8649"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODgzMzQxMg==", "bodyText": "Added", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r578833412", "createdAt": "2021-02-19T00:05:48Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -250,12 +250,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjU0NjM5Ng=="}, "originalCommit": {"oid": "6ef8204210deb8a0a8677a534f069fd637ba8649"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNTYwNTkxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQwNDo1MzozMlrOIl1t7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwOToxNzozNlrOImseaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjU0ODMzMg==", "bodyText": "No new writes are allowed once writeFlushLock is held by flush(),this implies that writer need not try to acquire the writeSealLock  to verify that retransmit to sealed segments are complete, right ?\nAlso, sealedSegmentQueue.isEmpty() check would suffice in the scenario where retransmit of inflight events face a sealed segment exception..", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r576548332", "createdAt": "2021-02-16T04:53:32Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -250,12 +250,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        while (!sealedSegmentQueue.isEmpty()) {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(10));\n+        }\n+        synchronized (writeSealLock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef8204210deb8a0a8677a534f069fd637ba8649"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzI2MzQxMQ==", "bodyText": "We want to make sure that when flush is called it does not return until all the segments have been flushed. It aquires the writeFlushLock to prevent future writes. However there may be a concurrent seal. We just need to keep retrying calling flush on the writers until all have flushed. The previous logic was \"correct\" however in the event there was an ongoing seal it was wasteful because it would keep trying to flush a sealed segment over and over. The solution here it to attempt to block on the seal being completed. sealedSegmentQueue.isEmpty() Would tell us that no seal operation is pending. This is a necessary but not a sufficient criteria, because there could be still one in progress. The writeSealLock is not needed to do anything here, (Notice nothing is done inside of the lock) it's just done to queue the flush thread on an ongoing seal if one is indeed in progress.\nIf this is too confusing and you would like me to add a reusable latch, I am happy to make that change.", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r577263411", "createdAt": "2021-02-17T01:33:55Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -250,12 +250,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        while (!sealedSegmentQueue.isEmpty()) {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(10));\n+        }\n+        synchronized (writeSealLock) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjU0ODMzMg=="}, "originalCommit": {"oid": "6ef8204210deb8a0a8677a534f069fd637ba8649"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzQ0NTQ4MQ==", "bodyText": "ok \ud83d\udc4d", "url": "https://github.com/pravega/pravega/pull/4965#discussion_r577445481", "createdAt": "2021-02-17T09:17:36Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java", "diffHunk": "@@ -250,12 +250,32 @@ public void flush() {\n                         // available writers.\n                         success = false;\n                         log.warn(\"Flush on segment {} failed due to {}, it will be retried.\", writer.getSegmentName(), e.getMessage());\n+                        tryWaitForSuccessors();\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n+    \n+    /**\n+     * This is used by flush to optimistically wait for the `handleLogSealed` work to be completed\n+     * to prevent a busy loop while waiting for the segments to be updated following a sealed\n+     * segment. Please note there are no guarantees about when this method returns. It can be\n+     * thought of as a sleep.\n+     */\n+    @GuardedBy(\"writeFlushLock\")\n+    private void tryWaitForSuccessors() {\n+        while (!sealedSegmentQueue.isEmpty()) {\n+            // A background thread should be waking up to process things. Give it a moment.\n+            Exceptions.handleInterrupted(() -> Thread.sleep(10));\n+        }\n+        synchronized (writeSealLock) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjU0ODMzMg=="}, "originalCommit": {"oid": "6ef8204210deb8a0a8677a534f069fd637ba8649"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4807, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}