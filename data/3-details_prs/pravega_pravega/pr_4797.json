{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NzE3Mzg3", "number": 4797, "title": "Issue 4796: (KeyValue Tables) CreateAPI for Key Value Tables", "bodyText": "Signed-off-by: pbelgundi prajakta.belgundi@emc.com\nChange log description\nThis PR adds code for supporting KeyValueTables on Pravega Controller.\nFor details please refer https://github.com/pravega/pravega/wiki/PDP-39-Key-Value-Tables\nPurpose of the change\nFixes #4796\nWhat the code does\nAdds CreateKeyValueTable API and getCurrentSegmentsKeyValueTable() API to Controller, that enables client to create a new KeyValueTable and fetch its currentSegments.\nHow to verify it\nAll Unit and Integration Tests should pass including those for CreateKeyValueTable.", "createdAt": "2020-05-18T20:12:11Z", "url": "https://github.com/pravega/pravega/pull/4797", "merged": true, "mergeCommit": {"oid": "6d69ff2ed75776c38a1a0fafe08180c85c31edac"}, "closed": true, "closedAt": "2020-06-17T14:56:00Z", "author": {"login": "pbelgundi"}, "timelineItems": {"totalCount": 75, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcild2eAH2gAyNDE5NzE3Mzg3OjVmYjQwMzM4OWY1YmRmZGVhZDE5MDQ2ZTY0NzE2YjNhODZmOTI1YjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsKdnegFqTQzMjQ0MDMxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5fb403389f5bdfdead19046e64716b3a86f925b4", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/5fb403389f5bdfdead19046e64716b3a86f925b4", "committedDate": "2020-05-18T19:58:36Z", "message": "glue code for KVTables\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "537376a3d983c5c57802902cd566d5ff142197d3", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/537376a3d983c5c57802902cd566d5ff142197d3", "committedDate": "2020-05-19T10:10:18Z", "message": "Added createAPI call to protobuf\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8aa83f2f3417db3920d5490b84976307e6b0320", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e8aa83f2f3417db3920d5490b84976307e6b0320", "committedDate": "2020-05-19T12:29:13Z", "message": "fixed glue code\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e6e300a778dc68d4f56a9fd443a0eb96651098b", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/3e6e300a778dc68d4f56a9fd443a0eb96651098b", "committedDate": "2020-05-20T13:10:56Z", "message": "createAPI metadata code\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70321c172e7bcd19d6049287cddc93f852aa0f84", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/70321c172e7bcd19d6049287cddc93f852aa0f84", "committedDate": "2020-05-21T17:47:08Z", "message": "more changes for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f42dcbf4c08c24a624cad76ca8fba3a33690a781", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/f42dcbf4c08c24a624cad76ca8fba3a33690a781", "committedDate": "2020-05-22T11:38:02Z", "message": "changes for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f07f3c03ddc0dd6332fa6cb85e757afc486c13a1", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/f07f3c03ddc0dd6332fa6cb85e757afc486c13a1", "committedDate": "2020-05-27T08:39:17Z", "message": "code review comments impl1\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1748d1e377ada68e3cdfaeb884fed0b385839d5", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/d1748d1e377ada68e3cdfaeb884fed0b385839d5", "committedDate": "2020-05-28T11:08:23Z", "message": "CreateAPI changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "801783001ad71841266cba48eb2a63dd0e386d6a", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/801783001ad71841266cba48eb2a63dd0e386d6a", "committedDate": "2020-05-28T11:25:59Z", "message": "Added builder to KeyVaueTableConfiguration\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "committedDate": "2020-05-28T13:18:56Z", "message": "fixed checkstyle errors\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjE5MjU5", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-420619259", "createdAt": "2020-05-29T02:50:18Z", "commit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMjo1MDoxOFrOGcNHBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoxMDo1NlrOGcOLPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODEwMQ==", "bodyText": "nit: revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228101", "createdAt": "2020-05-29T02:50:18Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -280,4 +280,6 @@\n      */\n     @Override\n     void close();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODIzNg==", "bodyText": "nit: TableConfig", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228236", "createdAt": "2020-05-29T02:50:55Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -115,6 +117,20 @@ public static final StreamConfiguration encode(final StreamConfig config) {\n                 .build();\n     }\n \n+    /**\n+     * Helper to convert StreamConfig into Stream Configuration Impl.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODg4NQ==", "bodyText": "maybe we can name it better as this is going to pravega common in futures.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228885", "createdAt": "2020-05-29T02:53:39Z", "author": {"login": "shiveshr"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +47,25 @@\n  */\n public final class Futures {\n \n+    public static <T> CompletableFuture<T> withCompletion(CompletableFuture<T> future, final Executor executor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODk4OA==", "bodyText": "please revert this reordering.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228988", "createdAt": "2020-05-29T02:54:12Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -21,15 +21,17 @@\n import io.pravega.controller.metrics.StreamMetrics;\n import io.pravega.controller.metrics.TransactionMetrics;\n import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.OperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n import io.pravega.controller.store.stream.BucketStore;\n-import io.pravega.controller.store.stream.OperationContext;\n-import io.pravega.controller.store.stream.ScaleMetadata;\n import io.pravega.controller.store.stream.State;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTEzMQ==", "bodyText": "nit: table", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432229131", "createdAt": "2020-05-29T02:54:49Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -95,6 +100,29 @@\n         }, executor);\n     }\n \n+    public CompletableFuture<CreateKeyValueTableStatus> createKeyValueTable(String scope, String kvtName,\n+                                                                            final KeyValueTableConfiguration kvtConfig,\n+                                                                            final long createTimestamp) {\n+        Preconditions.checkNotNull(kvtConfig, \"kvTableConfig\");\n+        Preconditions.checkArgument(createTimestamp >= 0);\n+        Timer timer = new Timer();\n+        try {\n+            NameUtils.validateUserKeyValueTableName(kvtName);\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            log.warn(\"Create KeyValueTable failed due to invalid name {}\", kvtName);\n+            return CompletableFuture.completedFuture(\n+                    CreateKeyValueTableStatus.newBuilder().setStatus(CreateKeyValueTableStatus.Status.INVALID_TABLE_NAME).build());\n+        }\n+        // check if stream with same name exists...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTU1Mg==", "bodyText": "CreateKVTableStatus", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432229552", "createdAt": "2020-05-29T02:56:40Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -484,6 +512,16 @@ private Throwable getRealException(Throwable ex) {\n \n     // Metrics reporting region\n \n+\n+    private void reportCreateKVTableMetrics(String scope, String kvtName, int initialSegments, CreateKeyValueTableStatus.Status status,\n+                                           Duration latency) {\n+        if (status.equals(CreateStreamStatus.Status.SUCCESS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTYwNA==", "bodyText": "same as above", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432229604", "createdAt": "2020-05-29T02:57:00Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -484,6 +512,16 @@ private Throwable getRealException(Throwable ex) {\n \n     // Metrics reporting region\n \n+\n+    private void reportCreateKVTableMetrics(String scope, String kvtName, int initialSegments, CreateKeyValueTableStatus.Status status,\n+                                           Duration latency) {\n+        if (status.equals(CreateStreamStatus.Status.SUCCESS)) {\n+            StreamMetrics.getInstance().createStream(scope, kvtName, initialSegments, latency);\n+        } else if (status.equals(CreateStreamStatus.Status.FAILURE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzMDAzMw==", "bodyText": "please revert the reordering of imports (here and everywhere else)", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432230033", "createdAt": "2020-05-29T02:58:54Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "diffHunk": "@@ -31,19 +31,24 @@\n import io.pravega.controller.eventProcessor.impl.EventProcessorGroupConfigImpl;\n import io.pravega.controller.eventProcessor.impl.EventProcessorSystemImpl;\n import io.pravega.controller.fault.FailoverSweeper;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.StreamRequestHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDYzMQ==", "bodyText": "please revert this.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432244631", "createdAt": "2020-05-29T04:06:41Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java", "diffHunk": "@@ -50,6 +50,7 @@\n     private final BucketStore bucketStore;\n     private final ScheduledExecutorService executor;\n     private final BlockingQueue<CommitEvent> processedEvents;\n+    private final StreamMetadataStore streamStore = (StreamMetadataStore) getMetadataStore();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTAxMQ==", "bodyText": "we dont need to add a getter. the protected variable is availble to derived classes.\nso revert these changes. And also revert all derived classes where you use the getter.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432245011", "createdAt": "2020-05-29T04:08:36Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java", "diffHunk": "@@ -54,15 +55,16 @@\n  * was set against its name.\n  */\n @Slf4j\n-public abstract class AbstractRequestProcessor<T extends ControllerEvent> extends SerializedRequestHandler<T> implements RequestProcessor {\n+public abstract class AbstractRequestProcessor<T extends ControllerEvent> extends SerializedRequestHandler<T> implements StreamRequestProcessor {\n     protected static final Predicate<Throwable> OPERATION_NOT_ALLOWED_PREDICATE = e -> Exceptions.unwrap(e) instanceof StoreException.OperationNotAllowedException;\n \n-    protected final StreamMetadataStore streamMetadataStore;\n+    @Getter\n+    protected final StreamMetadataStore metadataStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTU2Ng==", "bodyText": "nit: please revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432245566", "createdAt": "2020-05-29T04:10:56Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java", "diffHunk": "@@ -42,7 +42,7 @@\n \n     public DeleteStreamTask(final StreamMetadataTasks streamMetadataTasks,\n                             final StreamMetadataStore streamMetadataStore,\n-                            final BucketStore bucketStore, \n+                            final BucketStore bucketStore,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjQzMzY5", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-420643369", "createdAt": "2020-05-29T04:23:32Z", "commit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyMzozMlrOGcOWLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyMzozMlrOGcOWLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0ODM2Ng==", "bodyText": "Let us evaluate whether it makes sense to create this higher level abstraction right now.\nwe can create this abstraction when we think tables will also require a waiting request processor mechanism for fairness.\nthe whole waiting request processor business is a bit of a patchwork done for streams because we wanted fairness in execution of work for commit and other workflows.. primarily because commit can be overwhelmingly more frequent than other workflows which can end up waiting unnecessarily..\nmaybe we dont need such construct for tables ever.. at least not now..\nso creating this abstraction is unnecessary at this point and making these methods available and implemented in table store unnecessarily.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432248366", "createdAt": "2020-05-29T04:23:32Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/ArtifactStore.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store;\n+\n+import io.pravega.common.concurrent.Futures;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+public interface ArtifactStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjQzODY4", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-420643868", "createdAt": "2020-05-29T04:25:29Z", "commit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyNToyOVrOGcOXsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyNToyOVrOGcOXsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0ODc1NA==", "bodyText": "table's operation context and stream's operation context need not be derived from same base interface. table's requests (operations) are independent of streams. so we dont need a common interface for them.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432248754", "createdAt": "2020-05-29T04:25:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/OperationContext.java", "diffHunk": "@@ -7,14 +7,13 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.controller.store.stream;\n+package io.pravega.controller.store;\n \n /**\n  * Interface for defining an operation context.\n  * A context caches metadata fetches so within a context if for the same entity, multiple\n  * read operations against the store are requested, the values are served from the context's cache.\n  */\n-public interface OperationContext {\n-\n-    Stream getStream();\n+public interface OperationContext<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjQ0MzE1", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-420644315", "createdAt": "2020-05-29T04:27:10Z", "commit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyNzoxMFrOGcOZBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyNzoxMFrOGcOZBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTA5NQ==", "bodyText": "we can take out the scope's object cache into its own class.. and use that same cache here and in stream metadata store.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432249095", "createdAt": "2020-05-29T04:27:10Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/kvtable/AbstractTableMetadataStore.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.Scope;\n+import io.pravega.controller.store.OperationContext;\n+import io.pravega.controller.store.VersionedMetadata;\n+import io.pravega.controller.store.Artifact;\n+import io.pravega.controller.store.index.HostIndex;\n+import io.pravega.controller.store.stream.StoreException;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.ControllerEventSerializer;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.ParametersAreNonnullByDefault;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+\n+public abstract class AbstractTableMetadataStore implements TableMetadataStore {\n+    private final LoadingCache<String, Scope> scopeCache;\n+    private final LoadingCache<Pair<String, String>, KeyValueTable> cache;\n+    private final HostIndex hostTaskIndex;\n+    private final ControllerEventSerializer controllerEventSerializer;\n+\n+    protected AbstractTableMetadataStore(HostIndex hostTaskIndex) {\n+        cache = CacheBuilder.newBuilder()\n+                .maximumSize(10000)\n+                .refreshAfterWrite(10, TimeUnit.MINUTES)\n+                .expireAfterWrite(10, TimeUnit.MINUTES)\n+                .build(\n+                        new CacheLoader<Pair<String, String>, KeyValueTable>() {\n+                            @Override\n+                            @ParametersAreNonnullByDefault\n+                            public KeyValueTable load(Pair<String, String> input) {\n+                                try {\n+                                    return newKeyValueTable(input.getKey(), input.getValue());\n+                                } catch (Exception e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            }\n+                        });\n+\n+        scopeCache = CacheBuilder.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjQ0OTYw", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-420644960", "createdAt": "2020-05-29T04:29:42Z", "commit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyOTo0M1rOGcObEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoyOTo0M1rOGcObEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTYxNg==", "bodyText": "nit: table", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432249616", "createdAt": "2020-05-29T04:29:43Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/kvtable/KVTableState.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+\n+/**\n+ * This is used to represent the state of the Stream.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjQ1Njk1", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-420645695", "createdAt": "2020-05-29T04:32:43Z", "commit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDozMjo0M1rOGcOddg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDozMjo0M1rOGcOddg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MDIzMA==", "bodyText": "Please call this class AbstractTable.\nI have an issue for renaming PersistentStreamBase to AbstractStream as well.\nI dont know why i created that weird name earlier. But please using a different name here. We have followed the pattern of calling the base abstract class AbstractXXX", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432250230", "createdAt": "2020-05-29T04:32:43Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/kvtable/PersistentKVTableBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.Version;\n+import io.pravega.controller.store.VersionedMetadata;\n+import io.pravega.controller.store.kvtable.records.KVTEpochRecord;\n+import io.pravega.controller.store.kvtable.records.KVTSegmentRecord;\n+import io.pravega.controller.store.kvtable.records.KVTConfigurationRecord;\n+import io.pravega.controller.store.kvtable.records.KVTStateRecord;\n+import io.pravega.controller.store.stream.StoreException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.IntStream;\n+\n+\n+@Slf4j\n+public abstract class PersistentKVTableBase implements KeyValueTable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb444aa509869e20fd4618089aba4bb91c629f94", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/eb444aa509869e20fd4618089aba4bb91c629f94", "committedDate": "2020-05-29T10:10:42Z", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2deac3ded5585ac1bc8c0cfeb2815495df689a31", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/2deac3ded5585ac1bc8c0cfeb2815495df689a31", "committedDate": "2020-05-29T10:34:21Z", "message": "code review\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75459e7aafec4891a59f7c5dcef143f7e49f3816", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/75459e7aafec4891a59f7c5dcef143f7e49f3816", "committedDate": "2020-05-29T10:46:04Z", "message": "review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c66ed4e354ba0a46b1ce5495705151d8465395fd", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/c66ed4e354ba0a46b1ce5495705151d8465395fd", "committedDate": "2020-05-29T10:55:37Z", "message": "reverting unnecessary changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0b990123be86e6310006988de1936893460350e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/d0b990123be86e6310006988de1936893460350e", "committedDate": "2020-05-29T11:14:05Z", "message": "removed spaces\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "630dd1ba67f95c84543fd767ca302dc746088787", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/630dd1ba67f95c84543fd767ca302dc746088787", "committedDate": "2020-05-29T11:40:23Z", "message": "reverse unnecessary changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d6cd32e9f1ce52973a8b510a08383e08183f746", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/8d6cd32e9f1ce52973a8b510a08383e08183f746", "committedDate": "2020-05-29T11:54:43Z", "message": "removing unnecessary changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/6e5b12efea5a0991df33a69e070176f3b271f534", "committedDate": "2020-05-29T12:55:21Z", "message": "review comments impl\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwODk5NTY4", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-420899568", "createdAt": "2020-05-29T12:19:52Z", "commit": {"oid": "8d6cd32e9f1ce52973a8b510a08383e08183f746"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjoxOTo1MlrOGcaWuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyNjoyNlrOGclwLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NTExNQ==", "bodyText": "nit: stream config", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432445115", "createdAt": "2020-05-29T12:19:52Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -115,6 +117,20 @@ public static final StreamConfiguration encode(final StreamConfig config) {\n                 .build();\n     }\n \n+    /**\n+     * Helper to convert KeyValueTableConfig object into Stream Configuration Impl.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d6cd32e9f1ce52973a8b510a08383e08183f746"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NjMyOA==", "bodyText": "CompleteOn ?\nand if you are putting it in common.futures , then add proper javadoc as this is a public library.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432446328", "createdAt": "2020-05-29T12:22:06Z", "author": {"login": "shiveshr"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +47,25 @@\n  */\n public final class Futures {\n \n+    public static <T> CompletableFuture<T> withCompletion(CompletableFuture<T> future, final Executor executor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODg4NQ=="}, "originalCommit": {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMjc2Ng==", "bodyText": "nit: revert the import collection", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432612766", "createdAt": "2020-05-29T16:54:27Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java", "diffHunk": "@@ -14,27 +14,7 @@\n import java.time.Duration;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import static io.pravega.shared.MetricsNames.CREATE_STREAM;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.OPEN_TRANSACTIONS;\n-import static io.pravega.shared.MetricsNames.RETENTION_FREQUENCY;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_MERGES;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_SPLITS;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.globalMetricName;\n+import static io.pravega.shared.MetricsNames.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNTIxOQ==", "bodyText": "config.tablestreamname", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432615219", "createdAt": "2020-05-29T16:57:24Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "diffHunk": "@@ -262,11 +273,13 @@ public boolean isReady() {\n                         executor));\n     }\n \n-    public CompletableFuture<Void> bootstrap(final StreamTransactionMetadataTasks streamTransactionMetadataTasks, StreamMetadataTasks streamMetadataTasks) {\n+    public CompletableFuture<Void> bootstrap(final StreamTransactionMetadataTasks streamTransactionMetadataTasks,\n+                                             StreamMetadataTasks streamMetadataTasks, TableMetadataTasks tableMetadataTasks) {\n         log.info(\"Bootstrapping controller event processors\");\n         return createStreams().thenAcceptAsync(x -> {\n             streamMetadataTasks.initializeStreamWriters(clientFactory, config.getRequestStreamName());\n             streamTransactionMetadataTasks.initializeStreamWriters(clientFactory, config);\n+            tableMetadataTasks.initializeStreamWriters(clientFactory, config.getRequestStreamName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzUxMg==", "bodyText": "nit: revert this", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432617512", "createdAt": "2020-05-29T16:59:59Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java", "diffHunk": "@@ -127,7 +127,7 @@ public String getProcessorName() {\n         CompletableFuture<String> waitingProcFuture = suppressException(streamMetadataStore.getWaitingRequestProcessor(scope, stream, context, executor), null,\n                 \"Exception while trying to fetch waiting request. Logged and ignored.\");\n         CompletableFuture<Boolean> hasTaskStarted = task.hasTaskStarted(event);\n-        \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzY1MA==", "bodyText": "and this", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432617650", "createdAt": "2020-05-29T17:00:15Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java", "diffHunk": "@@ -184,4 +184,4 @@ public String getProcessorName() {\n                     }\n                 });\n     }\n-}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxODM0NA==", "bodyText": "this comment is not required here. this doesnt provide the common completion method for fairness.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432618344", "createdAt": "2020-05-29T17:01:32Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/AbstractTableRequestProcessor.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.eventProcessor.impl.SerializedRequestHandler;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.RequestUnsupportedException;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import io.pravega.shared.controller.event.kvtable.TableRequestProcessor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Abstract common class for all request processing done over SerializedRequestHandler.\n+ * This implements TableRequestProcessor interface and implements failing request processing for all ControllerEvent types with\n+ * RequestUnsupported.\n+ * Its derived classes should implement specific processing that they wish to handle.\n+ *\n+ * This class provides a common completion method which implements mechanisms that allow multiple event processors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxOTgzNA==", "bodyText": "nit: don't\nAlso, please elaborate more about why the check for table id mismatch is necessary", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432619834", "createdAt": "2020-05-29T17:04:41Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDk5OA==", "bodyText": "change the CreateStreamResponse to CreateKVTResponse", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432620998", "createdAt": "2020-05-29T17:06:33Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)\n+                        .thenComposeAsync(response -> {\n+                            // only if its a new kvtable or an already existing non-active kvtable then we will create\n+                            // segments and change the state of the kvtable to active.\n+                            if (response.getStatus().equals(CreateKVTableResponse.CreateStatus.NEW) ||\n+                                    response.getStatus().equals(CreateStreamResponse.CreateStatus.EXISTS_CREATING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzI5OA==", "bodyText": "There is one decision to take here -- do you wish to always complete the create table OR fail it after some retries if it cannot be created due to intermittent retryable exceptions?\nIf its former, then wrap this method in a retry block that retries indefinitely on retryable predicate being e -> Exceptions.unwrap(e) instance of RetryableException", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432623298", "createdAt": "2020-05-29T17:09:44Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNDM3Mg==", "bodyText": "If its latter, do note that the event could be replayed during controller failover. So if you dont retry forever, then you need to record the failure state.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432624372", "createdAt": "2020-05-29T17:11:52Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzI5OA=="}, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNTMyOA==", "bodyText": "add a common top level retry.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432625328", "createdAt": "2020-05-29T17:13:55Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)\n+                        .thenComposeAsync(response -> {\n+                            // only if its a new kvtable or an already existing non-active kvtable then we will create\n+                            // segments and change the state of the kvtable to active.\n+                            if (response.getStatus().equals(CreateKVTableResponse.CreateStatus.NEW) ||\n+                                    response.getStatus().equals(CreateStreamResponse.CreateStatus.EXISTS_CREATING)) {\n+                                final int startingSegmentNumber = response.getStartingSegmentNumber();\n+                                final int minNumSegments = response.getConfiguration().getPartitionCount();\n+                                List<Long> newSegments = IntStream.range(startingSegmentNumber, startingSegmentNumber + minNumSegments)\n+                                        .boxed()\n+                                        .map(x -> NameUtils.computeSegmentId(x, 0))\n+                                        .collect(Collectors.toList());\n+                                return kvtMetadataTasks.notifyNewSegments(scope, kvt, newSegments, requestId)\n+                                        .thenCompose(y -> {\n+                                            final KVTOperationContext context = kvtMetadataStore.createContext(scope, kvt);\n+                                            //TODO: add withRetries", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTg1Mw==", "bodyText": "please open an issue for creating in memory store later", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432631853", "createdAt": "2020-05-29T17:26:26Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/kvtable/KVTableStoreFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.client.StoreClient;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.curator.framework.CuratorFramework;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+public class KVTableStoreFactory {\n+\n+    public static KVTableMetadataStore createStore(final StoreClient storeClient, final SegmentHelper segmentHelper,\n+                                                   final GrpcAuthHelper authHelper, final ScheduledExecutorService executor) {\n+        switch (storeClient.getType()) {\n+            case PravegaTable:\n+                return new PravegaTablesKVTMetadataStore(segmentHelper, (CuratorFramework) storeClient.getClient(), executor, authHelper);\n+            default:\n+                throw new NotImplementedException(storeClient.getType().toString());\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    public static KVTableMetadataStore createPravegaTablesStore(final SegmentHelper segmentHelper, final GrpcAuthHelper authHelper,\n+                                                                final CuratorFramework client, final ScheduledExecutorService executor) {\n+        return new PravegaTablesKVTMetadataStore(segmentHelper, client, executor, authHelper);\n+    }\n+    \n+    @VisibleForTesting\n+    public static KVTableMetadataStore createZKStore(final CuratorFramework client, final ScheduledExecutorService executor) {\n+        throw new UnsupportedOperationException(\"ZKStore not supported for KeyValueTables\");\n+    }\n+    \n+    @VisibleForTesting\n+    public static KVTableMetadataStore createInMemoryStore(final Executor executor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDYzMDYx", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-421463061", "createdAt": "2020-05-31T05:35:02Z", "commit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNTozNTowMlrOGc21Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNTozNTowMlrOGc21Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg==", "bodyText": "you cannot get DataExistsException from isCreated method.\nThe task will complete. You are checking when the task completes using isCreated method.. Once complete, you should check if the table config and table creation time are as expected by the current request.. if they do, its a tableExists exception.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432911642", "createdAt": "2020-05-31T05:35:02Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(State.UNKNOWN) || state.equals(State.CREATING)) {\n+                        // 1. post event for CreateKVTable.\n+                        return  Futures.withCompletion(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(), createTimestamp, requestId, uuid);\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))\n+                                                                    .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName))\n+                                                                            .thenApply(y -> CreateKeyValueTableStatus.Status.SUCCESS));\n+                                                        }),\n+                                                e -> Exceptions.unwrap(e) instanceof StoreException.DataExistsException,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDYzMTM3", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-421463137", "createdAt": "2020-05-31T05:37:09Z", "commit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNTozNzowOVrOGc21mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNTozNzowOVrOGc21mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTc3MA==", "bodyText": "this response is not being sent by the task.. the task completes asynchronously..\nThe submitter of the task doesnt get the response from the task.. it checks for task completion condition (desired goal state).", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432911770", "createdAt": "2020-05-31T05:37:09Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)\n+                        .thenComposeAsync(response -> {\n+                            // only if its a new kvtable or an already existing non-active kvtable then we will create\n+                            // segments and change the state of the kvtable to active.\n+                            if (response.getStatus().equals(CreateKVTableResponse.CreateStatus.NEW) ||\n+                                    response.getStatus().equals(CreateStreamResponse.CreateStatus.EXISTS_CREATING)) {\n+                                final int startingSegmentNumber = response.getStartingSegmentNumber();\n+                                final int minNumSegments = response.getConfiguration().getPartitionCount();\n+                                List<Long> newSegments = IntStream.range(startingSegmentNumber, startingSegmentNumber + minNumSegments)\n+                                        .boxed()\n+                                        .map(x -> NameUtils.computeSegmentId(x, 0))\n+                                        .collect(Collectors.toList());\n+                                return kvtMetadataTasks.notifyNewSegments(scope, kvt, newSegments, requestId)\n+                                        .thenCompose(y -> {\n+                                            final KVTOperationContext context = kvtMetadataStore.createContext(scope, kvt);\n+                                            //TODO: add withRetries\n+                                            kvtMetadataStore.getVersionedState(scope, kvt, context, executor)\n+                                                    .thenCompose(state -> {\n+                                                        if (state.getObject().equals(State.CREATING)) {\n+                                                            kvtMetadataStore.updateVersionedState(scope, kvt, KVTableState.ACTIVE,\n+                                                                    state, context, executor);\n+                                                        }\n+                                                        return CompletableFuture.completedFuture(null);\n+                                                    });\n+                                            return CompletableFuture.completedFuture(null);\n+                                        });\n+                            }\n+                            return CompletableFuture.completedFuture(null);\n+                        });\n+                return CompletableFuture.completedFuture(null);\n+             }\n+        });\n+    }\n+\n+    private Controller.CreateKeyValueTableStatus.Status translate(CreateKVTableResponse.CreateStatus status) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 103}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b130080057d6810f694b84bb94baa38300022513", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/b130080057d6810f694b84bb94baa38300022513", "committedDate": "2020-06-01T10:12:12Z", "message": "added getCurrentSegments API\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/cc289d0f90fc464a588894b8dfc74e3b1645041a", "committedDate": "2020-06-01T11:26:57Z", "message": "code review changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/2f55f9550e557959d6fcfbef8620df60e757c45f", "committedDate": "2020-06-02T08:14:20Z", "message": "addressed code review comments for retries\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjU5NzQ1", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-423259745", "createdAt": "2020-06-03T06:44:27Z", "commit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNjo0NDoyOFrOGeOHMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNjo1MzowM1rOGeOVrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MTY4MA==", "bodyText": "nit: pls remove this", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434341680", "createdAt": "2020-06-03T06:44:28Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -330,6 +367,8 @@ private SegmentRange convert(final String scope,\n         return listOfSegment;\n     }\n \n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MTg1Mw==", "bodyText": "nit: revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434341853", "createdAt": "2020-06-03T06:44:51Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java", "diffHunk": "@@ -126,22 +132,24 @@ public ControllerServiceStarter(ControllerServiceConfig serviceConfig, StoreClie\n \n     @VisibleForTesting\n     ControllerServiceStarter(ControllerServiceConfig serviceConfig, StoreClient storeClient, SegmentHelper segmentHelper) {\n-        this(serviceConfig, storeClient, segmentHelper, null, null);\n+        this(serviceConfig, storeClient, segmentHelper, null, null, null);\n     }\n \n     @VisibleForTesting\n     ControllerServiceStarter(ControllerServiceConfig serviceConfig, StoreClient storeClient, SegmentHelper segmentHelper,\n-                             ConnectionFactory connectionFactory, StreamMetadataStore streamStore) {\n+                             ConnectionFactory connectionFactory, StreamMetadataStore streamStore, KVTableMetadataStore kvtStore) {\n         this.serviceConfig = serviceConfig;\n         this.storeClient = storeClient;\n         this.objectId = \"ControllerServiceStarter\";\n         this.controllerReadyLatch = new CountDownLatch(1);\n         this.segmentHelperRef = Optional.ofNullable(segmentHelper);\n         this.connectionFactoryRef = Optional.ofNullable(connectionFactory);\n         this.streamMetadataStoreRef = Optional.ofNullable(streamStore);\n+        this.kvtMetaStoreRef = Optional.ofNullable(kvtStore);\n         this.storeClientFailureFuture = new CompletableFuture<>();\n     }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0Mjg4Ng==", "bodyText": "revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434342886", "createdAt": "2020-06-03T06:47:17Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java", "diffHunk": "@@ -91,6 +91,7 @@ public CommitRequestHandler(final StreamMetadataStore streamMetadataStore,\n     public CompletableFuture<Void> execute(CommitEvent event) {\n         String scope = event.getScope();\n         String stream = event.getStream();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzAwMw==", "bodyText": "revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434343003", "createdAt": "2020-06-03T06:47:33Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java", "diffHunk": "@@ -162,4 +162,4 @@ public ScaleOperationTask(final StreamMetadataTasks streamMetadataTasks,\n         return streamMetadataStore.getState(event.getScope(), event.getStream(), true, null, executor)\n                                   .thenApply(state -> state.equals(State.SCALING));\n     }\n-}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NDQ0Nw==", "bodyText": "even this is a network call so wrapping this in retries block for retryable errors is required.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434344447", "createdAt": "2020-06-03T06:50:56Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NTM5MQ==", "bodyText": "this code path is not returning anything . Also this withRetries, what is the retry condition here?", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434345391", "createdAt": "2020-06-03T06:53:03Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                withRetries(() -> this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "committedDate": "2020-06-03T13:18:21Z", "message": "fixed failing tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "301efd36e0072e4322dd2b986586d9a7f16e5615", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/301efd36e0072e4322dd2b986586d9a7f16e5615", "committedDate": "2020-06-03T16:14:28Z", "message": "code review comments for retries\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bd4492db9f4392dfa8af4ab68f411757ed0ff56", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/5bd4492db9f4392dfa8af4ab68f411757ed0ff56", "committedDate": "2020-06-04T06:58:15Z", "message": "fixed retry logic for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/43494d0c773ddf0bb2c3bc54e6888c0c30ddd155", "committedDate": "2020-06-04T16:31:50Z", "message": "Fixing integration tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c068dc095fca55edf1591f7acc40a05b012d91a", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/4c068dc095fca55edf1591f7acc40a05b012d91a", "committedDate": "2020-06-05T16:17:59Z", "message": "KeyValueTable Integration test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MjQxMzI2", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-425241326", "createdAt": "2020-06-05T12:09:20Z", "commit": {"oid": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjowOToyMFrOGfr57Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMjozMDo0M1rOGgJM-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODM4MQ==", "bodyText": "nit: revert please", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435878381", "createdAt": "2020-06-05T12:09:20Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java", "diffHunk": "@@ -11,8 +11,10 @@\n \n import com.google.common.annotations.Beta;\n import java.io.Serializable;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3OTAxNQ==", "bodyText": "nit: revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435879015", "createdAt": "2020-06-05T12:10:47Z", "author": {"login": "shiveshr"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -35,6 +35,7 @@\n import java.util.function.Predicate;\n import java.util.function.Supplier;\n import java.util.stream.Collectors;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MTc2OA==", "bodyText": "nit: we have passed the executor to the store to use it to process the request, we dont need to do thenApplyAsync. we can simply do thenApply here", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435881768", "createdAt": "2020-06-05T12:16:18Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -95,6 +102,36 @@\n         }, executor);\n     }\n \n+    public CompletableFuture<CreateKeyValueTableStatus> createKeyValueTable(String scope, String kvtName,\n+                                                                            final KeyValueTableConfiguration kvtConfig,\n+                                                                            final long createTimestamp) {\n+        Preconditions.checkNotNull(kvtConfig, \"kvTableConfig\");\n+        Preconditions.checkArgument(createTimestamp >= 0);\n+        Timer timer = new Timer();\n+        try {\n+            NameUtils.validateUserKeyValueTableName(kvtName);\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            log.warn(\"Create KeyValueTable failed due to invalid name {}\", kvtName);\n+            return CompletableFuture.completedFuture(\n+                    CreateKeyValueTableStatus.newBuilder().setStatus(CreateKeyValueTableStatus.Status.INVALID_TABLE_NAME).build());\n+        }\n+        return kvtMetadataTasks.createKeyValueTable(scope, kvtName, kvtConfig, createTimestamp)\n+                .thenApplyAsync(status -> {\n+                    reportCreateKVTableMetrics(scope, kvtName, kvtConfig.getPartitionCount(), status, timer.getElapsed());\n+                    return CreateKeyValueTableStatus.newBuilder().setStatus(status).build();\n+                }, executor);\n+\n+    }\n+\n+    public CompletableFuture<List<SegmentRange>> getCurrentSegmentsKeyValueTable(final String scope, final String kvtName) {\n+        Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n+        Exceptions.checkNotNullOrEmpty(kvtName, \"KeyValueTable\");\n+\n+        // Fetch active segments from segment store.\n+        return kvtMetadataStore.getActiveSegments(scope, kvtName, null, executor)\n+                .thenApplyAsync(activeSegments -> getSegmentRanges(activeSegments, scope, kvtName), executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODA2Ng==", "bodyText": "the addIndexAndSubmitTask method gives atomic guarantee of posting event and updating a metadata..\nyou are not updating any metadata inside this. you are posting an event though.. so you can simply post the event in that case directly. you dont need addIndexAndSubmitTask method. basically then what it means is even if we create an entry into the KV tables, if we fail to post the event, the create is never processed. this is fine. the caller will get an error resulting from failure to post event anyway (or connection failure if controller crashed).\nAlternatively, if you want to use the atomic guarantee of addIndexAndSubmitTask method you can also do the following:\nUUID = new UUID(); // generate the id here instead of inside the store. and pass it to the store and include it in the event. \naddIndexAndSubmitTask(event, kvtMetadataStore.createEntryForKVTable(scope, kvtName, uuid, executor))\n\nnotice that i passed the ID to the kvmetadata store .. and if an id is already generated and exists in the table, this will fail with write conflict exception..\nyou can decide on the handling for the conflict - basically if another id is written, its event must have been posted too, and it will eventually complete.. so you can simply wait for the create to complete and respond with success or existing depending on what got created.\nMy personal preference will be the latter approach.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358066", "createdAt": "2020-06-07T12:26:30Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                        return Futures.completeOn(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(v -> kvtMetadataStore.getKVTable(scope, kvtName, null).getId()\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                                                                        createTimestamp, requestId, UUID.fromString(uuid));\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c068dc095fca55edf1591f7acc40a05b012d91a"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODE5Ng==", "bodyText": "what are you doing if you get DataExists exception?\nsecondly, the two phases are separate -- 1. submitting the request, 2. tracking the request..\nso do the handling of errors from two phases separately so that you know and are able to define handling specific to the phase.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358196", "createdAt": "2020-06-07T12:28:26Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(State.UNKNOWN) || state.equals(State.CREATING)) {\n+                        // 1. post event for CreateKVTable.\n+                        return  Futures.withCompletion(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(), createTimestamp, requestId, uuid);\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))\n+                                                                    .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName))\n+                                                                            .thenApply(y -> CreateKeyValueTableStatus.Status.SUCCESS));\n+                                                        }),\n+                                                e -> Exceptions.unwrap(e) instanceof StoreException.DataExistsException,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg=="}, "originalCommit": {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODI5Ng==", "bodyText": "please pull latest master and use the timeout mechanism used there..", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358296", "createdAt": "2020-06-07T12:29:44Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                        return Futures.completeOn(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(v -> kvtMetadataStore.getKVTable(scope, kvtName, null).getId()\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                                                                        createTimestamp, requestId, UUID.fromString(uuid));\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))\n+                                                                    .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                                                                            .thenCompose(y -> kvtMetadataStore.getConfiguration(scope, kvtName, null, executor)\n+                                                                            .thenCompose(cfg -> {\n+                                                                                if (cfg.getPartitionCount() == kvtConfig.getPartitionCount()) {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SUCCESS);\n+                                                                                } else {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                                                                }\n+                                                                            })));\n+                                                        })),\n+                                                e -> Exceptions.unwrap(e) instanceof StoreException.DataExistsException,\n+                                                CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                    } else {\n+                                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                                    }\n+                                }), executor);\n+                    } else {\n+                       return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                    }\n+                }), e -> Exceptions.unwrap(e) instanceof RetryableException, Integer.MAX_VALUE, executor);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition) {\n+        return checkDone(condition, 100L);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition, long delay) {\n+        AtomicBoolean isDone = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c068dc095fca55edf1591f7acc40a05b012d91a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODM5NQ==", "bodyText": "we should move this index and submit task to a helper class as this is identical to the code in streammetadatatasks.java", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358395", "createdAt": "2020-06-07T12:30:43Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                        return Futures.completeOn(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(v -> kvtMetadataStore.getKVTable(scope, kvtName, null).getId()\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                                                                        createTimestamp, requestId, UUID.fromString(uuid));\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))\n+                                                                    .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                                                                            .thenCompose(y -> kvtMetadataStore.getConfiguration(scope, kvtName, null, executor)\n+                                                                            .thenCompose(cfg -> {\n+                                                                                if (cfg.getPartitionCount() == kvtConfig.getPartitionCount()) {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SUCCESS);\n+                                                                                } else {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                                                                }\n+                                                                            })));\n+                                                        })),\n+                                                e -> Exceptions.unwrap(e) instanceof StoreException.DataExistsException,\n+                                                CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                    } else {\n+                                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                                    }\n+                                }), executor);\n+                    } else {\n+                       return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                    }\n+                }), e -> Exceptions.unwrap(e) instanceof RetryableException, Integer.MAX_VALUE, executor);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition) {\n+        return checkDone(condition, 100L);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition, long delay) {\n+        AtomicBoolean isDone = new AtomicBoolean(false);\n+        return Futures.loop(() -> !isDone.get(),\n+                () -> Futures.delayedFuture(condition, delay, executor)\n+                        .thenAccept(isDone::set), executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isCreated(String scope, String kvtName, KeyValueTableConfiguration kvtConfig, Executor executor) {\n+       return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> CompletableFuture.completedFuture(state.equals(KVTableState.ACTIVE)));\n+    }\n+\n+    @VisibleForTesting\n+    public void setRequestEventWriter(EventStreamWriter<ControllerEvent> requestEventWriter) {\n+        requestEventWriterRef.set(requestEventWriter);\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     * This method takes an event and a future supplier and guarantees that if future supplier has been executed then event will\n+     * be posted in request stream. It does it by following approach:\n+     * 1. it first adds the index for the event to be posted to the current host.\n+     * 2. it then invokes future.\n+     * 3. it then posts event.\n+     * 4. removes the index.\n+     *\n+     * If controller fails after step 2, a replacement controller will failover all indexes and {@link RequestSweeper} will\n+     * post events for any index that is found.\n+     *\n+     * Upon failover, an index can be found if failure occurred in any step before 3. It is safe to post duplicate events\n+     * because event processing is idempotent. It is also safe to post event even if step 2 was not performed because the\n+     * event will be ignored by the processor after a while.\n+     *\n+     * @param event      Event to publish.\n+     * @param futureSupplier  Supplier future to execute before submitting event.\n+     * @return CompletableFuture<T> returned by Supplier or Exception.\n+     */\n+    @VisibleForTesting\n+    <T> CompletableFuture<T> addIndexAndSubmitTask(ControllerEvent event, Supplier<CompletableFuture<T>> futureSupplier) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c068dc095fca55edf1591f7acc40a05b012d91a"}, "originalPosition": 189}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c5ed58cd7f2275e23e558550b014031254b8e28", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/9c5ed58cd7f2275e23e558550b014031254b8e28", "committedDate": "2020-06-08T09:33:57Z", "message": "changes for code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ac7d3d082cdeaa543a9bbf3185644b93e815ab5", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/1ac7d3d082cdeaa543a9bbf3185644b93e815ab5", "committedDate": "2020-06-08T12:19:52Z", "message": "testfix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/955ba7a4455dca423e95e998b6c3be84fb38669c", "committedDate": "2020-06-08T13:55:22Z", "message": "KVTIntegration test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MzM3ODk2", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-426337896", "createdAt": "2020-06-08T15:07:15Z", "commit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNTowNzoxNVrOGgi_gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNToyNTowN1rOGgjwKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MDkzMQ==", "bodyText": "Why do you need this?", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436780931", "createdAt": "2020-06-08T15:07:15Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;\n+\n+        // 1. Start ZK\n+        this.zkTestServer = new TestingServerStarter().start();\n+\n+        // 2. Start Pravega SegmentStore service.\n         this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n-        this.serviceBuilder.initialize();\n-        this.tableStore = this.serviceBuilder.createTableStoreService();\n-        int port = TestUtils.getAvailableListenPort();\n-        this.serverListener = new PravegaConnectionListener(false, port, mock(StreamSegmentStore.class), this.tableStore);\n-        this.serverListener.startListening();\n+        serviceBuilder.initialize();\n+        StreamSegmentStore store = serviceBuilder.createStreamSegmentService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MTU1NA==", "bodyText": "This is a configuration. Move it to the private static final section at the top of this file and make sure you pass this value to the Segment Store as well. Otherwise if we change this at one point the test will stop working.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436781554", "createdAt": "2020-06-08T15:08:13Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MjAzMg==", "bodyText": "Revert all these lines that made no actual change. Keep the code consistent. Either everything references this. or nothing.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436782032", "createdAt": "2020-06-08T15:08:55Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;\n+\n+        // 1. Start ZK\n+        this.zkTestServer = new TestingServerStarter().start();\n+\n+        // 2. Start Pravega SegmentStore service.\n         this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n-        this.serviceBuilder.initialize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MjEzNA==", "bodyText": "Why?", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436782134", "createdAt": "2020-06-08T15:09:04Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4Mjg2MQ==", "bodyText": "Why did you use this pattern here and not apply it to everything else? For cleanliness, I suggest you don't bother with this check.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436782861", "createdAt": "2020-06-08T15:10:10Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;\n+\n+        // 1. Start ZK\n+        this.zkTestServer = new TestingServerStarter().start();\n+\n+        // 2. Start Pravega SegmentStore service.\n         this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n-        this.serviceBuilder.initialize();\n-        this.tableStore = this.serviceBuilder.createTableStoreService();\n-        int port = TestUtils.getAvailableListenPort();\n-        this.serverListener = new PravegaConnectionListener(false, port, mock(StreamSegmentStore.class), this.tableStore);\n-        this.serverListener.startListening();\n+        serviceBuilder.initialize();\n+        StreamSegmentStore store = serviceBuilder.createStreamSegmentService();\n+        this.tableStore = serviceBuilder.createTableStoreService();\n \n-        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());\n-        this.controller = new MockController(ENDPOINT, port, this.connectionFactory, true);\n+        this.server = new PravegaConnectionListener(false, servicePort, store, tableStore);\n+        this.server.startListening();\n+\n+        // 3. Start Pravega Controller service\n+        this.controllerWrapper = new ControllerWrapper(zkTestServer.getConnectString(), false,\n+                controllerPort, serviceHost, servicePort, containerCount);\n+        this.controllerWrapper.awaitRunning();\n+        this.controller = controllerWrapper.getController();\n+\n+        //4. Create Scope\n         this.controller.createScope(SCOPE);\n+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());\n         this.keyValueTableFactory = new KeyValueTableFactoryImpl(SCOPE, this.controller, this.connectionFactory);\n     }\n \n+\n     @After\n-    public void tearDown() {\n+    public void tearDown() throws Exception {\n         this.controller.close();\n         this.connectionFactory.close();\n-        this.serverListener.close();\n+\n+        if (this.controllerWrapper != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4Mzk3MQ==", "bodyText": "Uncomment this. If Delete is not implemented, add a TODO with a GitHub issue reference.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436783971", "createdAt": "2020-06-08T15:11:46Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -91,16 +126,17 @@ public void testCreateDeleteKeyValueTable() {\n         Assert.assertTrue(created);\n         val segments = this.controller.getCurrentSegmentsForKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join();\n         Assert.assertEquals(DEFAULT_CONFIG.getPartitionCount(), segments.getSegments().size());\n+\n         for (val s : segments.getSegments()) {\n             // We know there's nothing in these segments. But if the segments hadn't been created, then this will throw\n             // an exception.\n-            this.tableStore.get(s.getScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT).join();\n+            this.tableStore.get(s.getKVTScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT).join();\n         }\n \n         // Verify re-creation does not work.\n         Assert.assertFalse(this.controller.createKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName(), DEFAULT_CONFIG).join());\n-\n         // Delete and verify segments have been deleted too.\n+        /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NTExOA==", "bodyText": "Revert changes to this file. the @Data annotation creates getters and constructors.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436785118", "createdAt": "2020-06-08T15:13:28Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java", "diffHunk": "@@ -26,5 +28,11 @@\n      * The number of Partitions for a Key-Value Table. This value cannot be adjusted after the Key-Value Table has been\n      * created.\n      */\n+    @Getter\n     private final int partitionCount;\n+\n+    public KeyValueTableConfiguration(int partitionCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NTY3MQ==", "bodyText": "Rephrase this as:\nReturns a new {@link CompletableFuture} that completes with the same outcome as the given one, but on the given {@link Executor}. This helps transfer the downstream callback executions on another executor.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436785671", "createdAt": "2020-06-08T15:14:18Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NzE1NQ==", "bodyText": "The future is not \"to execute\". The future is some object that will be completed after execution. Chances are that the execution of the backing task is already underway.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436787155", "createdAt": "2020-06-08T15:16:14Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NzM4MA==", "bodyText": "The executor to transfer callback execution onto.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436787380", "createdAt": "2020-06-08T15:16:33Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.\n+     * @param <T> The Type of the future's result.\n+     * @param executor The executor for executing the future.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NzkwOA==", "bodyText": "A new {@link CompletableFuture} that will complete with the same outcome as the given one, but on the given {@link Executor}.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436787908", "createdAt": "2020-06-08T15:17:13Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.\n+     * @param <T> The Type of the future's result.\n+     * @param executor The executor for executing the future.\n+     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4ODM3NQ==", "bodyText": "This method does not have any unit tests. Please write some.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436788375", "createdAt": "2020-06-08T15:17:53Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.\n+     * @param <T> The Type of the future's result.\n+     * @param executor The executor for executing the future.\n+     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     */\n+    public static <T> CompletableFuture<T> completeOn(CompletableFuture<T> future, final Executor executor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MDg4MA==", "bodyText": "Why did you make this change?", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436790880", "createdAt": "2020-06-08T15:21:33Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorTest.java", "diffHunk": "@@ -89,7 +89,7 @@\n import static org.mockito.Mockito.when;\n \n @Slf4j\n-public class PravegaRequestProcessorTest {\n+public class PravegaStreamRequestProcessorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MDk1MA==", "bodyText": "Revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436790950", "createdAt": "2020-06-08T15:21:38Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/TableMetadataStore.java", "diffHunk": "@@ -51,7 +51,6 @@\n     private final TableStore tableStore;\n     private final String metadataSegmentName;\n     private final AtomicBoolean initialized;\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MTA3NQ==", "bodyText": "Revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436791075", "createdAt": "2020-06-08T15:21:48Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorAuthFailedTest.java", "diffHunk": "@@ -23,7 +23,7 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n \n-public class PravegaRequestProcessorAuthFailedTest {\n+public class PravegaStreamRequestProcessorAuthFailedTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MjM3NA==", "bodyText": "Please add comments indicating what type of metric this is. See other metric names defined in this class.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436792374", "createdAt": "2020-06-08T15:23:35Z", "author": {"login": "andreipaduroiu"}, "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "diffHunk": "@@ -172,6 +172,13 @@\n     public static final String THREAD_POOL_ACTIVE_THREADS = PREFIX + \"segmentstore.thread_pool.active_threads\";  // Histogram\n \n     // Metrics in Controller\n+    // KeyValueTable request counts\n+    public static final String CREATE_KVTABLE = PREFIX + \"controller.kvtable.created\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MjQ3Ng==", "bodyText": "Be consistent. created -> create", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436792476", "createdAt": "2020-06-08T15:23:44Z", "author": {"login": "andreipaduroiu"}, "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "diffHunk": "@@ -172,6 +172,13 @@\n     public static final String THREAD_POOL_ACTIVE_THREADS = PREFIX + \"segmentstore.thread_pool.active_threads\";  // Histogram\n \n     // Metrics in Controller\n+    // KeyValueTable request counts\n+    public static final String CREATE_KVTABLE = PREFIX + \"controller.kvtable.created\";\n+    // segment counts\n+    public static final String KVTABLE_SEGMENTS_COUNT = PREFIX + \"controller.kvtable.segments.count\";\n+    public static final String CREATE_KVTABLE_LATENCY = PREFIX + \"controller.kvtable.created_latency_ms\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MzI0Mw==", "bodyText": "Why do we need to do this? Virtually all Segments for a KV Table will have this suffix and they'll all be in the same directory. So this is useless in my view.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436793243", "createdAt": "2020-06-08T15:24:54Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -285,13 +290,35 @@ public static String getScopedKeyValueTableName(String scope, String streamName)\n         return getScopedStreamNameInternal(scope, streamName).toString();\n     }\n \n+    /**\n+     * Method to generate Fully Qualified  TableSegmentName using scope, stream and segment id.\n+     * Table segments for KVTables have segment names suffixed with _table,\n+     * so we can have a stream and KeyValueTable with the same name.\n+     *\n+     * @param scope scope to be used in the ScopedTableSegment name\n+     * @param kvTableName kvTable name to be used in ScopedTableSegment name.\n+     * @param segmentId segment id to be used in ScopedStreamSegment name.\n+     * @return fully qualified TableSegmentName for a TableSegment that is part of the KeyValueTable.\n+     */\n+    public static String getQualifiedTableSegmentName(String scope, String kvTableName, long segmentId) {\n+        int segmentNumber = getSegmentNumber(segmentId);\n+        int epoch = getEpoch(segmentId);\n+        StringBuffer sb = getScopedStreamNameInternal(scope, kvTableName);\n+        sb.append('/');\n+        sb.append(segmentNumber);\n+        sb.append(EPOCH_DELIMITER);\n+        sb.append(epoch);\n+        sb.append(KVTABLE_SUFFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MzM4Nw==", "bodyText": "revert", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436793387", "createdAt": "2020-06-08T15:25:07Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -285,13 +290,35 @@ public static String getScopedKeyValueTableName(String scope, String streamName)\n         return getScopedStreamNameInternal(scope, streamName).toString();\n     }\n \n+    /**\n+     * Method to generate Fully Qualified  TableSegmentName using scope, stream and segment id.\n+     * Table segments for KVTables have segment names suffixed with _table,\n+     * so we can have a stream and KeyValueTable with the same name.\n+     *\n+     * @param scope scope to be used in the ScopedTableSegment name\n+     * @param kvTableName kvTable name to be used in ScopedTableSegment name.\n+     * @param segmentId segment id to be used in ScopedStreamSegment name.\n+     * @return fully qualified TableSegmentName for a TableSegment that is part of the KeyValueTable.\n+     */\n+    public static String getQualifiedTableSegmentName(String scope, String kvTableName, long segmentId) {\n+        int segmentNumber = getSegmentNumber(segmentId);\n+        int epoch = getEpoch(segmentId);\n+        StringBuffer sb = getScopedStreamNameInternal(scope, kvTableName);\n+        sb.append('/');\n+        sb.append(segmentNumber);\n+        sb.append(EPOCH_DELIMITER);\n+        sb.append(epoch);\n+        sb.append(KVTABLE_SUFFIX);\n+        return sb.toString();\n+    }\n+\n     /**\n      * Method to generate Fully Qualified StreamSegmentName using scope, stream and segment id.\n      *\n      * @param scope scope to be used in the ScopedStreamSegment name\n      * @param streamName stream name to be used in ScopedStreamSegment name.\n      * @param segmentId segment id to be used in ScopedStreamSegment name.\n-     * @return fully qualified StreamSegmentName.\n+     * @return fully qualified StreamSegmentName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c965adcacae987b0515ef92f931dffef958afea9", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/c965adcacae987b0515ef92f931dffef958afea9", "committedDate": "2020-06-08T17:30:09Z", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2ODUwNTgy", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-426850582", "createdAt": "2020-06-09T07:16:24Z", "commit": {"oid": "c965adcacae987b0515ef92f931dffef958afea9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzoxNjoyNFrOGg7xHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzoxNjoyNFrOGg7xHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4Njg0NQ==", "bodyText": "do a config.equals so that it is future safe.\notherwise when more configuration is added, this may become a stale value and the developer may not know to change it here.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437186845", "createdAt": "2020-06-09T07:16:24Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.common.util.BitConverter;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+               // 1. check if scope with this name exists...\n+               return kvtMetadataStore.checkScopeExists(scope)\n+                   .thenCompose(exists -> {\n+                        if (!exists) {\n+                           return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                        }\n+                        //2. check state of the KVTable, if found\n+                        return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                                 e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                                    .thenCompose(state -> {\n+                                       if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                                           //3. get a new UUID for the KVTable we will be creating.\n+                                           byte[] newUUID = kvtMetadataStore.newScope(scope).newId();\n+                                           CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                        createTimestamp, requestId, BitConverter.readUUID(newUUID, 0));\n+                                                //4. Update ScopeTable with entry for this KVT and Publish event for creation\n+                                                return Futures.exceptionallyExpecting(addIndexAndSubmitTask(event, () -> kvtMetadataStore.createEntryForKVTable(scope, kvtName, newUUID, executor))\n+                                                                .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                                                                        .thenCompose(y -> kvtMetadataStore.getConfiguration(scope, kvtName, null, executor)\n+                                                                                .thenCompose(cfg -> {\n+                                                                                    if (cfg.getPartitionCount() == kvtConfig.getPartitionCount()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c965adcacae987b0515ef92f931dffef958afea9"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b076eb0ba449758a27ce468ff2ae615bf3ee2a51", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/b076eb0ba449758a27ce468ff2ae615bf3ee2a51", "committedDate": "2020-06-09T12:59:29Z", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01cacbda1e057874f69a08847335251ad07a9b1e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/01cacbda1e057874f69a08847335251ad07a9b1e", "committedDate": "2020-06-10T10:38:06Z", "message": "fixed Integration Tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "661451adde10f924da9204cd7f964c5dacaea3dd", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/661451adde10f924da9204cd7f964c5dacaea3dd", "committedDate": "2020-06-10T11:54:11Z", "message": "going back to using the _kvt suffix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f8e27a9e0fa50954b56a6d99abd5305090e1f1a", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/4f8e27a9e0fa50954b56a6d99abd5305090e1f1a", "committedDate": "2020-06-10T12:34:14Z", "message": "unit test testBootstrap fixed\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a22d7c55c408b373384b4756d8481e4d92915180", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/a22d7c55c408b373384b4756d8481e4d92915180", "committedDate": "2020-06-10T13:00:56Z", "message": "deleting unused Integration test\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MTQ5NDMy", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-428149432", "createdAt": "2020-06-10T15:04:02Z", "commit": {"oid": "a22d7c55c408b373384b4756d8481e4d92915180"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTowNDowMlrOGh5QrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTowNTowMVrOGh5Tfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NDM0OA==", "bodyText": "Typo", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438194348", "createdAt": "2020-06-10T15:04:02Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/store/kvtable/PravegaTablesKVTable.java", "diffHunk": "@@ -202,6 +201,7 @@ private String getMetadataTableName(String id) {\n     @Override\n     CompletableFuture<Void> storeCreationTimeIfAbsent(final long creationTime) {\n         byte[] b = new byte[Long.BYTES];\n+        log.info(\"Sroring Creation time: {}\", creationTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22d7c55c408b373384b4756d8481e4d92915180"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NTA3MA==", "bodyText": "I think we can remove this line now that we user real controller.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438195070", "createdAt": "2020-06-10T15:05:01Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -42,13 +41,9 @@\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22d7c55c408b373384b4756d8481e4d92915180"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MTkzMjc2", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-428193276", "createdAt": "2020-06-10T15:48:07Z", "commit": {"oid": "a22d7c55c408b373384b4756d8481e4d92915180"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo0ODowN1rOGh7R8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo0ODowN1rOGh7R8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyNzQ0MA==", "bodyText": "In order for this to work properly (that's why the testIterators integration doesn't work), we need to do the following:\n\nIn SegmentHelper, update createTableSegment to include a boolean sortedTableSegment flag. Pass that value to line 340 when you createWireCommands.CreateTableSegments as the 3rd parameter (currently stubbed as false).\nIn this TableMetadataTasks class, pass true to it.\nIn PravegaTablesStoreHelper, pass false to it.\n\nYou may have to fix any unit tests, but having sorted Table Segments is a requirement for KVTs.", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438227440", "createdAt": "2020-06-10T15:48:07Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.common.util.BitConverter;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.AbstractKVTableMetadataStore;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.EventHelper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private EventHelper eventHelper;\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+\n+        this.eventHelper = new EventHelper(clientFactory.createEventWriter(streamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()), streamName,\n+                                            this.executor, this.eventExecutor, hostId,\n+                ((AbstractKVTableMetadataStore) this.kvtMetadataStore).getHostTaskIndex());\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+               // 1. check if scope with this name exists...\n+               return kvtMetadataStore.checkScopeExists(scope)\n+                   .thenCompose(exists -> {\n+                        if (!exists) {\n+                            return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                        }\n+                        //2. check state of the KVTable, if found\n+                        return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                                 e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                                    .thenCompose(state -> {\n+                                       if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                                           //3. get a new UUID for the KVTable we will be creating.\n+                                           byte[] newUUID = kvtMetadataStore.newScope(scope).newId();\n+                                           CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                        createTimestamp, requestId, BitConverter.readUUID(newUUID, 0));\n+                                           //4. Update ScopeTable with the entry for this KVT and Publish the event for creation\n+                                           return eventHelper.addIndexAndSubmitTask(event,\n+                                                   () -> kvtMetadataStore.createEntryForKVTable(scope, kvtName, newUUID, executor))\n+                                                   .thenCompose(x -> isCreateProcessed(scope, kvtName, kvtConfig, createTimestamp, executor));\n+                                       }\n+                                       return isCreateProcessed(scope, kvtName, kvtConfig, createTimestamp, executor);\n+                                 });\n+                            });\n+               }, e -> Exceptions.unwrap(e) instanceof RetryableException, Integer.MAX_VALUE, executor);\n+    }\n+\n+    private CompletableFuture<CreateKeyValueTableStatus.Status> isCreateProcessed(String scope, String kvtName,\n+                                                                                  KeyValueTableConfiguration kvtConfig,\n+                                                                                  final long createTimestamp,\n+                                                                                  Executor executor) {\n+        return eventHelper.checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                .thenCompose(y -> isSameCreateRequest(scope, kvtName, kvtConfig, createTimestamp, executor))\n+                .thenCompose(same -> {\n+                    if (same) {\n+                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<Boolean> isCreated(String scope, String kvtName, KeyValueTableConfiguration kvtConfig, Executor executor) {\n+       return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+               .thenApply(state -> {\n+                    log.debug(\"KVTable State is {}\", state.toString());\n+                    return state.equals(KVTableState.ACTIVE);\n+                });\n+    }\n+\n+    private CompletableFuture<Boolean> isSameCreateRequest(final String requestScopeName, final String requestKVTName,\n+                                                           final KeyValueTableConfiguration requestKVTConfig,\n+                                                           final long requestCreateTimestamp,\n+                                                           Executor executor) {\n+    return kvtMetadataStore.getCreationTime(requestScopeName, requestKVTName, null, executor)\n+    .thenCompose(creationTime -> {\n+        if (creationTime == requestCreateTimestamp) {\n+            return kvtMetadataStore.getConfiguration(requestScopeName, requestKVTName, null, executor)\n+                    .thenCompose(cfg -> {\n+                        if (cfg.getPartitionCount() == requestKVTConfig.getPartitionCount()) {\n+                            return CompletableFuture.completedFuture(Boolean.TRUE);\n+                        } else {\n+                            return CompletableFuture.completedFuture(Boolean.FALSE);\n+                        }\n+                    });\n+            }\n+        return CompletableFuture.completedFuture(Boolean.FALSE);\n+        });\n+    }\n+\n+    private String retrieveDelegationToken() {\n+        return authHelper.retrieveMasterToken();\n+    }\n+    \n+    public CompletableFuture<Void> createNewSegments(String scope, String kvt,\n+                                                     List<Long> segmentIds, long requestId) {\n+        return Futures.toVoid(Futures.allOfWithResults(segmentIds\n+                .stream()\n+                .parallel()\n+                .map(segment -> createNewSegment(scope, kvt, segment, retrieveDelegationToken(), requestId))\n+                .collect(Collectors.toList())));\n+    }\n+\n+    private CompletableFuture<Void> createNewSegment(String scope, String kvt, long segmentId, String controllerToken,\n+                                                     long requestId) {\n+        final String qualifiedTableSegmentName = getQualifiedTableSegmentName(scope, kvt, segmentId);\n+        return Futures.toVoid(withRetries(() -> segmentHelper.createTableSegment(qualifiedTableSegmentName, controllerToken, requestId), executor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22d7c55c408b373384b4756d8481e4d92915180"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTM3NDkw", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-428537490", "createdAt": "2020-06-11T01:44:07Z", "commit": {"oid": "a22d7c55c408b373384b4756d8481e4d92915180"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f102dd1ca1e90d77f0bdc57a3842bf744942885", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/0f102dd1ca1e90d77f0bdc57a3842bf744942885", "committedDate": "2020-06-11T09:14:55Z", "message": "rebase from upstream branch\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e53eddcf269aa62e4ad2440834ae1b60dce1aac1", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e53eddcf269aa62e4ad2440834ae1b60dce1aac1", "committedDate": "2020-06-11T09:21:50Z", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "303589fb15f2f9061038044b2e2c89e218d295ea", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/303589fb15f2f9061038044b2e2c89e218d295ea", "committedDate": "2020-06-11T09:39:24Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ed8d4b1916ef19cb5914dc07625abf02d50d905", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/1ed8d4b1916ef19cb5914dc07625abf02d50d905", "committedDate": "2020-06-11T10:06:52Z", "message": "client test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fe13395fe8be57f57b17fd609ccb45f001c9171", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/7fe13395fe8be57f57b17fd609ccb45f001c9171", "committedDate": "2020-06-11T10:52:18Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3842090c1c5a8c748169a81237b61b66c1100a37", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/3842090c1c5a8c748169a81237b61b66c1100a37", "committedDate": "2020-06-11T13:22:20Z", "message": "New Unit Tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d2891723add3ba320e76d56377723281964d983", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/3d2891723add3ba320e76d56377723281964d983", "committedDate": "2020-06-11T16:08:20Z", "message": "checkstyle fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23eebf743d8df56f5c908a9b65a45592bd269011", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/23eebf743d8df56f5c908a9b65a45592bd269011", "committedDate": "2020-06-12T07:12:52Z", "message": "changed retries to 10 for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54e4cc4ecd2a9c257863326a6aabb34c44180838", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/54e4cc4ecd2a9c257863326a6aabb34c44180838", "committedDate": "2020-06-12T08:08:16Z", "message": "KeyValueTableImplTest fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c889e6f3220519566ec62dbb4360a63c4bc61459", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/c889e6f3220519566ec62dbb4360a63c4bc61459", "committedDate": "2020-06-12T11:03:09Z", "message": "Unit tests for KVTables\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eeb041224149d18bfaf9f871f61810afd564fa6", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/0eeb041224149d18bfaf9f871f61810afd564fa6", "committedDate": "2020-06-15T16:29:08Z", "message": "Test fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59f3745129f594b524f230bb173c53dcbdace370", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/59f3745129f594b524f230bb173c53dcbdace370", "committedDate": "2020-06-15T16:40:41Z", "message": "comment fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8533890a91b15e18315354f2dfdadd1e8474e393", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/8533890a91b15e18315354f2dfdadd1e8474e393", "committedDate": "2020-06-15T16:56:17Z", "message": "code review comments fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43b5bdc05a192789c063eff14f08be9f0b27e71d", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/43b5bdc05a192789c063eff14f08be9f0b27e71d", "committedDate": "2020-06-16T14:11:52Z", "message": "added unit tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d9d191ada9c2bd83b261a8176c731348341c448", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/5d9d191ada9c2bd83b261a8176c731348341c448", "committedDate": "2020-06-16T16:52:23Z", "message": "UT coverage\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3a32cb8e14e43a0c9f9dc219a07eebcbb181492", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/c3a32cb8e14e43a0c9f9dc219a07eebcbb181492", "committedDate": "2020-06-16T17:52:49Z", "message": "UT fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b480afc6b879b45e1e3f49fdf906385df2a7fb1c", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/b480afc6b879b45e1e3f49fdf906385df2a7fb1c", "committedDate": "2020-06-17T02:06:16Z", "message": "more tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "039b3b26df0578334fa77be57a01613395fd7154", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/039b3b26df0578334fa77be57a01613395fd7154", "committedDate": "2020-06-17T02:44:33Z", "message": "Futures Unit Test\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b273d4354fd13b461b6de1f43b66775079920cb5", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/b273d4354fd13b461b6de1f43b66775079920cb5", "committedDate": "2020-06-17T03:12:13Z", "message": "fixed checkstyle errors\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8964cb8e0522bc64de32d232556356a2c0115704", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/8964cb8e0522bc64de32d232556356a2c0115704", "committedDate": "2020-06-17T04:34:33Z", "message": "Removed updateKeyValueTable API\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMTAxMjEz", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-432101213", "createdAt": "2020-06-17T06:43:41Z", "commit": {"oid": "8964cb8e0522bc64de32d232556356a2c0115704"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f2984a57cb7876ed306251eacde35cd0a599391", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/2f2984a57cb7876ed306251eacde35cd0a599391", "committedDate": "2020-06-17T07:47:10Z", "message": "More tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNDM3Nzcz", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-432437773", "createdAt": "2020-06-17T14:05:56Z", "commit": {"oid": "2f2984a57cb7876ed306251eacde35cd0a599391"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNDQwMzEw", "url": "https://github.com/pravega/pravega/pull/4797#pullrequestreview-432440310", "createdAt": "2020-06-17T14:08:27Z", "commit": {"oid": "2f2984a57cb7876ed306251eacde35cd0a599391"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowODoyN1rOGlHiXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowODoyN1rOGlHiXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3Mzk4Mg==", "bodyText": "What's the point of this? Do you not do this in the setup?", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r441573982", "createdAt": "2020-06-17T14:08:27Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/tables/impl/KeyValueTableTestBase.java", "diffHunk": "@@ -44,6 +44,7 @@\n      */\n     @Test\n     public void testSingleKeyConditionalInserts() {\n+        Assert.assertTrue(isScopeCreated);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f2984a57cb7876ed306251eacde35cd0a599391"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3484, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}