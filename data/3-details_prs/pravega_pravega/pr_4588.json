{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMDQ4MDkw", "number": 4588, "title": "Issue 4568: Key-Value Table Client Contracts", "bodyText": "Change log description\n\nCreated the publicly visible KeyValueTable interface which defines all operations that can be performed on a Key-Value Table. Created/updated ancillary interfaces and classes that are referenced by this one.\nRefactored TableSegment to not require generic Keys and Values but work with ByteBufs instead.\nUpdated SegmentHelper to make use of the updated TableSegment ByteBuf API.\n\nPurpose of the change\nFixes #4568.\nWhat the code does\nNew contracts added:\n\nKeyValueTable\n\nMoved some classes from impl into tables package:\n\nExceptions: ConditionalTableUpdateException, BadKeyVersionException, NoSuchKeyException\nIterators: IteratorItem and IteratorState\nTableKey, KeyVersion and TableEntry: made these classes instead of interfaces.\n\nChanged TableSegment from requiring a generic Key and generic Value to using ByteBufs\n\nAdded TableSegmentKey, TableSegmentKeyVersion and TableSegmentEntry that pertain to TableSegments\nThese classes will be used exclusively by the KeyValueTableImpl (not in this PR) and SegmentHelper (due to it currently using them).\n\nRefactored SegmentHelper\n\nIt was using the generic TableKey/TableEntry/KeyValue\nNow it uses the ByteBuf versions of those (the internal ones, in impl).\nNo functional changes have been made toSegmentHelper or upstream code. All changes are purely due to refactoring and most code changed was to maintain the ByteBuf lifecycles (See Javavdoc on TableSegment for details).\n\nNOTE: there is no implementation for TableSegment in this PR. A subsequent PR will introduce that.\nHow to verify it\nAll unit tests must pass.", "createdAt": "2020-03-03T16:23:59Z", "url": "https://github.com/pravega/pravega/pull/4588", "merged": true, "mergeCommit": {"oid": "37ea3f018b4b81f7055cf6b1c96f635fa8f5fbec"}, "closed": true, "closedAt": "2020-03-31T14:41:02Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHmcifgH2gAyMzgzMDQ4MDkwOmVmOTExMzQzMTk3NDQwZDE4YzMxODQ3MzFlNTZmNzhiM2I3NzUxOTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcR605cAFqTM4MzI2ODkzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ef911343197440d18c3184731e56f78b3b775192", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/ef911343197440d18c3184731e56f78b3b775192", "committedDate": "2020-02-24T23:51:07Z", "message": "Refactored TableSegment, TableEntry, TableKey in preparation for creating KeyValueTable. Moved a few classes around.\n\nRefactored SegmentHelper to make use of TableSegmentKey, TableSegmentEntry and TableSegmentKeyVersion which better map to what a Table Segment can do. Refactored upstream code and adjusted unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05ff3487b0c7e26b69c22e3ef1969823915141a2", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/05ff3487b0c7e26b69c22e3ef1969823915141a2", "committedDate": "2020-02-25T00:21:59Z", "message": "Javadoc.\nMoved IteratorItem into its own file.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65f52b7d5bc0cc86d9490957498480d151703be2", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/65f52b7d5bc0cc86d9490957498480d151703be2", "committedDate": "2020-02-25T18:03:54Z", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "201e5f049c5ba118018d0633463cf739ea11e7e4", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/201e5f049c5ba118018d0633463cf739ea11e7e4", "committedDate": "2020-02-25T18:21:59Z", "message": "Made IteratorState a class.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e11121b0ee12384c7bae18228bf06d87bacc3b4", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/2e11121b0ee12384c7bae18228bf06d87bacc3b4", "committedDate": "2020-02-25T22:48:52Z", "message": "Updated TableSegment.keyIterator and TableSegment.entryIterator.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "206d4847cf8fd13c7ed69deabe9abf7f047a9589", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/206d4847cf8fd13c7ed69deabe9abf7f047a9589", "committedDate": "2020-02-26T18:14:46Z", "message": "Javadoc fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e848733fbbb3a14ce48713e73a5cfa520dbaca03", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e848733fbbb3a14ce48713e73a5cfa520dbaca03", "committedDate": "2020-03-02T18:24:40Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4568-key-value-table-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bec961271dd6680d2f065f11505cd618bc50e14b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/bec961271dd6680d2f065f11505cd618bc50e14b", "committedDate": "2020-03-03T16:10:18Z", "message": "Refactored TableSegment, TableEntry, TableKey in preparation for creating KeyValueTable. Moved a few classes around.\n\nRefactored SegmentHelper to make use of TableSegmentKey, TableSegmentEntry and TableSegmentKeyVersion which better map to what a Table Segment can do. Refactored upstream code and adjusted unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdc48e967cae0a052e064c0178aacde4a34f7124", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/fdc48e967cae0a052e064c0178aacde4a34f7124", "committedDate": "2020-03-03T16:10:18Z", "message": "Javadoc.\nMoved IteratorItem into its own file.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57a4ae4f6a76424ffd789947232bb426e7266cec", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/57a4ae4f6a76424ffd789947232bb426e7266cec", "committedDate": "2020-03-03T16:10:18Z", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a9cc3e0dbf4d34ac8d51a2e842b999dc2fc471d", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/9a9cc3e0dbf4d34ac8d51a2e842b999dc2fc471d", "committedDate": "2020-03-03T16:10:18Z", "message": "Made IteratorState a class.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c138dd219c3bed59ad5998638c3cdf28e27471f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/2c138dd219c3bed59ad5998638c3cdf28e27471f", "committedDate": "2020-03-03T16:10:18Z", "message": "Updated TableSegment.keyIterator and TableSegment.entryIterator.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "096cdd4843a0cb3dd11893b7c66592c858b1471e", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/096cdd4843a0cb3dd11893b7c66592c858b1471e", "committedDate": "2020-03-03T16:10:18Z", "message": "Javadoc fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f81fbb3aa9d099e39986a9c258da838a4e7f630", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/5f81fbb3aa9d099e39986a9c258da838a4e7f630", "committedDate": "2020-03-04T16:17:34Z", "message": "Merge branch 'issue-4568-key-value-table-contracts' of https://github.com/andreipaduroiu/pravega into issue-4568-key-value-table-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8a3e9cb0186f3c390a8b500d71be299cceb8c8c", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e8a3e9cb0186f3c390a8b500d71be299cceb8c8c", "committedDate": "2020-03-04T16:56:28Z", "message": "Unit tests ... for coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/1cadfa9c07c323757ad24197deccd3e6fb27f577", "committedDate": "2020-03-04T21:05:59Z", "message": "Increasing coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODMwMDcw", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-369830070", "createdAt": "2020-03-05T18:57:29Z", "commit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo1NzoyOVrOFyf4jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTo1MjoyNFrOFyhx-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NTUwMQ==", "bodyText": "If there is no ordering this should really be a Set or a Collection and not a List.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388495501", "createdAt": "2020-03-05T18:57:29Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/IteratorItem.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import lombok.Data;\n+\n+/**\n+ * An iteration result item returned by {@link AsyncIterator} when invoking {@link KeyValueTable#entryIterator}\n+ * or {@link KeyValueTable#keyIterator}.\n+ *\n+ * @param <T> Iterator Item type.\n+ */\n+@Data\n+public class IteratorItem<T> {\n+    /**\n+     * Gets an {@link IteratorState} that can be used to reinvoke {@link KeyValueTable#entryIterator} or\n+     * {@link KeyValueTable#keyIterator} if a previous iteration has been interrupted (by losing the pointer to the\n+     * {@link AsyncIterator}), system restart, etc.\n+     */\n+    private final IteratorState state;\n+    /**\n+     * A List of items that are contained in this instance. The items in this list are not necessarily related to each", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDIyMA==", "bodyText": "Is this intended to be a public method? If so we cannot expose ByteBuf as it is from netty. This will need to be ByteBuffer as will the token above.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388504220", "createdAt": "2020-03-05T19:12:40Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/IteratorState.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import lombok.Data;\n+\n+/**\n+ * Represents the state of a resumable iterator. Such an iterator can be executed asynchronously and continued after an\n+ * interruption. Each iteration will result in a new request to the server (which is stateless). The entire state of\n+ * the iterator is encoded in this object and is non-transferable between different types of iterations. The server will\n+ * use the information within it to decide what to return for the next iteration call.\n+ */\n+@Data\n+public class IteratorState {\n+    /**\n+     * No state. Providing this value will result in an iterator that starts from the beginning (i.e., not resuming an\n+     * existing iteration).\n+     */\n+    public static final IteratorState EMPTY = new IteratorState(Unpooled.EMPTY_BUFFER);\n+\n+    private final ByteBuf token;\n+\n+    /**\n+     * Gets a value indicating whether this {@link IteratorState} instance is empty.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.token.readableBytes() == 0;\n+    }\n+\n+    /**\n+     * Deserializes the IteratorState from its serialized form obtained from calling {@link #getToken()} .\n+     *\n+     * @param serializedState A serialized {@link IteratorState}.\n+     * @return The IteratorState object.\n+     */\n+    public static IteratorState fromBytes(ByteBuf serializedState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjY3Nw==", "bodyText": "This concept is already complex enough without the additional possibility of some keys not being in a family. I think we can just make it mandatory. If users want them to be random they can just pass the same string twice.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388516677", "createdAt": "2020-03-05T19:34:41Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNzg0OQ==", "bodyText": "This is explaining that \"improper\" use is bad, but it does so without first explaining how the system is architected and what a 'proper' use looks like given that architecture.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388517849", "createdAt": "2020-03-05T19:36:55Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA==", "bodyText": "With these conditional and unconditional updates, I think we should blatantly copy the verbage from concurrenthashmap, because they are standardized in the Java Collections.\nput, putAll, putIfAbsent, remove, and replace.\nJava developers will recognise the meaning of these terms.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388522834", "createdAt": "2020-03-05T19:45:52Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries\n+ * are placed in the same Key Family (compared to the number of Key/Entries in other Key Families), it may not be\n+ * possible to uniformly distribute the Key-Value Table Entries across the cluster and more load will be placed on a\n+ * single backing Table Segment instead of spreading such load across many Table Segments. An ideally balanced Key-Value\n+ * Table will be one where Keys are not part of any Key Families or the number of Keys in each Key Family is approximately\n+ * the same. An improperly designed Key-Value Table will have all Keys part of a single Key Family which will cause a\n+ * single Table Segment to bear the full storage and processing load of the entire Key-Value Table.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyNjU4Nw==", "bodyText": "Why is there a getter for this? Generally we don't expose segments", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388526587", "createdAt": "2020-03-05T19:52:24Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyVersion.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.client.tables.impl.TableSegmentKeyVersion;\n+import java.io.Serializable;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Version of a Key in a Table.\n+ */\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+public class KeyVersion implements Serializable {\n+    /**\n+     * {@link KeyVersion} that indicates no specific version is desired. Using this will result in an unconditional\n+     * update or removal being performed. See {@link KeyValueTable} for details on conditional/unconditional updates.\n+     */\n+    public static final KeyVersion NO_VERSION = new KeyVersion(null, TableSegmentKeyVersion.NO_VERSION);\n+    /**\n+     * {@link KeyVersion} that indicates the {@link TableKey} must not exist. Using this will result in an conditional\n+     * update or removal being performed, conditioned on the {@link TableKey} not existing at the time of the operation.\n+     * See {@link KeyValueTable} for details on conditional/unconditional updates.\n+     */\n+    public static final KeyVersion NOT_EXISTS = new KeyVersion(null, TableSegmentKeyVersion.NOT_EXISTS);\n+\n+    /**\n+     * The Segment where this Key resides. May be null if this is a {@link #NOT_EXISTS} or {@link #NO_VERSION}\n+     * {@link KeyVersion}.\n+     */\n+    @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTMzMDEy", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-370933012", "createdAt": "2020-03-09T06:09:12Z", "commit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNjowOToxMlrOFzbxgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNjowOToxMlrOFzbxgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3NjczOQ==", "bodyText": "@andreipaduroiu Could you help undertstand how ByteBuf release is being handled here?", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389476739", "createdAt": "2020-03-09T06:09:12Z", "author": {"login": "shrids"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -376,27 +366,24 @@ private String getTransactionName(String scope, String stream, long segmentId, U\n     /**\n      * This method sends a WireCommand to update table entries.\n      *\n-     * @param tableName           Qualified table name.\n-     * @param entries             List of {@link TableEntry}s to be updated.\n-     * @param delegationToken     The token to be presented to the segmentstore.\n-     * @param clientRequestId     Request id.\n-     * @return A CompletableFuture that, when completed normally, will contain the current versions of each {@link TableEntry}\n+     * @param tableName       Qualified table name.\n+     * @param entries         List of {@link TableSegmentEntry} instances to be updated.\n+     * @param delegationToken The token to be presented to the Segment Store.\n+     * @param clientRequestId Request id.\n+     * @return A CompletableFuture that, when completed normally, will contain the current versions of each\n+     * {@link TableSegmentEntry}.\n      * If the operation failed, the future will be failed with the causing exception. If the exception can be retried\n      * then the future will be failed with {@link WireCommandFailedException}.\n      */\n-    public CompletableFuture<List<KeyVersion>> updateTableEntries(final String tableName,\n-                                                                  final List<TableEntry<byte[], byte[]>> entries,\n-                                                                  String delegationToken,\n-                                                                  final long clientRequestId) {\n+    public CompletableFuture<List<TableSegmentKeyVersion>> updateTableEntries(final String tableName,\n+                                                                              final List<TableSegmentEntry> entries,\n+                                                                              String delegationToken,\n+                                                                              final long clientRequestId) {\n         final Controller.NodeUri uri = getTableUri(tableName);\n         final WireCommandType type = WireCommandType.UPDATE_TABLE_ENTRIES;\n-        List<ByteBuf> buffersToRelease = new ArrayList<>();\n         List<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>> wireCommandEntries = entries.stream().map(te -> {\n             final WireCommands.TableKey key = convertToWireCommand(te.getKey());\n-            ByteBuf valueBuffer = wrappedBuffer(te.getValue());\n-            buffersToRelease.add(key.getData());\n-            buffersToRelease.add(valueBuffer);\n-            final WireCommands.TableValue value = new WireCommands.TableValue(valueBuffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df7480352538f93c7ccb10db86216513e019faa5", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/df7480352538f93c7ccb10db86216513e019faa5", "committedDate": "2020-03-09T22:03:06Z", "message": "Fixed some Javadoc verbiage.\nSeparated IteratorState (interface) and IteratorStateImpl (class) to hide some implementation details.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjU2ODQ2", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-374656846", "createdAt": "2020-03-13T22:45:37Z", "commit": {"oid": "df7480352538f93c7ccb10db86216513e019faa5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjo0NTozOFrOF2VX4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMzoxOToxMFrOF2V1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxNzYwMg==", "bodyText": "This should say \"(either all changes will be applied or none will)\".\nI am trying to avoid the implication that \"all\" refers to keys/entries rather than the changes.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392517602", "createdAt": "2020-03-13T22:45:38Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df7480352538f93c7ccb10db86216513e019faa5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODMyOA==", "bodyText": "That's not really an instruction. Please rephrase this sentence to tell people what they should do.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392518328", "createdAt": "2020-03-13T22:48:43Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNzg0OQ=="}, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTEwNg==", "bodyText": "No. I am proposing the following:\nRename KeyVersion to Version and move it off of key and put in on TableEntry. (It has to do with entries no keys after all) and have TableEntry extend Map.Entry.\nThen on this class have:\nCompletableFuture<TableEntry<KeyT, ValueT>> get(String keyFamily, KeyT key);\nCompletableFuture<List<TableEntry<KeyT, ValueT>>> getAll(String keyFamily, List<KeyT> keys);\nCompletableFuture<Version> put(String keyFamily, KeyT key, ValueT value);\nCompletableFuture<List<Version>> putAll(String keyFamily, Iterable<Entry<KeyT, ValueT> items);\nCompletableFuture<Version> putIfAbsent(String keyFamily, KeyT key, ValueT value);\nCompletableFuture<Version> replace(String keyFamily, KeyT key, Version version, ValueT value);\nCompletableFuture<List<Version>> replaceAll(String keyFamily, Iterable<TableEntry<KeyT, ValueT>> items);\nCompletableFuture<TableEntry<KeyT, ValueT>> remove(String keyFamily, KeyT key);\nCompletableFuture<Boolean> remove(String keyFamily, KeyT key, Version version);\nCompletableFuture<Boolean> removeAll(String keyFamily, Iterable<TableEntry<KeyT, ValueT>> items);\nIn all of the above keyFamily may be null.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392525106", "createdAt": "2020-03-13T23:19:10Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries\n+ * are placed in the same Key Family (compared to the number of Key/Entries in other Key Families), it may not be\n+ * possible to uniformly distribute the Key-Value Table Entries across the cluster and more load will be placed on a\n+ * single backing Table Segment instead of spreading such load across many Table Segments. An ideally balanced Key-Value\n+ * Table will be one where Keys are not part of any Key Families or the number of Keys in each Key Family is approximately\n+ * the same. An improperly designed Key-Value Table will have all Keys part of a single Key Family which will cause a\n+ * single Table Segment to bear the full storage and processing load of the entire Key-Value Table.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA=="}, "originalCommit": {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3f2e4d22f861bc513255b0a1d26e916c66e905b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d3f2e4d22f861bc513255b0a1d26e916c66e905b", "committedDate": "2020-03-17T16:00:03Z", "message": "Javadoc fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/5fa9ebfaafd25626e344949f70230ca690a41ff4", "committedDate": "2020-03-17T18:06:19Z", "message": "KeyValueTable API variant #2\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxODUxNDQ1", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-381851445", "createdAt": "2020-03-26T09:55:41Z", "commit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwOTo1NTo0MVrOF7_ISw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMDoyNjowMVrOF8ASdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NDYxOQ==", "bodyText": "This is a bit confusing. I understand that BadKeyVersion is a special case of ConditionalTableUpdate, but I don't understand what other case is included in ConditionalTableUpdate. If there is such a case, why not create an exception for that specific case?\nAlso, the use that I'm seeing of ConditionalTableUpdate in TableSegment is about version mismatch, so why are you not using BadKeyVersion there. From TableSegment:\n <li>{@link ConditionalTableUpdateException} If this is a Conditional Update and the condition was not satisfied.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398444619", "createdAt": "2020-03-26T09:55:41Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/BadKeyVersionException.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+/**\n+ * Exception that is thrown whenever a conditional {@link KeyValueTable} update failed due to the provided key version\n+ * mismatching. This is different from {@link NoSuchKeyException}.\n+ */\n+public class BadKeyVersionException extends ConditionalTableUpdateException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NjI0NQ==", "bodyText": "I'm not sure what \"non-transferable between different types of iterations\" is referring to. Are you referring to reusing state from different iterator instances?", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398446245", "createdAt": "2020-03-26T09:58:04Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/IteratorState.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.netty.buffer.Unpooled;\n+import io.pravega.client.tables.impl.IteratorStateImpl;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Represents the state of a resumable iterator. Such an iterator can be executed asynchronously and continued after an\n+ * interruption. Each iteration will result in a new request to the server (which is stateless). The entire state of\n+ * the iterator is encoded in this object and is non-transferable between different types of iterations. The server will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ1NTcxOQ==", "bodyText": "I suggest to rephrase this to the following:\nInserts a new Entry in the {@link KeyValueTable} only if the given Key is not already present.\n\nThe use of conditionally is redundant and the use of iff does not sound logically correct.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398455719", "createdAt": "2020-03-26T10:13:07Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link KeyVersion#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link KeyVersion#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NOT_EXISTS} or {@link KeyVersion#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link KeyVersion} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<KeyVersion> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if and only if the given Key is not already present.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ1NTk3Mw==", "bodyText": "Same comment about rephrasing.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398455973", "createdAt": "2020-03-26T10:13:32Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link KeyVersion#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link KeyVersion#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NOT_EXISTS} or {@link KeyVersion#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link KeyVersion} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<KeyVersion> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if and only if the given Key is not already present.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link KeyVersion} associated with the newly\n+     * inserted or updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is already present in the {@link KeyValueTable} for the\n+     * provided Key Family.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<KeyVersion> putIfAbsent(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Unconditionally inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family\n+     * into this {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link Map.Entry} instances to insert or update.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link KeyVersion} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as the number of\n+     * items in entries and the versions will be in the same order as the entries.\n+     */\n+    CompletableFuture<List<KeyVersion>> putAll(@NonNull String keyFamily, @NonNull Iterable<Map.Entry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Conditionally updates an existing Entry in the {@link KeyValueTable} if and only if the given Key exists and its", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MDc3MQ==", "bodyText": "I find this notion of \"key version\" confusing. I understand you want the comparison to be on separate value compared to making it conditional on the value itself, and I think I understand why you associate the version to the key: you the key is what is constant in a key-value pair. But, the version really refers to the KV pair, and it indicates state changes to a particular KV pair, where the state change is reflected in the change of a value.\nI'm saying all this to ask whether we can disassociate version from key. If we call it just version, then it would be ideal but it is too generic maybe and might conflict with some other definition of version. Another option is to call it KVVersion to associate to a KV pair.\nLet me know what you think.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398460771", "createdAt": "2020-03-26T10:21:23Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/KeyVersion.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.client.tables.impl.TableSegmentKeyVersion;\n+import java.io.Serializable;\n+import lombok.AccessLevel;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Version of a Key in a Table.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzI3OA==", "bodyText": "Is this supposed to be public or package protected? Do I understand right that TableSegment isn't a concept we are exposing, that it is an internal implementation detail?", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398463278", "createdAt": "2020-03-26T10:25:23Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentEntry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Entry in a {@link TableSegment}.\n+ */\n+@Getter\n+@RequiredArgsConstructor(access = AccessLevel.PACKAGE)\n+public class TableSegmentEntry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzYwNQ==", "bodyText": "Same question about the visibility of this class.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398463605", "createdAt": "2020-03-26T10:26:01Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentKey.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Key for a {@link TableSegment}.\n+ */\n+@Getter\n+@RequiredArgsConstructor(access = AccessLevel.PACKAGE)\n+public class TableSegmentKey {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b95541f6d6bb74395c9e470a651a9592a4f5762", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/7b95541f6d6bb74395c9e470a651a9592a4f5762", "committedDate": "2020-03-26T15:20:49Z", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyODcyMDU1", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-382872055", "createdAt": "2020-03-27T13:48:19Z", "commit": {"oid": "7b95541f6d6bb74395c9e470a651a9592a4f5762"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMzo0ODoxOVrOF8x5uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDowODo0OFrOF8ywWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI3NjQ3NQ==", "bodyText": "nit: missing }", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399276475", "createdAt": "2020-03-27T13:48:19Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegment.java", "diffHunk": "@@ -23,134 +26,123 @@\n  * * Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether that Key\n  * previously existed or not, and regardless of what that Key's version is.\n  * * Conditional Updates will only overwrite an existing value if the specified version matches that Key's version. If\n- * the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with {@link KeyVersion#NOT_EXISTS}\n- * in order for the update to succeed.\n+ * the key does not exist, the {@link TableSegmentKey} or {@link TableSegmentEntry} must have been created with\n+ * {@link TableSegmentKeyVersion#NOT_EXISTS} in order for the update to succeed.\n  * * Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also succeed (albeit\n  * with no effect) if the Key does not exist.\n- * * Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's version.\n- * It will also fail (with no effect) if the Key does not exist and Version is not set to {@link KeyVersion#NOT_EXISTS}.\n+ * * Conditional Removals will remove a Key only if the specified {@link TableSegmentKey#getVersion()} matches that Key's version.\n+ * It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link TableSegmentKeyVersion#NOT_EXISTS}.\n  *\n- * @param <KeyT>   Table Key Type.\n- * @param <ValueT> Table Value Type.\n+ * A note about {@link ByteBuf}s. All the methods defined in this interface make use of {@link ByteBuf} either directly\n+ * or via {@link TableSegmentKey}/{@link TableSegmentEntry}. It is expected that no implementation of the {@link TableSegment}\n+ * interface will either retain ({@link ByteBuf#retain()) or release ({@link ByteBuf#release()}) these buffers during", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b95541f6d6bb74395c9e470a651a9592a4f5762"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5MDQ1OA==", "bodyText": "+1", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399290458", "createdAt": "2020-03-27T14:08:48Z", "author": {"login": "shrids"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PravegaTablesStoreHelper.java", "diffHunk": "@@ -429,69 +445,24 @@ public void invalidateCache(String table, String key) {\n             Function<byte[], T> fromBytes) {\n         log.trace(\"get entries paginated called for : {}\", tableName);\n         return withRetries(() -> segmentHelper.readTableEntries(tableName, limit,\n-                IteratorState.fromBytes(continuationToken), authToken.get(), RequestTag.NON_EXISTENT_ID),\n+                IteratorStateImpl.fromBytes(continuationToken), authToken.get(), RequestTag.NON_EXISTENT_ID),\n                 () -> String.format(\"get entries paginated for table: %s\", tableName))\n                 .thenApplyAsync(result -> {\n-                    List<Map.Entry<String, VersionedMetadata<T>>> items = result.getItems().stream().map(x -> {\n-                        String key = new String(x.getKey().getKey(), Charsets.UTF_8);\n-                        T deserialized = fromBytes.apply(x.getValue());\n-                        VersionedMetadata<T> value = new VersionedMetadata<>(deserialized, new Version.LongVersion(x.getKey().getVersion().getSegmentVersion()));\n-                        return new AbstractMap.SimpleEntry<>(key, value);\n-                    }).collect(Collectors.toList());\n-                    log.trace(\"get keys paginated on table {} returned number of items {}\", tableName, items.size());\n-                    return new AbstractMap.SimpleEntry<>(result.getState().toBytes(), items);\n+                    try {\n+                        List<Map.Entry<String, VersionedMetadata<T>>> items = result.getItems().stream().map(x -> {\n+                            String key = new String(getArray(x.getKey().getKey()), Charsets.UTF_8);\n+                            T deserialized = fromBytes.apply(getArray(x.getValue()));\n+                            VersionedMetadata<T> value = new VersionedMetadata<>(deserialized, new Version.LongVersion(x.getKey().getVersion().getSegmentVersion()));\n+                            return new AbstractMap.SimpleEntry<>(key, value);\n+                        }).collect(Collectors.toList());\n+                        log.trace(\"get keys paginated on table {} returned number of items {}\", tableName, items.size());\n+                        return new AbstractMap.SimpleEntry<>(Unpooled.wrappedBuffer(result.getState().toBytes()), items);\n+                    } finally {\n+                        releaseEntries(result.getItems());\n+                    }\n                 }, executor);\n     }\n \n-    /**\n-     * Method to retrieve a collection of entries bounded by the specified limit size that satisfy the supplied filter.\n-     * This function makes calls into segment store and includes entries that satisfy the supplied\n-     * predicate. It makes repeated paginated calls into segment store until it has either collected deseried number\n-     * of entries or it has exhausted all entries in the store.\n-     * @param table table\n-     * @param fromStringKey function to deserialize key from String.\n-     * @param fromBytesValue function to deserialize value from byte array\n-     * @param filter filer predicate which takes key and value and returns true or false.\n-     * @param limit maximum number of entries to retrieve\n-     * @param <K> Type of Key\n-     * @param <V> Type of Value\n-     * @return CompletableFuture which when completed will have a map of keys and values of size bounded by supplied limit\n-     */\n-    public <K, V> CompletableFuture<Map<K, V>> getEntriesWithFilter(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b95541f6d6bb74395c9e470a651a9592a4f5762"}, "originalPosition": 330}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/253896be5fe963601edbccfb29e13efdb515280a", "committedDate": "2020-03-27T16:40:26Z", "message": "KeyVersion -> Version.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDg0Njgw", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-383084680", "createdAt": "2020-03-27T17:58:26Z", "commit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5f530b75c7f3e0df64cbcfad07fdc1fdbfdbd2f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b5f530b75c7f3e0df64cbcfad07fdc1fdbfdbd2f", "committedDate": "2020-03-27T19:58:39Z", "message": "Unit test coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDU0NTM4", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-383054538", "createdAt": "2020-03-27T17:17:33Z", "commit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNzoxNzozM1rOF86tYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMToxMTowOFrOF9B-JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMDc3MA==", "bodyText": "I think this needs to be updated.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399420770", "createdAt": "2020-03-27T17:17:33Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMTQ1MA==", "bodyText": "Same here. (What does it mean to condition a removal on the non-existence of the item?)", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399421450", "createdAt": "2020-03-27T17:18:44Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMjA1OA==", "bodyText": "Can we create a Version#WRONG_VERSION to make this more clear?", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399422058", "createdAt": "2020-03-27T17:19:46Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NOT_EXISTS} or {@link Version#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzOTY2Nw==", "bodyText": "This links to tableKey but the signature does not take one.", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399539667", "createdAt": "2020-03-27T21:10:53Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NOT_EXISTS} or {@link Version#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<Version> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if the given Key is not already present.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is already present in the {@link KeyValueTable} for the\n+     * provided Key Family.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> putIfAbsent(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Unconditionally inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family\n+     * into this {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link Map.Entry} instances to insert or update.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as the number of\n+     * items in entries and the versions will be in the same order as the entries.\n+     */\n+    CompletableFuture<List<Version>> putAll(@NonNull String keyFamily, @NonNull Iterable<Map.Entry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Conditionally updates an existing Entry in the {@link KeyValueTable} if the given Key exists and its\n+     * version matches the given {@link Version}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to update.\n+     * @param value     The new Value to be associated with the Key.\n+     * @param version   A {@link Version} representing the version that this Key must have in order to replace it.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the\n+     * updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is not present present in the {@link KeyValueTable} for the\n+     * provided Key Family or it is and has a different {@link Version}.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> replace(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value,\n+                                       @NonNull Version version);\n+\n+    /**\n+     * Inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family into this\n+     * {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link TableEntry} instances to insert or update. If for at least one\n+     *                  such entry, {@link TableEntry#getKey()}{@link TableKey#getVersion()} indicates a conditional\n+     *                  update, this will perform an atomic Conditional Update conditioned on the server-side versions\n+     *                  matching the provided ones (for all {@link TableEntry} instances that have one); otherwise an\n+     *                  Unconditional Update will be performed.\n+     *                  See {@link KeyValueTable} doc for more details on Types of Updates.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as entries.size()\n+     * and the versions will be in the same order as the entries. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If this is a Conditional Update and the condition was not satisfied.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<List<Version>> replaceAll(@NonNull String keyFamily, @NonNull Iterable<TableEntry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Unconditionally removes a {@link TableKey} from this Table Segment. If the Key does not exist, no action will be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzOTc0OA==", "bodyText": "Same here", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399539748", "createdAt": "2020-03-27T21:11:08Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NOT_EXISTS} or {@link Version#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<Version> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if the given Key is not already present.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is already present in the {@link KeyValueTable} for the\n+     * provided Key Family.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> putIfAbsent(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Unconditionally inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family\n+     * into this {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link Map.Entry} instances to insert or update.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as the number of\n+     * items in entries and the versions will be in the same order as the entries.\n+     */\n+    CompletableFuture<List<Version>> putAll(@NonNull String keyFamily, @NonNull Iterable<Map.Entry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Conditionally updates an existing Entry in the {@link KeyValueTable} if the given Key exists and its\n+     * version matches the given {@link Version}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to update.\n+     * @param value     The new Value to be associated with the Key.\n+     * @param version   A {@link Version} representing the version that this Key must have in order to replace it.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the\n+     * updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is not present present in the {@link KeyValueTable} for the\n+     * provided Key Family or it is and has a different {@link Version}.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> replace(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value,\n+                                       @NonNull Version version);\n+\n+    /**\n+     * Inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family into this\n+     * {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link TableEntry} instances to insert or update. If for at least one\n+     *                  such entry, {@link TableEntry#getKey()}{@link TableKey#getVersion()} indicates a conditional\n+     *                  update, this will perform an atomic Conditional Update conditioned on the server-side versions\n+     *                  matching the provided ones (for all {@link TableEntry} instances that have one); otherwise an\n+     *                  Unconditional Update will be performed.\n+     *                  See {@link KeyValueTable} doc for more details on Types of Updates.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as entries.size()\n+     * and the versions will be in the same order as the entries. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If this is a Conditional Update and the condition was not satisfied.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<List<Version>> replaceAll(@NonNull String keyFamily, @NonNull Iterable<TableEntry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Unconditionally removes a {@link TableKey} from this Table Segment. If the Key does not exist, no action will be\n+     * taken.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Key to remove.\n+     * @param key       The Key to remove.\n+     * @return A CompletableFuture that, when completed, will indicate the Key has been removed.\n+     */\n+    CompletableFuture<Void> remove(@Nullable String keyFamily, @NonNull KeyT key);\n+\n+    /**\n+     * Conditionally Removes a Key from this Table Segment.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the {@link TableKey} to remove.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253896be5fe963601edbccfb29e13efdb515280a"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a549c9bcba0ef0442b62c167e1acea979deba5d2", "committedDate": "2020-03-27T21:49:36Z", "message": "Javadoc\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7037d1c3fe0fde33f0cb7e5a87026185c2c351a6", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/7037d1c3fe0fde33f0cb7e5a87026185c2c351a6", "committedDate": "2020-03-27T22:37:10Z", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjY4OTMz", "url": "https://github.com/pravega/pravega/pull/4588#pullrequestreview-383268933", "createdAt": "2020-03-28T01:15:04Z", "commit": {"oid": "7037d1c3fe0fde33f0cb7e5a87026185c2c351a6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3611, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}