{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MzkwMjc5", "number": 5204, "title": "Issue:5109 Add and Remove Subscriber API on Controller", "bodyText": "Signed-off-by: pbelgundi prajakta.belgundi@emc.com\nChange log description\nThis PR adds the following 2 APIs to ControllerService:\nvoid addSubscriber (String RGName, String scopeName, String streamName)\nvoid removeSubscriber (String RGName, String scopeName, String streamName)\nvoid updateSubscriberStreamCut(String RGName, String scopeName, String streamName, Streamcut streamCut)\n\nPurpose of the change\nFixes #5109 #5110\nWhat the code does\nAdds API to Add/Remove a subscriber for a Stream.\nAdds API to UpdateSubscriberStreamCut for Truncation.\nNewly added classes:\nStreamSubscriber.java\nSubscriberSet.java\nClasses with changes:\nStreamMetadataTasks.java\nStreamMetadataStore.java\nAbstractStreamMetadataStore.java\nStream.java\nPersistentStreamBase.java\nPravegaTablesStream.java\nHow to verify it\nUnit and Integration tests should pass.", "createdAt": "2020-09-18T15:31:09Z", "url": "https://github.com/pravega/pravega/pull/5204", "merged": true, "mergeCommit": {"oid": "c9dac22c506f6d51b08fbd60b76095f40bb5c308"}, "closed": true, "closedAt": "2020-10-30T07:36:35Z", "author": {"login": "pbelgundi"}, "timelineItems": {"totalCount": 77, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMVM4QAH2gAyNDg5MzkwMjc5OmVkODVlNmU4N2U2MzUyZjkzMGU4NTExYjlhYTBlYTY3YTVmZGIyY2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXg6hxgFqTUyMDQwNjUwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ed85e6e87e6352f930e8511b9aa0ea67a5fdb2ca", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/ed85e6e87e6352f930e8511b9aa0ea67a5fdb2ca", "committedDate": "2020-09-25T12:46:24Z", "message": "addSubscriber API\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87e256205ee452c8476e2c6e9628bb16f4e3cd60", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/87e256205ee452c8476e2c6e9628bb16f4e3cd60", "committedDate": "2020-09-25T12:51:10Z", "message": "addSubscriber improvements\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c1b623b84e422f7e5a205deeba8e8458e66f5b5", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/8c1b623b84e422f7e5a205deeba8e8458e66f5b5", "committedDate": "2020-09-25T12:51:10Z", "message": "fix tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a142f1c701bab038c7a5b307100d9595ff0ed03", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/6a142f1c701bab038c7a5b307100d9595ff0ed03", "committedDate": "2020-09-25T12:51:10Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f60191187da0b5497a930c80a036ed5360621402", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/f60191187da0b5497a930c80a036ed5360621402", "committedDate": "2020-09-25T12:51:10Z", "message": "added code for ControllerImpl\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "f60191187da0b5497a930c80a036ed5360621402", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/f60191187da0b5497a930c80a036ed5360621402", "committedDate": "2020-09-25T12:51:10Z", "message": "added code for ControllerImpl\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a548b10373d40fc93641e0d80dded7558320653", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/6a548b10373d40fc93641e0d80dded7558320653", "committedDate": "2020-09-28T06:46:58Z", "message": "RemoveSubscriber API\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44e62c169ee5af1f133667b558a2e65d933acc72", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/44e62c169ee5af1f133667b558a2e65d933acc72", "committedDate": "2020-09-28T08:26:26Z", "message": "MockController fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a930f49f78b4deea60eb11b46906a57dd1c3fd94", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/a930f49f78b4deea60eb11b46906a57dd1c3fd94", "committedDate": "2020-09-28T09:23:28Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mzk0MDc3", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-497394077", "createdAt": "2020-09-28T10:46:01Z", "commit": {"oid": "a930f49f78b4deea60eb11b46906a57dd1c3fd94"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDo0NjowMVrOHY4PIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDo0NjowMVrOHY4PIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0OTI1MQ==", "bodyText": "do you need to add a subscriber asynchronously? that can be done inline for the call as it should be a single metadata update -- a new subscriber id as a record in some table, right?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r495849251", "createdAt": "2020-09-28T10:46:01Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "diffHunk": "@@ -156,6 +158,8 @@ public ControllerEventProcessors(final String host,\n                 new SealStreamTask(streamMetadataTasks, streamTransactionMetadataTasks, streamMetadataStore, executor),\n                 new DeleteStreamTask(streamMetadataTasks, streamMetadataStore, bucketStore, executor),\n                 new TruncateStreamTask(streamMetadataTasks, streamMetadataStore, executor),\n+                new AddSubscriberTask(streamMetadataTasks, streamMetadataStore, executor),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a930f49f78b4deea60eb11b46906a57dd1c3fd94"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bee195165af3e23c22071a74ddec761f705cb5c4", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/bee195165af3e23c22071a74ddec761f705cb5c4", "committedDate": "2020-09-28T11:31:13Z", "message": "addSubscriber API - changed return status to AddSubscriberStatus\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "177ee53c7e23b410796ca5968721738fad0ee7b3", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/177ee53c7e23b410796ca5968721738fad0ee7b3", "committedDate": "2020-09-29T07:37:12Z", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a2b76724863bd2fa3fbde3e6f3d229c2ea710a1", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/2a2b76724863bd2fa3fbde3e6f3d229c2ea710a1", "committedDate": "2020-09-29T10:58:06Z", "message": "code changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ed03cf9b0e2c8de69dd3a6464434997894d5ad4", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/8ed03cf9b0e2c8de69dd3a6464434997894d5ad4", "committedDate": "2020-09-29T10:59:45Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7d1238fc2fd4654a7116fbc0b8232ae0bd253fe", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/d7d1238fc2fd4654a7116fbc0b8232ae0bd253fe", "committedDate": "2020-10-01T07:31:41Z", "message": "changes for adding Unit and Integration tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e19722ed73646a75a1425e3db5d159a90009a89", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/6e19722ed73646a75a1425e3db5d159a90009a89", "committedDate": "2020-10-01T11:24:04Z", "message": "fix tests and code\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e70bbd60cf389ad9873214cc0a40ee0a41ef23f1", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e70bbd60cf389ad9873214cc0a40ee0a41ef23f1", "committedDate": "2020-10-01T11:25:54Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcd1a0e135e809b6b8d3e568bfefcf23715c8b0b", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/fcd1a0e135e809b6b8d3e568bfefcf23715c8b0b", "committedDate": "2020-10-01T13:31:08Z", "message": "more tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/5509932287a56919c52c51a17b893a2ec10ed01c", "committedDate": "2020-10-01T15:09:22Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzMzODE2", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-501733816", "createdAt": "2020-10-05T05:41:13Z", "commit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTo0MToxM1rOHcOOAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOTozNzoxNlrOHcVJxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTEzOQ==", "bodyText": "should we throw a checked exception so that users can handle it and choose to retry?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499355139", "createdAt": "2020-10-05T05:41:13Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw==", "bodyText": "IMO this should be idempotent case and non error case.. if you want to throw an exception, should this be something other than illegalargument", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499355993", "createdAt": "2020-10-05T05:44:50Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjEzOQ==", "bodyText": "idempotent case, should be treated as success perhaps", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499356139", "createdAt": "2020-10-05T05:45:23Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjcwMg==", "bodyText": "do you want to include SCopeNotFound and StreamNotFound error cases for this as well?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499356702", "createdAt": "2020-10-05T05:47:35Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Subscriber does not exist: \" + subscriber);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully removed subscriber {} from stream: {}/{}\", subscriber, scope, streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"removeSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"removeSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String streamName) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(scope, \"scopeName\");\n+        Preconditions.checkNotNull(streamName, \"stream\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"getSubscribersForStream\", streamName);\n+        final CompletableFuture<StreamSubscribers> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<StreamSubscribers> callback = new RPCAsyncCallback<>(requestId, \"getSubscribersForStream\", scope, streamName);\n+            client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS).getSubscribersForStream(ModelHelper.createStreamInfo(scope, streamName), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(subscribers -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTk2NQ==", "bodyText": "nit: preconditions for scope and stream as well.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499455965", "createdAt": "2020-10-05T09:18:05Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -324,6 +325,21 @@ public static final StreamConfig decode(String scope, String streamName, final S\n         return builder.build();\n     }\n \n+    /**\n+     * Converts StreamConfiguration into StreamConfig.\n+     *\n+     * @param scope the stream's scope\n+     * @param streamName The Stream Name\n+     * @param subscriberId Id of the subscriber for this stream.\n+     * @return StreamSubscriberInfo instance.\n+     */\n+    public static final StreamSubscriberInfo decode(String scope, String streamName, final String subscriberId) {\n+        Preconditions.checkNotNull(subscriberId, \"subscriber\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NjIyMQ==", "bodyText": "nit: revert this please", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499456221", "createdAt": "2020-10-05T09:18:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java", "diffHunk": "@@ -14,40 +14,7 @@\n import java.time.Duration;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE;\n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_SCOPE_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_SCOPE_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.OPEN_TRANSACTIONS;\n-import static io.pravega.shared.MetricsNames.RETENTION_FREQUENCY;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_MERGES;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_SPLITS;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_LATENCY;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE;\n-import static io.pravega.shared.MetricsNames.KVTABLE_SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE;\n-import static io.pravega.shared.MetricsNames.DELETE_KVTABLE_FAILED;\n-import static io.pravega.shared.MetricsNames.globalMetricName;\n+import static io.pravega.shared.MetricsNames.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1Njg1Ng==", "bodyText": "do you still need to route it through stream metadata tasks? you can perhaps directly write using the store apis.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499456856", "createdAt": "2020-10-05T09:19:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -158,6 +160,37 @@\n                 }, executor);\n     }\n \n+    public CompletableFuture<AddSubscriberStatus> addSubscriber(String scope, String stream, final String subscriber) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+        Preconditions.checkNotNull(subscriber, \"subscriber is null\");\n+        Timer timer = new Timer();\n+        return streamMetadataTasks.addSubscriber(scope, stream, subscriber, null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NzAxMQ==", "bodyText": "same here", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499457011", "createdAt": "2020-10-05T09:19:40Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -158,6 +160,37 @@\n                 }, executor);\n     }\n \n+    public CompletableFuture<AddSubscriberStatus> addSubscriber(String scope, String stream, final String subscriber) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+        Preconditions.checkNotNull(subscriber, \"subscriber is null\");\n+        Timer timer = new Timer();\n+        return streamMetadataTasks.addSubscriber(scope, stream, subscriber, null)\n+                .thenApplyAsync(status -> {\n+                    reportAddSubscriberMetrics(scope, stream, status, timer.getElapsed());\n+                    return AddSubscriberStatus.newBuilder().setStatus(status).build();\n+                }, executor);\n+    }\n+\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+\n+        return streamMetadataTasks.getSubscribersForStream(scope, stream, null);\n+    }\n+\n+    public CompletableFuture<RemoveSubscriberStatus> removeSubscriber(String scope, String stream, final String subscriber) {\n+        Preconditions.checkNotNull(scope, \"scopeName is null\");\n+        Preconditions.checkNotNull(stream, \"streamName is null\");\n+        Preconditions.checkNotNull(subscriber, \"subscriber is null\");\n+        Timer timer = new Timer();\n+        return streamMetadataTasks.removeSubscriber(scope, stream, subscriber, null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1ODI2Ng==", "bodyText": "please implement or throw notimplemented exception", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499458266", "createdAt": "2020-10-05T09:21:33Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "diffHunk": "@@ -823,6 +824,21 @@ private void handleStreamMetadataExists(final long timestamp, CompletableFuture<\n         return result;\n     }\n \n+    @Override\n+    CompletableFuture<Void> createSubscribersDataIfAbsent(StreamSubscribersRecord data) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1ODQ0Ng==", "bodyText": "here and everywhere else in this class.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499458446", "createdAt": "2020-10-05T09:21:50Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/InMemoryStream.java", "diffHunk": "@@ -823,6 +824,21 @@ private void handleStreamMetadataExists(final long timestamp, CompletableFuture<\n         return result;\n     }\n \n+    @Override\n+    CompletableFuture<Void> createSubscribersDataIfAbsent(StreamSubscribersRecord data) {\n+        return null;\n+    }\n+\n+    @Override\n+    CompletableFuture<VersionedMetadata<StreamSubscribersRecord>> getSubscribersData(boolean ignoreCached) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1OTE4NQ==", "bodyText": "we can maybe always create this subscriber record for a stream as part of stream creation..\nthat way it only needs to be updated if a subscriber registers or unregisters.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499459185", "createdAt": "2020-10-05T09:22:56Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -156,6 +158,50 @@ public String getScopeName() {\n         return deleteStream();\n     }\n \n+    /**\n+     * Create a subscribersRecord with provided subscriber for this Stream.\n+     * @return future of operation.\n+     */\n+    @Override\n+    public CompletableFuture<Void> createSubscribersRecord(String subscriber) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1OTkzMw==", "bodyText": "please add javadoc.. also mention that it can throw write conflict exceptions.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499459933", "createdAt": "2020-10-05T09:24:00Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -156,6 +158,50 @@ public String getScopeName() {\n         return deleteStream();\n     }\n \n+    /**\n+     * Create a subscribersRecord with provided subscriber for this Stream.\n+     * @return future of operation.\n+     */\n+    @Override\n+    public CompletableFuture<Void> createSubscribersRecord(String subscriber) {\n+        ImmutableMap<String, SubscriberConfiguration> subscribers\n+                = new ImmutableMap.Builder<String, SubscriberConfiguration>()\n+                .put(subscriber, SubscriberConfiguration.EMPTY).build();\n+        return createSubscribersDataIfAbsent(new StreamSubscribersRecord(subscribers));\n+    }\n+\n+    public CompletableFuture<Void> updateSubscribers(final String subscriber,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MTk4Ng==", "bodyText": "nit: create.\nalso store can expose AddSubscriber and RemoveSubscriber apis.\ninternally the subscriber record can be created at the time of stream creation and is updated whenver a new subscriber is added/removed by doing a get and set.\nand this can fail with write conflict to the caller may need to handle and retry the operation.\nwe follow optimistic concurrency.. the assumption here is that subscriber registration is a rare occurrence and there will not be many conflicts.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499461986", "createdAt": "2020-10-05T09:26:49Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/StreamMetadataStore.java", "diffHunk": "@@ -287,6 +289,67 @@\n                                                                                            final OperationContext context,\n                                                                                            final Executor executor);\n \n+\n+    /**\n+     * Updates the subscribers metadata for an existing stream.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzMwMw==", "bodyText": "nit: remove commented code", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499463303", "createdAt": "2020-10-05T09:28:50Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/StreamSubscribersRecord.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Data class for storing information about stream's subscribers.\n+ */\n+@Data\n+@Slf4j\n+public class StreamSubscribersRecord {\n+    public static final SubscribersRecordSerializer SERIALIZER = new SubscribersRecordSerializer();\n+    public static final StreamSubscribersRecord EMPTY = new StreamSubscribersRecord(ImmutableMap.of());\n+\n+    private final ImmutableMap<String, SubscriberConfiguration> streamSubscribers;\n+\n+    @Builder\n+    public StreamSubscribersRecord(@NonNull ImmutableMap<String, SubscriberConfiguration> streamSubcribers) {\n+        this.streamSubscribers = streamSubcribers;\n+    }\n+\n+    public boolean contains(String subscriber) {\n+        Preconditions.checkArgument(streamSubscribers != null, \"Null subscribers for Stream\");\n+        return streamSubscribers.containsKey(subscriber);\n+    }\n+\n+    public static StreamSubscribersRecord update(ImmutableMap<String, SubscriberConfiguration> existingSubscribers,\n+                                                 String newSubscriber, SubscriberConfiguration config) {\n+        Map<String, SubscriberConfiguration> streamSubscribers = new HashMap<String, SubscriberConfiguration>();\n+        streamSubscribers.putAll(existingSubscribers);\n+        streamSubscribers.put(newSubscriber, config);\n+        return new StreamSubscribersRecord(ImmutableMap.copyOf(streamSubscribers));\n+    }\n+\n+    public static StreamSubscribersRecord remove(ImmutableMap<String, SubscriberConfiguration> existingSubscribers,\n+                                                 String subscriber) {\n+        Map<String, SubscriberConfiguration> streamSubscribers = existingSubscribers.entrySet().stream()\n+                                                                .filter(e -> !e.getKey().equals(subscriber))\n+                                                                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));\n+        return new StreamSubscribersRecord(ImmutableMap.copyOf(streamSubscribers));\n+    }\n+\n+    private static class StreamSubscribersRecordBuilder implements ObjectBuilder<StreamSubscribersRecord> {\n+    }\n+\n+    @SneakyThrows(IOException.class)\n+    public static StreamSubscribersRecord fromBytes(final byte[] record) {\n+        //InputStream inputStream = new ByteArrayInputStream(record, 0, record.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzkwMQ==", "bodyText": "why do we need this?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499463901", "createdAt": "2020-10-05T09:29:44Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2ODc0MA==", "bodyText": "please dont put the position/streamcut inside the subscriber record. since this record is actually written under the StreamSubscribersRecord this will be problematic on two dimensions:\n\nwith large number of subscribers, the size of this record can exceed the 1mb limit of kvt record if there are large number of segments in the streamcut. its better to divide and rule.\nthis will mean StreamSubscribersRecord is upadted with every \"report\" from a subscriber which means the write conflicts can occur lot more whereby making optimistic concurrency undesirable.\n\nmy suggestion is to do as follows:\n\nStreamSubscribersRecord should only contain a list of subscriber ids.\ncreate separate record for each subscriber for their reported position.\n\naddSubscriber/removeSubscriber updates the StreamSubscribersRecord with the subscriber's id.\nthen for each subscriber there is a separate key called say subscriber_<subscriberId>.\nwhen subscriber with id reports its streamcut, its streamcut is updated in subscriber_id record.\ngetSubscribers will first fetch the StreamSubscribersRecord  and then fetch all their individual records corresponding to their last reported positions.\nremovesubscriber can perform batch update of StreamSubscribersRecord and subscriber_id record by updating the former and removing the later via an atomic kvt update.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r499468740", "createdAt": "2020-10-05T09:37:16Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/records/SubscriberConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.stream.records;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+/**\n+ * The configuration of a Stream Subscriber.\n+ */\n+@Data\n+@Builder\n+public class SubscriberConfiguration implements Serializable {\n+\n+    public static final SubscriberConfigurationSerializer SERIALIZER = new SubscriberConfigurationSerializer();\n+    public static final SubscriberConfiguration EMPTY = new SubscriberConfiguration(0L, ImmutableMap.of());\n+    private static final long serialVersionUID = 1L;\n+    /**\n+     * Time when this configuration was updated.\n+     */\n+    private final long updateTime;\n+\n+    /**\n+     * Truncation Stream cut published by this subscriber\n+     */\n+    private final ImmutableMap<Long, Long> streamCut;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9619f5b7909ef3b6a382b44f7acc52069406f06", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/f9619f5b7909ef3b6a382b44f7acc52069406f06", "committedDate": "2020-10-05T13:42:57Z", "message": "unit tests fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c7d6afb928dcc9d10575d2a34c8651cbf8eee01", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/3c7d6afb928dcc9d10575d2a34c8651cbf8eee01", "committedDate": "2020-10-05T13:43:01Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ae405ff8556068a73938ee2fe6e67842b02fd02", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/0ae405ff8556068a73938ee2fe6e67842b02fd02", "committedDate": "2020-10-06T12:13:27Z", "message": "test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b937fbd11d9ec8c936fcc1c4d23630c4d29ff03e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/b937fbd11d9ec8c936fcc1c4d23630c4d29ff03e", "committedDate": "2020-10-06T12:13:53Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c88c8e06f0ff116ceb457b3cf48eddecabe666c1", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/c88c8e06f0ff116ceb457b3cf48eddecabe666c1", "committedDate": "2020-10-08T12:15:59Z", "message": "code review changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0776a7e8bab826220d560119bf372beaf0866389", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/0776a7e8bab826220d560119bf372beaf0866389", "committedDate": "2020-10-08T12:16:22Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61e5cbe3f88b32fb0d46eb9ed6be354044d133eb", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/61e5cbe3f88b32fb0d46eb9ed6be354044d133eb", "committedDate": "2020-10-08T16:26:41Z", "message": "test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8211fa464a753eee4496d31b38e2cfc25fc1d01", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e8211fa464a753eee4496d31b38e2cfc25fc1d01", "committedDate": "2020-10-09T06:13:42Z", "message": "unit tests fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c85c47bfd42db4a892e41e5bceb7892afd88c7a7", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/c85c47bfd42db4a892e41e5bceb7892afd88c7a7", "committedDate": "2020-10-09T06:13:57Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc80b9197fc1b3c89fda495bf975276ba4d472f5", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/bc80b9197fc1b3c89fda495bf975276ba4d472f5", "committedDate": "2020-10-09T08:54:46Z", "message": "removeSubscriber fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a69c29e0fbac4eb352c16d30022b4617d3bfbb8d", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/a69c29e0fbac4eb352c16d30022b4617d3bfbb8d", "committedDate": "2020-10-09T09:10:57Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "937971e03571e0d267ed78d5b59155187a65533e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/937971e03571e0d267ed78d5b59155187a65533e", "committedDate": "2020-10-09T14:07:17Z", "message": "updateTruncationStreamCut API\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "272b559ec710b5b6f3d9e354c8a356ae702c919e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/272b559ec710b5b6f3d9e354c8a356ae702c919e", "committedDate": "2020-10-13T09:45:33Z", "message": "test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa0492d5a6c966573f0b71c432bffdbfb7720ada", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/fa0492d5a6c966573f0b71c432bffdbfb7720ada", "committedDate": "2020-10-13T10:34:35Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cb28fbe9589c9d4722020f14277e447478de995", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/1cb28fbe9589c9d4722020f14277e447478de995", "committedDate": "2020-10-13T14:29:49Z", "message": "UT for updateTruncationStreamCut\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea8a64a0d485e5cad38a9b1720f9e5a7861345f6", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/ea8a64a0d485e5cad38a9b1720f9e5a7861345f6", "committedDate": "2020-10-13T15:31:38Z", "message": "test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68f768bad814f7abf7c31569618937d956d7855d", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/68f768bad814f7abf7c31569618937d956d7855d", "committedDate": "2020-10-14T04:27:28Z", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b5dd0a852d0906bc453f3c872aff44719fadbec", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/3b5dd0a852d0906bc453f3c872aff44719fadbec", "committedDate": "2020-10-14T04:27:49Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1c891c9de0b6aa9e339046af5ac6caaa541955e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e1c891c9de0b6aa9e339046af5ac6caaa541955e", "committedDate": "2020-10-14T13:29:38Z", "message": "integration test\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c11ec9961f20efddc94c17f598fdb4c3c692e30", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/5c11ec9961f20efddc94c17f598fdb4c3c692e30", "committedDate": "2020-10-14T17:20:25Z", "message": "unit tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c09719267b76164583ecce5043e0a5455ca54b0", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/7c09719267b76164583ecce5043e0a5455ca54b0", "committedDate": "2020-10-15T05:55:07Z", "message": "spotbugsfix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/effae36bd9829f1a753651835dc5bb4dec156d42", "committedDate": "2020-10-15T06:45:28Z", "message": "test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MjI0NjA5", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-509224609", "createdAt": "2020-10-15T10:12:58Z", "commit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxMjo1OFrOHiAuiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxMjo1OFrOHiAuiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTU0Nw==", "bodyText": "why is it a boolean? is boolean helpful to user if the subscriber was already present?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505425547", "createdAt": "2020-10-15T10:12:58Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MjI2NzM5", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-509226739", "createdAt": "2020-10-15T10:15:37Z", "commit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxNTozOFrOHiA0ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxNTozOFrOHiA0ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNzA1MA==", "bodyText": "same question: what is the reason to return a boolean here?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505427050", "createdAt": "2020-10-15T10:15:38Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MjI4MjMx", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-509228231", "createdAt": "2020-10-15T10:17:34Z", "commit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxNzozNFrOHiA4sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDo0ODoyOVrOHiB8-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyODE0NQ==", "bodyText": "nit: since this api is in the context of a subscriber, the name should reflect it.. perhaps a better name for this API would be reportSubscriberStreamCut or reportSubscriberPosition.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505428145", "createdAt": "2020-10-15T10:17:34Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> updateTruncationStreamCut(final String scope, final String streamName, final String subscriber, final StreamCut streamCut);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyODM1OA==", "bodyText": "nit: subscriber's position was updated", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505428358", "createdAt": "2020-10-15T10:17:56Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMDc3NA==", "bodyText": "ok, but we need better exception handling for these cases. A pravega user is not expected to be aware of controller and controller failure exceptions. typically any exception can be propagated to the user apis and if they are actionable, then they should be specific, and perhaps even checked. I agree that we havent done this consistently across APIs. But we have the opportunity here to evaluate what is right behaviour for this API. it really depends on how the error is translated when its presented to the user, esp if we expect them to handle the error in a meaningful way.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505430774", "createdAt": "2020-10-15T10:22:17Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMjM4Mw==", "bodyText": "i see your point. however let me ask a counter question - is the subscriber id same as readergroup id or is it chosen by the user?\nif its former, then it doesnt matter if two users were attempting to perform this action simultaneously.\nHowever, if its implicit and handled at a readergroup level,", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505432383", "createdAt": "2020-10-15T10:25:02Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NTk5Mw=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMjkyOQ==", "bodyText": "remove is different from above case. since we are not doing conditional remove, but is predicated on the subscriber's name. it should perhaps not throw the exception.\nin fact i would say that this should not even be a response code for remove api from idempotent case's perspective.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505432929", "createdAt": "2020-10-15T10:25:58Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjEzOQ=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNjY2OA==", "bodyText": "the response structure for this api is a defined as a new protobuf message. so you have the opportunity to include a status and a response list.\nand you have pointed out an important thing -- that the pattern for streamnotfound is not consistently followed across apis stream apis.. please create a new issue in backlog for these (unrelated to current change set) to include a status with each such api where we can set the appropriate status or make use of grpc status runtime to indicate such failures..", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505436668", "createdAt": "2020-10-15T10:32:15Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -525,6 +525,116 @@ private RetryAndThrowConditionally createRetryConfig(final ControllerImplConfig\n         });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> addSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"addSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<AddSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<AddSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"addSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"addSubscriber\", scope, streamName)\n+                    .addSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_EXISTS:\n+                    log.warn(requestId, \"Subscriber {} for stream {}/{} already exists {}.\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully updated stream: {}\", streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"addSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"addSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> removeSubscriber(String scope, String streamName, String subscriber) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(subscriber, \"subscriberId\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"removeSubscriber\", subscriber, requestId);\n+\n+        final CompletableFuture<RemoveSubscriberStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<RemoveSubscriberStatus> callback = new RPCAsyncCallback<>(requestId, \"removeSubscriber\", scope, streamName, subscriber);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"removeSubscriber\", scope, streamName)\n+                    .removeSubscriber(ModelHelper.decode(scope, streamName, subscriber), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to update stream: {}\", streamName);\n+                    throw new ControllerFailureException(\"Failed to add subscriber: \" + subscriber);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case STREAM_NOT_FOUND:\n+                    log.warn(requestId, \"Stream does not exist: {}\", streamName);\n+                    throw new IllegalArgumentException(\"Stream does not exist: \" + streamName);\n+                case SUBSCRIBER_NOT_FOUND:\n+                    log.warn(requestId, \"Subscriber does not exist: {} for stream {}/{}\", subscriber, scope, streamName);\n+                    throw new IllegalArgumentException(\"Subscriber does not exist: \" + subscriber);\n+                case SUCCESS:\n+                    log.info(requestId, \"Successfully removed subscriber {} from stream: {}/{}\", subscriber, scope, streamName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status adding subscriber \" + subscriber\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"removeSubscriber {} for stream {}/{} failed: \", subscriber, scope, streamName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"removeSubscriber\", traceId, subscriber, requestId);\n+        });\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String streamName) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Preconditions.checkNotNull(scope, \"scopeName\");\n+        Preconditions.checkNotNull(streamName, \"stream\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"getSubscribersForStream\", streamName);\n+        final CompletableFuture<StreamSubscribers> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<StreamSubscribers> callback = new RPCAsyncCallback<>(requestId, \"getSubscribersForStream\", scope, streamName);\n+            client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS).getSubscribersForStream(ModelHelper.createStreamInfo(scope, streamName), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(subscribers -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM1NjcwMg=="}, "originalCommit": {"oid": "5509932287a56919c52c51a17b893a2ec10ed01c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNzMwOA==", "bodyText": "also add \"throws\" javadoc for exceptions that can be thrown from this if user needs to handle those exceptions. for instance - stream cut not valid should be propagated to the user.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505437308", "createdAt": "2020-10-15T10:33:20Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -118,6 +118,46 @@\n      */\n     CompletableFuture<Boolean> updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig);\n \n+    /**\n+     * API to add a Subscriber to the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber.\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> addSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * API to remove a Subscriber from list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> removeSubscriber(final String scope, final String streamName, final String subscriber);\n+\n+    /**\n+     * Get list of Subscribers for the Stream.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @return List of StreamSubscribers\n+     */\n+    CompletableFuture<List<String>> getSubscribersForStream(final String scope, final String streamName);\n+\n+    /**\n+     * API to update the truncation StreamCut for a particular Subscriber on Controller.\n+     * Used when Stream has Consumption Based Retention Policy configured.\n+     * @param scope Scope name\n+     * @param streamName Stream name\n+     * @param subscriber Name/Id that uniquely identifies a Stream Subscriber..\n+     * @param streamCut StreamCut at which Stream can be Truncated for a Consumption based retention policy\n+     * @return A future which will throw if the operation fails, otherwise returning a boolean to\n+     *         indicate that the subscriber was updated in Stream Metadata.\n+     */\n+    CompletableFuture<Boolean> updateTruncationStreamCut(final String scope, final String streamName, final String subscriber, final StreamCut streamCut);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzOTkyNQ==", "bodyText": "why return empty subscriber list when there is an exception?", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505439925", "createdAt": "2020-10-15T10:38:06Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MDgxMw==", "bodyText": "we should also make use of \"greater\" than property to see if the new streamcut is strictly greater than equal to previously reported truncation streamcut for the given subscriber so that it always move ahead.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505440813", "createdAt": "2020-10-15T10:39:38Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,184 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. if SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor);\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof StoreException.DataNotFoundException) {\n+                           return AddSubscriberStatus.Status.STREAM_NOT_FOUND;\n+                        } else if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<RemoveSubscriberStatus.Status> removeSubscriber(String scope, String stream,\n+                                                                      String subscriber,\n+                                                                      OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(RemoveSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.removeSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> RemoveSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return RemoveSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return RemoveSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<List<String>> getSubscribersForStream(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"getSubscribersForStream\", scope, stream);\n+        final List<String> emptySubscribersList = Collections.emptyList();\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                  if (!exists) {\n+                    // 1. if Stream does not exist return empty list\n+                    return CompletableFuture.completedFuture(emptySubscribersList);\n+                  }\n+                  // 2. get subscribers data\n+                  return Futures.exceptionallyExpecting(streamMetadataStore.getAllSubscribers(scope, stream, context, executor),\n+                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                        //3. if SubscribersRecord does not exist return empty list\n+                        if (subscribersData == null) {\n+                            return CompletableFuture.completedFuture(emptySubscribersList);\n+                        }\n+                        return CompletableFuture.completedFuture(subscribersData.keySet().stream().collect(Collectors.toList()));\n+                    }).exceptionally(ex -> {\n+                              log.warn(requestId, \"Exception thrown in trying to get list of Stream subscribers. {}\",\n+                                      ex.getMessage());\n+                              Throwable cause = Exceptions.unwrap(ex);\n+                              if (cause instanceof TimeoutException) {\n+                                  throw new CompletionException(cause);\n+                              } else {\n+                                  log.warn(requestId, \"getSubscribersForStream failed due to {}\", cause);\n+                                  return emptySubscribersList;\n+                              }\n+                          });\n+                  }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateTruncationStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateTruncationStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    // 1. check Stream exists\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                    }\n+                    // 2. check if StreamCut is valid\n+                    return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0MzY5OQ==", "bodyText": "although this approach is fine, but should we put the list of subscribers in the stream metadata table itself? I mean in principle it would be better if we avoid creating an additional table segment for each stream.\nfor example:\nkey: subscribers value: List\nkey: subscriber- value: \nthat way we avoid creating a separate table. and with this model, we dont necessarily need to iterate over entries in a separate table.. instead use two queries - 1 to get list of subscribers and then the streamcut for each subscriber while performing the truncation.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505443699", "createdAt": "2020-10-15T10:45:00Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PravegaTablesStream.java", "diffHunk": "@@ -212,10 +224,12 @@ private String getWritersTableName(String id) {\n             String metadataTable = getMetadataTableName(id);\n             String epochWithTxnTable = getEpochsWithTransactionsTableName(id);\n             String writersPositionsTable = getWritersTableName(id);\n+            String subscribersTable = getSubscribersTableName(id);\n             return CompletableFuture.allOf(storeHelper.createTable(metadataTable),\n-                    storeHelper.createTable(epochWithTxnTable), storeHelper.createTable(writersPositionsTable))\n-                                    .thenAccept(v -> log.debug(\"stream {}/{} metadata tables {}, {} & {} created\", getScope(), getName(), metadataTable,\n-                                            epochWithTxnTable, writersPositionsTable));\n+                    storeHelper.createTable(epochWithTxnTable), storeHelper.createTable(writersPositionsTable),\n+                    storeHelper.createTable(subscribersTable))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0NTU0NA==", "bodyText": "Please throw NotImplementedException or UnsupportedException", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505445544", "createdAt": "2020-10-15T10:48:18Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "diffHunk": "@@ -237,7 +241,32 @@\n         return getId().thenCompose(id -> store.getCachedData(creationPath, id, x -> BitConverter.readLong(x, 0))\n                 .thenApply(VersionedMetadata::getObject));\n     }\n-    \n+\n+    @Override\n+    public CompletableFuture<Void> createSubscriber(String subscriber) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ0NTYyNg==", "bodyText": "same for all apis in this class", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r505445626", "createdAt": "2020-10-15T10:48:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/ZKStream.java", "diffHunk": "@@ -237,7 +241,32 @@\n         return getId().thenCompose(id -> store.getCachedData(creationPath, id, x -> BitConverter.readLong(x, 0))\n                 .thenApply(VersionedMetadata::getObject));\n     }\n-    \n+\n+    @Override\n+    public CompletableFuture<Void> createSubscriber(String subscriber) {\n+        return null;\n+    }\n+\n+    @Override\n+    public CompletableFuture<VersionedMetadata<StreamSubscriber>> getSubscriber(String subscriber) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "effae36bd9829f1a753651835dc5bb4dec156d42"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "823704278d6c6b4e940451b8664a2b3c0bd826af", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/823704278d6c6b4e940451b8664a2b3c0bd826af", "committedDate": "2020-10-15T11:27:02Z", "message": "test fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8836451842d78227808ca3e394657605adb99a7c", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/8836451842d78227808ca3e394657605adb99a7c", "committedDate": "2020-10-16T06:15:36Z", "message": "review comments fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5684aa9bdb9791d1a1cb01e270f622d73f3f092", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/b5684aa9bdb9791d1a1cb01e270f622d73f3f092", "committedDate": "2020-10-16T06:15:57Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46a84150a9fe9a23ced359e1a5de643045237f56", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/46a84150a9fe9a23ced359e1a5de643045237f56", "committedDate": "2020-10-16T07:57:11Z", "message": "test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45c3fdc9218fb10f21926a2976928d75906e382e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/45c3fdc9218fb10f21926a2976928d75906e382e", "committedDate": "2020-10-16T15:51:19Z", "message": "review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aeeb77797b09bfa4bc927e94831a22519fe39304", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/aeeb77797b09bfa4bc927e94831a22519fe39304", "committedDate": "2020-10-18T17:43:30Z", "message": "change in metadata store for subscribers\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "029baace0a6d6736e5fc5b8935ccde17a0ec20cd", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/029baace0a6d6736e5fc5b8935ccde17a0ec20cd", "committedDate": "2020-10-18T17:43:51Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d017febc8eb30b8519f898b8666cbd487a77ed9", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/4d017febc8eb30b8519f898b8666cbd487a77ed9", "committedDate": "2020-10-19T13:09:47Z", "message": "code review changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d516a49a1ab31559fcf91016f698a248cab0a9c", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/6d516a49a1ab31559fcf91016f698a248cab0a9c", "committedDate": "2020-10-19T13:20:06Z", "message": "fixed ZKStream\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "569638a58f636921f4df3472fa192184d5119840", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/569638a58f636921f4df3472fa192184d5119840", "committedDate": "2020-10-19T13:33:23Z", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad1dca5cf0c3d81b6a9802158be56ccb0e1ec0bf", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/ad1dca5cf0c3d81b6a9802158be56ccb0e1ec0bf", "committedDate": "2020-10-19T13:35:13Z", "message": "checkstyle\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24dbe85714d4ca3ae894c171ef480877649e03d1", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/24dbe85714d4ca3ae894c171ef480877649e03d1", "committedDate": "2020-10-27T04:48:17Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff0d5cfec664cf167f283b7e51b2c1ba0e7df60a", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/ff0d5cfec664cf167f283b7e51b2c1ba0e7df60a", "committedDate": "2020-10-22T04:44:28Z", "message": "Merge branch 'master' into issue-5109-subscriber-rg"}, "afterCommit": {"oid": "24dbe85714d4ca3ae894c171ef480877649e03d1", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/24dbe85714d4ca3ae894c171ef480877649e03d1", "committedDate": "2020-10-27T04:48:17Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "077b6ca52732d08994e2c4f4c2731de3c841706e", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/077b6ca52732d08994e2c4f4c2731de3c841706e", "committedDate": "2020-10-27T13:28:34Z", "message": "code review changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4Mjk4Mzk5", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-518298399", "createdAt": "2020-10-28T03:25:51Z", "commit": {"oid": "6e691c5135b5d42685265095ea00b726a87bb67f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6e066829a2af649d5e7697df43d9b21e9a28471", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/a6e066829a2af649d5e7697df43d9b21e9a28471", "committedDate": "2020-10-28T08:46:49Z", "message": "test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8ea150b0f5d3aaa29db18dc2cde7d0b6c9e23e6", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e8ea150b0f5d3aaa29db18dc2cde7d0b6c9e23e6", "committedDate": "2020-10-28T08:47:46Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6e691c5135b5d42685265095ea00b726a87bb67f", "author": {"user": {"login": "shiveshr", "name": "shivesh ranjan"}}, "url": "https://github.com/pravega/pravega/commit/6e691c5135b5d42685265095ea00b726a87bb67f", "committedDate": "2020-10-28T03:18:53Z", "message": "Merge branch 'master' into issue-5109-subscriber-rg"}, "afterCommit": {"oid": "e8ea150b0f5d3aaa29db18dc2cde7d0b6c9e23e6", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e8ea150b0f5d3aaa29db18dc2cde7d0b6c9e23e6", "committedDate": "2020-10-28T08:47:46Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "126b59c542667ced7cb858624c77e4fbf9b2202f", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/126b59c542667ced7cb858624c77e4fbf9b2202f", "committedDate": "2020-10-28T09:20:22Z", "message": "tests fixed\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fad11d00e71200a9586c4d5462d5aae76ec73c5", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/5fad11d00e71200a9586c4d5462d5aae76ec73c5", "committedDate": "2020-10-28T09:56:33Z", "message": "test case fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "620bbd7fe32186a1b8d920d0ee3ef5e6ac227bc8", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/620bbd7fe32186a1b8d920d0ee3ef5e6ac227bc8", "committedDate": "2020-10-29T05:59:56Z", "message": "tests fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f656e88700c79f1fac2fa8efd1f980fa779728b", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/4f656e88700c79f1fac2fa8efd1f980fa779728b", "committedDate": "2020-10-29T06:00:22Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "4f656e88700c79f1fac2fa8efd1f980fa779728b", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/4f656e88700c79f1fac2fa8efd1f980fa779728b", "committedDate": "2020-10-29T06:00:22Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-5109-subscriber-rg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e48f7bd405ba9463f85d08e8e496b2dbae2d8063", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/e48f7bd405ba9463f85d08e8e496b2dbae2d8063", "committedDate": "2020-10-29T06:54:44Z", "message": "code coverage\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf4a64eaa88d46a03710b72991f3a63bf66a5993", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/bf4a64eaa88d46a03710b72991f3a63bf66a5993", "committedDate": "2020-10-29T09:44:11Z", "message": "test fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/16e95c00f9de8287956c63decd66d21b59cc83e2", "committedDate": "2020-10-29T09:58:40Z", "message": "minor change\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzM2MTQ3", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-520336147", "createdAt": "2020-10-30T02:22:22Z", "commit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoyMjoyMlrOHq3yJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoyMjoyMlrOHq3yJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxNjE5OQ==", "bodyText": "we dont necessarily need a public method here. this can be done as part of precondition check for updating a subscriber streamcut internally. that will allow for get and update post validation.\notherwise you are validating. and then refetchng subscriber's record and updating it which may mean the condition may have changed.\nthough this method is slightly unoptimized as it is validating and then computing streamcut span, which can both be done in a single pass followed by comparison.\nalso, we can compute spans for both stream cuts in parallel.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514716199", "createdAt": "2020-10-30T02:22:22Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/store/stream/PersistentStreamBase.java", "diffHunk": "@@ -671,6 +672,20 @@ private long findSegmentSplitsMerges(List<StreamSegmentRecord> referenceSegments\n                       });\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> isStreamCutValidForTruncation(final Map<Long, Long> streamCut, Map<Long, Long> previousStreamCut) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzM3NTQ3", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-520337547", "createdAt": "2020-10-30T02:26:57Z", "commit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoyNjo1N1rOHq4DLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoyNjo1N1rOHq4DLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyMDU1OA==", "bodyText": "here you are fetching subscriber record, checking its validity and then updating the subscriber record but the update is not predicated on previous subscriber record that you had fetched. this could mean if the  subscriber record was updated while you performed the check, it could get overwritten incorrectly.\nthis check should be done in the storage layer where you do a get followed by a check and then conditional update using the entity tag from the previous record.", "url": "https://github.com/pravega/pravega/pull/5204#discussion_r514720558", "createdAt": "2020-10-30T02:26:57Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -275,6 +282,205 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                                 });\n     }\n \n+    /**\n+     * Add a subscriber to stream metadata.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param newSubscriber  Id of the ReaderGroup to be added as subscriber\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<AddSubscriberStatus.Status> addSubscriber(String scope, String stream,\n+                                                                     String newSubscriber,\n+                                                                     OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"addSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+        .thenCompose(exists -> {\n+            // 1. check Stream exists\n+            if (!exists) {\n+                return CompletableFuture.completedFuture(AddSubscriberStatus.Status.STREAM_NOT_FOUND);\n+            } else {\n+                // 2. get subscribers data\n+                return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, newSubscriber, context, executor),\n+                     e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                    .thenCompose(subscribersData -> {\n+                    //4. If SubscriberRecord does not exist create one...\n+                    if (subscribersData == null) {\n+                        return streamMetadataStore.createSubscriber(scope, stream, newSubscriber, context, executor)\n+                                .thenApply(v -> AddSubscriberStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(AddSubscriberStatus.Status.SUBSCRIBER_EXISTS);\n+                    }\n+                    })\n+                    .exceptionally(ex -> {\n+                        log.warn(requestId, \"Exception thrown in trying to add subscriber {}\",\n+                                    ex.getMessage());\n+                        Throwable cause = Exceptions.unwrap(ex);\n+                        if (cause instanceof TimeoutException) {\n+                           throw new CompletionException(cause);\n+                        } else {\n+                           log.warn(requestId, \"Add subscriber {} failed due to {}\", newSubscriber, cause);\n+                           return AddSubscriberStatus.Status.FAILURE;\n+                        }\n+                    });\n+            }\n+        }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Id of the ReaderGroup to be added as subscriber.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<DeleteSubscriberStatus.Status> deleteSubscriber(String scope, String stream,\n+                                                                             String subscriber,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"removeSubscriber\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+           .thenCompose(exists -> {\n+               // 1. check Stream exists\n+               if (!exists) {\n+                   return CompletableFuture.completedFuture(DeleteSubscriberStatus.Status.STREAM_NOT_FOUND);\n+               }\n+               // 2. remove subscriber\n+               return streamMetadataStore.deleteSubscriber(scope, stream, subscriber, context, executor)\n+                       .thenApply(x -> DeleteSubscriberStatus.Status.SUCCESS)\n+                       .exceptionally(ex -> {\n+                           log.warn(requestId, \"Exception thrown when trying to remove subscriber from stream {}\", ex.getMessage());\n+                           Throwable cause = Exceptions.unwrap(ex);\n+                           if (cause instanceof StoreException.DataNotFoundException) {\n+                               return DeleteSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND;\n+                           } else if (cause instanceof TimeoutException) {\n+                               throw new CompletionException(cause);\n+                           } else {\n+                               log.warn(requestId, \"Remove subscriber from stream failed due to \", cause);\n+                               return DeleteSubscriberStatus.Status.FAILURE;\n+                           }\n+                       });\n+           }), e -> Exceptions.unwrap(e) instanceof RetryableException, SUBSCRIBER_OPERATION_RETRIES, executor);\n+    }\n+\n+\n+    /**\n+     * Get list of  subscribers for Stream.\n+     * Needed only for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+\n+    public CompletableFuture<SubscribersResponse> listSubscribers(String scope, String stream, OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"listSubscribers\", scope, stream);\n+        return streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                    if (!exists) {\n+                        return CompletableFuture.completedFuture(SubscribersResponse.newBuilder()\n+                                .setStatus(SubscribersResponse.Status.STREAM_NOT_FOUND).build());\n+                    }\n+                  // 2. get subscribers\n+                  return streamMetadataStore.listSubscribers(scope, stream, context, executor)\n+                          .thenApply(result -> SubscribersResponse.newBuilder()\n+                                     .setStatus(SubscribersResponse.Status.SUCCESS)\n+                                     .addAllSubscribers(result).build())\n+                            .exceptionally(ex -> {\n+                                log.warn(requestId, \"Exception trying to get list of Stream subscribers. {}\",\n+                                        ex.getMessage());\n+                                Throwable cause = Exceptions.unwrap(ex);\n+                                if (cause instanceof TimeoutException) {\n+                                    throw new CompletionException(cause);\n+                                } else {\n+                                    log.warn(requestId, \"listSubscribers failed due to {}\", ex.getMessage());\n+                                    return SubscribersResponse.newBuilder()\n+                                            .setStatus(SubscribersResponse.Status.FAILURE).build();\n+                                }\n+                            });\n+                });\n+\n+    }\n+\n+    /**\n+     * Remove a subscriber from subscribers' metadata.\n+     * Needed for Consumption based retention.\n+     * @param scope      scope.\n+     * @param stream     stream name.\n+     * @param subscriber  Stream Subscriber publishing the StreamCut.\n+     * @param truncationStreamCut  Truncation StreamCut.\n+     * @param contextOpt optional context\n+     * @return update status.\n+     */\n+    public CompletableFuture<UpdateSubscriberStatus.Status> updateSubscriberStreamCut(String scope, String stream,\n+                                                                             String subscriber, ImmutableMap<Long, Long> truncationStreamCut,\n+                                                                             OperationContext contextOpt) {\n+        final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateSubscriberStreamCut\", scope, stream);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.checkStreamExists(scope, stream)\n+                .thenCompose(exists -> {\n+                            // 1. check Stream exists\n+                            if (!exists) {\n+                                return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAM_NOT_FOUND);\n+                            }\n+                            // 2. check if StreamCut is valid\n+                            return Futures.exceptionallyExpecting(streamMetadataStore.getSubscriber(scope, stream, subscriber, contextOpt, executor),\n+                                    e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, null)\n+                                    .thenCompose(subscriberRecord -> {\n+                                        if (subscriberRecord == null) {\n+                                            return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.SUBSCRIBER_NOT_FOUND);\n+                                        } else {\n+                                            if (subscriberRecord.getObject().getTruncationStreamCut().isEmpty()) {\n+                                                return streamMetadataStore.isStreamCutValid(scope, stream, truncationStreamCut, context, executor)\n+                                                        .thenCompose( isValid -> {\n+                                                         if (isValid) {\n+                                                           return updateStreamCut(scope, stream, subscriber, truncationStreamCut, context, requestId);\n+                                                         } else {\n+                                                           return CompletableFuture.completedFuture(UpdateSubscriberStatus.Status.STREAMCUT_NOT_VALID);\n+                                                         }\n+                                                 });\n+                                            } else {\n+                                                return streamMetadataStore.isStreamCutValidForTruncation(scope, stream, truncationStreamCut,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "originalPosition": 214}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzQ0ODQy", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-520344842", "createdAt": "2020-10-30T02:52:50Z", "commit": {"oid": "16e95c00f9de8287956c63decd66d21b59cc83e2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfc8c858ef6c5b8ca2a623b0c3862ad9340c6efe", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/bfc8c858ef6c5b8ca2a623b0c3862ad9340c6efe", "committedDate": "2020-10-30T04:26:24Z", "message": "review fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a031a9e49d51ba0a6dcc57be635c5e1fc295aab", "author": {"user": {"login": "pbelgundi", "name": "Prajakta Belgundi"}}, "url": "https://github.com/pravega/pravega/commit/9a031a9e49d51ba0a6dcc57be635c5e1fc295aab", "committedDate": "2020-10-30T04:52:04Z", "message": "testfix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDA2NTA1", "url": "https://github.com/pravega/pravega/pull/5204#pullrequestreview-520406505", "createdAt": "2020-10-30T06:38:23Z", "commit": {"oid": "9a031a9e49d51ba0a6dcc57be635c5e1fc295aab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3882, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}