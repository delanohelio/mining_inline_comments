{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NTI5Mzkz", "number": 5193, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMjozMToxMlrOEkQzKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMToxMzo1MVrOEowmQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDU5NDMzOnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/rolling/RollingStorage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMjozMToxMlrOHTGaAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMjozMToxMlrOHTGaAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4OTk1NQ==", "bodyText": "Rolling storage is implemented using concept of chunks and a header file that points to them.\nProper implementation will involve following steps\n\nFind name of the header file (see functions in nameutils)\nDeserialize the header file\nFind out list of chunks\n For each chunk in list { \n          parse chunk name to extract offset, \n          using offset+new segment name generate new chunk name\n          rename by calling baseStorage.rename\n          update name in the header data structure\n}\nserialize updated header (so that it points to the recently renamed chunks)\nnow rename the header itself to new name.\n\n\nJust calling this.baseStorage.rename won't work because there is no such segment in base segment.\nJust renaming the header won't work because then we are still pointing to the old chunks. When new segment is created with old name, it will try to create a chunk at offset 0 which will be already existing.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r489789955", "createdAt": "2020-09-16T22:31:12Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/rolling/RollingStorage.java", "diffHunk": "@@ -442,6 +442,11 @@ public void concat(SegmentHandle targetHandle, long targetOffset, String sourceS\n         LoggerHelpers.traceLeave(log, \"concat\", traceId, target, targetOffset, sourceSegment);\n     }\n \n+    @Override\n+    public void rename(SegmentHandle handle, String newName) throws StreamSegmentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTc2ODg5OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTowOTo0NlrOHVVRaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjo0MTo1MFrOHVsEiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMDY2NA==", "bodyText": "This is an async method. And so is getStreamSegmentInfo.\nPlease rewrite this entire method to be aynchronous:\n\npublic CompletableFuture<Void> copySegment(...) (remove the throws Exception).\nUse CompletableFuture composition (thenCompose, thenApply, etc.) to chain your futures together.\nUse Futures.loop\nreturn the resulting CompletableFuture.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492130664", "createdAt": "2020-09-21T15:09:46Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +62,20 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public void copySegment(Storage storage, String sourceSegment, String targetSegment)\n+            throws Exception {\n+        storage.create(targetSegment, TIMEOUT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUwNDIwMQ==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492504201", "createdAt": "2020-09-22T06:41:50Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +62,20 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public void copySegment(Storage storage, String sourceSegment, String targetSegment)\n+            throws Exception {\n+        storage.create(targetSegment, TIMEOUT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMDY2NA=="}, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTc3MDQyOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNToxMDowMFrOHVVScA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjo0MTozN1rOHVsEHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMDkyOA==", "bodyText": "This buffer is too small. I suggest 4/8/16MB or so.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492130928", "createdAt": "2020-09-21T15:10:00Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -17,17 +17,21 @@\n import io.pravega.segmentstore.server.SegmentContainerFactory;\n import io.pravega.segmentstore.server.WriterFactory;\n import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.storage.Storage;\n import io.pravega.segmentstore.storage.StorageFactory;\n import io.pravega.segmentstore.server.SegmentContainerExtension;\n import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n \n+import java.io.ByteArrayInputStream;\n import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ScheduledExecutorService;\n \n @Slf4j\n public class DebugStreamSegmentContainer extends StreamSegmentContainer implements DebugSegmentContainer {\n     private static final Duration TIMEOUT = Duration.ofMinutes(1);\n+    private static final int BUFFER_SIZE = 8 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUwNDA5Mg==", "bodyText": "made it to 8MB.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492504092", "createdAt": "2020-09-22T06:41:37Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -17,17 +17,21 @@\n import io.pravega.segmentstore.server.SegmentContainerFactory;\n import io.pravega.segmentstore.server.WriterFactory;\n import io.pravega.segmentstore.server.attributes.AttributeIndexFactory;\n+import io.pravega.segmentstore.storage.Storage;\n import io.pravega.segmentstore.storage.StorageFactory;\n import io.pravega.segmentstore.server.SegmentContainerExtension;\n import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n \n+import java.io.ByteArrayInputStream;\n import java.time.Duration;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ScheduledExecutorService;\n \n @Slf4j\n public class DebugStreamSegmentContainer extends StreamSegmentContainer implements DebugSegmentContainer {\n     private static final Duration TIMEOUT = Duration.ofMinutes(1);\n+    private static final int BUFFER_SIZE = 8 * 1024;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMDkyOA=="}, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTc3NDI1OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNToxMDozM1rOHVVVHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjo0NjoxM1rOHVsLag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMTYxNA==", "bodyText": "Here, you invoke openRead on every loop call. This is highly inefficient. Invoke it once outside of the loop and then reuse the returned handle.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492131614", "createdAt": "2020-09-21T15:10:33Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +62,20 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public void copySegment(Storage storage, String sourceSegment, String targetSegment)\n+            throws Exception {\n+        storage.create(targetSegment, TIMEOUT);\n+        val info = storage.getStreamSegmentInfo(sourceSegment, TIMEOUT);\n+        int bytesToRead = (int) info.get().getLength();\n+        int offset = 0;\n+        while (bytesToRead > 0) {\n+            byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead)];\n+            int size = storage.read(storage.openRead(sourceSegment).join(), offset, buffer, 0, buffer.length, TIMEOUT).join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMjQxMg==", "bodyText": "also verify that size > 0. If it's 0, then you risk getting into an infinite loop.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492132412", "createdAt": "2020-09-21T15:11:11Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +62,20 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public void copySegment(Storage storage, String sourceSegment, String targetSegment)\n+            throws Exception {\n+        storage.create(targetSegment, TIMEOUT);\n+        val info = storage.getStreamSegmentInfo(sourceSegment, TIMEOUT);\n+        int bytesToRead = (int) info.get().getLength();\n+        int offset = 0;\n+        while (bytesToRead > 0) {\n+            byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead)];\n+            int size = storage.read(storage.openRead(sourceSegment).join(), offset, buffer, 0, buffer.length, TIMEOUT).join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMTYxNA=="}, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUwNTk2Mg==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492505962", "createdAt": "2020-09-22T06:46:13Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +62,20 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public void copySegment(Storage storage, String sourceSegment, String targetSegment)\n+            throws Exception {\n+        storage.create(targetSegment, TIMEOUT);\n+        val info = storage.getStreamSegmentInfo(sourceSegment, TIMEOUT);\n+        int bytesToRead = (int) info.get().getLength();\n+        int offset = 0;\n+        while (bytesToRead > 0) {\n+            byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead)];\n+            int size = storage.read(storage.openRead(sourceSegment).join(), offset, buffer, 0, buffer.length, TIMEOUT).join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMTYxNA=="}, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTc4MDM0OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNToxMToyN1rOHVVZMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjo0NjoyMFrOHVsLlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMjY1OA==", "bodyText": "openWrite outside of the loop.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492132658", "createdAt": "2020-09-21T15:11:27Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +62,20 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public void copySegment(Storage storage, String sourceSegment, String targetSegment)\n+            throws Exception {\n+        storage.create(targetSegment, TIMEOUT);\n+        val info = storage.getStreamSegmentInfo(sourceSegment, TIMEOUT);\n+        int bytesToRead = (int) info.get().getLength();\n+        int offset = 0;\n+        while (bytesToRead > 0) {\n+            byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead)];\n+            int size = storage.read(storage.openRead(sourceSegment).join(), offset, buffer, 0, buffer.length, TIMEOUT).join();\n+            bytesToRead -= size;\n+            storage.write(storage.openWrite(targetSegment).join(), offset, new ByteArrayInputStream(buffer, 0, size), size, TIMEOUT).join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUwNjAwNw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492506007", "createdAt": "2020-09-22T06:46:20Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +62,20 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public void copySegment(Storage storage, String sourceSegment, String targetSegment)\n+            throws Exception {\n+        storage.create(targetSegment, TIMEOUT);\n+        val info = storage.getStreamSegmentInfo(sourceSegment, TIMEOUT);\n+        int bytesToRead = (int) info.get().getLength();\n+        int offset = 0;\n+        while (bytesToRead > 0) {\n+            byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead)];\n+            int size = storage.read(storage.openRead(sourceSegment).join(), offset, buffer, 0, buffer.length, TIMEOUT).join();\n+            bytesToRead -= size;\n+            storage.write(storage.openWrite(targetSegment).join(), offset, new ByteArrayInputStream(buffer, 0, size), size, TIMEOUT).join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzMjY1OA=="}, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTc5MDg2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/DebugSegmentContainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNToxMzowN1rOHVVgKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDoxODoxNVrOHVg8Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzNDQ0Mw==", "bodyText": "Have we thought whether it would be better to put copySegment into the Storage interface? That way we could take advantage of LTS-specific copy features (so that we do not need to read everything and write it back). @sachin-j-joshi what do you think?", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492134443", "createdAt": "2020-09-21T15:13:07Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/DebugSegmentContainer.java", "diffHunk": "@@ -25,4 +27,13 @@\n      * completed. If the operation failed, the future will be failed with the causing exception.\n      */\n     CompletableFuture<Void> registerSegment(String streamSegmentName, long length, boolean isSealed);\n+\n+    /**\n+     * Creates a segment with target segment name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @throws Exception                In case of an exception occurred while execution.\n+     */\n+    void copySegment(Storage storage, String sourceSegment, String targetSegment) throws Exception;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyMTc5OA==", "bodyText": "Ideally we want rename method implemented in Storage. But that also means implementing  it for RollingStorage with all its corner cases.\nGiven that the rename functionality is needed only in DR tool and only once for a container metadata segment. I suggested this short term work around of copying that segment.\nIn near future we'll implement rename in Storage. But for now I think this is good enough to unblock us.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r492321798", "createdAt": "2020-09-21T20:18:15Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/DebugSegmentContainer.java", "diffHunk": "@@ -25,4 +27,13 @@\n      * completed. If the operation failed, the future will be failed with the causing exception.\n      */\n     CompletableFuture<Void> registerSegment(String streamSegmentName, long length, boolean isSealed);\n+\n+    /**\n+     * Creates a segment with target segment name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @throws Exception                In case of an exception occurred while execution.\n+     */\n+    void copySegment(Storage storage, String sourceSegment, String targetSegment) throws Exception;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzNDQ0Mw=="}, "originalCommit": {"oid": "6f9d360545a3986f03d6374db50b98154ec0a7c5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTc4NjI4OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoxNToxOVrOHWOPSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDo1NDozN1rOHWWU7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDAwOA==", "bodyText": "Need to get rid of these joins as well.\nIt should look something like below .\nAlso you don't need to openWrite again after create.\nreturn storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n           return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n               return storage.openRead(sourceSegment).thenCompose(sourceHandle  ->  {\n                      offset = 0;\n                      return Futures.loop( .....\n              }\n        })\n}})", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r493064008", "createdAt": "2020-09-22T22:15:19Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +66,27 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        val targetHandle = storage.create(targetSegment, TIMEOUT).thenCompose(v -> storage.openWrite(targetSegment)).join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f745e9daa7477ee0ca8e5220a7b100532302e8"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NjUyNw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r493196527", "createdAt": "2020-09-23T04:54:37Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainer.java", "diffHunk": "@@ -58,4 +66,27 @@\n         ArrayView segmentInfo = MetadataStore.SegmentInfo.recoveredSegment(streamSegmentName, length, isSealed);\n         return metadataStore.createSegment(streamSegmentName, segmentInfo, new TimeoutTimer(TIMEOUT));\n     }\n+\n+    @Override\n+    public CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        val targetHandle = storage.create(targetSegment, TIMEOUT).thenCompose(v -> storage.openWrite(targetSegment)).join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDAwOA=="}, "originalCommit": {"oid": "a4f745e9daa7477ee0ca8e5220a7b100532302e8"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTgwNTQxOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainerTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyMzoxMVrOHWOaxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNToxOToxMlrOHWWuqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2Njk1MQ==", "bodyText": "Does this need to be in loop?", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r493066951", "createdAt": "2020-09-22T22:23:11Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainerTests.java", "diffHunk": "@@ -247,6 +251,85 @@ public void testEndToEnd() throws Exception {\n         }\n     }\n \n+    /**\n+     * The test creates a segment and then writes some data to it. The method under the test copies the contents of the\n+     * segment to a segment with a different name. At the end, it is verified that the new segment has the accurate\n+     * contents from the first one.\n+     */\n+    @Test\n+    public void testCopySegment() throws Exception {\n+        // Create a storage.\n+        @Cleanup\n+        val baseStorage =  new InMemoryStorage();\n+        @Cleanup\n+        val s = new AsyncStorageWrapper(new RollingStorage(baseStorage, new SegmentRollingPolicy(1)), executorService());\n+        s.initialize(1);\n+        log.info(\"Created a storage instance\");\n+\n+        String sourceSegmentName = \"segment-\" + RANDOM.nextInt();\n+        String targetSegmentName = \"segment-\" + RANDOM.nextInt();\n+\n+        // Create source segment\n+        s.create(sourceSegmentName, TIMEOUT).join();\n+        val handle = s.openWrite(sourceSegmentName).join();\n+\n+        // do some writing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f745e9daa7477ee0ca8e5220a7b100532302e8"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIwMzExMw==", "bodyText": "Removed loop. Writing 10 MB data at once.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r493203113", "createdAt": "2020-09-23T05:19:12Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainerTests.java", "diffHunk": "@@ -247,6 +251,85 @@ public void testEndToEnd() throws Exception {\n         }\n     }\n \n+    /**\n+     * The test creates a segment and then writes some data to it. The method under the test copies the contents of the\n+     * segment to a segment with a different name. At the end, it is verified that the new segment has the accurate\n+     * contents from the first one.\n+     */\n+    @Test\n+    public void testCopySegment() throws Exception {\n+        // Create a storage.\n+        @Cleanup\n+        val baseStorage =  new InMemoryStorage();\n+        @Cleanup\n+        val s = new AsyncStorageWrapper(new RollingStorage(baseStorage, new SegmentRollingPolicy(1)), executorService());\n+        s.initialize(1);\n+        log.info(\"Created a storage instance\");\n+\n+        String sourceSegmentName = \"segment-\" + RANDOM.nextInt();\n+        String targetSegmentName = \"segment-\" + RANDOM.nextInt();\n+\n+        // Create source segment\n+        s.create(sourceSegmentName, TIMEOUT).join();\n+        val handle = s.openWrite(sourceSegmentName).join();\n+\n+        // do some writing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2Njk1MQ=="}, "originalCommit": {"oid": "a4f745e9daa7477ee0ca8e5220a7b100532302e8"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTgwOTQ3OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainerTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyNTowMlrOHWOdTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNToxOTo0MVrOHWWvSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NzU5Ng==", "bodyText": "Does this need to be in loop?", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r493067596", "createdAt": "2020-09-22T22:25:02Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainerTests.java", "diffHunk": "@@ -247,6 +251,85 @@ public void testEndToEnd() throws Exception {\n         }\n     }\n \n+    /**\n+     * The test creates a segment and then writes some data to it. The method under the test copies the contents of the\n+     * segment to a segment with a different name. At the end, it is verified that the new segment has the accurate\n+     * contents from the first one.\n+     */\n+    @Test\n+    public void testCopySegment() throws Exception {\n+        // Create a storage.\n+        @Cleanup\n+        val baseStorage =  new InMemoryStorage();\n+        @Cleanup\n+        val s = new AsyncStorageWrapper(new RollingStorage(baseStorage, new SegmentRollingPolicy(1)), executorService());\n+        s.initialize(1);\n+        log.info(\"Created a storage instance\");\n+\n+        String sourceSegmentName = \"segment-\" + RANDOM.nextInt();\n+        String targetSegmentName = \"segment-\" + RANDOM.nextInt();\n+\n+        // Create source segment\n+        s.create(sourceSegmentName, TIMEOUT).join();\n+        val handle = s.openWrite(sourceSegmentName).join();\n+\n+        // do some writing\n+        ByteArrayOutputStream writeStream = new ByteArrayOutputStream();\n+        long offset = 0;\n+        for (int j = 0; j < APPENDS_PER_SEGMENT; j++) {\n+            byte[] writeData = populate(APPEND_FORMAT.length());\n+\n+            val dataStream = new ByteArrayInputStream(writeData);\n+            s.write(handle, offset, dataStream, writeData.length, TIMEOUT).join();\n+            writeStream.write(writeData);\n+            offset += writeData.length;\n+        }\n+\n+        // create a debug segment container instance\n+        @Cleanup\n+        TestContext context = createContext(executorService());\n+        OperationLogFactory localDurableLogFactory = new DurableLogFactory(DEFAULT_DURABLE_LOG_CONFIG, context.dataLogFactory,\n+                executorService());\n+\n+        @Cleanup\n+        MetadataCleanupContainer localContainer = new MetadataCleanupContainer(0, CONTAINER_CONFIG, localDurableLogFactory,\n+                context.readIndexFactory, context.attributeIndexFactory, context.writerFactory, context.storageFactory,\n+                context.getDefaultExtensions(), executorService());\n+        Services.startAsync(localContainer, executorService()).join();\n+\n+        // copy segment\n+        localContainer.copySegment(s, sourceSegmentName, targetSegmentName, executorService()).join();\n+\n+        // new segment should exist\n+        Assert.assertTrue(\"Unexpected result for existing segment (no files).\", s.exists(sourceSegmentName, null).join());\n+        // Old segment should exist\n+        Assert.assertTrue(\"Unexpected result for missing segment (no files).\", s.exists(targetSegmentName, null).join());\n+\n+        // Do some reading.\n+        val readHandle = s.openRead(targetSegmentName).join();\n+        byte[] expectedData = writeStream.toByteArray();\n+\n+        for (offset = 0; offset < expectedData.length / 2; offset++) {\n+            int length = (int) (expectedData.length - 2 * offset);\n+            byte[] readBuffer = new byte[length];\n+            int bytesRead = s.read(readHandle, offset, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n+            Assert.assertEquals(String.format(\"Unexpected number of bytes read from offset %d.\", offset),\n+                    length, bytesRead);\n+            AssertExtensions.assertArrayEquals(String.format(\"Unexpected read result from offset %d.\", offset),\n+                    expectedData, (int) offset, readBuffer, 0, bytesRead);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f745e9daa7477ee0ca8e5220a7b100532302e8"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIwMzI3Mg==", "bodyText": "Removed data. Wrote 10 MB data, and reading all of it at once and verifying.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r493203272", "createdAt": "2020-09-23T05:19:41Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainerTests.java", "diffHunk": "@@ -247,6 +251,85 @@ public void testEndToEnd() throws Exception {\n         }\n     }\n \n+    /**\n+     * The test creates a segment and then writes some data to it. The method under the test copies the contents of the\n+     * segment to a segment with a different name. At the end, it is verified that the new segment has the accurate\n+     * contents from the first one.\n+     */\n+    @Test\n+    public void testCopySegment() throws Exception {\n+        // Create a storage.\n+        @Cleanup\n+        val baseStorage =  new InMemoryStorage();\n+        @Cleanup\n+        val s = new AsyncStorageWrapper(new RollingStorage(baseStorage, new SegmentRollingPolicy(1)), executorService());\n+        s.initialize(1);\n+        log.info(\"Created a storage instance\");\n+\n+        String sourceSegmentName = \"segment-\" + RANDOM.nextInt();\n+        String targetSegmentName = \"segment-\" + RANDOM.nextInt();\n+\n+        // Create source segment\n+        s.create(sourceSegmentName, TIMEOUT).join();\n+        val handle = s.openWrite(sourceSegmentName).join();\n+\n+        // do some writing\n+        ByteArrayOutputStream writeStream = new ByteArrayOutputStream();\n+        long offset = 0;\n+        for (int j = 0; j < APPENDS_PER_SEGMENT; j++) {\n+            byte[] writeData = populate(APPEND_FORMAT.length());\n+\n+            val dataStream = new ByteArrayInputStream(writeData);\n+            s.write(handle, offset, dataStream, writeData.length, TIMEOUT).join();\n+            writeStream.write(writeData);\n+            offset += writeData.length;\n+        }\n+\n+        // create a debug segment container instance\n+        @Cleanup\n+        TestContext context = createContext(executorService());\n+        OperationLogFactory localDurableLogFactory = new DurableLogFactory(DEFAULT_DURABLE_LOG_CONFIG, context.dataLogFactory,\n+                executorService());\n+\n+        @Cleanup\n+        MetadataCleanupContainer localContainer = new MetadataCleanupContainer(0, CONTAINER_CONFIG, localDurableLogFactory,\n+                context.readIndexFactory, context.attributeIndexFactory, context.writerFactory, context.storageFactory,\n+                context.getDefaultExtensions(), executorService());\n+        Services.startAsync(localContainer, executorService()).join();\n+\n+        // copy segment\n+        localContainer.copySegment(s, sourceSegmentName, targetSegmentName, executorService()).join();\n+\n+        // new segment should exist\n+        Assert.assertTrue(\"Unexpected result for existing segment (no files).\", s.exists(sourceSegmentName, null).join());\n+        // Old segment should exist\n+        Assert.assertTrue(\"Unexpected result for missing segment (no files).\", s.exists(targetSegmentName, null).join());\n+\n+        // Do some reading.\n+        val readHandle = s.openRead(targetSegmentName).join();\n+        byte[] expectedData = writeStream.toByteArray();\n+\n+        for (offset = 0; offset < expectedData.length / 2; offset++) {\n+            int length = (int) (expectedData.length - 2 * offset);\n+            byte[] readBuffer = new byte[length];\n+            int bytesRead = s.read(readHandle, offset, readBuffer, 0, readBuffer.length, TIMEOUT).join();\n+            Assert.assertEquals(String.format(\"Unexpected number of bytes read from offset %d.\", offset),\n+                    length, bytesRead);\n+            AssertExtensions.assertArrayEquals(String.format(\"Unexpected read result from offset %d.\", offset),\n+                    expectedData, (int) offset, readBuffer, 0, bytesRead);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NzU5Ng=="}, "originalCommit": {"oid": "a4f745e9daa7477ee0ca8e5220a7b100532302e8"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM3MDQ2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozMjowNFrOHYQEyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjowNzowM1rOHYvjYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MTI0Mw==", "bodyText": "This can  be done in 259 above, when you initialize the variable.\nActually you can move the declaration of both offset and bytesToRead here.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495191243", "createdAt": "2020-09-25T19:32:04Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwNjk3Nw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495706977", "createdAt": "2020-09-28T06:07:03Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MTI0Mw=="}, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM3Mjk1OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozMzowMFrOHYQGaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjowNjo1MlrOHYvjKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MTY1Ng==", "bodyText": "Instead of allocating this buffer every time, do it outside of the loop. Pre-allocate one of BUFFER_SIZE length.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495191656", "createdAt": "2020-09-25T19:33:00Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);\n+                    bytesToRead.set((int) info.getLength());\n+                    return Futures.loop(\n+                            () -> bytesToRead.get() > 0,\n+                            () -> {\n+                                byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead.get())];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwNjkyMA==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495706920", "createdAt": "2020-09-28T06:06:52Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);\n+                    bytesToRead.set((int) info.getLength());\n+                    return Futures.loop(\n+                            () -> bytesToRead.get() > 0,\n+                            () -> {\n+                                byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead.get())];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MTY1Ng=="}, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM3NjQ2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozNDoyNFrOHYQIsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjowNjozMFrOHYviuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MjI0Mg==", "bodyText": "You can move this in the thenAccept below.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495192242", "createdAt": "2020-09-25T19:34:24Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);\n+                    bytesToRead.set((int) info.getLength());\n+                    return Futures.loop(\n+                            () -> bytesToRead.get() > 0,\n+                            () -> {\n+                                byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead.get())];\n+                                return storage.read(sourceHandle, offset.get(), buffer, 0, buffer.length, TIMEOUT)\n+                                        .thenComposeAsync(size -> {\n+                                            bytesToRead.addAndGet(-size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwNjgwOQ==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495706809", "createdAt": "2020-09-28T06:06:30Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);\n+                    bytesToRead.set((int) info.getLength());\n+                    return Futures.loop(\n+                            () -> bytesToRead.get() > 0,\n+                            () -> {\n+                                byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead.get())];\n+                                return storage.read(sourceHandle, offset.get(), buffer, 0, buffer.length, TIMEOUT)\n+                                        .thenComposeAsync(size -> {\n+                                            bytesToRead.addAndGet(-size);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MjI0Mg=="}, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM4MDA0OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozNToyNlrOHYQKtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjowNjoyMlrOHYvilw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5Mjc1OA==", "bodyText": "For readability, please be consistent in how you format and indent these callbacks. For best readability, consider moving the .thenXYZ methods on a new line. Then you won't have these weird line wrap-arounds that break the read flow.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495192758", "createdAt": "2020-09-25T19:35:26Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);\n+                    bytesToRead.set((int) info.getLength());\n+                    return Futures.loop(\n+                            () -> bytesToRead.get() > 0,\n+                            () -> {\n+                                byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead.get())];\n+                                return storage.read(sourceHandle, offset.get(), buffer, 0, buffer.length, TIMEOUT)\n+                                        .thenComposeAsync(size -> {\n+                                            bytesToRead.addAndGet(-size);\n+                                            return (size > 0) ? storage.write(targetHandle, offset.get(), new\n+                                                    ByteArrayInputStream(buffer, 0, size), size, TIMEOUT).thenAcceptAsync(r -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwNjc3NQ==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495706775", "createdAt": "2020-09-28T06:06:22Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {\n+                return storage.openRead(sourceSegment).thenCompose(sourceHandle -> {\n+                    offset.set(0);\n+                    bytesToRead.set((int) info.getLength());\n+                    return Futures.loop(\n+                            () -> bytesToRead.get() > 0,\n+                            () -> {\n+                                byte[] buffer = new byte[Math.min(BUFFER_SIZE, bytesToRead.get())];\n+                                return storage.read(sourceHandle, offset.get(), buffer, 0, buffer.length, TIMEOUT)\n+                                        .thenComposeAsync(size -> {\n+                                            bytesToRead.addAndGet(-size);\n+                                            return (size > 0) ? storage.write(targetHandle, offset.get(), new\n+                                                    ByteArrayInputStream(buffer, 0, size), size, TIMEOUT).thenAcceptAsync(r -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5Mjc1OA=="}, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM4Nzk2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozODoxMFrOHYQPiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjowNjoxM1rOHYviWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5Mzk5Mw==", "bodyText": "What happens when the segment copy is interrupted in the middle (by whatever reason, including a crash)?\nFrom what I can tell, the target segment will be left in an inconsistent state. It will either be empty or have some partial data in it.\nShould we change this method to either:\n\nDelete and recreate the segment (i.e., overwrite)\nThrow (like now)\nResume from where it left off.\n\nIf think #3 is off the table given that it may already contain some other, unrelated data. I would choose between 1 and 2. Does the upstream code handle an exception gracefully? Can it recover from it?", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495193993", "createdAt": "2020-09-25T19:38:10Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwNjcxMw==", "bodyText": "This method will be used in an upcoming PR(#5180).  Delete & re-copy can be handled there.\nI will be working on renaming the segments, then this method will become obsolete.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r495706713", "createdAt": "2020-09-28T06:06:13Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,39 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        AtomicInteger offset = new AtomicInteger();\n+        AtomicInteger bytesToRead = new AtomicInteger();\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5Mzk5Mw=="}, "originalCommit": {"oid": "9c9b1fd6bb14619a6d23f41932ebab4d6cb43368"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTc0NzIwOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMToxMzo1MVrOHaCVww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzowNToxM1rOHaLsdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzM2Mw==", "bodyText": "Suggest that you use composeAsync here and previous line and pass in executor.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r497063363", "createdAt": "2020-09-29T21:13:51Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,37 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        byte[] buffer = new byte[BUFFER_SIZE];\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2df4610efb8037a43e7cf6189b4bfaf92b49925d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNjYyOA==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5193#discussion_r497216628", "createdAt": "2020-09-30T03:05:13Z", "author": {"login": "ManishKumarKeshri"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -242,4 +245,37 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 storage.openWrite(segmentName).thenCompose(segmentHandle -> storage.delete(segmentHandle, TIMEOUT)),\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n+\n+    /**\n+     * Creates a target segment with the given name and copies the contents of the source segment to the target segment.\n+     * @param storage                   A storage instance to create the segment.\n+     * @param sourceSegment             The name of the source segment to copy the contents from.\n+     * @param targetSegment             The name of the segment to write the contents to.\n+     * @param executor                  A thread pool for execution.\n+     * @return                          A CompletableFuture that, when completed normally, will indicate the operation\n+     * completed. If the operation failed, the future will be failed with the causing exception.\n+     */\n+    protected static CompletableFuture<Void> copySegment(Storage storage, String sourceSegment, String targetSegment, ExecutorService executor) {\n+        byte[] buffer = new byte[BUFFER_SIZE];\n+        return storage.create(targetSegment, TIMEOUT).thenCompose(targetHandle -> {\n+            return storage.getStreamSegmentInfo(sourceSegment, TIMEOUT).thenCompose(info -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzM2Mw=="}, "originalCommit": {"oid": "2df4610efb8037a43e7cf6189b4bfaf92b49925d"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4699, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}