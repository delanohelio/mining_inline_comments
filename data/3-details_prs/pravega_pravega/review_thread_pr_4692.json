{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNTYxNDMx", "number": 4692, "reviewThreads": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMjowMzoxN1rODyCllw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzowNjowNlrOD9ezcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzk3NzgzOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMjowMzoxN1rOGF2hJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNToxMjo1MlrOGF-jCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc4OTI4Nw==", "bodyText": "if connection pooling is enabled then all the sessions will be terminated. We should send a WireCommands.AuthTokenCheckFailed .", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408789287", "createdAt": "2020-04-15T12:03:17Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -142,6 +146,30 @@ public void setupAppend(SetupAppend setupAppend) {\n                 tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n                         AuthHandler.Permissions.READ_UPDATE);\n+\n+                final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+                if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+                    if (durationToExpiry.isNegative()) {\n+                        log.debug(\"Token has already expired\");\n+                        throw new TokenExpiredException(\"Token already expired\");\n+                    } else {\n+                        Futures.delayedTask(() -> {\n+                            if (writerStates.containsKey(Pair.of(newSegment, writer))) {\n+                                // Closing the connection will result in client authenticating with Controller again\n+                                // and retrying.\n+                                log.debug(\"Closing client connection due to token expiry\");\n+                                try {\n+                                    this.connection.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca1d4fca561ae0557e228ca6e896b7f600080d1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyMDg0MA==", "bodyText": "Sure, I've made the change in the latest commits that I just pushed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408920840", "createdAt": "2020-04-15T15:12:52Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -142,6 +146,30 @@ public void setupAppend(SetupAppend setupAppend) {\n                 tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n                         AuthHandler.Permissions.READ_UPDATE);\n+\n+                final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+                if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+                    if (durationToExpiry.isNegative()) {\n+                        log.debug(\"Token has already expired\");\n+                        throw new TokenExpiredException(\"Token already expired\");\n+                    } else {\n+                        Futures.delayedTask(() -> {\n+                            if (writerStates.containsKey(Pair.of(newSegment, writer))) {\n+                                // Closing the connection will result in client authenticating with Controller again\n+                                // and retrying.\n+                                log.debug(\"Closing client connection due to token expiry\");\n+                                try {\n+                                    this.connection.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc4OTI4Nw=="}, "originalCommit": {"oid": "0ca1d4fca561ae0557e228ca6e896b7f600080d1"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODkyOTQzOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0MTozM1rOGF_4YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDoxODoxMFrOGGT92A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0MjY4OA==", "bodyText": "Revert this line", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408942688", "createdAt": "2020-04-15T15:41:33Z", "author": {"login": "andreipaduroiu"}, "path": "build.gradle", "diffHunk": "@@ -337,7 +346,7 @@ project ('bindings') {\n         compile project(':common')\n         compile project(':segmentstore:storage')\n         compile project(':shared:metrics')\n-        testCompile project(':test:testcommon')\n+        testCompile project(':test:testcommon') ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTc2OA==", "bodyText": "Done. Thanks for catching it.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409271768", "createdAt": "2020-04-16T04:18:10Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -337,7 +346,7 @@ project ('bindings') {\n         compile project(':common')\n         compile project(':segmentstore:storage')\n         compile project(':shared:metrics')\n-        testCompile project(':test:testcommon')\n+        testCompile project(':test:testcommon') ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0MjY4OA=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODkzMTYwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0MjowNFrOGF_5wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDoxODo0MVrOGGT-UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0MzA0MA==", "bodyText": "Revert this", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408943040", "createdAt": "2020-04-15T15:42:04Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "diffHunk": "@@ -205,6 +153,7 @@ public boolean populateToken(String token) {\n         } else {\n             return this.delegationToken.compareAndSet(currentToken, new DelegationToken(token, extractExpirationTime(token)));\n         }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTg4OA==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409271888", "createdAt": "2020-04-16T04:18:41Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "diffHunk": "@@ -205,6 +153,7 @@ public boolean populateToken(String token) {\n         } else {\n             return this.delegationToken.compareAndSet(currentToken, new DelegationToken(token, extractExpirationTime(token)));\n         }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0MzA0MA=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODk0MjQ3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0NDozNFrOGGAAuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDoxOTozNFrOGGT_Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NDgyNA==", "bodyText": "\"Unable to parse JWT body for expiration time: {}\"", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408944824", "createdAt": "2020-04-15T15:44:34Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.security;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JwtUtils {\n+\n+    /**\n+     * The regex pattern for extracting \"exp\" field from the JWT.\n+     *\n+     * Examples:\n+     *    Input:- {\"sub\":\"subject\",\"aud\":\"segmentstore\",\"iat\":1569837384,\"exp\":1569837434}, output:- \"exp\":1569837434\n+     *    Input:- {\"sub\": \"subject\",\"aud\": \"segmentstore\",\"iat\": 1569837384,\"exp\": 1569837434}, output:- \"exp\": 1569837434\n+     */\n+    private static final Pattern JWT_EXPIRATION_PATTERN = Pattern.compile(\"\\\"exp\\\":\\\\s?(\\\\d+)\");\n+\n+    public static Long extractExpirationTime(String token) {\n+        if (token == null || token.trim().equals(\"\")) {\n+            return null;\n+        }\n+        String[] tokenParts = token.split(\"\\\\.\");\n+\n+        //A JWT token has 3 parts: the header, the body and the signature.\n+        if (tokenParts == null || tokenParts.length != 3) {\n+            return null;\n+        }\n+\n+        // The second part of the JWT token is the body, which contains the expiration time if present.\n+        String encodedBody = tokenParts[1];\n+        String decodedJsonBody = new String(Base64.getDecoder().decode(encodedBody));\n+\n+        return parseExpirationTime(decodedJsonBody);\n+    }\n+\n+    public static Duration durationToExpiry(String token) {\n+        Long expirationTime = extractExpirationTime(token);\n+        if (expirationTime == null) {\n+            return null;\n+        } else {\n+            return Duration.between(Instant.now(), Instant.ofEpochSecond(expirationTime));\n+        }\n+    }\n+\n+    public static Long parseExpirationTime(String jwtBody) {\n+        Long result = null;\n+        if (jwtBody != null && !jwtBody.trim().equals(\"\")) {\n+            Matcher matcher = JWT_EXPIRATION_PATTERN.matcher(jwtBody);\n+            if (matcher.find()) {\n+                // Should look like this, if a proper match is found: \"exp\": 1569837434\n+                String matchedString = matcher.group();\n+\n+                // JwtUtils\n+\n+                String[] expiryTimeFieldParts = matchedString.split(\":\");\n+                if (expiryTimeFieldParts != null && expiryTimeFieldParts.length == 2) {\n+                    try {\n+                        result = Long.parseLong(expiryTimeFieldParts[1].trim());\n+                    } catch (NumberFormatException e) {\n+                        // ignore\n+                        log.warn(\"Encountered this exception when parsing JWT body for expiration time: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjExMA==", "bodyText": "Yeah, I had missed that - had thought of changing it later. I have fixed it now.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272110", "createdAt": "2020-04-16T04:19:34Z", "author": {"login": "ravisharda"}, "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.security;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JwtUtils {\n+\n+    /**\n+     * The regex pattern for extracting \"exp\" field from the JWT.\n+     *\n+     * Examples:\n+     *    Input:- {\"sub\":\"subject\",\"aud\":\"segmentstore\",\"iat\":1569837384,\"exp\":1569837434}, output:- \"exp\":1569837434\n+     *    Input:- {\"sub\": \"subject\",\"aud\": \"segmentstore\",\"iat\": 1569837384,\"exp\": 1569837434}, output:- \"exp\": 1569837434\n+     */\n+    private static final Pattern JWT_EXPIRATION_PATTERN = Pattern.compile(\"\\\"exp\\\":\\\\s?(\\\\d+)\");\n+\n+    public static Long extractExpirationTime(String token) {\n+        if (token == null || token.trim().equals(\"\")) {\n+            return null;\n+        }\n+        String[] tokenParts = token.split(\"\\\\.\");\n+\n+        //A JWT token has 3 parts: the header, the body and the signature.\n+        if (tokenParts == null || tokenParts.length != 3) {\n+            return null;\n+        }\n+\n+        // The second part of the JWT token is the body, which contains the expiration time if present.\n+        String encodedBody = tokenParts[1];\n+        String decodedJsonBody = new String(Base64.getDecoder().decode(encodedBody));\n+\n+        return parseExpirationTime(decodedJsonBody);\n+    }\n+\n+    public static Duration durationToExpiry(String token) {\n+        Long expirationTime = extractExpirationTime(token);\n+        if (expirationTime == null) {\n+            return null;\n+        } else {\n+            return Duration.between(Instant.now(), Instant.ofEpochSecond(expirationTime));\n+        }\n+    }\n+\n+    public static Long parseExpirationTime(String jwtBody) {\n+        Long result = null;\n+        if (jwtBody != null && !jwtBody.trim().equals(\"\")) {\n+            Matcher matcher = JWT_EXPIRATION_PATTERN.matcher(jwtBody);\n+            if (matcher.find()) {\n+                // Should look like this, if a proper match is found: \"exp\": 1569837434\n+                String matchedString = matcher.group();\n+\n+                // JwtUtils\n+\n+                String[] expiryTimeFieldParts = matchedString.split(\":\");\n+                if (expiryTimeFieldParts != null && expiryTimeFieldParts.length == 2) {\n+                    try {\n+                        result = Long.parseLong(expiryTimeFieldParts[1].trim());\n+                    } catch (NumberFormatException e) {\n+                        // ignore\n+                        log.warn(\"Encountered this exception when parsing JWT body for expiration time: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NDgyNA=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODk0NjUzOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0NToyN1rOGGADJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDoyMDowOFrOGGT_1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTQ0Ng==", "bodyText": "Include segment and writer id in the message. Both here and everywhere else you log or throw something.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408945446", "createdAt": "2020-04-15T15:45:27Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    void setupTokenExpiryTask(SetupAppend setupAppend, String newSegment, UUID writer) {\n+        final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+            if (durationToExpiry.isNegative()) {\n+                log.debug(\"Token has already expired\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjI3Ng==", "bodyText": "Sure, I've made this change.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272276", "createdAt": "2020-04-16T04:20:08Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    void setupTokenExpiryTask(SetupAppend setupAppend, String newSegment, UUID writer) {\n+        final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+            if (durationToExpiry.isNegative()) {\n+                log.debug(\"Token has already expired\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTQ0Ng=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODk1MjY3OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0Njo0OFrOGGAG8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDoyMDozNlrOGGUAfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NjQxNg==", "bodyText": "Better message", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408946416", "createdAt": "2020-04-15T15:46:48Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    void setupTokenExpiryTask(SetupAppend setupAppend, String newSegment, UUID writer) {\n+        final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+            if (durationToExpiry.isNegative()) {\n+                log.debug(\"Token has already expired\");\n+                throw new TokenExpiredException(\"Token already expired\");\n+            } else {\n+                Futures.delayedTask(() -> {\n+                    if (writerStates.containsKey(Pair.of(newSegment, writer))) {\n+                        try {\n+                            log.debug(\"Informing the client about token expiry\");\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    \"Token expired\",\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        } catch (RuntimeException e) {\n+                            log.warn(\"Encountered an exception\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjQ0Ng==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272446", "createdAt": "2020-04-16T04:20:36Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    void setupTokenExpiryTask(SetupAppend setupAppend, String newSegment, UUID writer) {\n+        final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+            if (durationToExpiry.isNegative()) {\n+                log.debug(\"Token has already expired\");\n+                throw new TokenExpiredException(\"Token already expired\");\n+            } else {\n+                Futures.delayedTask(() -> {\n+                    if (writerStates.containsKey(Pair.of(newSegment, writer))) {\n+                        try {\n+                            log.debug(\"Informing the client about token expiry\");\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    \"Token expired\",\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        } catch (RuntimeException e) {\n+                            log.warn(\"Encountered an exception\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NjQxNg=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODk1OTkwOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0ODozMlrOGGALjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNzo1OTozNFrOGNzzVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NzU5OA==", "bodyText": "Please do not create random executors. There are already executors created in the Segment Store process; use one of them. Or otherwise try to rework your code to not require an executor.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408947598", "createdAt": "2020-04-15T15:48:32Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -90,6 +92,10 @@\n \n     private FileModificationMonitor tlsCertFileModificationMonitor; // used only if tls reload is enabled\n \n+    // Used for running token expiry handling tasks.\n+    private final ScheduledExecutorService tokenExpiryHandlerExecutor =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTYxMw==", "bodyText": "Ok. I have modified the code to use a preexisting executor that is passed from the ServiceStarter.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411855613", "createdAt": "2020-04-21T04:15:34Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -90,6 +92,10 @@\n \n     private FileModificationMonitor tlsCertFileModificationMonitor; // used only if tls reload is enabled\n \n+    // Used for running token expiry handling tasks.\n+    private final ScheduledExecutorService tokenExpiryHandlerExecutor =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NzU5OA=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzM5OQ==", "bodyText": "On second thought, I realized that it'd be better to run the token expiry tasks on a separate executor spinning up lower priority threads, just so that these tasks don't end up overwhelming the core executor. So, I have now modified the code again.\nPlease take a look again and see what you think.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417133399", "createdAt": "2020-04-29T07:59:34Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -90,6 +92,10 @@\n \n     private FileModificationMonitor tlsCertFileModificationMonitor; // used only if tls reload is enabled\n \n+    // Used for running token expiry handling tasks.\n+    private final ScheduledExecutorService tokenExpiryHandlerExecutor =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NzU5OA=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODk2MjU3OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0OTowMlrOGGANKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDoyMDo1NFrOGGUAvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODAxMA==", "bodyText": "This is the wrong way to shut down an executor. See ExecutorServiceHelpers.shutdown. But anyway, see my comment above.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408948010", "createdAt": "2020-04-15T15:49:02Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -280,5 +286,8 @@ public void close() {\n         if (tlsCertFileModificationMonitor != null) {\n             tlsCertFileModificationMonitor.stopMonitoring();\n         }\n+        if (tokenExpiryHandlerExecutor != null) {\n+            tokenExpiryHandlerExecutor.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjUxMQ==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272511", "createdAt": "2020-04-16T04:20:54Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -280,5 +286,8 @@ public void close() {\n         if (tlsCertFileModificationMonitor != null) {\n             tlsCertFileModificationMonitor.stopMonitoring();\n         }\n+        if (tokenExpiryHandlerExecutor != null) {\n+            tokenExpiryHandlerExecutor.shutdownNow();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODAxMA=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODk2NDkwOnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtTestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0OTozNlrOGGAOwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDoyMTowNFrOGGUA5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODQxNw==", "bodyText": "Javadoc for this class and all its methods.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408948417", "createdAt": "2020-04-15T15:49:36Z", "author": {"login": "andreipaduroiu"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtTestUtils.java", "diffHunk": "@@ -7,20 +7,24 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.client.security.auth;\n+package io.pravega.test.common;\n \n import com.google.gson.Gson;\n \n import java.util.Base64;\n \n public class JwtTestUtils {\n \n-    static String createJwtBody(JwtBody jwt) {\n+    public static String createJwtBody(JwtBody jwt) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjU1MQ==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272551", "createdAt": "2020-04-16T04:21:04Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtTestUtils.java", "diffHunk": "@@ -7,20 +7,24 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.client.security.auth;\n+package io.pravega.test.common;\n \n import com.google.gson.Gson;\n \n import java.util.Base64;\n \n public class JwtTestUtils {\n \n-    static String createJwtBody(JwtBody jwt) {\n+    public static String createJwtBody(JwtBody jwt) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODQxNw=="}, "originalCommit": {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODg4NzMwOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNDoyMDowNFrOGIxwEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozNDo0MlrOGJvb4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NjkxNQ==", "bodyText": "Can we move the resolution strategy to the global one in build.gradle, to enforce a common lib across all.\n\n  \n    \n      pravega/build.gradle\n    \n    \n        Lines 109 to 115\n      in\n      729bc23\n    \n    \n    \n    \n\n        \n          \n           configurations.all { \n        \n\n        \n          \n               resolutionStrategy { \n        \n\n        \n          \n                   //failOnVersionConflict() \n        \n\n        \n          \n                   force \"com.google.guava:guava:\" + guavaVersion \n        \n\n        \n          \n                   force \"com.google.protobuf:protobuf-java:\" + protobufProtocVersion \n        \n\n        \n          \n                   force \"io.grpc:grpc-context:\" + grpcVersion \n        \n\n        \n          \n                   force \"commons-beanutils:commons-beanutils:\" + commonsBeanutilsVersion", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411856915", "createdAt": "2020-04-21T04:20:04Z", "author": {"login": "shrids"}, "path": "build.gradle", "diffHunk": "@@ -321,6 +322,14 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NTQ5Mw==", "bodyText": "Let me explain the rationale for the change a bit.\nWe use Gson version 2.8.5 elsewhere, including in :test:testcommon. The :bindings project depends on both:\n\n:test:testcommon sub-project, which brings in Gson 2.8.5 as transitive dependency.\nHDFS and ECS libraries, which depend on/bring Gson 2.5 as transitive dependency.\n\nSince the two Gson versions are not compatible with each other, we run into version conflicts here. So, I had to force the use of the older version in the :bindings sub-project. But, we don't want to use the older version of Gson everywhere, that is why the config change is local to the :bindings project. If/when we upgrade HDFS and ECS dependencies, we might be able to remove this change.\nSo, I think the suggested change might not be required. What do you say?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411885493", "createdAt": "2020-04-21T05:43:50Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -321,6 +322,14 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NjkxNQ=="}, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMDk5Mg==", "bodyText": "Thanks @ravisharda , yeah we would end up downgrading gson version that is used by test common to avoid this. As discussed, this could be changed once we upgrade hdfs dependency...", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411910992", "createdAt": "2020-04-21T06:39:22Z", "author": {"login": "shrids"}, "path": "build.gradle", "diffHunk": "@@ -321,6 +322,14 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NjkxNQ=="}, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NzU1Mw==", "bodyText": "yeah, I've added a comment in the build file towards this end.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r412867553", "createdAt": "2020-04-22T10:34:42Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -321,6 +322,14 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NjkxNQ=="}, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODkyODMwOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNDozNzoxM1rOGIyF5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozODoxMFrOGJvj_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg==", "bodyText": "Can we avoid sending this if the connection is closed? A connection closing should ensure all the pending tasks are cancelled.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411862502", "createdAt": "2020-04-21T04:37:13Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3ODEzMA==", "bodyText": "The ServerConnection interface doesn't seem to have a way to check if the connection is closed. My understanding is that if the connection is closed, sending a message over it will result in an exception being thrown, which we are catching and ignoring here.\nWhat do you say? Am I missing something else?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411878130", "createdAt": "2020-04-21T05:24:16Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg=="}, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMjI2Mg==", "bodyText": "The connection can be closed externally or due to connection.close() invoked by the appendProcessor. This would lead to these delayed tasks being unnecessarily executed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411912262", "createdAt": "2020-04-21T06:41:43Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg=="}, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2OTYzMQ==", "bodyText": "I've now introduced an isClosed() method to the connection, so that we the task checks for it before trying to send the token expiry notification. This makes it a bit more efficient. However, the core issue remains: whether/when/how do we cancel the task?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r412869631", "createdAt": "2020-04-22T10:38:10Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg=="}, "originalCommit": {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1OTI5NTIzOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjo0NDoyMVrOGI1NgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozNToyNFrOGJvdVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMzYwMA==", "bodyText": "I think we should have a lower log level here.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411913600", "createdAt": "2020-04-21T06:44:21Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                        writerId, segment, requestId),\n+                                WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2183a08a79bc15a6fc4c5b9e902dbf78ff4f17dd"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NzkyNA==", "bodyText": "Sure, that sounds good. I've reduced the log level.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r412867924", "createdAt": "2020-04-22T10:35:24Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                        writerId, segment, requestId),\n+                                WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMzYwMA=="}, "originalCommit": {"oid": "2183a08a79bc15a6fc4c5b9e902dbf78ff4f17dd"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODc3OTIyOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDozNjoxM1rOGM2kZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNjoyMzozMlrOGNxLEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDE1MQ==", "bodyText": "Can this be merged into the larger block of these on line 110?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416130151", "createdAt": "2020-04-27T20:36:13Z", "author": {"login": "tkaitchuck"}, "path": "build.gradle", "diffHunk": "@@ -321,6 +322,17 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {\n+        resolutionStrategy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MDMyMw==", "bodyText": "Line 110 is in the allProjects  block in the Gradle file, and so applies to all sub-projects, as well as the root project. The configurations.all one we have here is applicable to this specific sub-project (bindings). I think that keeping it here along-side the rest of the sub-project makes this part of the code more cohesive. Besides, I don't think there is a clean way of putting this configuration up in the allProjects block and still apply to this specific sub-project.  So, I'm leaving it as is.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417090323", "createdAt": "2020-04-29T06:23:32Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -321,6 +322,17 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {\n+        resolutionStrategy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDE1MQ=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTAxNTE3OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMTozNDozNFrOGM4tEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODowMTo1OVrOGNz4gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NTEzOA==", "bodyText": "This should not be creating threads on a per connection basis. This is going to need to be provided by the caller.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416165138", "createdAt": "2020-04-27T21:34:34Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -108,7 +113,9 @@ public static AppendProcessorBuilder defaultBuilder() {\n                 .nextRequestProcessor(new FailingRequestProcessor())\n                 .statsRecorder(SegmentStatsRecorder.noOp())\n                 .connectionTracker(new ConnectionTracker())\n-                .replyWithStackTraceOnError(false);\n+                .replyWithStackTraceOnError(false)\n+                .tokenExpiryHandlerExecutor(ExecutorServiceHelpers.newScheduledThreadPool(2,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwOTE2Nw==", "bodyText": "Also:\n\nThis executor has a weird name.\nIt is never shut down.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416209167", "createdAt": "2020-04-27T23:06:59Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -108,7 +113,9 @@ public static AppendProcessorBuilder defaultBuilder() {\n                 .nextRequestProcessor(new FailingRequestProcessor())\n                 .statsRecorder(SegmentStatsRecorder.noOp())\n                 .connectionTracker(new ConnectionTracker())\n-                .replyWithStackTraceOnError(false);\n+                .replyWithStackTraceOnError(false)\n+                .tokenExpiryHandlerExecutor(ExecutorServiceHelpers.newScheduledThreadPool(2,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NTEzOA=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNDcyMw==", "bodyText": "Even though the preexisting defaultBuilder() method where this executor was added was only meant for testing, it was inappropriate. So, I've removed it altogether in the latest push.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417134723", "createdAt": "2020-04-29T08:01:59Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -108,7 +113,9 @@ public static AppendProcessorBuilder defaultBuilder() {\n                 .nextRequestProcessor(new FailingRequestProcessor())\n                 .statsRecorder(SegmentStatsRecorder.noOp())\n                 .connectionTracker(new ConnectionTracker())\n-                .replyWithStackTraceOnError(false);\n+                .replyWithStackTraceOnError(false)\n+                .tokenExpiryHandlerExecutor(ExecutorServiceHelpers.newScheduledThreadPool(2,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NTEzOA=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTAyMzA2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMTozNjoyN1rOGM4xfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo1MjoyOVrOGSgHng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ==", "bodyText": "This sends a message over the connection and then leaves it open, so appends can continue to occur if the client simply ignores the message.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416166269", "createdAt": "2020-04-27T21:36:27Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTc2MQ==", "bodyText": "Yes, that is right. We are depending on the client to meet its contract related to token expiry, reauthenticate with the controller and invoke the segment store with the new token. One way to forcefully ensure that would have been to close the connection, but that'd be too expensive I suppose. What do you say?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417141761", "createdAt": "2020-04-29T08:15:41Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1MjYxMA==", "bodyText": "I can maintain a flag in the WriteState such that when the token expires, the task will set it to true. Then, I can check the flag on each append. However, that can introduce additional performance cost for each append. I believe the current solution is adequate and provides a good balance of security and performance.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417952610", "createdAt": "2020-04-30T11:50:17Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMzkwMw==", "bodyText": "This is a question of authentication. You can't rely on the client, that saying \"We enforce authorization by asking nicely\". The connection needs to be closed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r421003903", "createdAt": "2020-05-06T18:30:09Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1NTE0Nw==", "bodyText": "If connection pooling is enabled then closing the connection would cause all the clients using this connection to see a connection drop. But since it is a question of authentication the other clients would see a connection drop and would re-establish a connection with the SSS.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r421955147", "createdAt": "2020-05-08T05:59:43Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1Mzc5MA==", "bodyText": "I've modified the code to close the connection, as suggested.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422053790", "createdAt": "2020-05-08T09:52:29Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTAyNDU2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMTozNjo0OFrOGM4yTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODowNzowNlrOGN0CoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjQ3OA==", "bodyText": "I think this is a warn level event", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416166478", "createdAt": "2020-04-27T21:36:48Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                            writerId, segment, requestId),\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.debug(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzMxMg==", "bodyText": "Yeah, the log level was changed from warn to debug previously, as the exception would also occur if the task ran after the connection was closed. Now that the main portion of the task is only run if the connection is not already closed, it'd be appropriate to change this back to warn level. I've made this change in the latest push.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417137312", "createdAt": "2020-04-29T08:07:06Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                            writerId, segment, requestId),\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.debug(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjQ3OA=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTAzMjA1OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMTozODo0NFrOGM42lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODowNzoyOFrOGN0Dbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NzU3Mg==", "bodyText": "why this change?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416167572", "createdAt": "2020-04-27T21:38:44Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -199,13 +217,10 @@ public void initChannel(SocketChannel ch) {\n                          new AppendDecoder(),\n                          lsh);\n \n-                 lsh.setRequestProcessor(new AppendProcessor(store,\n-                         lsh,\n-                         connectionTracker,\n-                         new PravegaRequestProcessor(store, tableStore, lsh, statsRecorder, tableStatsRecorder, tokenVerifier, replyWithStackTraceOnError),\n-                         statsRecorder,\n-                         tokenVerifier,\n-                         replyWithStackTraceOnError));\n+                 lsh.setRequestProcessor(new AppendProcessor(store, lsh, connectionTracker,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzUxOQ==", "bodyText": "Yeah, this is unnecessary. I've reverted it.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417137519", "createdAt": "2020-04-29T08:07:28Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -199,13 +217,10 @@ public void initChannel(SocketChannel ch) {\n                          new AppendDecoder(),\n                          lsh);\n \n-                 lsh.setRequestProcessor(new AppendProcessor(store,\n-                         lsh,\n-                         connectionTracker,\n-                         new PravegaRequestProcessor(store, tableStore, lsh, statsRecorder, tableStatsRecorder, tokenVerifier, replyWithStackTraceOnError),\n-                         statsRecorder,\n-                         tokenVerifier,\n-                         replyWithStackTraceOnError));\n+                 lsh.setRequestProcessor(new AppendProcessor(store, lsh, connectionTracker,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NzU3Mg=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTMxMDU5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzowMzo0MFrOGM7TkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyNzoyMVrOGVhuaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwNzc2MA==", "bodyText": "This is an expensive string parse. Can you just look up exp and get the number that succeeds it?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416207760", "createdAt": "2020-04-27T23:03:40Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.security;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility methods for JSON Web Tokens (JWT).\n+ */\n+@Slf4j\n+public class JwtUtils {\n+\n+    /**\n+     * The regex pattern for extracting \"exp\" field from the JWT.\n+     *\n+     * Examples:\n+     *    Input:- {\"sub\":\"subject\",\"aud\":\"segmentstore\",\"iat\":1569837384,\"exp\":1569837434}, output:- \"exp\":1569837434\n+     *    Input:- {\"sub\": \"subject\",\"aud\": \"segmentstore\",\"iat\": 1569837384,\"exp\": 1569837434}, output:- \"exp\": 1569837434\n+     */\n+    private static final Pattern JWT_EXPIRATION_PATTERN = Pattern.compile(\"\\\"exp\\\":\\\\s?(\\\\d+)\");\n+\n+    /**\n+     * Extracts expiration time from the specified JWT token.\n+     *\n+     * @param jsonWebToken the JWT to extract the expiration time from\n+     * @return the the expiration time (in seconds). Returns null if\n+     *         a) the specified token is blank, or\n+     *         b) the specified token is of invalid format, or\n+     *         c) expiration time is missing from the token, or\n+     *         d) expiration time is not a number.\n+     */\n+    public static Long extractExpirationTime(String jsonWebToken) {\n+        if (jsonWebToken == null || jsonWebToken.trim().equals(\"\")) {\n+            return null;\n+        }\n+        String[] tokenParts = jsonWebToken.split(\"\\\\.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2MjEzNg==", "bodyText": "Actually, we do look up the expiry string (for example: \"exp\": 1569837434) in another method parseExpirationTime(), after first extracting the JWT body and decoding it here.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422062136", "createdAt": "2020-05-08T10:12:27Z", "author": {"login": "ravisharda"}, "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.security;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility methods for JSON Web Tokens (JWT).\n+ */\n+@Slf4j\n+public class JwtUtils {\n+\n+    /**\n+     * The regex pattern for extracting \"exp\" field from the JWT.\n+     *\n+     * Examples:\n+     *    Input:- {\"sub\":\"subject\",\"aud\":\"segmentstore\",\"iat\":1569837384,\"exp\":1569837434}, output:- \"exp\":1569837434\n+     *    Input:- {\"sub\": \"subject\",\"aud\": \"segmentstore\",\"iat\": 1569837384,\"exp\": 1569837434}, output:- \"exp\": 1569837434\n+     */\n+    private static final Pattern JWT_EXPIRATION_PATTERN = Pattern.compile(\"\\\"exp\\\":\\\\s?(\\\\d+)\");\n+\n+    /**\n+     * Extracts expiration time from the specified JWT token.\n+     *\n+     * @param jsonWebToken the JWT to extract the expiration time from\n+     * @return the the expiration time (in seconds). Returns null if\n+     *         a) the specified token is blank, or\n+     *         b) the specified token is of invalid format, or\n+     *         c) expiration time is missing from the token, or\n+     *         d) expiration time is not a number.\n+     */\n+    public static Long extractExpirationTime(String jsonWebToken) {\n+        if (jsonWebToken == null || jsonWebToken.trim().equals(\"\")) {\n+            return null;\n+        }\n+        String[] tokenParts = jsonWebToken.split(\"\\\\.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwNzc2MA=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyNTgzMg==", "bodyText": "This PR now doesn't use this method anymore. It continues to be used elsewhere.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425225832", "createdAt": "2020-05-14T15:27:21Z", "author": {"login": "ravisharda"}, "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.security;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility methods for JSON Web Tokens (JWT).\n+ */\n+@Slf4j\n+public class JwtUtils {\n+\n+    /**\n+     * The regex pattern for extracting \"exp\" field from the JWT.\n+     *\n+     * Examples:\n+     *    Input:- {\"sub\":\"subject\",\"aud\":\"segmentstore\",\"iat\":1569837384,\"exp\":1569837434}, output:- \"exp\":1569837434\n+     *    Input:- {\"sub\": \"subject\",\"aud\": \"segmentstore\",\"iat\": 1569837384,\"exp\": 1569837434}, output:- \"exp\": 1569837434\n+     */\n+    private static final Pattern JWT_EXPIRATION_PATTERN = Pattern.compile(\"\\\"exp\\\":\\\\s?(\\\\d+)\");\n+\n+    /**\n+     * Extracts expiration time from the specified JWT token.\n+     *\n+     * @param jsonWebToken the JWT to extract the expiration time from\n+     * @return the the expiration time (in seconds). Returns null if\n+     *         a) the specified token is blank, or\n+     *         b) the specified token is of invalid format, or\n+     *         c) expiration time is missing from the token, or\n+     *         d) expiration time is not a number.\n+     */\n+    public static Long extractExpirationTime(String jsonWebToken) {\n+        if (jsonWebToken == null || jsonWebToken.trim().equals(\"\")) {\n+            return null;\n+        }\n+        String[] tokenParts = jsonWebToken.split(\"\\\\.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwNzc2MA=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTMxNjg1OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzowNTo1NVrOGM7XJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNzoxMTo1OVrOGNyWbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwODY3Nw==", "bodyText": "RuntimeException extends Exception. Please catch Exception.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416208677", "createdAt": "2020-04-27T23:05:55Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                            writerId, segment, requestId),\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        }\n+                    } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwOTYxMw==", "bodyText": "I want to be specific here, as the intention is only to catch any runtime exceptions.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417109613", "createdAt": "2020-04-29T07:11:59Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                            writerId, segment, requestId),\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        }\n+                    } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwODY3Nw=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTMyMjA2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzowNzozNlrOGM7aBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoxODoxM1rOGN0ZJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwOTQxMg==", "bodyText": "Who manages this executor?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416209412", "createdAt": "2020-04-27T23:07:36Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -105,7 +110,17 @@\n     @VisibleForTesting\n     public PravegaConnectionListener(boolean enableTls, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore) {\n         this(enableTls, false, \"localhost\", port, streamSegmentStore, tableStore, SegmentStatsRecorder.noOp(), TableSegmentStatsRecorder.noOp(),\n-                new PassingTokenVerifier(), null, null, true);\n+                new PassingTokenVerifier(), null, null, true,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzA3Ng==", "bodyText": "Even though the preexisting defaultBuilder() method where this executor was added, was only meant for testing, it was inappropriate to add the executor here. So, I've removed it altogether in the latest push. Please review the revised code.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417143076", "createdAt": "2020-04-29T08:18:13Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -105,7 +110,17 @@\n     @VisibleForTesting\n     public PravegaConnectionListener(boolean enableTls, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore) {\n         this(enableTls, false, \"localhost\", port, streamSegmentStore, tableStore, SegmentStatsRecorder.noOp(), TableSegmentStatsRecorder.noOp(),\n-                new PassingTokenVerifier(), null, null, true);\n+                new PassingTokenVerifier(), null, null, true,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwOTQxMg=="}, "originalCommit": {"oid": "1b8576bca639525205f27471acbd466b6e259758"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTQ2MjIzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNjoxMTo0M1rOGObDcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo1Mjo0MVrOGSgH_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc3NjQ5Nw==", "bodyText": "Default priority can be java.lang.Thread#NORM_PRIORITY", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417776497", "createdAt": "2020-04-30T06:11:43Z", "author": {"login": "shrids"}, "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "diffHunk": "@@ -66,6 +66,17 @@ public void uncaughtException(Thread t, Throwable e) {\n      * @return a thread factory\n      */\n     public static ThreadFactory getThreadFactory(String groupName) {\n+        return getThreadFactory(groupName, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "948799327d98405f60952b7eba26007c18d7a2c7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1Mzg4Nw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422053887", "createdAt": "2020-05-08T09:52:41Z", "author": {"login": "ravisharda"}, "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "diffHunk": "@@ -66,6 +66,17 @@ public void uncaughtException(Thread t, Throwable e) {\n      * @return a thread factory\n      */\n     public static ThreadFactory getThreadFactory(String groupName) {\n+        return getThreadFactory(groupName, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc3NjQ5Nw=="}, "originalCommit": {"oid": "948799327d98405f60952b7eba26007c18d7a2c7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzY0MTM5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDoxOTowM1rOGSgyXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDozMjoyOFrOGShHNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDczMw==", "bodyText": "can we remove this redundant null check? The user would invoke newScheduledThreadPool(int size, String poolName) if the priority is default.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422064733", "createdAt": "2020-05-08T10:19:03Z", "author": {"login": "shrids"}, "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "diffHunk": "@@ -86,8 +100,24 @@ public Thread newThread(Runnable r) {\n      * @return A new executor service.\n      */\n     public static ScheduledExecutorService newScheduledThreadPool(int size, String poolName) {\n+        return newScheduledThreadPool(size, poolName, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates a new ScheduledExecutorService that will use daemon threads with specified priority and names.\n+     *\n+     * @param size The number of threads in the threadpool\n+     * @param poolName The name of the pool (this will be printed in logs)\n+     * @param threadPriority The priority to be assigned to the threads\n+     * @return A new executor service.\n+     */\n+    public static ScheduledExecutorService newScheduledThreadPool(int size, String poolName, Integer threadPriority) {\n+\n+        ThreadFactory threadFactory =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c964260a602b5fba01486a6013efdcd3dbc0d33"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MDA3MA==", "bodyText": "Yeah, but since it is a public method, we can't assume that's always true. Besides, having the check makes the intention explicit.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422070070", "createdAt": "2020-05-08T10:32:28Z", "author": {"login": "ravisharda"}, "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "diffHunk": "@@ -86,8 +100,24 @@ public Thread newThread(Runnable r) {\n      * @return A new executor service.\n      */\n     public static ScheduledExecutorService newScheduledThreadPool(int size, String poolName) {\n+        return newScheduledThreadPool(size, poolName, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates a new ScheduledExecutorService that will use daemon threads with specified priority and names.\n+     *\n+     * @param size The number of threads in the threadpool\n+     * @param poolName The name of the pool (this will be printed in logs)\n+     * @param threadPriority The priority to be assigned to the threads\n+     * @return A new executor service.\n+     */\n+    public static ScheduledExecutorService newScheduledThreadPool(int size, String poolName, Integer threadPriority) {\n+\n+        ThreadFactory threadFactory =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDczMw=="}, "originalCommit": {"oid": "2c964260a602b5fba01486a6013efdcd3dbc0d33"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzgxMTM1OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMToyNTo1MFrOGSiWfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTowOTo0MVrOGU2U1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDM2NQ==", "bodyText": "We can improve/remove the warn message here since we are closing the connection and not informing the writer via a Wirecommand.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422090365", "createdAt": "2020-05-08T11:25:50Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNDc3NQ==", "bodyText": "We don't need to catch the exception anymore after we modified the code here to close the connection, so I've removed the code.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424514775", "createdAt": "2020-05-13T15:09:41Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDM2NQ=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzgxNDY5OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMToyNzowOVrOGSiYaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyNDo0MlrOGVhmRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDg1Ng==", "bodyText": "we do not need this check since we are closing the connection.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422090856", "createdAt": "2020-05-08T11:27:09Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MDA3NQ==", "bodyText": "IMO, this check is still useful because this task is a background task and the connection might already have closed out-of-band.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424170075", "createdAt": "2020-05-13T04:47:52Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDg1Ng=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMzc0OA==", "bodyText": "I've moved this check inside close itself, and have removed it here.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425223748", "createdAt": "2020-05-14T15:24:42Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDg1Ng=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzgxOTIzOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMToyOTowN1rOGSibSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToxMDo0OFrOGU2YMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MTU5Mg==", "bodyText": "I did not understand the need to catch an exception for connection.close()?\n(if it is required, then this pattern should be replicated at all connection.close() invocation instances. )", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422091592", "createdAt": "2020-05-08T11:29:07Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNTYzMw==", "bodyText": "We don't need to catch the exception anymore after we modified the code here to close the connection, so I've removed the code.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424515633", "createdAt": "2020-05-13T15:10:48Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MTU5Mg=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzg0MTMxOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMTozNzoxMFrOGSioDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyNTowM1rOGVhnYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg==", "bodyText": "Would the TokenVerifierImpl#verifyToken verify if the duration is negative? If not, we could move the check there to ensure expired tokens are not allowed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422094862", "createdAt": "2020-05-08T11:37:10Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                    }\n+                }\n+                return null;\n+            }, expiryDuration, this.tokenExpiryHandlerExecutor);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    Duration durationToExpiry(SetupAppend setupAppend) {\n+        final Duration duration = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        // Note that duration can be null, say if token had no expiry set (for internal communications).\n+\n+        if (duration != null && duration.isNegative()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwOTg3Mw==", "bodyText": "Yes, that check is for finding out if the token has already expired.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424209873", "createdAt": "2020-05-13T06:52:39Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                    }\n+                }\n+                return null;\n+            }, expiryDuration, this.tokenExpiryHandlerExecutor);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    Duration durationToExpiry(SetupAppend setupAppend) {\n+        final Duration duration = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        // Note that duration can be null, say if token had no expiry set (for internal communications).\n+\n+        if (duration != null && duration.isNegative()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NzAxOA==", "bodyText": "TokenVerifierImpl#verifyToken is already checking for TokenExpired. Hence this check seems redundant.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424867018", "createdAt": "2020-05-14T04:40:58Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                    }\n+                }\n+                return null;\n+            }, expiryDuration, this.tokenExpiryHandlerExecutor);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    Duration durationToExpiry(SetupAppend setupAppend) {\n+        final Duration duration = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        // Note that duration can be null, say if token had no expiry set (for internal communications).\n+\n+        if (duration != null && duration.isNegative()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyNDAzMg==", "bodyText": "I've now removed it.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425224032", "createdAt": "2020-05-14T15:25:03Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                    }\n+                }\n+                return null;\n+            }, expiryDuration, this.tokenExpiryHandlerExecutor);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    Duration durationToExpiry(SetupAppend setupAppend) {\n+        final Duration duration = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        // Note that duration can be null, say if token had no expiry set (for internal communications).\n+\n+        if (duration != null && duration.isNegative()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTY1MTMzOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMToxMzozOVrOGSz6Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODoyNzoxOFrOGWZEAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3ODA4Mg==", "bodyText": "This comment makes no sense. If there is a conflict with testcommon why is the bindings version being changed? This fix should go into testcommon. Because testcommon is not depended on by any non-test target there should be no conflict.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422378082", "createdAt": "2020-05-08T21:13:39Z", "author": {"login": "tkaitchuck"}, "path": "build.gradle", "diffHunk": "@@ -322,6 +323,17 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {\n+        resolutionStrategy {\n+            // We need to force this version as dependency, since ':test:testcommon' brings in a newer version of ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NjczNw==", "bodyText": "To clarify a bit more:\n\nHDFS and S3 dependencies of the :bindings Gradle sub-project bring in an older version of Gson - 2.5 (2015), transitively.\nThe :client and :test:testcommon sub-projects depend upon a newer version - 2.8.5 (2018).\nThe two versions of Gson - 2.8.5 and 2.5 have compile-time incompatibilities.\nThe :bindings sub-project depends on :test:testcommon too, so the transitive dependency of Gson will resolve to 2.8.5, without the change made here. So, HDFS and S3 related code doesn't compile, without this change.\n\nWe can resolve the issue by downgrading the dependencies of client and testcommon sub-projects to 2.5. But that'd be a bad idea. The older version is about 5 years old. The newer version is also a couple of years old, but at least we are free to upgrade it in these sub-projects at will.\nAlso, we already have plans to upgrade HDFS and S3 to newer versions, which should allow us to remove this Gradle config to let the bindings sub-project use Gson 2.5.\nSo, IMO this change needs to stay. What do you say?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424176737", "createdAt": "2020-05-13T05:13:56Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -322,6 +323,17 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {\n+        resolutionStrategy {\n+            // We need to force this version as dependency, since ':test:testcommon' brings in a newer version of ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3ODA4Mg=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1ODkwNQ==", "bodyText": "Now that you have changed the code both :client and :test:testcommon can remove the dependency all together.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425958905", "createdAt": "2020-05-15T17:53:25Z", "author": {"login": "tkaitchuck"}, "path": "build.gradle", "diffHunk": "@@ -322,6 +323,17 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {\n+        resolutionStrategy {\n+            // We need to force this version as dependency, since ':test:testcommon' brings in a newer version of ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3ODA4Mg=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjQ4MQ==", "bodyText": "The :test:testcommon still uses the Gson library in JwtBody class, which in turn is being used by several test classes, and therefore I can't remove it from there. I've removed it from :client though. Also, I'll need to keep the configuration for forcing gson dependency to one that HDFS and S3  can use, otherwise tests would fail.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426132481", "createdAt": "2020-05-16T08:27:18Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -322,6 +323,17 @@ project('segmentstore:storage:impl') {\n }\n \n project ('bindings') {\n+    configurations.all {\n+        resolutionStrategy {\n+            // We need to force this version as dependency, since ':test:testcommon' brings in a newer version of ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3ODA4Mg=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTY1ODk2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMToxNjoxNVrOGSz-0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToxMjo1N1rOGU2eVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3OTIxNw==", "bodyText": "In this code path, this executor does not look like it will ever be shutdown. That is a thread leak.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422379217", "createdAt": "2020-05-08T21:16:15Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -105,7 +110,17 @@\n     @VisibleForTesting\n     public PravegaConnectionListener(boolean enableTls, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore) {\n         this(enableTls, false, \"localhost\", port, streamSegmentStore, tableStore, SegmentStatsRecorder.noOp(), TableSegmentStatsRecorder.noOp(),\n-                new PassingTokenVerifier(), null, null, true);\n+                new PassingTokenVerifier(), null, null, true,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));\n+    }\n+\n+    public PravegaConnectionListener(boolean enableTls, boolean enableTlsReload, String host, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore,\n+                                     SegmentStatsRecorder statsRecorder, TableSegmentStatsRecorder tableStatsRecorder,\n+                                     DelegationTokenVerifier tokenVerifier, String certFile, String keyFile,\n+                                     boolean replyWithStackTraceOnError) {\n+        this(enableTls, enableTlsReload, host, port, streamSegmentStore, tableStore, statsRecorder, tableStatsRecorder,\n+                tokenVerifier, certFile, keyFile, replyWithStackTraceOnError,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNzIwNg==", "bodyText": "That constructor was being used in unit tests. I've modified it to inject the executor from outside, and have modified the tests.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424517206", "createdAt": "2020-05-13T15:12:57Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -105,7 +110,17 @@\n     @VisibleForTesting\n     public PravegaConnectionListener(boolean enableTls, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore) {\n         this(enableTls, false, \"localhost\", port, streamSegmentStore, tableStore, SegmentStatsRecorder.noOp(), TableSegmentStatsRecorder.noOp(),\n-                new PassingTokenVerifier(), null, null, true);\n+                new PassingTokenVerifier(), null, null, true,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));\n+    }\n+\n+    public PravegaConnectionListener(boolean enableTls, boolean enableTlsReload, String host, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore,\n+                                     SegmentStatsRecorder statsRecorder, TableSegmentStatsRecorder tableStatsRecorder,\n+                                     DelegationTokenVerifier tokenVerifier, String certFile, String keyFile,\n+                                     boolean replyWithStackTraceOnError) {\n+        this(enableTls, enableTlsReload, host, port, streamSegmentStore, tableStore, statsRecorder, tableStatsRecorder,\n+                tokenVerifier, certFile, keyFile, replyWithStackTraceOnError,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3OTIxNw=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTY3NjkwOnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtBody.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMToyMjozNVrOGS0JZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToxNDowNFrOGU2htA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4MTkyNQ==", "bodyText": "This is such a small amount of json, and it doesn't even have nesting. Rather than dealing with dependency managment of Gson can we just use a Format template?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422381925", "createdAt": "2020-05-08T21:22:35Z", "author": {"login": "tkaitchuck"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtBody.java", "diffHunk": "@@ -20,7 +20,7 @@\n @Builder\n @Getter\n @Setter\n-class JwtBody {\n+public class JwtBody {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxODA2OA==", "bodyText": "This is an existing piece of code and I think we should explore seeing if that'd make sense and do the change separately of this PR.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424518068", "createdAt": "2020-05-13T15:14:04Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtBody.java", "diffHunk": "@@ -20,7 +20,7 @@\n @Builder\n @Getter\n @Setter\n-class JwtBody {\n+public class JwtBody {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4MTkyNQ=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTY4MzQyOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMToyNTowOVrOGS0NgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToxNDo1MlrOGU2kMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4Mjk3Ng==", "bodyText": "This doesn't appear to be used anywhere.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422382976", "createdAt": "2020-05-08T21:25:09Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -66,13 +66,15 @@\n public class ServiceBuilder implements AutoCloseable {\n     //region Members\n \n-    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(30);\n+    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(45);\n     private final SegmentStoreMetrics.ThreadPool threadPoolMetrics;\n     private final SegmentToContainerMapper segmentToContainerMapper;\n     private final ServiceBuilderConfig serviceBuilderConfig;\n     @Getter(AccessLevel.PROTECTED)\n     private final ScheduledExecutorService coreExecutor;\n     private final ScheduledExecutorService storageExecutor;\n+    @Getter(AccessLevel.PUBLIC)\n+    private final ScheduledExecutorService lowPriorityExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxODcwNQ==", "bodyText": "We were using it in ServiceStarter. Now, we also use it elsewhere as you can see in the latest push.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424518705", "createdAt": "2020-05-13T15:14:52Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -66,13 +66,15 @@\n public class ServiceBuilder implements AutoCloseable {\n     //region Members\n \n-    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(30);\n+    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(45);\n     private final SegmentStoreMetrics.ThreadPool threadPoolMetrics;\n     private final SegmentToContainerMapper segmentToContainerMapper;\n     private final ServiceBuilderConfig serviceBuilderConfig;\n     @Getter(AccessLevel.PROTECTED)\n     private final ScheduledExecutorService coreExecutor;\n     private final ScheduledExecutorService storageExecutor;\n+    @Getter(AccessLevel.PUBLIC)\n+    private final ScheduledExecutorService lowPriorityExecutor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4Mjk3Ng=="}, "originalCommit": {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcyMTgxOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/ServerConnectionInboundHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDoxMTozN1rOGVLafA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTozNzoxOVrOGVYN5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDI4NA==", "bodyText": "can we ensure close() is invoked only once? i.e\nif (isClosed.compareAndSet(false, true) ) {\n   Channel ch = ...\n}", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424860284", "createdAt": "2020-05-14T04:11:37Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/ServerConnectionInboundHandler.java", "diffHunk": "@@ -84,6 +87,12 @@ public void close() {\n             // wait for all messages to be sent before closing the channel.\n             ch.eventLoop().execute(() -> ch.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE));\n         }\n+        isClosed.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd1b91dc2634453ac46ab3a328f8fea0d430844"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MDA1NQ==", "bodyText": "Ok, I've moved the check as suggested.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425070055", "createdAt": "2020-05-14T11:37:19Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/ServerConnectionInboundHandler.java", "diffHunk": "@@ -84,6 +87,12 @@ public void close() {\n             // wait for all messages to be sent before closing the channel.\n             ch.eventLoop().execute(() -> ch.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE));\n         }\n+        isClosed.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDI4NA=="}, "originalCommit": {"oid": "bdd1b91dc2634453ac46ab3a328f8fea0d430844"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDA2Njg3OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/DelegationTokenVerifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNDo0NDo1N1rOGV2UfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNDo0NDo1N1rOGV2UfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2MzI2MA==", "bodyText": "+1", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425563260", "createdAt": "2020-05-15T04:44:57Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/DelegationTokenVerifier.java", "diffHunk": "@@ -33,7 +34,8 @@\n      * @throws InvalidClaimException  if the {@code token} does not contain the claim representing\n      *                                {@code expectedLevel} of access\n      * @throws TokenException         if any other failure condition is encountered\n+     * @return JsonWebToken           a non-null value if token was parsed and verified successfully, otherwise null.\n      */\n-    void verifyToken(String resource, String token, AuthHandler.Permissions expectedLevel)\n+    JsonWebToken verifyToken(String resource, String token, AuthHandler.Permissions expectedLevel)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDA3NTgxOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNDo1MToxOVrOGV2Z6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozNTozMlrOGWZGKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2NDY0OA==", "bodyText": "Should this be bumped to ERROR log level ?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425564648", "createdAt": "2020-05-15T04:51:19Z", "author": {"login": "shrids"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -328,8 +361,7 @@ private void handleException(UUID writerId, long requestId, String segment, long\n             connection.close();\n         } else if (u instanceof TokenExpiredException) {\n             log.warn(requestId, \"Token expired for writer {} on segment {}.\", writerId, segment, u);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzAzMg==", "bodyText": "ERROR would be too harsh here, as things continue to function normally.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133032", "createdAt": "2020-05-16T08:35:32Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -328,8 +361,7 @@ private void handleException(UUID writerId, long requestId, String segment, long\n             connection.close();\n         } else if (u instanceof TokenExpiredException) {\n             log.warn(requestId, \"Token expired for writer {} on segment {}.\", writerId, segment, u);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2NDY0OA=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ5NTYxOnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/token/JsonWebToken.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0NjozOVrOGWOQOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODoyODozMFrOGWZEaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NTM4Nw==", "bodyText": "Should this have a defensive copy?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425955387", "createdAt": "2020-05-15T17:46:39Z", "author": {"login": "tkaitchuck"}, "path": "shared/security/src/main/java/io/pravega/shared/security/token/JsonWebToken.java", "diffHunk": "@@ -107,6 +104,19 @@ public JsonWebToken(@NonNull String subject, @NonNull String audience, @NonNull\n         this.permissionsByResource = resourcePermissionClaims;\n     }\n \n+    public JsonWebToken(@NonNull String subject, @NonNull String audience, @NonNull byte[] signingKey,\n+                        Date expiry, Map<String, Object> resourcePermissionClaims) {\n+        this.subject = subject;\n+        this.audience = audience;\n+        this.signingKey = signingKey.clone();\n+        if (expiry != null) {\n+            this.expirationTime = Date.from(expiry.toInstant());\n+        } else {\n+            this.expirationTime = null;\n+        }\n+        this.permissionsByResource = resourcePermissionClaims;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjU4NA==", "bodyText": "The class is used internally. I had to make a defensive copy of expiration time and bytes to satisfy Spotbugs.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426132584", "createdAt": "2020-05-16T08:28:30Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/token/JsonWebToken.java", "diffHunk": "@@ -107,6 +104,19 @@ public JsonWebToken(@NonNull String subject, @NonNull String audience, @NonNull\n         this.permissionsByResource = resourcePermissionClaims;\n     }\n \n+    public JsonWebToken(@NonNull String subject, @NonNull String audience, @NonNull byte[] signingKey,\n+                        Date expiry, Map<String, Object> resourcePermissionClaims) {\n+        this.subject = subject;\n+        this.audience = audience;\n+        this.signingKey = signingKey.clone();\n+        if (expiry != null) {\n+            this.expirationTime = Date.from(expiry.toInstant());\n+        } else {\n+            this.expirationTime = null;\n+        }\n+        this.permissionsByResource = resourcePermissionClaims;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NTM4Nw=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgxNTY0OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTozMzoxOFrOGWRbTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMjo0NDo1OVrOGWXsag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwNzM3NQ==", "bodyText": "Why do you return a future when you don't use it?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426007375", "createdAt": "2020-05-15T19:33:18Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +173,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(@NonNull SetupAppend setupAppend, @NonNull JsonWebToken token) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMDA1OA==", "bodyText": "A couple of tests use the future to wait for task completion before making the assertion.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426110058", "createdAt": "2020-05-16T02:44:59Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +173,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(@NonNull SetupAppend setupAppend, @NonNull JsonWebToken token) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwNzM3NQ=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgyMjA2OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTozNToyMlrOGWRfCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozMDoxM1rOGWZEzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODMyOQ==", "bodyText": "Please do everything you can to avoid sleeping arbitrary amounts of time in unit tests. This just adds unnecessary delays.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426008329", "createdAt": "2020-05-15T19:35:22Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java", "diffHunk": "@@ -124,6 +136,101 @@ public void testAppend() {\n         verifyNoMoreInteractions(store);\n \n         verify(mockedRecorder).recordAppend(eq(streamSegmentName), eq(8L), eq(1), any());\n+        assertTrue(processor.isSetupAppendCompleted(setupAppendCommand.getSegment(), setupAppendCommand.getWriterId()));\n+    }\n+\n+    @Test\n+    public void testSetupAppendClosesConnectionIfTokenHasExpired() {\n+        String streamSegmentName = \"scope/stream/0.#epoch.0\";\n+        UUID clientId = UUID.randomUUID();\n+        byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };\n+        StreamSegmentStore store = mock(StreamSegmentStore.class);\n+        ServerConnection connection = mock(ServerConnection.class);\n+        ConnectionTracker tracker = mock(ConnectionTracker.class);\n+        val mockedRecorder = Mockito.mock(SegmentStatsRecorder.class);\n+\n+        AppendProcessor processor = AppendProcessor.defaultBuilder()\n+                .store(store)\n+                .connection(connection)\n+                .connectionTracker(tracker)\n+                .statsRecorder(mockedRecorder)\n+                .tokenVerifier(new TokenVerifierImpl(\"secret\"))\n+                .build();\n+\n+        setupGetAttributes(streamSegmentName, clientId, store);\n+        val ac = interceptAppend(store, streamSegmentName, updateEventNumber(clientId, data.length), CompletableFuture.completedFuture((long) data.length));\n+\n+        Date expiryDate = Date.from(Instant.now().minusSeconds(100));\n+        JsonWebToken token = new JsonWebToken(\"subject\", \"audience\", \"secret\".getBytes(), expiryDate, null);\n+\n+        SetupAppend setupAppend = new SetupAppend(1, clientId, streamSegmentName, token.toCompactString());\n+        processor.setupAppend(setupAppend);\n+        verify(connection).close();\n+    }\n+\n+    @Test\n+    public void testSetupTokenExpiryTaskClosesConnectionIfTokenHasExpired() throws InterruptedException {\n+        // Arrange\n+        String streamSegmentName = \"scope/stream/0.#epoch.0\";\n+        UUID clientId = UUID.randomUUID();\n+\n+        StreamSegmentStore mockStore = mock(StreamSegmentStore.class);\n+        ServerConnection mockConnection = mock(ServerConnection.class);\n+\n+        @Cleanup(\"shutdown\")\n+        ScheduledExecutorService executor = new InlineExecutor();\n+        AppendProcessor processor = AppendProcessor.defaultBuilder()\n+                .store(mockStore)\n+                .connection(mockConnection)\n+                .tokenExpiryHandlerExecutor(executor)\n+                .build();\n+\n+        // Spy the actual Append Processor, so that we can have some of the methods return stubbed values.\n+        AppendProcessor mockProcessor = spy(processor);\n+        doReturn(true).when(mockProcessor).isSetupAppendCompleted(streamSegmentName, clientId);\n+        // doReturn(Duration.ofMillis(20)).when(mockProcessor);\n+\n+        JsonWebToken token = new JsonWebToken(\"subject\", \"audience\", \"secret\".getBytes(),\n+                Date.from(Instant.now().plusMillis(100)), null);\n+        SetupAppend setupAppend = new SetupAppend(1, clientId, streamSegmentName, token.toCompactString());\n+\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjY4Ng==", "bodyText": "Yeah, I agree with you fully. This was supposed to be a stop-gap, until I found a better solution, but I pushed the change by mistake. In any case, the solution turned out to be quite simple, and I have pushed the change in the latest commit.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426132686", "createdAt": "2020-05-16T08:30:13Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java", "diffHunk": "@@ -124,6 +136,101 @@ public void testAppend() {\n         verifyNoMoreInteractions(store);\n \n         verify(mockedRecorder).recordAppend(eq(streamSegmentName), eq(8L), eq(1), any());\n+        assertTrue(processor.isSetupAppendCompleted(setupAppendCommand.getSegment(), setupAppendCommand.getWriterId()));\n+    }\n+\n+    @Test\n+    public void testSetupAppendClosesConnectionIfTokenHasExpired() {\n+        String streamSegmentName = \"scope/stream/0.#epoch.0\";\n+        UUID clientId = UUID.randomUUID();\n+        byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };\n+        StreamSegmentStore store = mock(StreamSegmentStore.class);\n+        ServerConnection connection = mock(ServerConnection.class);\n+        ConnectionTracker tracker = mock(ConnectionTracker.class);\n+        val mockedRecorder = Mockito.mock(SegmentStatsRecorder.class);\n+\n+        AppendProcessor processor = AppendProcessor.defaultBuilder()\n+                .store(store)\n+                .connection(connection)\n+                .connectionTracker(tracker)\n+                .statsRecorder(mockedRecorder)\n+                .tokenVerifier(new TokenVerifierImpl(\"secret\"))\n+                .build();\n+\n+        setupGetAttributes(streamSegmentName, clientId, store);\n+        val ac = interceptAppend(store, streamSegmentName, updateEventNumber(clientId, data.length), CompletableFuture.completedFuture((long) data.length));\n+\n+        Date expiryDate = Date.from(Instant.now().minusSeconds(100));\n+        JsonWebToken token = new JsonWebToken(\"subject\", \"audience\", \"secret\".getBytes(), expiryDate, null);\n+\n+        SetupAppend setupAppend = new SetupAppend(1, clientId, streamSegmentName, token.toCompactString());\n+        processor.setupAppend(setupAppend);\n+        verify(connection).close();\n+    }\n+\n+    @Test\n+    public void testSetupTokenExpiryTaskClosesConnectionIfTokenHasExpired() throws InterruptedException {\n+        // Arrange\n+        String streamSegmentName = \"scope/stream/0.#epoch.0\";\n+        UUID clientId = UUID.randomUUID();\n+\n+        StreamSegmentStore mockStore = mock(StreamSegmentStore.class);\n+        ServerConnection mockConnection = mock(ServerConnection.class);\n+\n+        @Cleanup(\"shutdown\")\n+        ScheduledExecutorService executor = new InlineExecutor();\n+        AppendProcessor processor = AppendProcessor.defaultBuilder()\n+                .store(mockStore)\n+                .connection(mockConnection)\n+                .tokenExpiryHandlerExecutor(executor)\n+                .build();\n+\n+        // Spy the actual Append Processor, so that we can have some of the methods return stubbed values.\n+        AppendProcessor mockProcessor = spy(processor);\n+        doReturn(true).when(mockProcessor).isSetupAppendCompleted(streamSegmentName, clientId);\n+        // doReturn(Duration.ofMillis(20)).when(mockProcessor);\n+\n+        JsonWebToken token = new JsonWebToken(\"subject\", \"audience\", \"secret\".getBytes(),\n+                Date.from(Instant.now().plusMillis(100)), null);\n+        SetupAppend setupAppend = new SetupAppend(1, clientId, streamSegmentName, token.toCompactString());\n+\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODMyOQ=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgyMzIwOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTozNTo0OFrOGWRfwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMzowMzoxOFrOGWXx5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODUxMg==", "bodyText": "Why?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426008512", "createdAt": "2020-05-15T19:35:48Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -66,13 +66,15 @@\n public class ServiceBuilder implements AutoCloseable {\n     //region Members\n \n-    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(30);\n+    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(45);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMTQ2MQ==", "bodyText": "This is to give some allowance as we will also be closing the new lowPriorityExecutor in addition to the two preexisting executors coreExecutor and storageExecutor. I just made a simplistic assumption here that if we give two executors 30 seconds, then we should give three of them 45.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426111461", "createdAt": "2020-05-16T03:03:18Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -66,13 +66,15 @@\n public class ServiceBuilder implements AutoCloseable {\n     //region Members\n \n-    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(30);\n+    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(45);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODUxMg=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgyNTExOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTozNjo0MFrOGWRg-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMzoxOFrOGWa7pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODgyNA==", "bodyText": "What does 2 mean here? Above you use Thread.NORM_PRIORITY. Is there another constant you can use?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426008824", "createdAt": "2020-05-15T19:36:40Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -122,8 +124,10 @@ private ServiceBuilder(ServiceBuilderConfig serviceBuilderConfig, ServiceConfig\n \n         // Setup Thread Pools.\n         String instancePrefix = getInstanceIdPrefix(serviceConfig);\n-        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\");\n-        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\");\n+        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\", Thread.NORM_PRIORITY);\n+        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\", Thread.NORM_PRIORITY);\n+        this.lowPriorityExecutor =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTA5Ng==", "bodyText": "Also do not hardcode the number of threads. Please add an entry in ServiceConfig, default it to 10, so that we may change it at any time if we encounter problems.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426009096", "createdAt": "2020-05-15T19:37:20Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -122,8 +124,10 @@ private ServiceBuilder(ServiceBuilderConfig serviceBuilderConfig, ServiceConfig\n \n         // Setup Thread Pools.\n         String instancePrefix = getInstanceIdPrefix(serviceConfig);\n-        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\");\n-        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\");\n+        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\", Thread.NORM_PRIORITY);\n+        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\", Thread.NORM_PRIORITY);\n+        this.lowPriorityExecutor =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODgyNA=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzExMQ==", "bodyText": "Sure, done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426163111", "createdAt": "2020-05-16T15:23:18Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -122,8 +124,10 @@ private ServiceBuilder(ServiceBuilderConfig serviceBuilderConfig, ServiceConfig\n \n         // Setup Thread Pools.\n         String instancePrefix = getInstanceIdPrefix(serviceConfig);\n-        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\");\n-        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\");\n+        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\", Thread.NORM_PRIORITY);\n+        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\", Thread.NORM_PRIORITY);\n+        this.lowPriorityExecutor =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODgyNA=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgzMTA4OnYy", "diffSide": "RIGHT", "path": "test/integration/src/test/java/io/pravega/test/integration/ReaderGroupTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTozODo0OFrOGWRkng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozNTo1OVrOGWZGTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTc1OA==", "bodyText": "Undo", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426009758", "createdAt": "2020-05-15T19:38:48Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ReaderGroupTest.java", "diffHunk": "@@ -67,7 +67,7 @@ public void run() {\n         }\n     }\n \n-    @Test(timeout = 20000)\n+    @Test//(timeout = 20000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzA2OA==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133068", "createdAt": "2020-05-16T08:35:59Z", "author": {"login": "ravisharda"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ReaderGroupTest.java", "diffHunk": "@@ -67,7 +67,7 @@ public void run() {\n         }\n     }\n \n-    @Test(timeout = 20000)\n+    @Test//(timeout = 20000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTc1OA=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgzNTY5OnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTo0MDoyM1rOGWRnaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozNzowOFrOGWZGkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDQ3Mw==", "bodyText": "This is probably going to hurt someone at one point if they don't know they work with this. If the return value is null, and they want to cancel it, they'll hit a nullptr exception. You'll need to return a no-op future for this.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010473", "createdAt": "2020-05-15T19:40:23Z", "author": {"login": "andreipaduroiu"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzEzNw==", "bodyText": "Sure, I've modified the code return a dummy scheduled future.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133137", "createdAt": "2020-05-16T08:37:08Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDQ3Mw=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgzNjk1OnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTo0MDo1MlrOGWRoQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozNjozM1rOGWZGbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDY4OA==", "bodyText": "Does this return value match the contract of Executor.shutdownNow?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010688", "createdAt": "2020-05-15T19:40:52Z", "author": {"login": "andreipaduroiu"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzEwMw==", "bodyText": "Yes. I've modified the code to return an empty list.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133103", "createdAt": "2020-05-16T08:36:33Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDY4OA=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgzNzYyOnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTo0MTowOFrOGWRosg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNDo0Mjo1MlrOGWatwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDgwMg==", "bodyText": "Should return true if you invoked shutdown", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010802", "createdAt": "2020-05-15T19:41:08Z", "author": {"login": "andreipaduroiu"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1OTU1Mw==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426159553", "createdAt": "2020-05-16T14:42:52Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDgwMg=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgzODI5OnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTo0MToyNFrOGWRpJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozNzoxOFrOGWZGlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDkxOQ==", "bodyText": "Should return true if terminated.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010919", "createdAt": "2020-05-15T19:41:24Z", "author": {"login": "andreipaduroiu"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzE0Mw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133143", "createdAt": "2020-05-16T08:37:18Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDkxOQ=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjgzODc4OnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTo0MTozNFrOGWRpaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwODozODowMlrOGWZG4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDk4Nw==", "bodyText": "same comment as above.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010987", "createdAt": "2020-05-15T19:41:34Z", "author": {"login": "andreipaduroiu"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> callable) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzIxNw==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133217", "createdAt": "2020-05-16T08:38:02Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> callable) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDk4Nw=="}, "originalCommit": {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzkzODQ0OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzowNDoyNVrOGXAF2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzo0NzozNFrOGXBhHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTkzMQ==", "bodyText": "Why can't you use Thread.MIN_PRIORITY?", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426771931", "createdAt": "2020-05-18T17:04:25Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -126,8 +126,8 @@ private ServiceBuilder(ServiceBuilderConfig serviceBuilderConfig, ServiceConfig\n         String instancePrefix = getInstanceIdPrefix(serviceConfig);\n         this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\", Thread.NORM_PRIORITY);\n         this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\", Thread.NORM_PRIORITY);\n-        this.lowPriorityExecutor =\n-                executorBuilder.apply(10, instancePrefix + \"low-priority-cleanup\", 2);\n+        this.lowPriorityExecutor = executorBuilder.apply(serviceConfig.getLowPriorityThreadPoolSize(),\n+                instancePrefix + \"low-priority-cleanup\", 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf90e6649ddec2c7a18a10a5225412a8c77537b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5NTI5NA==", "bodyText": "Sure, done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426795294", "createdAt": "2020-05-18T17:47:34Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -126,8 +126,8 @@ private ServiceBuilder(ServiceBuilderConfig serviceBuilderConfig, ServiceConfig\n         String instancePrefix = getInstanceIdPrefix(serviceConfig);\n         this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\", Thread.NORM_PRIORITY);\n         this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\", Thread.NORM_PRIORITY);\n-        this.lowPriorityExecutor =\n-                executorBuilder.apply(10, instancePrefix + \"low-priority-cleanup\", 2);\n+        this.lowPriorityExecutor = executorBuilder.apply(serviceConfig.getLowPriorityThreadPoolSize(),\n+                instancePrefix + \"low-priority-cleanup\", 2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTkzMQ=="}, "originalCommit": {"oid": "dbf90e6649ddec2c7a18a10a5225412a8c77537b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Nzk0NDE4OnYy", "diffSide": "RIGHT", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzowNjowNlrOGXAJcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzo0ODowMFrOGXBiEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3Mjg0OQ==", "bodyText": "Hmm.. I wonder how come checkstyle didn't catch this. We shouldn't define more than one class/interface per file.\nYou should move this as a static nested class inside the NoOpScheduledExecutor class.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426772849", "createdAt": "2020-05-18T17:06:06Z", "author": {"login": "andreipaduroiu"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -9,110 +9,173 @@\n  */\n package io.pravega.test.common;\n \n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Delayed;\n import java.util.concurrent.Future;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /**\n- * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * A fake implementation of ScheduledExecutorService that does nothing. An instance of this class may be used as a\n  * placeholder for unused scheduled executor in tests.\n  */\n public class NoOpScheduledExecutor implements ScheduledExecutorService {\n \n     private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n \n+    private AtomicBoolean isShutDown = new AtomicBoolean(false);\n+\n     public static NoOpScheduledExecutor get() {\n         return INSTANCE;\n     }\n \n     @Override\n     public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public void shutdown() {\n-\n+        isShutDown.set(true);\n     }\n \n     @Override\n     public List<Runnable> shutdownNow() {\n-        return null;\n+        isShutDown.set(true);\n+        return new ArrayList<>();\n     }\n \n     @Override\n     public boolean isShutdown() {\n-        return false;\n+        return isShutDown.get();\n     }\n \n     @Override\n     public boolean isTerminated() {\n-        return false;\n+        return isShutDown.get();\n     }\n \n     @Override\n-    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n-        return false;\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) {\n+        return isShutDown.get();\n     }\n \n     @Override\n     public <T> Future<T> submit(Callable<T> callable) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n     public <T> Future<T> submit(Runnable runnable, T t) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n     public Future<?> submit(Runnable runnable) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) throws InterruptedException {\n-        return null;\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) {\n+        return new ArrayList<>();\n     }\n \n     @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) throws InterruptedException {\n-        return null;\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) {\n+        return new ArrayList<>();\n     }\n \n     @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> collection) throws InterruptedException, ExecutionException {\n-        return null;\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection) {\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {\n-        return null;\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) {\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public void execute(Runnable runnable) {\n+    }\n+}\n+\n+@EqualsAndHashCode // Required to keep Spotbugs satisfied (owing to code in `compareTo()`).\n+@RequiredArgsConstructor\n+class DummyScheduledFuture implements ScheduledFuture<Integer> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf90e6649ddec2c7a18a10a5225412a8c77537b"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5NTUzOQ==", "bodyText": "Yeah, that sounds good. Done.", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426795539", "createdAt": "2020-05-18T17:48:00Z", "author": {"login": "ravisharda"}, "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -9,110 +9,173 @@\n  */\n package io.pravega.test.common;\n \n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Delayed;\n import java.util.concurrent.Future;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /**\n- * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * A fake implementation of ScheduledExecutorService that does nothing. An instance of this class may be used as a\n  * placeholder for unused scheduled executor in tests.\n  */\n public class NoOpScheduledExecutor implements ScheduledExecutorService {\n \n     private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n \n+    private AtomicBoolean isShutDown = new AtomicBoolean(false);\n+\n     public static NoOpScheduledExecutor get() {\n         return INSTANCE;\n     }\n \n     @Override\n     public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public void shutdown() {\n-\n+        isShutDown.set(true);\n     }\n \n     @Override\n     public List<Runnable> shutdownNow() {\n-        return null;\n+        isShutDown.set(true);\n+        return new ArrayList<>();\n     }\n \n     @Override\n     public boolean isShutdown() {\n-        return false;\n+        return isShutDown.get();\n     }\n \n     @Override\n     public boolean isTerminated() {\n-        return false;\n+        return isShutDown.get();\n     }\n \n     @Override\n-    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n-        return false;\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) {\n+        return isShutDown.get();\n     }\n \n     @Override\n     public <T> Future<T> submit(Callable<T> callable) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n     public <T> Future<T> submit(Runnable runnable, T t) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n     public Future<?> submit(Runnable runnable) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) throws InterruptedException {\n-        return null;\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) {\n+        return new ArrayList<>();\n     }\n \n     @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) throws InterruptedException {\n-        return null;\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) {\n+        return new ArrayList<>();\n     }\n \n     @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> collection) throws InterruptedException, ExecutionException {\n-        return null;\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection) {\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {\n-        return null;\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) {\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public void execute(Runnable runnable) {\n+    }\n+}\n+\n+@EqualsAndHashCode // Required to keep Spotbugs satisfied (owing to code in `compareTo()`).\n+@RequiredArgsConstructor\n+class DummyScheduledFuture implements ScheduledFuture<Integer> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3Mjg0OQ=="}, "originalCommit": {"oid": "dbf90e6649ddec2c7a18a10a5225412a8c77537b"}, "originalPosition": 147}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4254, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}