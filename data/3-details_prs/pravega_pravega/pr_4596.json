{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MDY5NzY2", "number": 4596, "title": "Issue 4590: (SegmentStore) Fixed Read Index concurrent Tier 2 read bug (Part 2)", "bodyText": "Change log description\nFixed a (second) bug in StreamSegmentReadIndex where it would have been possible for two concurrent Storage read requests to override one another, resulting in potential (in-memory) data loss should there be an append executed in between the two.\nPurpose of the change\nFixes #4590.\nWhat the code does\nSee #4592 for details on the first bug.\n#4592 handled the case when the concurrent reads began at  exactly the same Segment offset. This PR covers an additional case when two or more concurrent Tier 2 reads (resulting from cache misses) do not necessarily start at the same offset, but have at least one overlapping byte.\nThis PR aims to completely eliminate duplicated data in the Read Index due to such situations. Having Read Index entries that overlap can cause inconsistent read behaviors depending on what offset your read originated; this can also cause recently appended data to vanish from the read index (see parent issue for how this can happen).\nHow to verify it\nNew unit tests added to verify this specific scenario.", "createdAt": "2020-03-06T23:55:38Z", "url": "https://github.com/pravega/pravega/pull/4596", "merged": true, "mergeCommit": {"oid": "b57bf6c55b3712bceb5a3b938b3f23cba494e9e0"}, "closed": true, "closedAt": "2020-03-09T23:45:28Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcLJAZtAH2gAyMzg1MDY5NzY2OjhlNmViYzhkODk5N2MzYzZkNjczYzJlZDU0YTQzZDc3YTkzNTgyZmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMESZIgH2gAyMzg1MDY5NzY2OjY5YjNlNDliNWUxYjdiZTM2Nzk1OGIyYzAwNmQ1ZWExZjU1YzZlNmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8e6ebc8d8997c3c6d673c2ed54a43d77a93582fb", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/8e6ebc8d8997c3c6d673c2ed54a43d77a93582fb", "committedDate": "2020-03-06T23:48:50Z", "message": "Fixed a storage read concurrency bug.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6d37630d0b3e744a2386f2a96494edb87a14ebf", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a6d37630d0b3e744a2386f2a96494edb87a14ebf", "committedDate": "2020-03-07T03:16:45Z", "message": "Reverted unintentional change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4fd14a6e54143ae76e2edaf80f021d59df62fb7", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b4fd14a6e54143ae76e2edaf80f021d59df62fb7", "committedDate": "2020-03-07T03:18:51Z", "message": "Reverted unintentional change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "725a98cf63ac8a36bebff33bc9ec6d8c46a4a464", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/725a98cf63ac8a36bebff33bc9ec6d8c46a4a464", "committedDate": "2020-03-09T16:50:33Z", "message": "Code coverage\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79d39db7c0dc8c28c1380c51a5f8363c3aca4b45", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/79d39db7c0dc8c28c1380c51a5f8363c3aca4b45", "committedDate": "2020-03-09T16:58:16Z", "message": "Code coverage\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNDM4NjA1", "url": "https://github.com/pravega/pravega/pull/4596#pullrequestreview-371438605", "createdAt": "2020-03-09T18:45:08Z", "commit": {"oid": "79d39db7c0dc8c28c1380c51a5f8363c3aca4b45"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNDc1OTE3", "url": "https://github.com/pravega/pravega/pull/4596#pullrequestreview-371475917", "createdAt": "2020-03-09T19:42:49Z", "commit": {"oid": "79d39db7c0dc8c28c1380c51a5f8363c3aca4b45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0Mjo0OVrOFz2yNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0Mjo0OVrOFz2yNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTI4Ng==", "bodyText": "Is this line reachable? (in practice)", "url": "https://github.com/pravega/pravega/pull/4596#discussion_r389919286", "createdAt": "2020-03-09T19:42:49Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/reading/StreamSegmentReadIndex.java", "diffHunk": "@@ -577,41 +586,67 @@ private CacheIndexEntry addSingleEntryToCacheAndIndex(BufferView data, long offs\n             throw ex;\n         }\n \n-        if (rejectedEntry != null) {\n-            deleteData(rejectedEntry);\n-            if (rejectedEntry != newEntry) {\n-                log.warn(\"{}: {} overrode existing entry (Offset = {}, OldLength = {}, NewLength = {}).\",\n-                        this.traceObjectId, operationName, newEntry.getStreamSegmentOffset(), rejectedEntry.getLength(), newEntry.getLength());\n-            }\n-        }\n         return newEntry;\n     }\n \n     /**\n-     * Attempts to add the given {@link ReadIndexEntry} to the index. No cache operations are performed.\n+     * Inserts data in the index.\n      *\n-     * @param entry The {@link ReadIndexEntry} to add.\n-     * @return A rejected {@link ReadIndexEntry}. If the given entry has overridden another that already existed in the\n-     * index, the overridden one will be returned. If the given entry could not be added to the index due to another,\n-     * more up-to-date one existing already, the given entry will be returned as rejected (and no modifications will\n-     * be made to the index). A null value will be returned if there was no conflict.\n+     * @param data          A {@link BufferView} representing the data to insert.\n+     * @param segmentOffset The segment offset that maps to the first byte in the given {@link BufferView}.\n+     * @return A {@link CacheIndexEntry} representing the index entry added. If the given {@link BufferView} spanned\n+     * multiple entries (due to index fragmentation), only the last {@link CacheIndexEntry} is added.\n      */\n+    private CacheIndexEntry insertEntriesToCacheAndIndex(BufferView data, long segmentOffset) {\n+        CacheIndexEntry lastInsertedEntry = null;\n+        synchronized (this.lock) {\n+            while (data != null && data.getLength() > 0) {\n+                // Figure out if the first byte in the buffer is already cached.\n+                ReadIndexEntry existingEntry = this.indexEntries.getFloor(segmentOffset);\n+                long overlapLength;\n+                if (existingEntry != null && existingEntry.getLastStreamSegmentOffset() >= segmentOffset) {\n+                    // First offset exists already. We need to skip over to the end of this entry.\n+                    overlapLength = existingEntry.getStreamSegmentOffset() + existingEntry.getLength() - segmentOffset;\n+                    segmentOffset += overlapLength;\n+                } else {\n+                    // First offset does not exist. Let's find out how much we can insert.\n+                    existingEntry = this.indexEntries.getCeiling(segmentOffset);\n+                    overlapLength = existingEntry == null ? data.getLength() : existingEntry.getStreamSegmentOffset() - segmentOffset;\n+                    assert overlapLength > 0 : \"indexEntries.getFloor(offset) == null != indexEntries.getCeiling(offset)\";\n+\n+                    // Slice the data that we need to insert. We may be able to insert the whole buffer at once.\n+                    BufferView dataToInsert = overlapLength >= data.getLength() ? data : data.slice(0, (int) overlapLength);\n+                    CacheIndexEntry newEntry;\n+                    int dataAddress = this.cacheStorage.insert(dataToInsert);\n+                    try {\n+                        newEntry = new CacheIndexEntry(segmentOffset, dataToInsert.getLength(), dataAddress);\n+                        ReadIndexEntry overriddenEntry = addToIndex(newEntry);\n+                        assert overriddenEntry == null : \"Insert overrode existing entry; \" + segmentOffset + \":\" + dataToInsert.getLength();\n+                        lastInsertedEntry = newEntry;\n+                    } catch (Throwable ex) {\n+                        // Clean up the data we inserted if we were unable to add it to the index.\n+                        this.cacheStorage.delete(dataAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d39db7c0dc8c28c1380c51a5f8363c3aca4b45"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69b3e49b5e1b7be367958b2c006d5ea1f55c6e6b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/69b3e49b5e1b7be367958b2c006d5ea1f55c6e6b", "committedDate": "2020-03-09T20:52:53Z", "message": "Logging uncaught errors from insert callbacks.\nAdded a unit test to verify cache insert failure handling.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3616, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}