{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2OTUyNzg3", "number": 4617, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1MzowN1rODnR8sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMjowMDowMVrODnpslA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE1MTIwOnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1MzowN1rOF1L_Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDozOToyMVrOF1N2gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTI2Nw==", "bodyText": "If the threshold is configurable, then please add it into config.properties as commented line with description.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391315267", "createdAt": "2020-03-11T22:53:07Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -93,6 +97,7 @@ private ExtendedS3StorageConfig(TypedProperties properties) throws Configuration\n         String givenPrefix = Preconditions.checkNotNull(properties.get(PREFIX), \"prefix\");\n         this.prefix = givenPrefix.endsWith(PATH_SEPARATOR) ? givenPrefix : givenPrefix + PATH_SEPARATOR;\n         this.useNoneMatch = properties.getBoolean(USENONEMATCH);\n+        this.smallObjectThreshold = properties.getInt(SMALL_OBJECT_THRESHOLD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODY0Nw==", "bodyText": "+1. In config.properties, please add recommended values and explain what could happen if setting it too small or too large.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391318647", "createdAt": "2020-03-11T23:02:58Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -93,6 +97,7 @@ private ExtendedS3StorageConfig(TypedProperties properties) throws Configuration\n         String givenPrefix = Preconditions.checkNotNull(properties.get(PREFIX), \"prefix\");\n         this.prefix = givenPrefix.endsWith(PATH_SEPARATOR) ? givenPrefix : givenPrefix + PATH_SEPARATOR;\n         this.useNoneMatch = properties.getBoolean(USENONEMATCH);\n+        this.smallObjectThreshold = properties.getInt(SMALL_OBJECT_THRESHOLD);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTI2Nw=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyNjM1Mg==", "bodyText": "Do we use any kind of prefix to highlight which component this config property from? Something like extendeds3.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391326352", "createdAt": "2020-03-11T23:27:36Z", "author": {"login": "medvedevigorek"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -93,6 +97,7 @@ private ExtendedS3StorageConfig(TypedProperties properties) throws Configuration\n         String givenPrefix = Preconditions.checkNotNull(properties.get(PREFIX), \"prefix\");\n         this.prefix = givenPrefix.endsWith(PATH_SEPARATOR) ? givenPrefix : givenPrefix + PATH_SEPARATOR;\n         this.useNoneMatch = properties.getBoolean(USENONEMATCH);\n+        this.smallObjectThreshold = properties.getInt(SMALL_OBJECT_THRESHOLD);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTI2Nw=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyNzY2OA==", "bodyText": "yes, there are namespaces for configs. so in config.properties it's going to be something like extendeds3.smallObjectThreshold, which will be only picked up by ExtendedS3Config", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391327668", "createdAt": "2020-03-11T23:32:08Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -93,6 +97,7 @@ private ExtendedS3StorageConfig(TypedProperties properties) throws Configuration\n         String givenPrefix = Preconditions.checkNotNull(properties.get(PREFIX), \"prefix\");\n         this.prefix = givenPrefix.endsWith(PATH_SEPARATOR) ? givenPrefix : givenPrefix + PATH_SEPARATOR;\n         this.useNoneMatch = properties.getBoolean(USENONEMATCH);\n+        this.smallObjectThreshold = properties.getInt(SMALL_OBJECT_THRESHOLD);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTI2Nw=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NTc5NQ==", "bodyText": "Good catch @kevinhan88 .Added to config value.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391345795", "createdAt": "2020-03-12T00:39:21Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -93,6 +97,7 @@ private ExtendedS3StorageConfig(TypedProperties properties) throws Configuration\n         String givenPrefix = Preconditions.checkNotNull(properties.get(PREFIX), \"prefix\");\n         this.prefix = givenPrefix.endsWith(PATH_SEPARATOR) ? givenPrefix : givenPrefix + PATH_SEPARATOR;\n         this.useNoneMatch = properties.getBoolean(USENONEMATCH);\n+        this.smallObjectThreshold = properties.getInt(SMALL_OBJECT_THRESHOLD);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTI2Nw=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE1OTY1OnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1Njo1MVrOF1MEag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDozODo0N1rOF1N2Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNjU4Ng==", "bodyText": "Can you break these into 2 different methods please? It will make it so much easier to read.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391316586", "createdAt": "2020-03-11T22:56:51Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyNzA1Mg==", "bodyText": "Shall the size of a segment to merge be strictly less than the threshold?", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391327052", "createdAt": "2020-03-11T23:29:57Z", "author": {"login": "medvedevigorek"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNjU4Ng=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDg0Mw==", "bodyText": "broke those into two methods.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391344843", "createdAt": "2020-03-12T00:35:14Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNjU4Ng=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NTY4Mw==", "bodyText": "check is such that large object is greater than threshold", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391345683", "createdAt": "2020-03-12T00:38:47Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNjU4Ng=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE2Mzc1OnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1ODo0M1rOF1MG4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDozNzo1OFrOF1N1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNzIxNg==", "bodyText": "What exceptions are you catching here? Blindly catching Exception is a bad thing.\nCan this partially copy the source segment and then throw an exception? IF true, then we have a problem and we might have to read the object into a byte array and then write it back fully.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391317216", "createdAt": "2020-03-11T22:58:43Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NTQwNA==", "bodyText": "Actually we don't need to handle exception here. It will bubble up to execute method in this class and then will be handled in throwException", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391345404", "createdAt": "2020-03-12T00:37:38Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNzIxNg=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NTQ3Mg==", "bodyText": "remove catch block, we don't need it.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391345472", "createdAt": "2020-03-12T00:37:58Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNzIxNg=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE2NDIyOnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1ODo1OVrOF1MHLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDozOTo0MVrOF1N2yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNzI5NA==", "bodyText": "This line is the same as in the block above. Move it out.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391317294", "createdAt": "2020-03-11T22:58:59Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NTg2Ng==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391345866", "createdAt": "2020-03-12T00:39:41Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNzI5NA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE3MDIwOnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzowMTo1OFrOF1MLIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyNzo1M1rOF1Oitg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODMwNQ==", "bodyText": "What does smallObjectThreshold mean? Someone who has no idea what this means will not be able to use this properly.\nSecond you must always include the unit of measure in your property names. Is this bytes, KB, MB, ..., TB?\nPlease name this something more appropriate, such as nativeConcatThresholdBytes or multiPartUploadConcatThresholdBytes .", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391318305", "createdAt": "2020-03-11T23:01:58Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -30,6 +30,7 @@\n     public static final Property<String> BUCKET = Property.named(\"bucket\", \"\");\n     public static final Property<String> PREFIX = Property.named(\"prefix\", \"/\");\n     public static final Property<Boolean> USENONEMATCH = Property.named(\"useNoneMatch\", false);\n+    public static final Property<Integer> SMALL_OBJECT_THRESHOLD = Property.named(\"smallObjectThreshold\", 1024 * 1024);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NzExMA==", "bodyText": "renamed", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391357110", "createdAt": "2020-03-12T01:27:53Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -30,6 +30,7 @@\n     public static final Property<String> BUCKET = Property.named(\"bucket\", \"\");\n     public static final Property<String> PREFIX = Property.named(\"prefix\", \"/\");\n     public static final Property<Boolean> USENONEMATCH = Property.named(\"useNoneMatch\", false);\n+    public static final Property<Integer> SMALL_OBJECT_THRESHOLD = Property.named(\"smallObjectThreshold\", 1024 * 1024);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODMwNQ=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE3MTE2OnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzowMjoxOFrOF1MLqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzowMjoxOFrOF1MLqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODQ0Mw==", "bodyText": "Add a comment to the field explaining exactly what the behavior is.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391318443", "createdAt": "2020-03-11T23:02:18Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -75,6 +76,9 @@\n     @Getter\n     private final boolean useNoneMatch;\n \n+    @Getter\n+    private final int smallObjectThreshold;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE3MzQ5OnYy", "diffSide": "RIGHT", "path": "bindings/src/test/java/io/pravega/storage/extendeds3/ExtendedS3StorageTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzowMzoyMlrOF1MNAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyODoxMVrOF1OjAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODc4Ng==", "bodyText": "How do you know MPU was used?", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391318786", "createdAt": "2020-03-11T23:03:22Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/test/java/io/pravega/storage/extendeds3/ExtendedS3StorageTest.java", "diffHunk": "@@ -227,6 +227,26 @@ public void testExistsWithPrefix() throws Exception {\n         }\n     }\n \n+    /**\n+     * Tests the concat() method forcing to use multipart upload.\n+     *\n+     * @throws Exception if an unexpected error occurred.\n+     */\n+    @Test\n+    public void testConcatWithMultipartUpload() throws Exception {\n+        val adapterConfig = ExtendedS3StorageConfig.builder()\n+                .with(ExtendedS3StorageConfig.CONFIGURI, setup.configUri)\n+                .with(ExtendedS3StorageConfig.BUCKET, setup.adapterConfig.getBucket())\n+                .with(ExtendedS3StorageConfig.PREFIX, \"samplePrefix\")\n+                .with(ExtendedS3StorageConfig.USENONEMATCH, true)\n+                .with(ExtendedS3StorageConfig.SMALL_OBJECT_THRESHOLD, 1)\n+                .build();\n+        final String context = createSegmentName(\"Concat\");\n+        try (Storage s = createStorage(setup.client, adapterConfig, executorService())) {\n+            testConcat(context, s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NzE4NA==", "bodyText": "added check", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391357184", "createdAt": "2020-03-12T01:28:11Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/test/java/io/pravega/storage/extendeds3/ExtendedS3StorageTest.java", "diffHunk": "@@ -227,6 +227,26 @@ public void testExistsWithPrefix() throws Exception {\n         }\n     }\n \n+    /**\n+     * Tests the concat() method forcing to use multipart upload.\n+     *\n+     * @throws Exception if an unexpected error occurred.\n+     */\n+    @Test\n+    public void testConcatWithMultipartUpload() throws Exception {\n+        val adapterConfig = ExtendedS3StorageConfig.builder()\n+                .with(ExtendedS3StorageConfig.CONFIGURI, setup.configUri)\n+                .with(ExtendedS3StorageConfig.BUCKET, setup.adapterConfig.getBucket())\n+                .with(ExtendedS3StorageConfig.PREFIX, \"samplePrefix\")\n+                .with(ExtendedS3StorageConfig.USENONEMATCH, true)\n+                .with(ExtendedS3StorageConfig.SMALL_OBJECT_THRESHOLD, 1)\n+                .build();\n+        final String context = createSegmentName(\"Concat\");\n+        try (Storage s = createStorage(setup.client, adapterConfig, executorService())) {\n+            testConcat(context, s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODc4Ng=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE3NzI0OnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzowNTowNVrOF1MPNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODozNjoxN1rOF1qnug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA==", "bodyText": "Only delete original object in case of success, right? move this line into try block.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391319350", "createdAt": "2020-03-11T23:05:05Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyODg4Mw==", "bodyText": "Delete operation may fail too.  Need some error handling here and of course sufficient logging.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391328883", "createdAt": "2020-03-11T23:36:14Z", "author": {"login": "medvedevigorek"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MzIzMA==", "bodyText": "Yes. actually this could be a nasty bug. If concat succeeds but delete fails then we are leaving target segment in a state where it is bigger than before. But for the caller the operation has failed so it will not update size. If now operation is retried it will be done with older offset which will fail again and again. Solution is to either move delete as a separate step to upper layers or not fail the concat call when delete operation fails.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391363230", "createdAt": "2020-03-12T01:56:51Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzMzNg==", "bodyText": "This is not as bad as you think. If the concat succeeds but the delete fails, the storage writer will reattempt. You will need to throw a BadOffsetException because your precondition will not hold. The StorageWriter will them enter a reconciliation state and figure out that the source segment has actually been merged in.\nThe only downside is that the old segment will be left behind, occupying space but not being used.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391707336", "createdAt": "2020-03-12T15:37:36Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MDE0Nw==", "bodyText": "Okay, it makes sense then.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391740147", "createdAt": "2020-03-12T16:27:05Z", "author": {"login": "medvedevigorek"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0NjM4MQ==", "bodyText": "I just realized that in case of delete failures, the concat operation will be retried with same offset and we'll simply overwrite the same byte range with same contents. There is a test case that tests this idempotent behavior (concat at same offset). If the delete failure was intermittent then eventually it will succeed. Otherwise its likely that root cause will manifest in other operations too.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391746381", "createdAt": "2020-03-12T16:36:30Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0NjY3NA==", "bodyText": "The other observation is S3Client being used here doesn't declare any exceptions for its methods but actually it does throw S3Exception if it receives a response with status code other than 2xx.\nSince S3Exception is defined as a runtime exception we need to ensure the call stack handles it correctly and doesn't lead to a serious disaster as it may not assume to handle a runtime exception at all.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391746674", "createdAt": "2020-03-12T16:37:00Z", "author": {"login": "medvedevigorek"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNzE0Ng==", "bodyText": "Updated to throw BadOffsetException on failure during delete. This will trigger reconciliation.\nIn normal course we continue to allow concat to be idempotent.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391817146", "createdAt": "2020-03-12T18:36:17Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTM1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE3OTIxOnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzowNTo0OFrOF1MQYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyODo1OVrOF1OjxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTY1MA==", "bodyText": "Please give more information here with the exception, particularly this is something new we're trying", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391319650", "createdAt": "2020-03-11T23:05:48Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NzM4MA==", "bodyText": "actually we don't need to catch exception here.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391357380", "createdAt": "2020-03-12T01:28:59Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -403,39 +405,53 @@ private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegm\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n-        //Copy the first part\n-        CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n-                targetPath,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                1).withSourceRange(Range.fromOffsetLength(0, offset));\n-        CopyPartResult copyResult = client.copyPart(copyRequest);\n-\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Copy the second part\n-        S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n-                config.getPrefix() + sourceSegment);\n-        long objectSize = metadataResult.getContentLength(); // in bytes\n-\n-        copyRequest = new CopyPartRequest(config.getBucket(),\n-                config.getPrefix() + sourceSegment,\n-                config.getBucket(),\n-                targetPath,\n-                uploadId,\n-                2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n-\n-        copyResult = client.copyPart(copyRequest);\n-        partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n-\n-        //Close the upload\n-        client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n-                targetPath, uploadId).withParts(partEtags));\n-\n-        client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n-        Duration elapsed = timer.getElapsed();\n+        if (config.getSmallObjectThreshold() < si.getLength()) {\n+\n+            //Copy the first part\n+            CopyPartRequest copyRequest = new CopyPartRequest(config.getBucket(),\n+                    targetPath,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    1).withSourceRange(Range.fromOffsetLength(0, offset));\n+            CopyPartResult copyResult = client.copyPart(copyRequest);\n+\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n+\n+            //Copy the second part\n+            S3ObjectMetadata metadataResult = client.getObjectMetadata(config.getBucket(),\n+                    config.getPrefix() + sourceSegment);\n+            long objectSize = metadataResult.getContentLength(); // in bytes\n+\n+            copyRequest = new CopyPartRequest(config.getBucket(),\n+                    config.getPrefix() + sourceSegment,\n+                    config.getBucket(),\n+                    targetPath,\n+                    uploadId,\n+                    2).withSourceRange(Range.fromOffsetLength(0, objectSize));\n+\n+            copyResult = client.copyPart(copyRequest);\n+            partEtags.add(new MultipartPartETag(copyResult.getPartNumber(), copyResult.getETag()));\n \n+            //Close the upload\n+            client.completeMultipartUpload(new CompleteMultipartUploadRequest(config.getBucket(),\n+                    targetPath, uploadId).withParts(partEtags));\n+\n+            client.deleteObject(config.getBucket(), config.getPrefix() + sourceSegment);\n+\n+        } else {\n+            try (InputStream reader = client.readObjectStream(config.getBucket(),\n+                    config.getPrefix() + sourceSegment, Range.fromOffsetLength(0, si.getLength()))) {\n+                client.putObject(this.config.getBucket(),\n+                        targetPath,\n+                        Range.fromOffsetLength(offset, si.getLength()),\n+                        new BufferedInputStream(reader, Math.toIntExact(si.getLength())));\n+            } catch (Exception e) {\n+                throw Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxOTY1MA=="}, "originalCommit": {"oid": "72502422c719cfee0ee90c16eacfa30e8919dc03"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTQwOTQ0OnYy", "diffSide": "RIGHT", "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyMDozMlrOF1Ob4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMTo0MzozNVrOF1OvtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTM2Mg==", "bodyText": "It says LARGE concat count but with literal value of \"small\"", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391355362", "createdAt": "2020-03-12T01:20:32Z", "author": {"login": "kevinhan88"}, "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "diffHunk": "@@ -108,6 +108,7 @@\n     public static final String STORAGE_CREATE_COUNT = PREFIX + \"segmentstore.storage.create_count\";      // Counter\n     public static final String STORAGE_DELETE_COUNT = PREFIX + \"segmentstore.storage.delete_count\";      // Counter\n     public static final String STORAGE_CONCAT_COUNT = PREFIX + \"segmentstore.storage.concat_count\";      // Counter\n+    public static final String STORAGE_LARGE_CONCAT_COUNT = PREFIX + \"segmentstore.storage.small_concat_count\"; // Counter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1ODA2Nw==", "bodyText": "oh no!", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391358067", "createdAt": "2020-03-12T01:32:30Z", "author": {"login": "sachin-j-joshi"}, "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "diffHunk": "@@ -108,6 +108,7 @@\n     public static final String STORAGE_CREATE_COUNT = PREFIX + \"segmentstore.storage.create_count\";      // Counter\n     public static final String STORAGE_DELETE_COUNT = PREFIX + \"segmentstore.storage.delete_count\";      // Counter\n     public static final String STORAGE_CONCAT_COUNT = PREFIX + \"segmentstore.storage.concat_count\";      // Counter\n+    public static final String STORAGE_LARGE_CONCAT_COUNT = PREFIX + \"segmentstore.storage.small_concat_count\"; // Counter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTM2Mg=="}, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MDQzNg==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391360436", "createdAt": "2020-03-12T01:43:35Z", "author": {"login": "sachin-j-joshi"}, "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "diffHunk": "@@ -108,6 +108,7 @@\n     public static final String STORAGE_CREATE_COUNT = PREFIX + \"segmentstore.storage.create_count\";      // Counter\n     public static final String STORAGE_DELETE_COUNT = PREFIX + \"segmentstore.storage.delete_count\";      // Counter\n     public static final String STORAGE_CONCAT_COUNT = PREFIX + \"segmentstore.storage.concat_count\";      // Counter\n+    public static final String STORAGE_LARGE_CONCAT_COUNT = PREFIX + \"segmentstore.storage.small_concat_count\"; // Counter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTM2Mg=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTQxNjI2OnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyNDozM1rOF1Oftg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyNDozM1rOF1Oftg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjM0Mg==", "bodyText": "Why the metric says Large but config is called small? Please straight them out.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391356342", "createdAt": "2020-03-12T01:24:33Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -93,6 +97,7 @@ private ExtendedS3StorageConfig(TypedProperties properties) throws Configuration\n         String givenPrefix = Preconditions.checkNotNull(properties.get(PREFIX), \"prefix\");\n         this.prefix = givenPrefix.endsWith(PATH_SEPARATOR) ? givenPrefix : givenPrefix + PATH_SEPARATOR;\n         this.useNoneMatch = properties.getBoolean(USENONEMATCH);\n+        this.smallObjectThreshold = properties.getInt(SMALL_OBJECT_THRESHOLD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTQxNzE0OnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyNToxMVrOF1OgSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMTo0OToyOVrOF1O0Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjQ5MQ==", "bodyText": "Please add unit into the name as commented.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391356491", "createdAt": "2020-03-12T01:25:11Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -30,6 +30,7 @@\n     public static final Property<String> BUCKET = Property.named(\"bucket\", \"\");\n     public static final Property<String> PREFIX = Property.named(\"prefix\", \"/\");\n     public static final Property<Boolean> USENONEMATCH = Property.named(\"useNoneMatch\", false);\n+    public static final Property<Integer> SMALL_OBJECT_THRESHOLD = Property.named(\"smallObjectThreshold\", 1024 * 1024);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MTU5OA==", "bodyText": "value is in bytes so by convention without suffix.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391361598", "createdAt": "2020-03-12T01:49:29Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3StorageConfig.java", "diffHunk": "@@ -30,6 +30,7 @@\n     public static final Property<String> BUCKET = Property.named(\"bucket\", \"\");\n     public static final Property<String> PREFIX = Property.named(\"prefix\", \"/\");\n     public static final Property<Boolean> USENONEMATCH = Property.named(\"useNoneMatch\", false);\n+    public static final Property<Integer> SMALL_OBJECT_THRESHOLD = Property.named(\"smallObjectThreshold\", 1024 * 1024);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjQ5MQ=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTQyOTIzOnYy", "diffSide": "RIGHT", "path": "config/config.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMTozNDowNFrOF1On4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMTo0OTo0NVrOF1O0bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1ODQzMg==", "bodyText": "Please call out what is the default value, which really matters in the case.\nAlso consider saying something like: \"In most cases, the default value should just work. Change this value with cautiousness.\"", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391358432", "createdAt": "2020-03-12T01:34:04Z", "author": {"login": "kevinhan88"}, "path": "config/config.properties", "diffHunk": "@@ -448,6 +448,15 @@ extendeds3.configUri=http://localhost:9020?identity=user&secretKey=password\n # Prefix is optional.\n # extendeds3.prefix=\n \n+# Size of ECS objects in bytes above which it is no longer considered a small object.\n+# This value is used to optimize transactions performance when size of transaction segments is small.\n+# For small transaction segments, to implement concat ExtendedS3Storage reads complete source segment and appends it to target\n+# instead of using multipart upload.\n+# smallObjectSizeLimitForConcat is optional.\n+# Valid values: Positive integer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2MTY0NA==", "bodyText": "Good point. Updated", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391361644", "createdAt": "2020-03-12T01:49:45Z", "author": {"login": "sachin-j-joshi"}, "path": "config/config.properties", "diffHunk": "@@ -448,6 +448,15 @@ extendeds3.configUri=http://localhost:9020?identity=user&secretKey=password\n # Prefix is optional.\n # extendeds3.prefix=\n \n+# Size of ECS objects in bytes above which it is no longer considered a small object.\n+# This value is used to optimize transactions performance when size of transaction segments is small.\n+# For small transaction segments, to implement concat ExtendedS3Storage reads complete source segment and appends it to target\n+# instead of using multipart upload.\n+# smallObjectSizeLimitForConcat is optional.\n+# Valid values: Positive integer.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1ODQzMg=="}, "originalCommit": null, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTAzNDkzOnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTo1Nzo1NlrOF1xZtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMjo0OTozM1rOF1yfLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyODI0NQ==", "bodyText": "concat_count should be updated before calling deleteObject() otherwise it will not be consistent with large_concat_count in case of deleteObject() fails.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391928245", "createdAt": "2020-03-12T21:57:56Z", "author": {"login": "medvedevigorek"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);\n+        ExtendedS3Metrics.CONCAT_BYTES.add(si.getLength());\n+        ExtendedS3Metrics.CONCAT_COUNT.inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTIyMQ==", "bodyText": "In other words we should update them around the same time. I prefer after, so that we may only record successful runs.\nIf we record it before, then every retry will be counted, which is not what we want.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391931221", "createdAt": "2020-03-12T22:05:14Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);\n+        ExtendedS3Metrics.CONCAT_BYTES.add(si.getLength());\n+        ExtendedS3Metrics.CONCAT_COUNT.inc();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyODI0NQ=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0NjAzMA==", "bodyText": "I think I would agree with @andreipaduroiu , for 0.7 let's record metrics only for successful events. Let's track this as a separate issue to be resolved  in 0.8 along with BadOffsetException change.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391946030", "createdAt": "2020-03-12T22:49:33Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);\n+        ExtendedS3Metrics.CONCAT_BYTES.add(si.getLength());\n+        ExtendedS3Metrics.CONCAT_COUNT.inc();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyODI0NQ=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTA0MjEyOnYy", "diffSide": "RIGHT", "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMjowMDowMVrOF1xd7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMjo1MToxNVrOF1yhLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTMyNg==", "bodyText": "latency and bytes are recorded only in case of success, in case of a failure in deleteObject() those will not be recorded. Don't they need to be recorded anyway?", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391929326", "createdAt": "2020-03-12T22:00:01Z", "author": {"login": "medvedevigorek"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMDgwOQ==", "bodyText": "We never record these for failed requests.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391930809", "createdAt": "2020-03-12T22:04:05Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTMyNg=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzNTkxOQ==", "bodyText": "We can start reportFailEvent in case concat (or/and delete) failed.\nWe may report success only after both concat and delete succeeded, otherwise report failure.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391935919", "createdAt": "2020-03-12T22:18:15Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTMyNg=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzNjc0Nw==", "bodyText": "Yes, we could do that. But this would be the only place in the code we currently do that. We can tackle this as a widespread change in another PR.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391936747", "createdAt": "2020-03-12T22:20:32Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTMyNg=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzNzE0Mg==", "bodyText": "Shall we delete the source segment through ExtendedS3Storage.delete(), instead of calling client.delete() directly?\nGoing through that path, we have Tier2 DELETE metrics triggered.", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391937142", "createdAt": "2020-03-12T22:21:40Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTMyNg=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzODIzNA==", "bodyText": "Yes, just overload the doDelete(SegmentHandle handle) with doDelete(String bucket, String prefix, String segmentName).", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391938234", "createdAt": "2020-03-12T22:25:02Z", "author": {"login": "kevinhan88"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTMyNg=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0NjU0Mg==", "bodyText": "For 0.7 let's update metrics for only successful requests.\nLet's track the issue as separate issue for 0.8", "url": "https://github.com/pravega/pravega/pull/4617#discussion_r391946542", "createdAt": "2020-03-12T22:51:15Z", "author": {"login": "sachin-j-joshi"}, "path": "bindings/src/main/java/io/pravega/storage/extendeds3/ExtendedS3Storage.java", "diffHunk": "@@ -386,23 +388,57 @@ private void setPermission(SegmentHandle handle, Permission permission) {\n      * completeMultiPartUpload call. Specifically, to concatenate, we are copying the target segment T and the\n      * source segment S to T, so essentially we are doing T <- T + S.\n      */\n-    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws StreamSegmentNotExistsException {\n+    private Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws Exception {\n         Preconditions.checkArgument(!targetHandle.isReadOnly(), \"target handle must not be read-only.\");\n         long traceId = LoggerHelpers.traceEnter(log, \"concat\", targetHandle.getSegmentName(), offset, sourceSegment);\n         Timer timer = new Timer();\n-        SortedSet<MultipartPartETag> partEtags = new TreeSet<>();\n-        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n-        String uploadId = client.initiateMultipartUpload(config.getBucket(), targetPath);\n \n+        String targetPath = config.getPrefix() + targetHandle.getSegmentName();\n         // check whether the target exists\n         if (!doExists(targetHandle.getSegmentName())) {\n             throw new StreamSegmentNotExistsException(targetHandle.getSegmentName());\n         }\n         // check whether the source is sealed\n         SegmentProperties si = doGetStreamSegmentInfo(sourceSegment);\n+        String sourcePath = config.getPrefix() + sourceSegment;\n         Preconditions.checkState(si.isSealed(), \"Cannot concat segment '%s' into '%s' because it is not sealed.\",\n                 sourceSegment, targetHandle.getSegmentName());\n \n+        if (config.getSmallObjectSizeLimitForConcat() < si.getLength()) {\n+            doConcatWithMultipartUpload(targetPath, sourceSegment, offset);\n+            ExtendedS3Metrics.LARGE_CONCAT_COUNT.inc();\n+        } else {\n+            doConcatWithAppend(targetPath, sourcePath, offset, si.getLength());\n+        }\n+        // Now delete the source object.\n+        client.deleteObject(config.getBucket(), sourcePath);\n+\n+        Duration elapsed = timer.getElapsed();\n+        log.debug(\"Concat target={} source={} offset={} bytesWritten={} latency={}.\", targetHandle.getSegmentName(), sourceSegment, offset, si.getLength(), elapsed.toMillis());\n+\n+        ExtendedS3Metrics.CONCAT_LATENCY.reportSuccessEvent(elapsed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTMyNg=="}, "originalCommit": {"oid": "9ef13dd50bd0a6e14ca8345a8fffa82e28ecb8cd"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4462, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}