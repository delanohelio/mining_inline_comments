{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMzIxOTQ4", "number": 5355, "title": "Issue 5345: (SegmentStore) Rewiring StorageWriter into DurableLog", "bodyText": "Change log description\nChanged the way DurableLog holds Tier 1 Operations in memory and how they are read by the Storage Writer. Retired uses of SequencedItemList in this case and replaced with a BlockingDrainingQueue.\nChanged the internals of BlockingDrainingQueue and PriorityBlockingDrainingQueue to use a variation of ArrayDeque  that is more efficient at polling (removing) items in bulk.\nPurpose of the change\nFixes #5345.\nWhat the code does\n\nSimpleDeque: ArrayDeque-like implementation that has an extra method (pollFirst(int)) which efficiently removes a number of items from the head of the queue. This is more efficient than pulling one item out at a time and accumulating the result in a collection.\nUpdated BlockingDrainingQueue and PriorityBlockingDrainingQueue to make use of SimpleDeque internally (in lieu of ArrayDeque).\n\nBoth of these classes are meant to extract items in bulk (1000 or 10,000 at once), so such a method should improve runtime performance.\n\n\nDurableLog\n\nChanged the \"In-Memory Log\" to not be an identical replica of the Operations that exist in Tier 1.\nThis Log now contains only those Operations that have been written to Tier 1 but not yet picked up for processing by the StorageWriter. As soon as the StorageWriter picks them up, they are removed from this in-memory log.\nUsing a BlockingDrainingQueue to implement this in-memory log.\nThis required an update to the DurableLog.read method (new contract, new signature) and triggered some changes downstream in the StorageWriter (to adapt to the new API).\nThis simplified the internals of the DurableLog quite a bit. All the complex reading, including tail reads with timeout, is now delegated to the BlockingDrainingQueue, which is much nimbler at this task (that class is used twice in the OperationProcessor already).\n\n\n\nHow to verify it\nAll tests must pass.", "createdAt": "2020-11-18T16:48:51Z", "url": "https://github.com/pravega/pravega/pull/5355", "merged": true, "mergeCommit": {"oid": "dd258b46c7fbea53a60d01874e13a021d341321f"}, "closed": true, "closedAt": "2020-11-22T18:58:25Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddj8A2AH2gAyNTIzMzIxOTQ4OmJiOWU3OTQ5YWU5NTkwNjExZDA0YzdmOWQ2MDA4Yjc3Y2NmNDQyYTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdefVW-gH2gAyNTIzMzIxOTQ4OjEyMzI0ZmE1YzI3MGNhNTI1YWQ5YTI2OGRlNzQ2MmFlMzdiMjgzZTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bb9e7949ae9590611d04c7f9d6008b77ccf442a5", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/bb9e7949ae9590611d04c7f9d6008b77ccf442a5", "committedDate": "2020-11-18T01:33:16Z", "message": "Retired SequencedItemList.\nAbstractDrainingQueue.take overload with timeout.\nChanged OperationLog.read to return a Collection of unread items.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "664416436d87731a30f1f503bf2b02597c2affaf", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/664416436d87731a30f1f503bf2b02597c2affaf", "committedDate": "2020-11-18T02:01:06Z", "message": "Unit tests for AbstractDrainingQueue and InMemoryLog.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31cfe440d15d0b510974c8588a50cef91415fae2", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/31cfe440d15d0b510974c8588a50cef91415fae2", "committedDate": "2020-11-18T16:23:47Z", "message": "Updated DurableLogTests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1890c79b584112f62b0193b3b0ff4b7352b4099e", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/1890c79b584112f62b0193b3b0ff4b7352b4099e", "committedDate": "2020-11-18T16:47:10Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5345-storage-writer-data-source"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a44d1227227358a90aa7c0a58d6c18e33496e51", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/1a44d1227227358a90aa7c0a58d6c18e33496e51", "committedDate": "2020-11-18T22:31:55Z", "message": "Using SimpleDeque instead of ArrayDeque in BlockingDrainingQueue and PriorityBlockingDrainingQueue\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc9e798f66ef6ae2a2bf44b1a367efb0b49960ff", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/fc9e798f66ef6ae2a2bf44b1a367efb0b49960ff", "committedDate": "2020-11-19T15:24:33Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5345-storage-writer-data-source\n\n# Conflicts:\n#\tsegmentstore/server/src/main/java/io/pravega/segmentstore/server/SegmentStoreMetrics.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a6a04b1b39e9eb32712b280512f67143de2b221a", "committedDate": "2020-11-19T15:32:48Z", "message": "Merge conflicts and unit test fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0Njk1NTAx", "url": "https://github.com/pravega/pravega/pull/5355#pullrequestreview-534695501", "createdAt": "2020-11-19T17:42:06Z", "commit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzo0MjowNlrOH2qPqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzo0MjowNlrOH2qPqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzI4OA==", "bodyText": "Why 16 has been chosen as the initialization value?", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527077288", "createdAt": "2020-11-19T17:42:06Z", "author": {"login": "RaulGracia"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0ODgxMTQy", "url": "https://github.com/pravega/pravega/pull/5355#pullrequestreview-534881142", "createdAt": "2020-11-19T21:45:39Z", "commit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo0NTozOVrOH2zIDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoyOToxOVrOH20mpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMjc5OA==", "bodyText": "This code is assuming that this: https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#setRemoveOnCancelPolicy-boolean-\nis set to true on the thread pool. confirm is the case and maybe document this.", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527222798", "createdAt": "2020-11-19T21:45:39Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractDrainingQueue.java", "diffHunk": "@@ -147,6 +152,41 @@ public void add(T item) {\n         }\n     }\n \n+    /**\n+     * Returns the next items from the queue. If the queue is empty, it blocks the call until at least one item is added,\n+     * or until the given timeout expires.\n+     *\n+     * @param maxCount        The maximum number of items to return. This argument will be ignored if the queue is currently\n+     *                        empty, but in that case the result will always be completed with exactly one element.\n+     * @param timeout         Timeout.\n+     * @param timeoutExecutor An Executor to use for timing out.\n+     * @return A CompletableFuture that, when completed, will contain the requested result. If the queue is not currently\n+     * empty, this Future will already be completed, otherwise it will be completed the next time the add() method is called.\n+     * If the queue is closed and this Future is not yet completed, it will be cancelled. If the timeout expires prior\n+     * to adding a new element, this future will be completed with a {@link TimeoutException}.\n+     * @throws ObjectClosedException If the Queue is closed.\n+     * @throws IllegalStateException If another call to take() is in progress.\n+     */\n+    public CompletableFuture<Queue<T>> take(int maxCount, Duration timeout, ScheduledExecutorService timeoutExecutor) {\n+        CompletableFuture<Queue<T>> result = take(maxCount);\n+        if (!result.isDone()) {\n+            ScheduledFuture<?> sf = timeoutExecutor.schedule(() -> {\n+                synchronized (this.lock) {\n+                    if (this.pendingTake == result) {\n+                        this.pendingTake = null;\n+                    }\n+                }\n+\n+                // Timeout the future after we have unregistered it. A zealous callback may invoke us immediately and be\n+                // surprised that their call is rejected since we can only have one take() outstanding at any given time.\n+                result.completeExceptionally(new TimeoutException());\n+            }, timeout.toMillis(), TimeUnit.MILLISECONDS);\n+            result.whenComplete((r, ex) -> sf.cancel(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzMTExNw==", "bodyText": "The correctness of this function and several others are predicated on the fact that there is always at least one empty position in the array. This appears to be enforced but it probably worth explicitly stating in a comment somewhere.", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527231117", "createdAt": "2020-11-19T22:01:11Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTU0NQ==", "bodyText": "Based on the above definition of addLast I don't believe this.tail == this.head && newItems[this.head] != null can ever be true.", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527235545", "createdAt": "2020-11-19T22:09:38Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNzAyMQ==", "bodyText": "Can't a fill do this? (Or it could be avoided per my above comment)", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527237021", "createdAt": "2020-11-19T22:12:38Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzODU3NQ==", "bodyText": "Looking at the implementation of this method, it would be more efficient to just allocate a new array, then copy the part after head and then copy the part up until tail if it was wrapped.", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527238575", "createdAt": "2020-11-19T22:14:49Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTg5Ng==", "bodyText": "Per the documentation here:\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html\nElement is a variation on peek not on poll.", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527241896", "createdAt": "2020-11-19T22:19:00Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {\n+                newItems[idx] = null;\n+                idx++;\n+            }\n+        }\n+\n+        this.items = newItems;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Size = %s, Capacity = %s, Head = %s, Tail = %s\", size(), this.items.length, this.head, this.tail);\n+    }\n+\n+    //endregion\n+\n+    //region WrapQueue\n+\n+    @RequiredArgsConstructor\n+    @NotThreadSafe\n+    private static class WrapQueue<T> extends AbstractCollection<T> implements Queue<T> {\n+        private final Object[] items;\n+        private int nextIndex = 0;\n+\n+        //region Queue Implementation\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public T poll() {\n+            if (this.nextIndex >= this.items.length) {\n+                return null;\n+            }\n+\n+            return (T) this.items[this.nextIndex++];\n+        }\n+\n+        @Override\n+        public T element() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjUxMQ==", "bodyText": "Here remove is unimplemented but the function element above is doing what remove is supposed to be doing.", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527242511", "createdAt": "2020-11-19T22:20:14Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {\n+                newItems[idx] = null;\n+                idx++;\n+            }\n+        }\n+\n+        this.items = newItems;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Size = %s, Capacity = %s, Head = %s, Tail = %s\", size(), this.items.length, this.head, this.tail);\n+    }\n+\n+    //endregion\n+\n+    //region WrapQueue\n+\n+    @RequiredArgsConstructor\n+    @NotThreadSafe\n+    private static class WrapQueue<T> extends AbstractCollection<T> implements Queue<T> {\n+        private final Object[] items;\n+        private int nextIndex = 0;\n+\n+        //region Queue Implementation\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public T poll() {\n+            if (this.nextIndex >= this.items.length) {\n+                return null;\n+            }\n+\n+            return (T) this.items[this.nextIndex++];\n+        }\n+\n+        @Override\n+        public T element() {\n+            T result = poll();\n+            if (result == null) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            return result;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public T peek() {\n+            return this.nextIndex >= this.items.length ? null : (T) this.items[nextIndex];\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Iterator<T> iterator() {\n+            return Arrays.stream(this.items).skip(this.nextIndex).map(o -> (T) o).iterator();\n+        }\n+\n+        @Override\n+        public int size() {\n+            return this.items.length - this.nextIndex;\n+        }\n+\n+        //endregion\n+\n+        //region Unsupported Methods\n+\n+        @Override\n+        public boolean offer(T t) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public T remove() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjkzMw==", "bodyText": "Javadoc", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527242933", "createdAt": "2020-11-19T22:21:04Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {\n+                newItems[idx] = null;\n+                idx++;\n+            }\n+        }\n+\n+        this.items = newItems;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Size = %s, Capacity = %s, Head = %s, Tail = %s\", size(), this.items.length, this.head, this.tail);\n+    }\n+\n+    //endregion\n+\n+    //region WrapQueue\n+\n+    @RequiredArgsConstructor\n+    @NotThreadSafe\n+    private static class WrapQueue<T> extends AbstractCollection<T> implements Queue<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MzkwNQ==", "bodyText": "Shouldn't poll remove the item from q, in which case it won't matter if you modify it?", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527243905", "createdAt": "2020-11-19T22:22:58Z", "author": {"login": "tkaitchuck"}, "path": "common/src/test/java/io/pravega/common/util/PriorityBlockingDrainingQueueTests.java", "diffHunk": "@@ -155,7 +155,7 @@ public void testMultiplePriorities() {\n         Assert.assertEquals(\"Unexpected size.\", expectedItems.size(), q.size());\n         Assert.assertSame(\"Unexpected peek.\", expectedItems.first(), q.peek());\n \n-        val finalPoll = q.poll(100);\n+        val finalPoll = new ArrayDeque<>(q.poll(100)); // Make a copy since we need to modify it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NzAxMw==", "bodyText": "These two operations are not thread safe but this class extends BlockingDrainingQueue which calls itself threadsafe.\nThere are multiple race conditions:\n\nThere could be two threads the first perform the check and then both call addInternal even though the second one is before the first violating the invariant above.\nThere could be two threads which insert in one order but set lastSequenceNumber in the other order resulting in the wrong sequence number.", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527247013", "createdAt": "2020-11-19T22:29:19Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/InMemoryLog.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.logs;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.util.BlockingDrainingQueue;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+/**\n+ * {@link BlockingDrainingQueue} implementation for {@link Operation}s. Prevents adding {@link Operation}s out of order.\n+ */\n+public class InMemoryLog extends BlockingDrainingQueue<Operation> {\n+    /**\n+     * The last sequence number added. This field is only accessed in {@link #addInternal}, which is guaranteed to be\n+     * executed while holding the base class' lock, hence no need for extra synchronization here.\n+     */\n+    @Getter(AccessLevel.PACKAGE)\n+    @VisibleForTesting\n+    private long lastSequenceNumber = Operation.NO_SEQUENCE_NUMBER;\n+\n+    /**\n+     * See {@link BlockingDrainingQueue#addInternal}.\n+     *\n+     * @param item The item to include.\n+     * @throws OutOfOrderOperationException If item's Sequence Number is out of order.\n+     */\n+    @Override\n+    protected void addInternal(Operation item) {\n+        if (this.lastSequenceNumber >= item.getSequenceNumber()) {\n+            throw new OutOfOrderOperationException(String.format(\"Operation '%s' is out of order. Expected sequence number of at least %s.\",\n+                    item, this.lastSequenceNumber));\n+        }\n+        super.addInternal(item);\n+        this.lastSequenceNumber = item.getSequenceNumber();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e7152f5b8f92c495fae50076473fa327efc1941", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/0e7152f5b8f92c495fae50076473fa327efc1941", "committedDate": "2020-11-19T23:56:50Z", "message": "Code review feedback. Bug fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a87a96e9055eda8d5bfd1f069751834e9df5ef1", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/7a87a96e9055eda8d5bfd1f069751834e9df5ef1", "committedDate": "2020-11-20T04:54:11Z", "message": "Merge branch 'master' into issue-5345-storage-writer-data-source"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03a72d6824491d38f143db1b501688a86353394a", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/03a72d6824491d38f143db1b501688a86353394a", "committedDate": "2020-11-20T14:59:10Z", "message": "Merge branch 'master' into issue-5345-storage-writer-data-source"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzA0MjMx", "url": "https://github.com/pravega/pravega/pull/5355#pullrequestreview-535704231", "createdAt": "2020-11-20T19:06:24Z", "commit": {"oid": "03a72d6824491d38f143db1b501688a86353394a"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTowNjoyNFrOH3dVDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTowNjoyNFrOH3dVDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNDI1NQ==", "bodyText": "Ah, ok. Please add the @guardedby annotation on both this and the BlockingDrainingQueue.addInternal", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527914255", "createdAt": "2020-11-20T19:06:24Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/InMemoryLog.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.logs;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.util.BlockingDrainingQueue;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+/**\n+ * {@link BlockingDrainingQueue} implementation for {@link Operation}s. Prevents adding {@link Operation}s out of order.\n+ */\n+public class InMemoryLog extends BlockingDrainingQueue<Operation> {\n+    /**\n+     * The last sequence number added. This field is only accessed in {@link #addInternal}, which is guaranteed to be\n+     * executed while holding the base class' lock, hence no need for extra synchronization here.\n+     */\n+    @Getter(AccessLevel.PACKAGE)\n+    @VisibleForTesting\n+    private long lastSequenceNumber = Operation.NO_SEQUENCE_NUMBER;\n+\n+    /**\n+     * See {@link BlockingDrainingQueue#addInternal}.\n+     *\n+     * @param item The item to include.\n+     * @throws OutOfOrderOperationException If item's Sequence Number is out of order.\n+     */\n+    @Override\n+    protected void addInternal(Operation item) {\n+        if (this.lastSequenceNumber >= item.getSequenceNumber()) {\n+            throw new OutOfOrderOperationException(String.format(\"Operation '%s' is out of order. Expected sequence number of at least %s.\",\n+                    item, this.lastSequenceNumber));\n+        }\n+        super.addInternal(item);\n+        this.lastSequenceNumber = item.getSequenceNumber();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NzAxMw=="}, "originalCommit": {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d257ee4fb844ad24a8e26897c169f2741ad3eca1", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d257ee4fb844ad24a8e26897c169f2741ad3eca1", "committedDate": "2020-11-20T22:45:13Z", "message": "Added GuardedBy annotation.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12324fa5c270ca525ad9a268de7462ae37b283e5", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/12324fa5c270ca525ad9a268de7462ae37b283e5", "committedDate": "2020-11-20T22:45:21Z", "message": "Merge remote-tracking branch 'ap/issue-5345-storage-writer-data-source' into issue-5345-storage-writer-data-source"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3747, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}