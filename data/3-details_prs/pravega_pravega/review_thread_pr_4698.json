{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MDUwNTQ0", "number": 4698, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo1OTo1NVrODy_p1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToxNDo1N1rOD3Yjsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzk4MjkyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo1OTo1NVrOGHX0mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxOTo1MlrOGHb42A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MzUxMw==", "bodyText": "Per the javadocs nioBuffer() may make a copy. I would like to avoid making two copies here.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410383513", "createdAt": "2020-04-17T17:59:55Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -150,20 +150,21 @@ private void handleRequest() throws SegmentTruncatedException {\n             throw e;\n         }\n         verifyIsAtCorrectOffset(segmentRead);\n-        if (segmentRead.getData().hasRemaining()) {\n-            buffer.fill(segmentRead.getData());\n+        if (segmentRead.getData().readableBytes() > 0) {\n+            int copied = buffer.fill(segmentRead.getData().nioBuffer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDEzNg==", "bodyText": "Added a method to CircularBuffer to handle this.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410450136", "createdAt": "2020-04-17T20:19:52Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -150,20 +150,21 @@ private void handleRequest() throws SegmentTruncatedException {\n             throw e;\n         }\n         verifyIsAtCorrectOffset(segmentRead);\n-        if (segmentRead.getData().hasRemaining()) {\n-            buffer.fill(segmentRead.getData());\n+        if (segmentRead.getData().readableBytes() > 0) {\n+            int copied = buffer.fill(segmentRead.getData().nioBuffer());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MzUxMw=="}, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzk5NTEzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/ArrayView.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODowMzo1NFrOGHX8ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTozODozOFrOGHawJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTU2Ng==", "bodyText": "Given that the array() method already exists on this interface, I think the return type can just be a single ByteBuffer. If there were multiple components array() wouldn't be implementable in which case it would make sense to just use a different interface.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410385566", "createdAt": "2020-04-17T18:03:54Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ArrayView.java", "diffHunk": "@@ -48,4 +52,9 @@\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n     void copyTo(byte[] target, int targetOffset, int length);\n+\n+    @Override\n+    default List<ByteBuffer> getContents() {\n+        return Collections.singletonList(ByteBuffer.wrap(array(), arrayOffset(), getLength()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTUyNA==", "bodyText": "This method is inherited from BufferView which may wrap multiple buffers. I can't change the return type.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410431524", "createdAt": "2020-04-17T19:38:38Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/ArrayView.java", "diffHunk": "@@ -48,4 +52,9 @@\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n     void copyTo(byte[] target, int targetOffset, int length);\n+\n+    @Override\n+    default List<ByteBuffer> getContents() {\n+        return Collections.singletonList(ByteBuffer.wrap(array(), arrayOffset(), getLength()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTU2Ng=="}, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODAxMTExOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODowODo1NVrOGHYG8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjoxMjo1NlrOGIp00g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA==", "bodyText": "This may have unintended consequences if there is a subclass of bufferView which has internal state such as a modifiable position.\nI think instead there should be be a 'getView' method on bufferView the default version of which returns this. But which can be overridden by some impls to perform a slice.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410388208", "createdAt": "2020-04-17T18:08:55Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -104,4 +105,28 @@ default void retain() {\n     default void release() {\n         // Default implementation intentionally left blank. Any derived class may implement if needed.\n     }\n+\n+    /**\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     *\n+     * @return A List of {@link ByteBuffer}.\n+     */\n+    List<ByteBuffer> getContents();\n+\n+    /**\n+     * Wraps the given {@link BufferView} into a single instance.\n+     *\n+     * @param components The components to wrap.\n+     * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n+     * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n+     */\n+    static BufferView wrap(List<BufferView> components) {\n+        if (components.size() == 0) {\n+            return new ByteArraySegment(new byte[0]);\n+        } else if (components.size() == 1) {\n+            return components.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTk3Nw==", "bodyText": "Can I just name it BufferView.slice() which will invoke BufferView.slice(0, BufferView.getLength())?", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410449977", "createdAt": "2020-04-17T20:19:34Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -104,4 +105,28 @@ default void retain() {\n     default void release() {\n         // Default implementation intentionally left blank. Any derived class may implement if needed.\n     }\n+\n+    /**\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     *\n+     * @return A List of {@link ByteBuffer}.\n+     */\n+    List<ByteBuffer> getContents();\n+\n+    /**\n+     * Wraps the given {@link BufferView} into a single instance.\n+     *\n+     * @param components The components to wrap.\n+     * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n+     * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n+     */\n+    static BufferView wrap(List<BufferView> components) {\n+        if (components.size() == 0) {\n+            return new ByteArraySegment(new byte[0]);\n+        } else if (components.size() == 1) {\n+            return components.get(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3Mzk0Mw==", "bodyText": "sure", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410473943", "createdAt": "2020-04-17T21:16:11Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -104,4 +105,28 @@ default void retain() {\n     default void release() {\n         // Default implementation intentionally left blank. Any derived class may implement if needed.\n     }\n+\n+    /**\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     *\n+     * @return A List of {@link ByteBuffer}.\n+     */\n+    List<ByteBuffer> getContents();\n+\n+    /**\n+     * Wraps the given {@link BufferView} into a single instance.\n+     *\n+     * @param components The components to wrap.\n+     * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n+     * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n+     */\n+    static BufferView wrap(List<BufferView> components) {\n+        if (components.size() == 0) {\n+            return new ByteArraySegment(new byte[0]);\n+        } else if (components.size() == 1) {\n+            return components.get(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzA1OA==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r411727058", "createdAt": "2020-04-20T22:12:56Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -104,4 +105,28 @@ default void retain() {\n     default void release() {\n         // Default implementation intentionally left blank. Any derived class may implement if needed.\n     }\n+\n+    /**\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     *\n+     * @return A List of {@link ByteBuffer}.\n+     */\n+    List<ByteBuffer> getContents();\n+\n+    /**\n+     * Wraps the given {@link BufferView} into a single instance.\n+     *\n+     * @param components The components to wrap.\n+     * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n+     * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n+     */\n+    static BufferView wrap(List<BufferView> components) {\n+        if (components.size() == 0) {\n+            return new ByteArraySegment(new byte[0]);\n+        } else if (components.size() == 1) {\n+            return components.get(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}, "originalCommit": {"oid": "2e52b331a0604f599101957d50e7bd07d8145503"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODAyNjg3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoxMzo1NFrOGHYQ1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0MTowMlrOGHa0cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5MDc0MA==", "bodyText": "I really don't like these methods. Because they aren't used in most code paths they won't be well tested and the code handling these classes may assume it's working with an impl that doesn't use them, and will break with one that does.\nIf it is at all possible to remove them, I suggest we do so.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410390740", "createdAt": "2020-04-17T18:13:54Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Provides a unified view of multiple wrapped {@link BufferView} instances.\n+ */\n+class CompositeBufferView implements BufferView {\n+    //region Members\n+\n+    private final List<BufferView> components;\n+    @Getter\n+    private final int length;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeBufferView} class. It is recommended to use {@link BufferView#wrap}\n+     * instead.\n+     *\n+     * @param components The components to wrap.\n+     */\n+    CompositeBufferView(@NonNull List<BufferView> components) {\n+        this.components = new ArrayList<>();\n+        int length = 0;\n+        for (BufferView c : components) {\n+            if (c instanceof CompositeBufferView) {\n+                this.components.addAll(((CompositeBufferView) c).components);\n+            } else {\n+                this.components.add(c);\n+            }\n+            length += c.getLength();\n+        }\n+        this.length = length;\n+    }\n+\n+    //endregion\n+\n+    //region BufferView implementation\n+\n+    @Override\n+    public InputStream getReader() {\n+        this.components.stream().map(BufferView::getReader).iterator();\n+        return new SequenceInputStream(Iterators.asEnumeration(this.components.stream().map(BufferView::getReader).iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public BufferView slice(int offset, int length) {\n+        Preconditions.checkArgument(offset >= 0 && offset < length && length <= this.length,\n+                \"offset and length must be non-negative and less than %s.\", this.length);\n+        if (offset == 0 && length == this.length) {\n+            return this;\n+        }\n+        ArrayList<BufferView> components = new ArrayList<>(this.components.size());\n+        int index = 0;\n+        int currentOffset = 0;\n+        while (length > 0) {\n+            BufferView c = this.components.get(index);\n+            int lastComponentOffset = currentOffset + c.getLength();\n+            if (offset < lastComponentOffset) {\n+                int sliceStart = Math.max(0, offset - currentOffset);\n+                int sliceLength = Math.min(length, c.getLength() - sliceStart);\n+                components.add(c.slice(sliceStart, sliceLength));\n+                length -= sliceLength;\n+            }\n+\n+            index++;\n+            currentOffset += c.getLength();\n+        }\n+\n+        return BufferView.wrap(components);\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {\n+        byte[] result = new byte[getLength()];\n+        int offset = 0;\n+        for (BufferView c : this.components) {\n+            int copiedBytes = c.copyTo(ByteBuffer.wrap(result, offset, c.getLength()));\n+            assert copiedBytes == c.getLength();\n+            offset += copiedBytes;\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public void copyTo(OutputStream target) throws IOException {\n+        for (BufferView c : this.components) {\n+            c.copyTo(target);\n+        }\n+    }\n+\n+    @Override\n+    public int copyTo(ByteBuffer target) {\n+        int bytesCopied = 0;\n+        for (BufferView c : this.components) {\n+            bytesCopied += c.copyTo(target);\n+        }\n+\n+        return bytesCopied;\n+    }\n+\n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>(this.components.size());\n+        for (BufferView c : this.components) {\n+            result.addAll(c.getContents());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public void retain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjYyNQ==", "bodyText": "There is an implementation of BufferView that wraps ByteBufs. I need these methods for that specific case. The default implementation in BufferView does nothing, so they are only overridden if they have to.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410432625", "createdAt": "2020-04-17T19:41:02Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Provides a unified view of multiple wrapped {@link BufferView} instances.\n+ */\n+class CompositeBufferView implements BufferView {\n+    //region Members\n+\n+    private final List<BufferView> components;\n+    @Getter\n+    private final int length;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeBufferView} class. It is recommended to use {@link BufferView#wrap}\n+     * instead.\n+     *\n+     * @param components The components to wrap.\n+     */\n+    CompositeBufferView(@NonNull List<BufferView> components) {\n+        this.components = new ArrayList<>();\n+        int length = 0;\n+        for (BufferView c : components) {\n+            if (c instanceof CompositeBufferView) {\n+                this.components.addAll(((CompositeBufferView) c).components);\n+            } else {\n+                this.components.add(c);\n+            }\n+            length += c.getLength();\n+        }\n+        this.length = length;\n+    }\n+\n+    //endregion\n+\n+    //region BufferView implementation\n+\n+    @Override\n+    public InputStream getReader() {\n+        this.components.stream().map(BufferView::getReader).iterator();\n+        return new SequenceInputStream(Iterators.asEnumeration(this.components.stream().map(BufferView::getReader).iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public BufferView slice(int offset, int length) {\n+        Preconditions.checkArgument(offset >= 0 && offset < length && length <= this.length,\n+                \"offset and length must be non-negative and less than %s.\", this.length);\n+        if (offset == 0 && length == this.length) {\n+            return this;\n+        }\n+        ArrayList<BufferView> components = new ArrayList<>(this.components.size());\n+        int index = 0;\n+        int currentOffset = 0;\n+        while (length > 0) {\n+            BufferView c = this.components.get(index);\n+            int lastComponentOffset = currentOffset + c.getLength();\n+            if (offset < lastComponentOffset) {\n+                int sliceStart = Math.max(0, offset - currentOffset);\n+                int sliceLength = Math.min(length, c.getLength() - sliceStart);\n+                components.add(c.slice(sliceStart, sliceLength));\n+                length -= sliceLength;\n+            }\n+\n+            index++;\n+            currentOffset += c.getLength();\n+        }\n+\n+        return BufferView.wrap(components);\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {\n+        byte[] result = new byte[getLength()];\n+        int offset = 0;\n+        for (BufferView c : this.components) {\n+            int copiedBytes = c.copyTo(ByteBuffer.wrap(result, offset, c.getLength()));\n+            assert copiedBytes == c.getLength();\n+            offset += copiedBytes;\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public void copyTo(OutputStream target) throws IOException {\n+        for (BufferView c : this.components) {\n+            c.copyTo(target);\n+        }\n+    }\n+\n+    @Override\n+    public int copyTo(ByteBuffer target) {\n+        int bytesCopied = 0;\n+        for (BufferView c : this.components) {\n+            bytesCopied += c.copyTo(target);\n+        }\n+\n+        return bytesCopied;\n+    }\n+\n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>(this.components.size());\n+        for (BufferView c : this.components) {\n+            result.addAll(c.getContents());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public void retain() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5MDc0MA=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODA0NzczOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyMDoyMlrOGHYd5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0NToyNlrOGHa8Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDA4Nw==", "bodyText": "Why is arrays an Object[] rather than a byte[][]?", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410394087", "createdAt": "2020-04-17T18:20:22Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNDY0Mg==", "bodyText": "because byte[][] arrays = new byte[x][y] will create y arrays of x elements. This defeats the purpose of this class, which is a view of a sparse array (only allocates sub-arrays as they are needed).", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410434642", "createdAt": "2020-04-17T19:45:26Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDA4Nw=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODA2MTEwOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyNDozMVrOGHYmbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0ODoxNlrOGHbBfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjI2OQ==", "bodyText": "It is not obvious from the method signature/javadoc that it is going to allocate.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410396269", "createdAt": "2020-04-17T18:24:31Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);\n+            if (a == null) {\n+                int size = i == this.arrays.length - 1 ? this.length % this.arraySize : this.arraySize;\n+                result.add(ByteBuffer.allocate(size));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTk2Nw==", "bodyText": "Fixed the javadoc on CompositeArrayView to explain this.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410435967", "createdAt": "2020-04-17T19:48:16Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);\n+            if (a == null) {\n+                int size = i == this.arrays.length - 1 ? this.length % this.arraySize : this.arraySize;\n+                result.add(ByteBuffer.allocate(size));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjI2OQ=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODA2Nzg4OnYy", "diffSide": "LEFT", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/ReadResult.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyNjozNlrOGHYqoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjoxNTo1MVrOGIp6EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ==", "bodyText": "The streamHelpers method should be updated, as there are probably other callers.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410397345", "createdAt": "2020-04-17T18:26:36Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/ReadResult.java", "diffHunk": "@@ -104,25 +101,25 @@ default int readRemaining(byte[] target, Duration fetchTimeout) {\n                 entry.requestContent(fetchTimeout);\n             }\n \n-            ReadResultEntryContents contents = entry.getContent().join();\n-            StreamHelpers.readAll(contents.getData(), target, bytesRead, Math.min(contents.getLength(), target.length - bytesRead));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTQzMQ==", "bodyText": "I opened this a while back, with no clear solution in mind (at the time):  #2924.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410449431", "createdAt": "2020-04-17T20:18:22Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/ReadResult.java", "diffHunk": "@@ -104,25 +101,25 @@ default int readRemaining(byte[] target, Duration fetchTimeout) {\n                 entry.requestContent(fetchTimeout);\n             }\n \n-            ReadResultEntryContents contents = entry.getContent().join();\n-            StreamHelpers.readAll(contents.getData(), target, bytesRead, Math.min(contents.getLength(), target.length - bytesRead));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMTQzNA==", "bodyText": "Ok, let's link to that issue in the Javadoc for the method so that it doesn't get used when it doesn't have to be.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410501434", "createdAt": "2020-04-17T22:36:36Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/ReadResult.java", "diffHunk": "@@ -104,25 +101,25 @@ default int readRemaining(byte[] target, Duration fetchTimeout) {\n                 entry.requestContent(fetchTimeout);\n             }\n \n-            ReadResultEntryContents contents = entry.getContent().join();\n-            StreamHelpers.readAll(contents.getData(), target, bytesRead, Math.min(contents.getLength(), target.length - bytesRead));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyODQwMA==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r411728400", "createdAt": "2020-04-20T22:15:51Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/ReadResult.java", "diffHunk": "@@ -104,25 +101,25 @@ default int readRemaining(byte[] target, Duration fetchTimeout) {\n                 entry.requestContent(fetchTimeout);\n             }\n \n-            ReadResultEntryContents contents = entry.getContent().join();\n-            StreamHelpers.readAll(contents.getData(), target, bytesRead, Math.min(contents.getLength(), target.length - bytesRead));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODIxMDgxOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToxNTowMFrOGHaGOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0OTo0MVrOGHbEKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMDc5Mg==", "bodyText": "It should be noted this can return null.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410420792", "createdAt": "2020-04-17T19:15:00Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java", "diffHunk": "@@ -757,34 +758,34 @@ private boolean canContinueFlushingExcess() {\n     }\n \n     /**\n-     * Returns a FlushArgs which contains the data needing to be flushed to Storage.\n+     * Returns a {@link BufferView} which contains the data needing to be flushed to Storage.\n      *\n-     * @return The aggregated object that can be used for flushing.\n+     * @return A {@link BufferView} to flush.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjY0OA==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410436648", "createdAt": "2020-04-17T19:49:41Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java", "diffHunk": "@@ -757,34 +758,34 @@ private boolean canContinueFlushingExcess() {\n     }\n \n     /**\n-     * Returns a FlushArgs which contains the data needing to be flushed to Storage.\n+     * Returns a {@link BufferView} which contains the data needing to be flushed to Storage.\n      *\n-     * @return The aggregated object that can be used for flushing.\n+     * @return A {@link BufferView} to flush.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMDc5Mg=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODIyNzc0OnYy", "diffSide": "RIGHT", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ByteBufWrapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyMDo1MlrOGHaQyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo1MDo1MlrOGHbGcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMzQ5OA==", "bodyText": "This code is fine, but I don't see how it's any different than the code before. It's not saving any copies.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410423498", "createdAt": "2020-04-17T19:20:52Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ByteBufWrapper.java", "diffHunk": "@@ -113,14 +120,17 @@ public void copyTo(OutputStream target) throws IOException {\n     @Override\n     public int copyTo(ByteBuffer byteBuffer) {\n         Exceptions.checkNotClosed(this.buf.refCnt() == 0, this);\n-        ByteBuf buf = this.buf.duplicate();\n+        ByteBuf source = this.buf.duplicate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNzIzMg==", "bodyText": "The previous code had a bug in it where it would not update the target buffer's position after the write, thus ending up overwriting the same data over and over again.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410437232", "createdAt": "2020-04-17T19:50:52Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ByteBufWrapper.java", "diffHunk": "@@ -113,14 +120,17 @@ public void copyTo(OutputStream target) throws IOException {\n     @Override\n     public int copyTo(ByteBuffer byteBuffer) {\n         Exceptions.checkNotClosed(this.buf.refCnt() == 0, this);\n-        ByteBuf buf = this.buf.duplicate();\n+        ByteBuf source = this.buf.duplicate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMzQ5OA=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODI0MjE5OnYy", "diffSide": "RIGHT", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyNjowNFrOGHaaEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjo0MjowNVrOGHfGzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ==", "bodyText": "This is adding a call to retain(). Where is the corresponding release() call?", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410425875", "createdAt": "2020-04-17T19:26:04Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -828,10 +827,9 @@ public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOE\n             if (dataLength > length) {\n                 throw new BufferOverflowException();\n             }\n-            byte[] data = new byte[dataLength];\n-            in.readFully(data);\n-            long requestId =  in.available() >= Long.BYTES ? in.readLong() : -1L;\n-            return new SegmentRead(segment, offset, atTail, endOfSegment, ByteBuffer.wrap(data), requestId);\n+            ByteBuf data = in.readFully(dataLength).retain();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODA5NA==", "bodyText": "Good point. Due to the fact that this class is instantiated in 2 ways (with an external ByteBuf via the constructor, and by deserializing), I only need to retain for the serialization, so the solution is a bit less elegant than I wished. I added some unit tests to verify it works as I intend to.\nThe corresponding release has been added to SegmentInputStreamImpl.handleRequest", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410448094", "createdAt": "2020-04-17T20:15:23Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -828,10 +827,9 @@ public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOE\n             if (dataLength > length) {\n                 throw new BufferOverflowException();\n             }\n-            byte[] data = new byte[dataLength];\n-            in.readFully(data);\n-            long requestId =  in.available() >= Long.BYTES ? in.readLong() : -1L;\n-            return new SegmentRead(segment, offset, atTail, endOfSegment, ByteBuffer.wrap(data), requestId);\n+            ByteBuf data = in.readFully(dataLength).retain();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODkyOA==", "bodyText": "I am not 100% sure this is correct. But I do not know of any way to prevent memory leaks without making a copy in the deserialization. I am concerned about cancelled requests or other unexpected situations.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410448928", "createdAt": "2020-04-17T20:17:12Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -828,10 +827,9 @@ public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOE\n             if (dataLength > length) {\n                 throw new BufferOverflowException();\n             }\n-            byte[] data = new byte[dataLength];\n-            in.readFully(data);\n-            long requestId =  in.available() >= Long.BYTES ? in.readLong() : -1L;\n-            return new SegmentRead(segment, offset, atTail, endOfSegment, ByteBuffer.wrap(data), requestId);\n+            ByteBuf data = in.readFully(dataLength).retain();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMjg2MQ==", "bodyText": "SegmentInputStreamImpl:89 is missing the logic to call release. In case setoffset is called before reading the data is complete.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410502861", "createdAt": "2020-04-17T22:42:05Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -828,10 +827,9 @@ public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOE\n             if (dataLength > length) {\n                 throw new BufferOverflowException();\n             }\n-            byte[] data = new byte[dataLength];\n-            in.readFully(data);\n-            long requestId =  in.available() >= Long.BYTES ? in.readLong() : -1L;\n-            return new SegmentRead(segment, offset, atTail, endOfSegment, ByteBuffer.wrap(data), requestId);\n+            ByteBuf data = in.readFully(dataLength).retain();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}, "originalCommit": {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODc2Mjg4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDozMjowN1rOGM2bVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDozMjowN1rOGM2bVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNzgzMA==", "bodyText": "This is a complicated case:\nIf the buffer has completed but has not had any slices pulled out of it we need to call releaese() if it does, then those could become invalid. So we need to make sure they don't like longer than the scope of $lock", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416127830", "createdAt": "2020-04-27T20:32:07Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -197,14 +198,20 @@ private int computeReadLength(long currentFetchOffset) {\n         return Math.toIntExact(Math.min(currentReadLength, numberOfBytesRemaining));\n     }\n \n+    @GuardedBy(\"$lock\")\n+    private void cancelOutstandingRequest() {\n+        outstandingRequest.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb55b9b4ec7d31af14bdd9fe0f5696a73c758cf0"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mzc3MzIwOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoxMDoxNFrOGNk_kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoyMDo0OVrOGNqiNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA==", "bodyText": "These two exception listeners could be combined so as to avoid an extra link in the future chain.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416890770", "createdAt": "2020-04-28T20:10:14Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -228,6 +229,40 @@\n         return result;\n     }\n \n+    /**\n+     * Returns a CompletableFuture that will complete with the same outcome or result as the given source, but when\n+     * cancelled, will apply a consumer to the eventual result of the original future.\n+     * <p>\n+     * If the returned CompletableFuture is NOT cancelled ({@link CompletableFuture#cancel}):\n+     * - If source completes normally, the result CompletableFuture will complete with the same result.\n+     * - If source completes exceptionally, the result CompletableFuture will complete with the same result.\n+     * <p>\n+     * If the returned CompletableFuture is cancelled ({@link CompletableFuture#cancel}):\n+     * - If the source has already completed, the result CompletableFuture will also be completed with the same outcome.\n+     * - If the source has not already been completed, if it completes normally, then `onCancel` will be applied to\n+     * the result when it eventually completes. The source completes exceptionally, nothing will happen.\n+     *\n+     * @param source   The CompletableFuture to wrap.\n+     * @param onCancel A Consumer to invoke on source's eventual completion result if the result of this method is cancelled.\n+     * @param <T>      Result type.\n+     * @return A CompletableFuture that will complete with the same outcome or result as the given source.\n+     */\n+    public static <T> CompletableFuture<T> cancellableFuture(CompletableFuture<T> source, Consumer<T> onCancel) {\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        val result = new CompletableFuture<T>();\n+        source.thenAccept(result::complete);\n+        Futures.exceptionListener(source, result::completeExceptionally);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjA4Mg==", "bodyText": "These listeners are on different futures. The first one is on the source (which we're passed in) and propagates the failure to the result. The second one is on the result and invokes the onCancel callback if someone cancelled the result. I cannot combine them into one.\nAlso, these are not affecting the future chain. We are returning result directly, yet we are attaching these listeners to the result but not chain them anywhere. They will only be executed in case of some exception; they will not affect the normal path.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416976082", "createdAt": "2020-04-28T23:05:46Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -228,6 +229,40 @@\n         return result;\n     }\n \n+    /**\n+     * Returns a CompletableFuture that will complete with the same outcome or result as the given source, but when\n+     * cancelled, will apply a consumer to the eventual result of the original future.\n+     * <p>\n+     * If the returned CompletableFuture is NOT cancelled ({@link CompletableFuture#cancel}):\n+     * - If source completes normally, the result CompletableFuture will complete with the same result.\n+     * - If source completes exceptionally, the result CompletableFuture will complete with the same result.\n+     * <p>\n+     * If the returned CompletableFuture is cancelled ({@link CompletableFuture#cancel}):\n+     * - If the source has already completed, the result CompletableFuture will also be completed with the same outcome.\n+     * - If the source has not already been completed, if it completes normally, then `onCancel` will be applied to\n+     * the result when it eventually completes. The source completes exceptionally, nothing will happen.\n+     *\n+     * @param source   The CompletableFuture to wrap.\n+     * @param onCancel A Consumer to invoke on source's eventual completion result if the result of this method is cancelled.\n+     * @param <T>      Result type.\n+     * @return A CompletableFuture that will complete with the same outcome or result as the given source.\n+     */\n+    public static <T> CompletableFuture<T> cancellableFuture(CompletableFuture<T> source, Consumer<T> onCancel) {\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        val result = new CompletableFuture<T>();\n+        source.thenAccept(result::complete);\n+        Futures.exceptionListener(source, result::completeExceptionally);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}, "originalCommit": {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTU1NA==", "bodyText": "I see my phrasing was confusing. I intended to refer to this and the above line.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416979554", "createdAt": "2020-04-28T23:15:26Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -228,6 +229,40 @@\n         return result;\n     }\n \n+    /**\n+     * Returns a CompletableFuture that will complete with the same outcome or result as the given source, but when\n+     * cancelled, will apply a consumer to the eventual result of the original future.\n+     * <p>\n+     * If the returned CompletableFuture is NOT cancelled ({@link CompletableFuture#cancel}):\n+     * - If source completes normally, the result CompletableFuture will complete with the same result.\n+     * - If source completes exceptionally, the result CompletableFuture will complete with the same result.\n+     * <p>\n+     * If the returned CompletableFuture is cancelled ({@link CompletableFuture#cancel}):\n+     * - If the source has already completed, the result CompletableFuture will also be completed with the same outcome.\n+     * - If the source has not already been completed, if it completes normally, then `onCancel` will be applied to\n+     * the result when it eventually completes. The source completes exceptionally, nothing will happen.\n+     *\n+     * @param source   The CompletableFuture to wrap.\n+     * @param onCancel A Consumer to invoke on source's eventual completion result if the result of this method is cancelled.\n+     * @param <T>      Result type.\n+     * @return A CompletableFuture that will complete with the same outcome or result as the given source.\n+     */\n+    public static <T> CompletableFuture<T> cancellableFuture(CompletableFuture<T> source, Consumer<T> onCancel) {\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        val result = new CompletableFuture<T>();\n+        source.thenAccept(result::complete);\n+        Futures.exceptionListener(source, result::completeExceptionally);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}, "originalCommit": {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTU1Nw==", "bodyText": "Got it now. Fixed it.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416981557", "createdAt": "2020-04-28T23:20:49Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -228,6 +229,40 @@\n         return result;\n     }\n \n+    /**\n+     * Returns a CompletableFuture that will complete with the same outcome or result as the given source, but when\n+     * cancelled, will apply a consumer to the eventual result of the original future.\n+     * <p>\n+     * If the returned CompletableFuture is NOT cancelled ({@link CompletableFuture#cancel}):\n+     * - If source completes normally, the result CompletableFuture will complete with the same result.\n+     * - If source completes exceptionally, the result CompletableFuture will complete with the same result.\n+     * <p>\n+     * If the returned CompletableFuture is cancelled ({@link CompletableFuture#cancel}):\n+     * - If the source has already completed, the result CompletableFuture will also be completed with the same outcome.\n+     * - If the source has not already been completed, if it completes normally, then `onCancel` will be applied to\n+     * the result when it eventually completes. The source completes exceptionally, nothing will happen.\n+     *\n+     * @param source   The CompletableFuture to wrap.\n+     * @param onCancel A Consumer to invoke on source's eventual completion result if the result of this method is cancelled.\n+     * @param <T>      Result type.\n+     * @return A CompletableFuture that will complete with the same outcome or result as the given source.\n+     */\n+    public static <T> CompletableFuture<T> cancellableFuture(CompletableFuture<T> source, Consumer<T> onCancel) {\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        val result = new CompletableFuture<T>();\n+        source.thenAccept(result::complete);\n+        Futures.exceptionListener(source, result::completeExceptionally);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}, "originalCommit": {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDAwNjI3OnYy", "diffSide": "RIGHT", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToxNDo1N1rOGNnOIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowNTo1MFrOGNqM-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzI2Ng==", "bodyText": "NotThreadSafe unless you want to make released an atomic boolean", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416927266", "createdAt": "2020-04-28T21:14:57Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -792,15 +795,24 @@ public long getRequestId() {\n         }\n     }\n \n-    @Data\n+    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+    @Getter\n+    @ToString\n+    @EqualsAndHashCode(exclude = {\"mustRelease\", \"released\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjEyMA==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416976120", "createdAt": "2020-04-28T23:05:50Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -792,15 +795,24 @@ public long getRequestId() {\n         }\n     }\n \n-    @Data\n+    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+    @Getter\n+    @ToString\n+    @EqualsAndHashCode(exclude = {\"mustRelease\", \"released\"})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzI2Ng=="}, "originalCommit": {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4257, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}