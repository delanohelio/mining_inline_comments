{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMjAzODUz", "number": 5084, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjozNzoyOVrOEcbuSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTowMTo1NFrOEfrkYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjQ5ODAwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/SingleRoutingKeyTransactionWriterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjozNzoyOVrOHG92BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNzozNzoxOFrOHG_mhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2Njc1Nw==", "bodyText": "I do not see how there can be multiple PendingEvents here. Am I missing something here?", "url": "https://github.com/pravega/pravega/pull/5084#discussion_r477066757", "createdAt": "2020-08-26T06:37:29Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/SingleRoutingKeyTransactionWriterImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.stream.impl;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.security.auth.DelegationTokenProvider;\n+import io.pravega.client.security.auth.DelegationTokenProviderFactory;\n+import io.pravega.client.segment.impl.Segment;\n+import io.pravega.client.segment.impl.SegmentOutputStream;\n+import io.pravega.client.segment.impl.SegmentOutputStreamFactory;\n+import io.pravega.client.segment.impl.SegmentSealedException;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.Serializer;\n+import io.pravega.client.stream.SingleRoutingKeyTransaction;\n+import io.pravega.client.stream.SingleRoutingKeyTransactionWriter;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.Transaction;\n+import io.pravega.client.stream.TxnFailedException;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.util.Retry;\n+import lombok.NonNull;\n+import lombok.Synchronized;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates transactions, and manages their lifecycle.\n+ *\n+ * @param <Type> The type of event that is sent\n+ */\n+@Slf4j\n+@ToString(of = {\"stream\", \"closed\"})\n+public class SingleRoutingKeyTransactionWriterImpl<Type> implements SingleRoutingKeyTransactionWriter<Type> {\n+    private final Stream stream;\n+    private final Serializer<Type> serializer;\n+    private final String routingKey;\n+    private final SegmentOutputStreamFactory outputStreamFactory;\n+    private final Controller controller;\n+    private final AtomicBoolean closed;\n+\n+    @GuardedBy(\"$lock\")\n+    private SegmentOutputStream segmentOutputStream;\n+    @GuardedBy(\"$lock\")\n+    private SingleRoutingKeyTransactionImpl<Type> transaction;\n+    private final DelegationTokenProvider tokenProvider;\n+\n+    SingleRoutingKeyTransactionWriterImpl(Stream stream, String routingKey, Controller controller, SegmentOutputStreamFactory outputStreamFactory,\n+                                          Serializer<Type> serializer) {\n+        this.stream = Preconditions.checkNotNull(stream);\n+        this.routingKey = Preconditions.checkNotNull(routingKey);\n+        this.controller = Preconditions.checkNotNull(controller);\n+        this.outputStreamFactory = Preconditions.checkNotNull(outputStreamFactory);\n+        this.serializer = Preconditions.checkNotNull(serializer);\n+        this.closed = new AtomicBoolean(false);\n+        this.tokenProvider = DelegationTokenProviderFactory.create(controller, stream.getScope(), stream.getStreamName());\n+\n+    }\n+\n+    private static class SingleRoutingKeyTransactionImpl<Type> implements SingleRoutingKeyTransaction<Type> {\n+        @NonNull\n+        private final Serializer<Type> serializer;\n+        @GuardedBy(\"$lock\")\n+        private Transaction.Status state;\n+        @GuardedBy(\"$lock\")\n+        private final List<ByteBuffer> events;\n+        private final Function<List<ByteBuffer>, CompletableFuture<Void>> write;\n+\n+        SingleRoutingKeyTransactionImpl(Serializer<Type> serializer, Function<List<ByteBuffer>, CompletableFuture<Void>> write) {\n+            this.serializer = serializer;\n+            this.state = Transaction.Status.OPEN;\n+            this.events = new ArrayList<>();\n+            this.write = write;\n+        }\n+\n+        @Override\n+        public void writeEvent(Type event) throws TxnFailedException {\n+            Preconditions.checkNotNull(event);\n+\n+            ByteBuffer buffer = serializer.serialize(event);\n+            synchronized (this) {\n+                throwIfClosed();\n+                events.add(buffer);\n+            }\n+        }\n+\n+        @Override\n+        public CompletableFuture<Void> commit() throws TxnFailedException {\n+            synchronized (this) {\n+                throwIfClosed();\n+                if (state.equals(Transaction.Status.OPEN)) {\n+                    state = Transaction.Status.COMMITTING;\n+                } else {\n+                    throw new IllegalStateException(\"Transaction is already closed.\");\n+                }\n+            }\n+            return write.apply(events);\n+        }\n+\n+        @Override\n+        public void abort() {\n+            synchronized (this) {\n+                if (state.equals(Transaction.Status.OPEN)) {\n+                    state = Transaction.Status.ABORTED;\n+                }\n+            }\n+        }\n+\n+        private void throwIfClosed() throws TxnFailedException {\n+            synchronized (this) {\n+                if (!state.equals(Transaction.Status.OPEN)) {\n+                    throw new TxnFailedException();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SingleRoutingKeyTransaction<Type> beginTxn() {\n+        synchronized (this) {\n+            if (transaction == null) {\n+                transaction = new SingleRoutingKeyTransactionImpl<>(serializer, this::writeEvents);\n+                return transaction;\n+            } else {\n+                throw new IllegalStateException();\n+            }\n+        }\n+    }\n+\n+    private SegmentOutputStream getSegmentOutputStream() {\n+        synchronized (this) {\n+            if (segmentOutputStream != null) {\n+                return segmentOutputStream;\n+            } else {\n+                return controller.getCurrentSegments(stream.getScope(), stream.getStreamName())\n+                                 .thenApply(segments -> {\n+                                     Segment segment = segments.getSegmentForKey(routingKey);\n+                                     return createSegmentOutputStream(segment);\n+                                 }).join();\n+            }\n+        }\n+    }\n+\n+    private SegmentOutputStream createSegmentOutputStream(Segment segment) {\n+        synchronized (this) {\n+            if (!segmentOutputStream.getSegmentName().equals(segment.getScopedName())) {\n+                segmentOutputStream = outputStreamFactory.createOutputStreamForSegment(segment,\n+                        this::segmentSealedCallback,\n+                        EventWriterConfig.builder().build(), tokenProvider);\n+            }\n+            return segmentOutputStream;\n+        }\n+    }\n+\n+    @Synchronized\n+    private void segmentSealedCallback(Segment segment) {\n+        // instead of traversing thru successors we will call current segments and fetch the appropriate segment.\n+        // by setting segmentOutputStream to null we will force the caller to get the replacement segmentoutputstream.\n+        // we will call resend while holding the lock so that successor segment outputstream is setup and events are\n+        // replayed to it before new writeevents into successor are triggered. \n+        List<PendingEvent> toResend = segmentOutputStream.getUnackedEventsOnSeal();\n+        segmentOutputStream = null;\n+        for (PendingEvent event : toResend) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ef2c4266871fa57c7c2ac6679002b084bd42067"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA5NTU1Nw==", "bodyText": "so conceptually there could be multiple \"transactions\" created on the same txn writer. so there could be more than one pending event (one per transaction)", "url": "https://github.com/pravega/pravega/pull/5084#discussion_r477095557", "createdAt": "2020-08-26T07:37:18Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/impl/SingleRoutingKeyTransactionWriterImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.stream.impl;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.control.impl.Controller;\n+import io.pravega.client.security.auth.DelegationTokenProvider;\n+import io.pravega.client.security.auth.DelegationTokenProviderFactory;\n+import io.pravega.client.segment.impl.Segment;\n+import io.pravega.client.segment.impl.SegmentOutputStream;\n+import io.pravega.client.segment.impl.SegmentOutputStreamFactory;\n+import io.pravega.client.segment.impl.SegmentSealedException;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.Serializer;\n+import io.pravega.client.stream.SingleRoutingKeyTransaction;\n+import io.pravega.client.stream.SingleRoutingKeyTransactionWriter;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.Transaction;\n+import io.pravega.client.stream.TxnFailedException;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.util.Retry;\n+import lombok.NonNull;\n+import lombok.Synchronized;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates transactions, and manages their lifecycle.\n+ *\n+ * @param <Type> The type of event that is sent\n+ */\n+@Slf4j\n+@ToString(of = {\"stream\", \"closed\"})\n+public class SingleRoutingKeyTransactionWriterImpl<Type> implements SingleRoutingKeyTransactionWriter<Type> {\n+    private final Stream stream;\n+    private final Serializer<Type> serializer;\n+    private final String routingKey;\n+    private final SegmentOutputStreamFactory outputStreamFactory;\n+    private final Controller controller;\n+    private final AtomicBoolean closed;\n+\n+    @GuardedBy(\"$lock\")\n+    private SegmentOutputStream segmentOutputStream;\n+    @GuardedBy(\"$lock\")\n+    private SingleRoutingKeyTransactionImpl<Type> transaction;\n+    private final DelegationTokenProvider tokenProvider;\n+\n+    SingleRoutingKeyTransactionWriterImpl(Stream stream, String routingKey, Controller controller, SegmentOutputStreamFactory outputStreamFactory,\n+                                          Serializer<Type> serializer) {\n+        this.stream = Preconditions.checkNotNull(stream);\n+        this.routingKey = Preconditions.checkNotNull(routingKey);\n+        this.controller = Preconditions.checkNotNull(controller);\n+        this.outputStreamFactory = Preconditions.checkNotNull(outputStreamFactory);\n+        this.serializer = Preconditions.checkNotNull(serializer);\n+        this.closed = new AtomicBoolean(false);\n+        this.tokenProvider = DelegationTokenProviderFactory.create(controller, stream.getScope(), stream.getStreamName());\n+\n+    }\n+\n+    private static class SingleRoutingKeyTransactionImpl<Type> implements SingleRoutingKeyTransaction<Type> {\n+        @NonNull\n+        private final Serializer<Type> serializer;\n+        @GuardedBy(\"$lock\")\n+        private Transaction.Status state;\n+        @GuardedBy(\"$lock\")\n+        private final List<ByteBuffer> events;\n+        private final Function<List<ByteBuffer>, CompletableFuture<Void>> write;\n+\n+        SingleRoutingKeyTransactionImpl(Serializer<Type> serializer, Function<List<ByteBuffer>, CompletableFuture<Void>> write) {\n+            this.serializer = serializer;\n+            this.state = Transaction.Status.OPEN;\n+            this.events = new ArrayList<>();\n+            this.write = write;\n+        }\n+\n+        @Override\n+        public void writeEvent(Type event) throws TxnFailedException {\n+            Preconditions.checkNotNull(event);\n+\n+            ByteBuffer buffer = serializer.serialize(event);\n+            synchronized (this) {\n+                throwIfClosed();\n+                events.add(buffer);\n+            }\n+        }\n+\n+        @Override\n+        public CompletableFuture<Void> commit() throws TxnFailedException {\n+            synchronized (this) {\n+                throwIfClosed();\n+                if (state.equals(Transaction.Status.OPEN)) {\n+                    state = Transaction.Status.COMMITTING;\n+                } else {\n+                    throw new IllegalStateException(\"Transaction is already closed.\");\n+                }\n+            }\n+            return write.apply(events);\n+        }\n+\n+        @Override\n+        public void abort() {\n+            synchronized (this) {\n+                if (state.equals(Transaction.Status.OPEN)) {\n+                    state = Transaction.Status.ABORTED;\n+                }\n+            }\n+        }\n+\n+        private void throwIfClosed() throws TxnFailedException {\n+            synchronized (this) {\n+                if (!state.equals(Transaction.Status.OPEN)) {\n+                    throw new TxnFailedException();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SingleRoutingKeyTransaction<Type> beginTxn() {\n+        synchronized (this) {\n+            if (transaction == null) {\n+                transaction = new SingleRoutingKeyTransactionImpl<>(serializer, this::writeEvents);\n+                return transaction;\n+            } else {\n+                throw new IllegalStateException();\n+            }\n+        }\n+    }\n+\n+    private SegmentOutputStream getSegmentOutputStream() {\n+        synchronized (this) {\n+            if (segmentOutputStream != null) {\n+                return segmentOutputStream;\n+            } else {\n+                return controller.getCurrentSegments(stream.getScope(), stream.getStreamName())\n+                                 .thenApply(segments -> {\n+                                     Segment segment = segments.getSegmentForKey(routingKey);\n+                                     return createSegmentOutputStream(segment);\n+                                 }).join();\n+            }\n+        }\n+    }\n+\n+    private SegmentOutputStream createSegmentOutputStream(Segment segment) {\n+        synchronized (this) {\n+            if (!segmentOutputStream.getSegmentName().equals(segment.getScopedName())) {\n+                segmentOutputStream = outputStreamFactory.createOutputStreamForSegment(segment,\n+                        this::segmentSealedCallback,\n+                        EventWriterConfig.builder().build(), tokenProvider);\n+            }\n+            return segmentOutputStream;\n+        }\n+    }\n+\n+    @Synchronized\n+    private void segmentSealedCallback(Segment segment) {\n+        // instead of traversing thru successors we will call current segments and fetch the appropriate segment.\n+        // by setting segmentOutputStream to null we will force the caller to get the replacement segmentoutputstream.\n+        // we will call resend while holding the lock so that successor segment outputstream is setup and events are\n+        // replayed to it before new writeevents into successor are triggered. \n+        List<PendingEvent> toResend = segmentOutputStream.getUnackedEventsOnSeal();\n+        segmentOutputStream = null;\n+        for (PendingEvent event : toResend) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2Njc1Nw=="}, "originalCommit": {"oid": "9ef2c4266871fa57c7c2ac6679002b084bd42067"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjQ5NTYyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/EventStreamWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1NDoxNFrOHMGqEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1NDoxNFrOHMGqEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ1NDAzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * collective batch should be twice of {@link Serializer#MAX_EVENT_SIZE}. \n          \n          \n            \n                 * collective batch should less than twice the {@link Serializer#MAX_EVENT_SIZE}.", "url": "https://github.com/pravega/pravega/pull/5084#discussion_r482454035", "createdAt": "2020-09-02T20:54:14Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/EventStreamWriter.java", "diffHunk": "@@ -60,7 +61,29 @@\n      *         exponential backoff. So there is no need to attempt to retry in the event of an exception.\n      */\n     CompletableFuture<Void> writeEvent(String routingKey, Type event);\n-    \n+\n+    /**\n+     * Write an ordered list of events to the stream atomically for a given routing key. \n+     * Events written with the same routing key will be read by readers in exactly the same order they were written. \n+     * The maximum size of the serialized event individually should be {@link Serializer#MAX_EVENT_SIZE} and the \n+     * collective batch should be twice of {@link Serializer#MAX_EVENT_SIZE}. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ef2c4266871fa57c7c2ac6679002b084bd42067"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjUxNjMxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/EventStreamClientFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1NzowOFrOHMG5KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwMzowMToyNVrOHNuzGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ1Nzg5Nw==", "bodyText": "Do we need a new method here? Or should the beginTxn on TransactionalWriter take an optional routing key?", "url": "https://github.com/pravega/pravega/pull/5084#discussion_r482457897", "createdAt": "2020-09-02T20:57:08Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/EventStreamClientFactory.java", "diffHunk": "@@ -85,6 +86,18 @@ static EventStreamClientFactory withScope(String scope, ClientConfig config) {\n      */\n     <T> EventStreamWriter<T> createEventWriter(String writerId, String streamName, Serializer<T> s, EventWriterConfig config);\n     \n+    /**\n+     * Creates a new single routing key transaction writer that can write a batch of events with atomic guarantees. \n+     * There are limits on the size of each event in the batch and the overall size of the batch.\n+     *\n+     * @param streamName The name of the stream to write to.\n+     * @param routingKey Routing key to be used while writing the events.\n+     * @param s The Serializer.\n+     * @param <T> The type of events.\n+     * @return Newly created writer object\n+     */\n+    <T> SingleRoutingKeyTransactionWriter<T> createSingleRoutingKeyWriter(String streamName, String routingKey, Serializer<T> s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ef2c4266871fa57c7c2ac6679002b084bd42067"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE2MDI4Mg==", "bodyText": "This is a good suggestion. Though based on the feedback and suggestion from @fpj and others, i am removing the transaction decoration at the moment.\nWe are going to attempt to improve the performance of distributed transaction and see if we can incorporate \"single\" routing key transaction by using the transient segment and performing segment-merges.", "url": "https://github.com/pravega/pravega/pull/5084#discussion_r484160282", "createdAt": "2020-09-07T03:01:25Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/EventStreamClientFactory.java", "diffHunk": "@@ -85,6 +86,18 @@ static EventStreamClientFactory withScope(String scope, ClientConfig config) {\n      */\n     <T> EventStreamWriter<T> createEventWriter(String writerId, String streamName, Serializer<T> s, EventWriterConfig config);\n     \n+    /**\n+     * Creates a new single routing key transaction writer that can write a batch of events with atomic guarantees. \n+     * There are limits on the size of each event in the batch and the overall size of the batch.\n+     *\n+     * @param streamName The name of the stream to write to.\n+     * @param routingKey Routing key to be used while writing the events.\n+     * @param s The Serializer.\n+     * @param <T> The type of events.\n+     * @return Newly created writer object\n+     */\n+    <T> SingleRoutingKeyTransactionWriter<T> createSingleRoutingKeyWriter(String streamName, String routingKey, Serializer<T> s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ1Nzg5Nw=="}, "originalCommit": {"oid": "9ef2c4266871fa57c7c2ac6679002b084bd42067"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjU1MTM4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PendingEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTowMTo1NFrOHMHRvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTowMTo1NFrOHMHRvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ2NDE5MA==", "bodyText": "Rather than making an N level deep structure, it would be better to add all the buffers into a list and then create a single wrapping buffer.", "url": "https://github.com/pravega/pravega/pull/5084#discussion_r482464190", "createdAt": "2020-09-02T21:01:54Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PendingEvent.java", "diffHunk": "@@ -38,26 +43,48 @@\n      * The data to be written. Note this is limited to {@value #MAX_WRITE_SIZE} bytes.\n      */\n     private final ByteBuf data;\n+    \n+    private final int eventCount;\n     /**\n      * Callback to be invoked when the data is written.\n      */\n     private final CompletableFuture<Void> ackFuture;\n        \n-    private PendingEvent(String routingKey, ByteBuf data, CompletableFuture<Void> ackFuture) {\n+    private PendingEvent(String routingKey, ByteBuf data, int eventCount, CompletableFuture<Void> ackFuture) {\n         Preconditions.checkNotNull(data);\n-        Preconditions.checkArgument(data.readableBytes() <= MAX_WRITE_SIZE, \"Write size too large: %s\", data.readableBytes());\n         this.routingKey = routingKey;\n         this.data = data;\n         this.ackFuture = ackFuture;\n+        this.eventCount = eventCount;\n     }\n     \n     public static PendingEvent withHeader(String routingKey, ByteBuffer data, CompletableFuture<Void> ackFuture) {\n+        ByteBuf eventBuf = getByteBuf(data);\n+        return new PendingEvent(routingKey, eventBuf, 1, ackFuture);\n+    }\n+\n+    private static ByteBuf getByteBuf(ByteBuffer data) {\n         ByteBuf eventBuf = new Event(Unpooled.wrappedBuffer(data)).getAsByteBuf();\n-        return new PendingEvent(routingKey, eventBuf, ackFuture);\n-        \n+        Preconditions.checkArgument(eventBuf.readableBytes() <= MAX_WRITE_SIZE, \"Write size too large: %s\", eventBuf.readableBytes());\n+        return eventBuf;\n     }\n-    \n+\n+    public static PendingEvent withHeader(@NonNull String routingKey, @NonNull List<ByteBuffer> batch, @NonNull CompletableFuture<Void> ackFuture) {\n+        Preconditions.checkArgument(!batch.isEmpty(), \"Batch cannot be empty\");\n+        ByteBuf batchBuff = Unpooled.EMPTY_BUFFER;\n+        for (int i = 0; i < batch.size(); i++) {\n+            ByteBuf eventBuf = getByteBuf(batch.get(i));\n+            batchBuff = Unpooled.wrappedUnmodifiableBuffer(batchBuff, eventBuf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ef2c4266871fa57c7c2ac6679002b084bd42067"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4639, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}