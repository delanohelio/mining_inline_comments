{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNjEzNzM5", "number": 4916, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTowNzowMlrOELH9zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0OToyNFrOEPkJNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTAwMzAzOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNTowNzowMlrOGsj05w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNToxNTo1NlrOGsj8Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3NzUxMQ==", "bodyText": "Can we create a method on lines of the below pattern? This would eliminate the need for extra code.\npublic static <T> CompletableFuture<T> wrapFutureWithTimeout(CompletableFuture<T> cf, Duration timeout, ScheduledExecutorService executorService) {\n     \n       ScheduledFuture<Boolean> sf = executorService.schedule(() -> cf.completeExceptionally(new TimeoutException(tag)), timeout.toMillis(), TimeUnit.MILLISECONDS);\n       cf.whenComplete((r, ex) -> sf.cancel(true));\n       return cf;\n   }", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r449377511", "createdAt": "2020-07-03T05:07:02Z", "author": {"login": "shrids"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -635,17 +651,34 @@ private void closeConnection(Reply reply, RawClient client) {\n     }\n \n     private <T extends Request & WireCommand> CompletableFuture<Reply> sendRequest(RawClient connection, long requestId, T request) {\n-        return connection.sendRequest(requestId, request)\n+        CompletableFuture<Reply> future = Futures.futureWithTimeout(timeout.get(), executorService);\n+        AtomicReference<CompletableFuture<Reply>> f = new AtomicReference<>();\n+        Futures.completeAfter(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f17bd6c5ae055366f3d3c0527b99eda316c9069"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3OTQxNQ==", "bodyText": "Interestingly JAVA9 APIS support this https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html#completeOnTimeout-T-long-java.util.concurrent.TimeUnit-", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r449379415", "createdAt": "2020-07-03T05:15:56Z", "author": {"login": "shrids"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -635,17 +651,34 @@ private void closeConnection(Reply reply, RawClient client) {\n     }\n \n     private <T extends Request & WireCommand> CompletableFuture<Reply> sendRequest(RawClient connection, long requestId, T request) {\n-        return connection.sendRequest(requestId, request)\n+        CompletableFuture<Reply> future = Futures.futureWithTimeout(timeout.get(), executorService);\n+        AtomicReference<CompletableFuture<Reply>> f = new AtomicReference<>();\n+        Futures.completeAfter(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM3NzUxMQ=="}, "originalCommit": {"oid": "2f17bd6c5ae055366f3d3c0527b99eda316c9069"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTI4MTcyOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDowNDozNVrOGtIK-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjo0MToyM1rOGtKlrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Mjk4NA==", "bodyText": "Is there a reason why we need to create a new CompletableFuture object? Can we avoid it ?", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r449972984", "createdAt": "2020-07-06T04:04:35Z", "author": {"login": "shrids"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -543,6 +543,32 @@\n         result.whenComplete((r, ex) -> sf.cancel(true));\n         return result;\n     }\n+    \n+    /**\n+     * Creates a new CompletableFuture that either holds the result of future from the futureSupplier\n+     * or will timeout after the given amount of time.\n+     *\n+     * @param futureSupplier  Supplier of the future. \n+     * @param timeout         The timeout for the future.\n+     * @param executorService An ExecutorService that will be used to invoke the timeout on.\n+     * @param <T>             The Type argument for the CompletableFuture to create.\n+     * @return The result.\n+     */\n+    public static <T> CompletableFuture<T> futureWithTimeout(Supplier<CompletableFuture<T>> futureSupplier, \n+                                                             Duration timeout, ScheduledExecutorService executorService) {\n+        CompletableFuture<T> result = new CompletableFuture<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0605369ec1e50f2b013534f2a05a4ed0677a83"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NzA0OA==", "bodyText": "i kept as separate future so that we can issue a cancel on the future received from futureSupplier.\nso at least any downstream processing that was chained may get cancelled.\ni think any ongoing computation is not interrupted with cancellation.. rather the future corresponding to it is cancelled with cancellation exception.\nbut if it were to cancel an ongoing computation, then it would be beneficial.", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r449977048", "createdAt": "2020-07-06T04:25:43Z", "author": {"login": "shiveshr"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -543,6 +543,32 @@\n         result.whenComplete((r, ex) -> sf.cancel(true));\n         return result;\n     }\n+    \n+    /**\n+     * Creates a new CompletableFuture that either holds the result of future from the futureSupplier\n+     * or will timeout after the given amount of time.\n+     *\n+     * @param futureSupplier  Supplier of the future. \n+     * @param timeout         The timeout for the future.\n+     * @param executorService An ExecutorService that will be used to invoke the timeout on.\n+     * @param <T>             The Type argument for the CompletableFuture to create.\n+     * @return The result.\n+     */\n+    public static <T> CompletableFuture<T> futureWithTimeout(Supplier<CompletableFuture<T>> futureSupplier, \n+                                                             Duration timeout, ScheduledExecutorService executorService) {\n+        CompletableFuture<T> result = new CompletableFuture<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Mjk4NA=="}, "originalCommit": {"oid": "0a0605369ec1e50f2b013534f2a05a4ed0677a83"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAwMDAyNg==", "bodyText": "I have made the change to not create a new future. I have also added a method in futures to add timeout to an existing future.", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r450000026", "createdAt": "2020-07-06T06:04:29Z", "author": {"login": "shiveshr"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -543,6 +543,32 @@\n         result.whenComplete((r, ex) -> sf.cancel(true));\n         return result;\n     }\n+    \n+    /**\n+     * Creates a new CompletableFuture that either holds the result of future from the futureSupplier\n+     * or will timeout after the given amount of time.\n+     *\n+     * @param futureSupplier  Supplier of the future. \n+     * @param timeout         The timeout for the future.\n+     * @param executorService An ExecutorService that will be used to invoke the timeout on.\n+     * @param <T>             The Type argument for the CompletableFuture to create.\n+     * @return The result.\n+     */\n+    public static <T> CompletableFuture<T> futureWithTimeout(Supplier<CompletableFuture<T>> futureSupplier, \n+                                                             Duration timeout, ScheduledExecutorService executorService) {\n+        CompletableFuture<T> result = new CompletableFuture<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Mjk4NA=="}, "originalCommit": {"oid": "0a0605369ec1e50f2b013534f2a05a4ed0677a83"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMjU5MA==", "bodyText": "Thanks Shivesh.\ncancel() does not cancel the computation as per the java doc.\n/**\n     * If not already completed, completes this CompletableFuture with\n     * a {@link CancellationException}. Dependent CompletableFutures\n     * that have not already completed will also complete\n     * exceptionally, with a {@link CompletionException} caused by\n     * this {@code CancellationException}.\n     *\n     * @param mayInterruptIfRunning this value has no effect in this\n     * implementation because interrupts are not used to control\n     * processing.\n     *\n     * @return {@code true} if this task is now cancelled\n     */\n    public boolean cancel(boolean mayInterruptIfRunning)", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r450012590", "createdAt": "2020-07-06T06:41:23Z", "author": {"login": "shrids"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -543,6 +543,32 @@\n         result.whenComplete((r, ex) -> sf.cancel(true));\n         return result;\n     }\n+    \n+    /**\n+     * Creates a new CompletableFuture that either holds the result of future from the futureSupplier\n+     * or will timeout after the given amount of time.\n+     *\n+     * @param futureSupplier  Supplier of the future. \n+     * @param timeout         The timeout for the future.\n+     * @param executorService An ExecutorService that will be used to invoke the timeout on.\n+     * @param <T>             The Type argument for the CompletableFuture to create.\n+     * @return The result.\n+     */\n+    public static <T> CompletableFuture<T> futureWithTimeout(Supplier<CompletableFuture<T>> futureSupplier, \n+                                                             Duration timeout, ScheduledExecutorService executorService) {\n+        CompletableFuture<T> result = new CompletableFuture<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Mjk4NA=="}, "originalCommit": {"oid": "0a0605369ec1e50f2b013534f2a05a4ed0677a83"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTI4ODUzOnYy", "diffSide": "LEFT", "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDowOTozN1rOGtIOzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDoyMDoyNFrOGtIW8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Mzk2NQ==", "bodyText": "we should retain the auth failure logs.", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r449973965", "createdAt": "2020-07-06T04:09:37Z", "author": {"login": "shrids"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -635,17 +651,27 @@ private void closeConnection(Reply reply, RawClient client) {\n     }\n \n     private <T extends Request & WireCommand> CompletableFuture<Reply> sendRequest(RawClient connection, long requestId, T request) {\n-        return connection.sendRequest(requestId, request)\n+        CompletableFuture<Reply> future = Futures.futureWithTimeout(\n+                () -> connection.sendRequest(requestId, request)\n+                                .exceptionally(e -> {\n+                                    Throwable unwrap = Exceptions.unwrap(e);\n+                                    if (unwrap instanceof ConnectionFailedException || unwrap instanceof ConnectionClosedException) {\n+                                        log.warn(requestId, \"Connection dropped\");\n+                                        throw new WireCommandFailedException(request.getType(), WireCommandFailedException.Reason.ConnectionFailed);\n+                                    } else {\n+                                        log.error(requestId, \"Request failed\", e);\n+                                        throw new CompletionException(e);\n+                                    }\n+                                }),\n+                timeout.get(), executorService);\n+\n+        return future\n                 .exceptionally(e -> {\n-                    Throwable unwrap = Exceptions.unwrap(e);\n-                    if (unwrap instanceof ConnectionFailedException || unwrap instanceof ConnectionClosedException) {\n-                        log.warn(requestId, \"Connection dropped\");\n+                    if (Exceptions.unwrap(e) instanceof TimeoutException) {\n+                        log.warn(requestId, \"Request timedout.\");\n                         throw new WireCommandFailedException(request.getType(), WireCommandFailedException.Reason.ConnectionFailed);\n-                    } else if (unwrap instanceof AuthenticationException) {\n-                        log.warn(requestId, \"Authentication Exception\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0605369ec1e50f2b013534f2a05a4ed0677a83"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NjA1MA==", "bodyText": "authentication exception cannot come here ever. this is an unreachable code.\nthis is because auth failure will always come in as a response from segment store.\nwhich is handled and translated in handleReply method.\nI can retain it but its a code that doesnt get covered and decreases the coverage.", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r449976050", "createdAt": "2020-07-06T04:20:24Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -635,17 +651,27 @@ private void closeConnection(Reply reply, RawClient client) {\n     }\n \n     private <T extends Request & WireCommand> CompletableFuture<Reply> sendRequest(RawClient connection, long requestId, T request) {\n-        return connection.sendRequest(requestId, request)\n+        CompletableFuture<Reply> future = Futures.futureWithTimeout(\n+                () -> connection.sendRequest(requestId, request)\n+                                .exceptionally(e -> {\n+                                    Throwable unwrap = Exceptions.unwrap(e);\n+                                    if (unwrap instanceof ConnectionFailedException || unwrap instanceof ConnectionClosedException) {\n+                                        log.warn(requestId, \"Connection dropped\");\n+                                        throw new WireCommandFailedException(request.getType(), WireCommandFailedException.Reason.ConnectionFailed);\n+                                    } else {\n+                                        log.error(requestId, \"Request failed\", e);\n+                                        throw new CompletionException(e);\n+                                    }\n+                                }),\n+                timeout.get(), executorService);\n+\n+        return future\n                 .exceptionally(e -> {\n-                    Throwable unwrap = Exceptions.unwrap(e);\n-                    if (unwrap instanceof ConnectionFailedException || unwrap instanceof ConnectionClosedException) {\n-                        log.warn(requestId, \"Connection dropped\");\n+                    if (Exceptions.unwrap(e) instanceof TimeoutException) {\n+                        log.warn(requestId, \"Request timedout.\");\n                         throw new WireCommandFailedException(request.getType(), WireCommandFailedException.Reason.ConnectionFailed);\n-                    } else if (unwrap instanceof AuthenticationException) {\n-                        log.warn(requestId, \"Authentication Exception\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Mzk2NQ=="}, "originalCommit": {"oid": "0a0605369ec1e50f2b013534f2a05a4ed0677a83"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTI5Njg3OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDoxNToyOFrOGtITXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDoxNToyOFrOGtITXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NTEzMg==", "bodyText": "nit: Can we have all the exception handling in one block? it will reduce the creation of a CompletionStage and all the error handling will be done in one block (e.g: right before returning the future below)", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r449975132", "createdAt": "2020-07-06T04:15:28Z", "author": {"login": "shrids"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -635,17 +651,27 @@ private void closeConnection(Reply reply, RawClient client) {\n     }\n \n     private <T extends Request & WireCommand> CompletableFuture<Reply> sendRequest(RawClient connection, long requestId, T request) {\n-        return connection.sendRequest(requestId, request)\n+        CompletableFuture<Reply> future = Futures.futureWithTimeout(\n+                () -> connection.sendRequest(requestId, request)\n+                                .exceptionally(e -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0605369ec1e50f2b013534f2a05a4ed0677a83"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzUzNjY1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0MzoxOFrOGzVwIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0MzoxOFrOGzVwIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4Njk0NA==", "bodyText": "please rewrite the futureWithTimeout above to make use of this method.\nEx:\nreturn futureWithTimeout(CompletableFuture::new, timeout, executorService)", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r456486944", "createdAt": "2020-07-17T14:43:18Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -567,6 +567,47 @@\n         result.whenComplete((r, ex) -> sf.cancel(true));\n         return result;\n     }\n+    \n+    /**\n+     * Creates a new CompletableFuture that either holds the result of future from the futureSupplier\n+     * or will timeout after the given amount of time.\n+     *\n+     * @param futureSupplier  Supplier of the future. \n+     * @param timeout         The timeout for the future.\n+     * @param executorService An ExecutorService that will be used to invoke the timeout on.\n+     * @param <T>             The Type argument for the CompletableFuture to create.\n+     * @return A CompletableFuture which is either completed within given timebound or failed with timeout exception.\n+     */\n+    public static <T> CompletableFuture<T> futureWithTimeout(Supplier<CompletableFuture<T>> futureSupplier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78456e11282a73a751ee64421764eb463460077d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzU0MTg3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0NDo0NFrOGzVzcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0NDo0NFrOGzVzcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4Nzc5Mg==", "bodyText": "This can be rewritten as\nfutureWithTimeout(() -> future, timeout, executorService)", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r456487792", "createdAt": "2020-07-17T14:44:44Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -567,6 +567,47 @@\n         result.whenComplete((r, ex) -> sf.cancel(true));\n         return result;\n     }\n+    \n+    /**\n+     * Creates a new CompletableFuture that either holds the result of future from the futureSupplier\n+     * or will timeout after the given amount of time.\n+     *\n+     * @param futureSupplier  Supplier of the future. \n+     * @param timeout         The timeout for the future.\n+     * @param executorService An ExecutorService that will be used to invoke the timeout on.\n+     * @param <T>             The Type argument for the CompletableFuture to create.\n+     * @return A CompletableFuture which is either completed within given timebound or failed with timeout exception.\n+     */\n+    public static <T> CompletableFuture<T> futureWithTimeout(Supplier<CompletableFuture<T>> futureSupplier,\n+                                                             Duration timeout, ScheduledExecutorService executorService) {\n+        CompletableFuture<T> future = futureSupplier.get();\n+        ScheduledFuture<Boolean> sf = executorService.schedule(() -> future.completeExceptionally(\n+                new TimeoutException()), timeout.toMillis(), TimeUnit.MILLISECONDS);\n+        \n+        return future.whenComplete((r, ex) -> {\n+            sf.cancel(true);\n+        });\n+    }\n+\n+    /**\n+     * Add a timeout to the CompletableFuture. If the future does not complete within the specified timeout,\n+     * this would complete the future with timeout exception. \n+     *\n+     * @param future          Completable future to add timeout to. \n+     * @param timeout         The timeout for the future.\n+     * @param executorService An ExecutorService that will be used to invoke the timeout on.\n+     * @param <T>             The Type argument for the CompletableFuture to create.\n+     */\n+    public static <T> void addTimeout(CompletableFuture<T> future, Duration timeout, ScheduledExecutorService executorService) {\n+        ScheduledFuture<Boolean> sf = executorService.schedule(() -> future.completeExceptionally(new TimeoutException()), timeout.toMillis(), TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78456e11282a73a751ee64421764eb463460077d"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzU1MTQwOnYy", "diffSide": "RIGHT", "path": "common/src/test/java/io/pravega/common/concurrent/FuturesTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0Njo0OFrOGzV47g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0Njo0OFrOGzV47g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4OTE5OA==", "bodyText": "Please change this class to extend from ThreadPooledTestSuite and override getThreadPoolSize to return 1.\nThat base class will take care of your executor.\nWhile you're at it, there is at least one other test in this class that makes its own executor (and never shuts it down!). Please change that too to use executorService() instead.", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r456489198", "createdAt": "2020-07-17T14:46:48Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/test/java/io/pravega/common/concurrent/FuturesTests.java", "diffHunk": "@@ -21,23 +24,40 @@\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ForkJoinPool;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.Executor;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Function;\n import java.util.function.Predicate;\n+import java.util.function.Supplier;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n import lombok.val;\n+import org.junit.After;\n import org.junit.Assert;\n+import org.junit.Before;\n import org.junit.Test;\n \n /**\n  * Unit tests for the Futures class.\n  */\n public class FuturesTests {\n+    private ScheduledExecutorService executor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78456e11282a73a751ee64421764eb463460077d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzU1NjAxOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0Nzo1MFrOGzV7nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0Nzo1MFrOGzV7nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4OTg4NQ==", "bodyText": "Futures.futureWithTimeout(() -> connection.sendRequest(...), ...) ?\nThat will preclude the need for Futures.addTimeout", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r456489885", "createdAt": "2020-07-17T14:47:50Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -605,7 +622,9 @@ private void closeConnection(Reply reply, RawClient client) {\n     }\n \n     private <T extends Request & WireCommand> CompletableFuture<Reply> sendRequest(RawClient connection, long requestId, T request) {\n-        return connection.sendRequest(requestId, request)\n+        CompletableFuture<Reply> future = connection.sendRequest(requestId, request);\n+        Futures.addTimeout(future, timeout.get(), executorService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78456e11282a73a751ee64421764eb463460077d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzU1ODEyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0ODoxOVrOGzV83w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0ODoxOVrOGzV83w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5MDIwNw==", "bodyText": "unwrap contains the unwrapped e. Use that.", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r456490207", "createdAt": "2020-07-17T14:48:19Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -614,6 +633,9 @@ private void closeConnection(Reply reply, RawClient client) {\n                     } else if (unwrap instanceof AuthenticationException) {\n                         log.warn(requestId, \"Authentication Exception\");\n                         throw new WireCommandFailedException(request.getType(), WireCommandFailedException.Reason.AuthFailed);\n+                    } else if (Exceptions.unwrap(e) instanceof TimeoutException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78456e11282a73a751ee64421764eb463460077d"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzU2MTM2OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/util/Config.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0OTowNVrOGzV-0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0OTowNVrOGzV-0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5MDcwNA==", "bodyText": "I would suggest you express this in seconds. We may want to add 30s timeouts. 2 minutes seems too long.", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r456490704", "createdAt": "2020-07-17T14:49:05Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/util/Config.java", "diffHunk": "@@ -128,6 +128,9 @@\n     public static final Property<String> PROPERTY_TLS_ENABLED_FOR_SEGMENT_STORE = Property.named(\n             \"segmentstore.connect.channel.tls\", \"\", \"auth.segmentStoreTlsEnabled\");\n \n+    public static final Property<Integer> PROPERTY_SEGMENT_STORE_REQUEST_TIMEOUT_MINUTES = Property.named(\n+            \"segmentstore.connect.channel.timeoutMinutes\", 2, \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78456e11282a73a751ee64421764eb463460077d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzU2Mjc5OnYy", "diffSide": "RIGHT", "path": "controller/src/test/java/io/pravega/controller/server/SegmentHelperTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0OToyNFrOGzV_qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0OToyNFrOGzV_qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5MDkyMQ==", "bodyText": "Use ThreadPooledTestSuite", "url": "https://github.com/pravega/pravega/pull/4916#discussion_r456490921", "createdAt": "2020-07-17T14:49:24Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/test/java/io/pravega/controller/server/SegmentHelperTest.java", "diffHunk": "@@ -65,19 +70,29 @@\n     private final byte[] value = \"v\".getBytes();\n     private final ByteBuf token1 = wrappedBuffer(new byte[]{0x01});\n     private final ByteBuf token2 = wrappedBuffer(new byte[]{0x02});\n-\n+    private ScheduledExecutorService executorService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78456e11282a73a751ee64421764eb463460077d"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4778, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}