{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2Mzk3MjU1", "number": 5305, "title": "Issue 5296: Using Java 11 Intrinsic Serializers for Shorts, Ints and Longs.", "bodyText": "Change log description\nMaking use of ByteBuffer's putInt, putLong, putShort extensively in BufferView implementations. This enables the use of intrinsic serializers (available since Java 9), which should reduce the CPU overhead during our frequent serializations or deserializations.\nPurpose of the change\nFixes #5296.\nWhat the code does\n\nDefined StructuredWritableBuffer and StructuredReadableBuffer. These will define any BufferView that can support writing (and reading, if needed) primitive types (longs, ints, shorts)\n\nNot all types of buffers need this feature and not all need both writing and reading.\nCompositeByteArraySegment, for example, is only used for writing. There is no reading done from it so it only implements StructuredWritableBuffer. ByteArraySegment, on the other hand, needs to support both.\n\n\nByteBufferOutputStream: created a ByteArrayOutputStream-like implementation that writes to ByteBuffers. This helps in exposing APIs that can write primitive types.\n\nThis class will replace FixedByteArrayOutputStream and EnhancedByteArrayOutputStream, which have been retired.\n\n\nDirectDataOutput defined a simplified version of java.io.DataOutput with only the primitive types we need. Some OutputStreams that we care about (i.e., ByteBufferOutputStream) implement this.\nVersionedSerializer and RevisionDataOutputStream\n\nMaking use of DirectDataOutput (if the underlying OutputStream supports it) when writing structured types.\nUnfortunately this forced me to reimplement all methods from DataOutputStream since DataOutputStream has \"final\" methods so I can't override them\n\n\nDataFrame, DataFrameOutputStream\n\nAdded support for primitive types (shorts, longs, ints) that are passed down directly to the underlying buffer (i.e., CompositeByteArraySegment)\nSome copy-pasting had to be done in these methods since otherwise I'd have to use a lambda which showed a noticeable degradation in performance (these methods are called very, very frequently, so every microsecond counts here).\n\n\nCompositeByteArraySegment\n\nImplemented StructuredWriteableBuffer, with extra care to split multi-byte serializations over component buffers.\n\n\nAdded unit tests for BufferView to verify that the serializations are backward compatible and fully compatible with DataOutputStream/DataInputStream (i.e., the gold standard).\n\nHow to verify it\nAll tests must pass.\nNew unit tests added.", "createdAt": "2020-11-05T23:20:01Z", "url": "https://github.com/pravega/pravega/pull/5305", "merged": true, "mergeCommit": {"oid": "be6dc5d56aa3cf6a891093448be0904657aeeb99"}, "closed": true, "closedAt": "2020-12-03T23:11:36Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZCvj1AH2gAyNTE2Mzk3MjU1OjYyYWQyYWE3NmQ4MDhlMDIwMzg4NzViODEyYWNiMzJiMGU2OWJiNDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdinqaYgFqTU0NDI2Nzg5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "62ad2aa76d808e02038875b812acb32b0e69bb42", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/62ad2aa76d808e02038875b812acb32b0e69bb42", "committedDate": "2020-11-04T00:37:06Z", "message": "BufferViewSink -> DirectDataOutput\nAdded writeShort, writeInt and writeLong to DirectDataOutput.\nDataFrameOutputStream, DataFrame and CompositeArrayView/CompositeByteArraySegment: added support for writing direct ints, longs and shorts using (if available) intrinsic methods.\nAdded some unit tests. More to follow.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa35d331166623f599b6b3a2b411f6567adeacfa", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/aa35d331166623f599b6b3a2b411f6567adeacfa", "committedDate": "2020-11-04T19:00:31Z", "message": "StructuredReadableBuffer and StructuredWritableBuffer. Made ByteArraySegment and CompositeArrayView implement these (as needed). Not yet wired into other upstream classes.\nByteArraySegment uses a ByteBuf underneath.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e32d8198f21c8312a502d510175415ab166358ac", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e32d8198f21c8312a502d510175415ab166358ac", "committedDate": "2020-11-05T00:19:21Z", "message": "Removing usages of BitConverter obsolete methods.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66f1f108130f46a100aa1b5cc9136b6bbedc5dd8", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/66f1f108130f46a100aa1b5cc9136b6bbedc5dd8", "committedDate": "2020-11-05T00:38:45Z", "message": "Bugfix.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7c90a2e7269e221c0178a13c5af807f632209ee", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/c7c90a2e7269e221c0178a13c5af807f632209ee", "committedDate": "2020-11-05T20:59:21Z", "message": "Retired FixedByteArrayOutputStream. Retired EnhancedByteArrayOutputStream.\nCreated ByteBufferOutputStream that will replace both of them. Updated callsites as necessary.\nImproving RevisionDataOutputStream to make use of DirectDataOutput for more situations.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03c1bfe94714eac59be8e8a711f5c400916b4bd9", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/03c1bfe94714eac59be8e8a711f5c400916b4bd9", "committedDate": "2020-11-05T22:10:57Z", "message": "BitConverter unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a1806fdaa3fb7caa68fddc855fe6a890f8b39f8", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/4a1806fdaa3fb7caa68fddc855fe6a890f8b39f8", "committedDate": "2020-11-05T23:18:02Z", "message": "RevisionDataOutputStream unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46e30269eb377b7af82ba2ef2bec1a1da8d00de3", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/46e30269eb377b7af82ba2ef2bec1a1da8d00de3", "committedDate": "2020-11-05T23:18:27Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ddad3c52e8b7532b0098d9fcb6ec4897640672a", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/0ddad3c52e8b7532b0098d9fcb6ec4897640672a", "committedDate": "2020-11-06T00:45:26Z", "message": "Spotbugs.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e54ac4cb2504e55be9c77c2d00a9541ffd07db74", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e54ac4cb2504e55be9c77c2d00a9541ffd07db74", "committedDate": "2020-11-06T17:55:22Z", "message": "Optimizing code.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51c1800ddced2a4fe0e7f63acef67bf55809e875", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/51c1800ddced2a4fe0e7f63acef67bf55809e875", "committedDate": "2020-11-07T02:48:11Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd00cc24c7cda2505594e0c07be27930114d207d", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/fd00cc24c7cda2505594e0c07be27930114d207d", "committedDate": "2020-11-09T23:45:41Z", "message": "Improving tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77f68de9e4cde3d2870447d48e3a845d5aee2196", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/77f68de9e4cde3d2870447d48e3a845d5aee2196", "committedDate": "2020-11-09T23:45:48Z", "message": "Merge remote-tracking branch 'ap/issue-5296-fast-serializers' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MjYyNzE3", "url": "https://github.com/pravega/pravega/pull/5305#pullrequestreview-527262717", "createdAt": "2020-11-10T14:34:03Z", "commit": {"oid": "77f68de9e4cde3d2870447d48e3a845d5aee2196"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNDozNDowM1rOHwfZIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNDozNDowM1rOHwfZIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODAzNQ==", "bodyText": "Have you thought about releasing the ByteBuffer with the cleaner ?", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r520608035", "createdAt": "2020-11-10T14:34:03Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/io/ByteBufferOutputStream.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.io.serialization.RandomAccessOutputStream;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * An {@link OutputStream} that is backed by a {@link ByteBuffer} which can be resized as needed. Prefer using this\n+ * instead of {@link java.io.ByteArrayOutputStream} since this makes direct use of {@link ByteBuffer} intrinsic methods\n+ * for writing primitive types (see {@link DirectDataOutput} for example).\n+ */\n+@NotThreadSafe\n+public class ByteBufferOutputStream extends OutputStream implements RandomAccessOutputStream {\n+    //region Private\n+\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - Long.BYTES;\n+    private ByteBuffer buf;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream}.\n+     */\n+    public ByteBufferOutputStream() {\n+        this(128);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream} with given initial size.\n+     *\n+     * @param initialSize The initial size to create with.\n+     */\n+    public ByteBufferOutputStream(int initialSize) {\n+        this.buf = ByteBuffer.allocate(initialSize);\n+    }\n+\n+    //endregion\n+\n+    //region Implementation\n+\n+    @Override\n+    public void write(int b) {\n+        ensureExtraCapacity(1);\n+        this.buf.put((byte) b);\n+    }\n+\n+    @Override\n+    public void write(int byteValue, int streamPosition) {\n+        this.buf.put(streamPosition, (byte) byteValue);\n+    }\n+\n+    @Override\n+    public void write(byte[] array) {\n+        write(array, 0, array.length);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int offset, int length) {\n+        ensureExtraCapacity(length);\n+        this.buf.put(b, offset, length);\n+    }\n+\n+    @Override\n+    public void write(byte[] array, int arrayOffset, int length, int streamPosition) {\n+        if (arrayOffset < 0 || length < 0 || (length > 0 && arrayOffset + length > array.length)) {\n+            throw new ArrayIndexOutOfBoundsException(\"bufferOffset and length must refer to a range within buffer.\");\n+        }\n+\n+        final int extra = streamPosition + length - this.buf.position();\n+        if (extra > 0) {\n+            ensureExtraCapacity(extra);\n+        }\n+\n+        final int originalPos = this.buf.position();\n+        this.buf.position(streamPosition);\n+        this.buf.put(array, arrayOffset, length);\n+        this.buf.position(Math.max(originalPos, streamPosition + length));\n+    }\n+\n+\n+    @Override\n+    public int size() {\n+        return this.buf.position();\n+    }\n+\n+    @Override\n+    public void flush() {\n+        // This method intentionally left blank.\n+    }\n+\n+    @Override\n+    public void close() {\n+        // This method intentionally left blank.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77f68de9e4cde3d2870447d48e3a845d5aee2196"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MjYzMjQ5", "url": "https://github.com/pravega/pravega/pull/5305#pullrequestreview-527263249", "createdAt": "2020-11-10T14:34:33Z", "commit": {"oid": "77f68de9e4cde3d2870447d48e3a845d5aee2196"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNDozNDozM1rOHwfawg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNDozNDozM1rOHwfawg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODQ1MA==", "bodyText": "Have you thought about releasing the old ByteBuffer with the cleaner ?", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r520608450", "createdAt": "2020-11-10T14:34:33Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/io/ByteBufferOutputStream.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.io.serialization.RandomAccessOutputStream;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * An {@link OutputStream} that is backed by a {@link ByteBuffer} which can be resized as needed. Prefer using this\n+ * instead of {@link java.io.ByteArrayOutputStream} since this makes direct use of {@link ByteBuffer} intrinsic methods\n+ * for writing primitive types (see {@link DirectDataOutput} for example).\n+ */\n+@NotThreadSafe\n+public class ByteBufferOutputStream extends OutputStream implements RandomAccessOutputStream {\n+    //region Private\n+\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - Long.BYTES;\n+    private ByteBuffer buf;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream}.\n+     */\n+    public ByteBufferOutputStream() {\n+        this(128);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream} with given initial size.\n+     *\n+     * @param initialSize The initial size to create with.\n+     */\n+    public ByteBufferOutputStream(int initialSize) {\n+        this.buf = ByteBuffer.allocate(initialSize);\n+    }\n+\n+    //endregion\n+\n+    //region Implementation\n+\n+    @Override\n+    public void write(int b) {\n+        ensureExtraCapacity(1);\n+        this.buf.put((byte) b);\n+    }\n+\n+    @Override\n+    public void write(int byteValue, int streamPosition) {\n+        this.buf.put(streamPosition, (byte) byteValue);\n+    }\n+\n+    @Override\n+    public void write(byte[] array) {\n+        write(array, 0, array.length);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int offset, int length) {\n+        ensureExtraCapacity(length);\n+        this.buf.put(b, offset, length);\n+    }\n+\n+    @Override\n+    public void write(byte[] array, int arrayOffset, int length, int streamPosition) {\n+        if (arrayOffset < 0 || length < 0 || (length > 0 && arrayOffset + length > array.length)) {\n+            throw new ArrayIndexOutOfBoundsException(\"bufferOffset and length must refer to a range within buffer.\");\n+        }\n+\n+        final int extra = streamPosition + length - this.buf.position();\n+        if (extra > 0) {\n+            ensureExtraCapacity(extra);\n+        }\n+\n+        final int originalPos = this.buf.position();\n+        this.buf.position(streamPosition);\n+        this.buf.put(array, arrayOffset, length);\n+        this.buf.position(Math.max(originalPos, streamPosition + length));\n+    }\n+\n+\n+    @Override\n+    public int size() {\n+        return this.buf.position();\n+    }\n+\n+    @Override\n+    public void flush() {\n+        // This method intentionally left blank.\n+    }\n+\n+    @Override\n+    public void close() {\n+        // This method intentionally left blank.\n+    }\n+\n+    //endregion\n+\n+    //region RandomAccessOutputStream and DirectDataOutput Implementation\n+\n+    @Override\n+    public void writeBuffer(BufferView buffer) {\n+        ensureExtraCapacity(buffer.getLength());\n+        int bytesCopied = buffer.copyTo(this.buf);\n+        assert bytesCopied == buffer.getLength();\n+    }\n+\n+    @Override\n+    public void writeShort(int shortValue) {\n+        ensureExtraCapacity(Short.BYTES);\n+        this.buf.putShort((short) shortValue);\n+    }\n+\n+    @Override\n+    public void writeInt(int intValue) {\n+        ensureExtraCapacity(Integer.BYTES);\n+        this.buf.putInt(intValue);\n+    }\n+\n+    @Override\n+    public void writeInt(int intValue, int streamPosition) {\n+        this.buf.putInt(streamPosition, intValue);\n+    }\n+\n+    @Override\n+    public void writeLong(long longValue) {\n+        ensureExtraCapacity(Long.BYTES);\n+        this.buf.putLong(longValue);\n+    }\n+\n+    @Override\n+    public ByteArraySegment getData() {\n+        return new ByteArraySegment(this.buf.array(), this.buf.arrayOffset(), size());\n+    }\n+\n+    //endregion\n+\n+    //region Helpers\n+\n+    private void ensureExtraCapacity(int count) {\n+        // This method is borrowed from ByteArrayOutputStream and adapted for use with ByteBuffers.\n+        final int minCapacity = this.buf.position() + count;\n+        if (minCapacity <= this.buf.limit()) {\n+            return;\n+        }\n+\n+        final int oldCapacity = this.buf.limit();\n+        int newCapacity = oldCapacity << 1;\n+        if (newCapacity - minCapacity < 0) {\n+            newCapacity = minCapacity;\n+        }\n+\n+        if (newCapacity - MAX_ARRAY_SIZE > 0) {\n+            if (minCapacity < 0) {\n+                throw new OutOfMemoryError();\n+            } else {\n+                newCapacity = minCapacity > MAX_ARRAY_SIZE ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;\n+            }\n+        }\n+\n+        final int oldPosition = this.buf.position();\n+        this.buf.position(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77f68de9e4cde3d2870447d48e3a845d5aee2196"}, "originalPosition": 175}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a727d464855ef748aaefcd4de189ea8f30bc979e", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a727d464855ef748aaefcd4de189ea8f30bc979e", "committedDate": "2020-11-10T20:51:29Z", "message": "BufferView.Reader.readBytes now targets a ByteBuffer (instead of ByteArraySegment).\nOptimizing code.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6c0ee7b0da6f43eba2edb6c51ed2a81e548eee7", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a6c0ee7b0da6f43eba2edb6c51ed2a81e548eee7", "committedDate": "2020-11-16T16:22:38Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8336ba47708989475488d3680d8da222b53a74e", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e8336ba47708989475488d3680d8da222b53a74e", "committedDate": "2020-11-19T15:34:42Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d7a0cc711eb753c84b1fd10107a49662cc1c2b1", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/0d7a0cc711eb753c84b1fd10107a49662cc1c2b1", "committedDate": "2020-11-20T10:20:42Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MzAyMTMz", "url": "https://github.com/pravega/pravega/pull/5305#pullrequestreview-535302133", "createdAt": "2020-11-20T10:23:08Z", "commit": {"oid": "0d7a0cc711eb753c84b1fd10107a49662cc1c2b1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8960fc7fa010db18de3f8c1325302b71bbfc8200", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/8960fc7fa010db18de3f8c1325302b71bbfc8200", "committedDate": "2020-11-20T15:56:19Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7af6eae7f9063141c91b5642e8cf0b68c728aa25", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/7af6eae7f9063141c91b5642e8cf0b68c728aa25", "committedDate": "2020-11-20T22:41:54Z", "message": "Fixed a bug in CompositeByteArraySegment where it would incorrectly read more than needed when reading into the last ByteBuffer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9a3872951bab154cd13d8d6b9d2b07c1f7ba8cd", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a9a3872951bab154cd13d8d6b9d2b07c1f7ba8cd", "committedDate": "2020-11-22T20:52:19Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ef147c70e62361c9b8a97f2f83af60fca1c1b18", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/5ef147c70e62361c9b8a97f2f83af60fca1c1b18", "committedDate": "2020-11-23T15:33:57Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzgwMjQy", "url": "https://github.com/pravega/pravega/pull/5305#pullrequestreview-536780242", "createdAt": "2020-11-23T19:27:17Z", "commit": {"oid": "5ef147c70e62361c9b8a97f2f83af60fca1c1b18"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb60bdfd4fb0d26ba17bce354b49849285cd9473", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/fb60bdfd4fb0d26ba17bce354b49849285cd9473", "committedDate": "2020-11-24T01:40:00Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/b4c518306198cc9e8090fac9f90587bd6d948dc1", "committedDate": "2020-11-24T13:47:24Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3OTY1ODIw", "url": "https://github.com/pravega/pravega/pull/5305#pullrequestreview-537965820", "createdAt": "2020-11-24T21:31:47Z", "commit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozMTo0OFrOH5V-pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoxMTo1NFrOH5eKxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MDk4Mg==", "bodyText": "Take a look at how I handled this here:\nhttps://github.com/pravega/pravega/pull/5249/files#diff-281329b3593c7cd026ac5e38d7d89ecdabb4d4ebff070c50268ce53f328798aeR214\nI think rather than this random access pattern which has the problem of passing offsets that have not yet been allocated. (IE ensureExtraCapacity is not called here) it's better to return a slice that can be written to to write to. This allows a caller to delay writing to a particular location until later and have an object which represents the location that they can jump back to.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529890982", "createdAt": "2020-11-24T21:31:48Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/io/ByteBufferOutputStream.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.io.serialization.RandomAccessOutputStream;\n+import io.pravega.common.util.BufferView;\n+import io.pravega.common.util.ByteArraySegment;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * An {@link OutputStream} that is backed by a {@link ByteBuffer} which can be resized as needed. Prefer using this\n+ * instead of {@link java.io.ByteArrayOutputStream} since this makes direct use of {@link ByteBuffer} intrinsic methods\n+ * for writing primitive types (see {@link DirectDataOutput} for example).\n+ */\n+@NotThreadSafe\n+public class ByteBufferOutputStream extends OutputStream implements RandomAccessOutputStream {\n+    //region Private\n+\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - Long.BYTES;\n+    private ByteBuffer buf;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream}.\n+     */\n+    public ByteBufferOutputStream() {\n+        this(128);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ByteBufferOutputStream} with given initial size.\n+     *\n+     * @param initialSize The initial size to create with.\n+     */\n+    public ByteBufferOutputStream(int initialSize) {\n+        this.buf = ByteBuffer.allocate(initialSize);\n+    }\n+\n+    //endregion\n+\n+    //region Implementation\n+\n+    @Override\n+    public void write(int b) {\n+        ensureExtraCapacity(1);\n+        this.buf.put((byte) b);\n+    }\n+\n+    @Override\n+    public void write(int byteValue, int streamPosition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MjY4OQ==", "bodyText": "Is there a reason this is prefered to DataOutput with is a built in interface for more or less the same thing?", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529892689", "createdAt": "2020-11-24T21:35:25Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/io/DirectDataOutput.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.io;\n+\n+import io.pravega.common.util.BufferView;\n+import java.io.IOException;\n+\n+/**\n+ * Defines an object meant for serializing data (usually an {@link java.io.OutputStream}) that can write various inputs\n+ * more efficiently than otherwise (i.e., byte-by-byte copy).\n+ */\n+public interface DirectDataOutput {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDk0Nw==", "bodyText": "You can use slicing to eliminate the need for this member.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529894947", "createdAt": "2020-11-24T21:39:58Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -21,17 +20,18 @@\n import java.util.Iterator;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n+import lombok.Getter;\n \n /**\n  * Allows segmenting a byte array and operating only on that segment.\n  */\n public class ByteArraySegment extends AbstractBufferView implements ArrayView {\n     //region Members\n \n-    private final byte[] array;\n-    private final int startOffset;\n+    private final ByteBuffer buffer;\n+    private final int bufferPosition;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NTg2OA==", "bodyText": "This method name does not imply a copy will be performed. The prefix \"as\" would lead me to believe that one will not.\nWe should either rename the method, or make it avoid the copy.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529895868", "createdAt": "2020-11-24T21:41:42Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -123,24 +114,30 @@ public Reader getBufferViewReader() {\n \n     @Override\n     public InputStream getReader() {\n-        return new ByteArrayInputStream(this.array, this.startOffset, this.length);\n+        return new ByteArrayInputStream(array(), arrayOffset(), this.length);\n     }\n \n     @Override\n     public InputStream getReader(int offset, int length) {\n         Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n-        return new ByteArrayInputStream(this.array, this.startOffset + offset, length);\n+        return new ByteArrayInputStream(array(), arrayOffset() + offset, length);\n     }\n \n     @Override\n     public ByteArraySegment slice(int offset, int length) {\n-        return subSegment(offset, length, this.readOnly);\n+        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n+        return new ByteArraySegment(array(), arrayOffset() + offset, length);\n+    }\n+\n+    @Override\n+    public ByteBuffer asByteBuffer() {\n+        return this.buffer.duplicate(); // Duplicate to prevent anyone external from messing with our buffer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NjgwMg==", "bodyText": ".array() is not guaranteed to exist. It is OK to rely on if this class is the one creating the buffer but in this case it is not. So if the provided buffer came from a socket then this method could throw.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529896802", "createdAt": "2020-11-24T21:43:31Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -68,7 +55,7 @@ public ByteArraySegment(byte[] array, int startOffset, int length) {\n      * @throws UnsupportedOperationException  If buff is not backed by an array.\n      */\n     public ByteArraySegment(ByteBuffer buff) {\n-        this(buff.array(), buff.arrayOffset() + buff.position(), buff.remaining(), false);\n+        this(buff.array(), buff.arrayOffset() + buff.position(), buff.remaining());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NzE4Mw==", "bodyText": "See above. (Also I think byteBuffer already has a method for this)", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529897183", "createdAt": "2020-11-24T21:44:10Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -149,13 +146,13 @@ public void copyTo(byte[] target, int targetOffset, int length) {\n         Preconditions.checkElementIndex(length, this.length + 1, \"length\");\n         Exceptions.checkArrayRange(targetOffset, length, target.length, \"index\", \"values.length\");\n \n-        System.arraycopy(this.array, this.startOffset, target, targetOffset, length);\n+        System.arraycopy(array(), arrayOffset(), target, targetOffset, length);\n     }\n \n     @Override\n     public int copyTo(ByteBuffer target) {\n         int length = Math.min(this.length, target.remaining());\n-        target.put(this.array, this.startOffset, length);\n+        target.put(array(), arrayOffset(), length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NzMwNQ==", "bodyText": "See above. (Also I think byteBuffer already has a method for this)", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529897305", "createdAt": "2020-11-24T21:44:24Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -168,16 +165,16 @@ public int copyTo(ByteBuffer target) {\n      */\n     @Override\n     public void copyTo(OutputStream stream) throws IOException {\n-        stream.write(this.array, this.startOffset, this.length);\n+        stream.write(array(), arrayOffset(), this.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5Nzk4OQ==", "bodyText": "Here is an example of where the \"asByteBuffer\" performing a copy is unexpected. Before there was no copy here and now there is.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529897989", "createdAt": "2020-11-24T21:45:37Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODA2Mg==", "bodyText": "same here", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898062", "createdAt": "2020-11-24T21:45:45Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());\n     }\n \n     @Override\n     public Iterator<ByteBuffer> iterateBuffers() {\n-        return Iterators.singletonIterator(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        return Iterators.singletonIterator(asByteBuffer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODE2OA==", "bodyText": "See above.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898168", "createdAt": "2020-11-24T21:46:00Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());\n     }\n \n     @Override\n     public Iterator<ByteBuffer> iterateBuffers() {\n-        return Iterators.singletonIterator(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        return Iterators.singletonIterator(asByteBuffer());\n     }\n \n-    //endregion\n+    @Override\n+    public void set(int index, byte value) {\n+        this.buffer.put(this.bufferPosition + index, value);\n+    }\n \n-    //region Operations\n+    @Override\n+    public void setShort(int index, short value) {\n+        this.buffer.putShort(this.bufferPosition + index, value);\n+    }\n \n-    /**\n-     * Sets the value at the specified index.\n-     *\n-     * @param index The index to set the value at.\n-     * @param value The value to set.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n-     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n-     */\n-    public void set(int index, byte value) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        Preconditions.checkElementIndex(index, this.length, \"index\");\n-        this.array[index + this.startOffset] = value;\n+    @Override\n+    public void setInt(int index, int value) {\n+        this.buffer.putInt(this.bufferPosition + index, value);\n     }\n \n-    /**\n-     * Gets a value indicating whether the ByteArraySegment is read-only.\n-     *\n-     * @return The value.\n-     */\n-    public boolean isReadOnly() {\n-        return this.readOnly;\n+    @Override\n+    public void setLong(int index, long value) {\n+        this.buffer.putLong(this.bufferPosition + index, value);\n     }\n \n+    //endregion\n+\n+    //region Other Operations\n+\n     /**\n-     * Copies a specified number of bytes from the given ByteArraySegment into this ByteArraySegment.\n+     * Copies a specified number of bytes from the given {@link ArrayView} into this ByteArraySegment.\n      *\n-     * @param source       The ByteArraySegment to copy bytes from.\n+     * @param source       The {@link ArrayView} to copy bytes from.\n      * @param targetOffset The offset within this ByteArraySegment to start copying at.\n      * @param length       The number of bytes to copy.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n-    public void copyFrom(ByteArraySegment source, int targetOffset, int length) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n+    public void copyFrom(ArrayView source, int targetOffset, int length) {\n         Exceptions.checkArrayRange(targetOffset, length, this.length, \"index\", \"values.length\");\n         Preconditions.checkElementIndex(length, source.getLength() + 1, \"length\");\n \n-        System.arraycopy(source.array, source.startOffset, this.array, targetOffset + this.startOffset, length);\n+        System.arraycopy(source.array(), source.arrayOffset(), this.array(), this.bufferPosition + targetOffset, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODIzMA==", "bodyText": "See above.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898230", "createdAt": "2020-11-24T21:46:08Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -186,113 +183,77 @@ public boolean equals(BufferView other) {\n \n     @Override\n     public <ExceptionT extends Exception> void collect(Collector<ExceptionT> bufferCollector) throws ExceptionT {\n-        bufferCollector.accept(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        bufferCollector.accept(asByteBuffer());\n     }\n \n     @Override\n     public Iterator<ByteBuffer> iterateBuffers() {\n-        return Iterators.singletonIterator(ByteBuffer.wrap(this.array, this.startOffset, this.length));\n+        return Iterators.singletonIterator(asByteBuffer());\n     }\n \n-    //endregion\n+    @Override\n+    public void set(int index, byte value) {\n+        this.buffer.put(this.bufferPosition + index, value);\n+    }\n \n-    //region Operations\n+    @Override\n+    public void setShort(int index, short value) {\n+        this.buffer.putShort(this.bufferPosition + index, value);\n+    }\n \n-    /**\n-     * Sets the value at the specified index.\n-     *\n-     * @param index The index to set the value at.\n-     * @param value The value to set.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n-     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n-     */\n-    public void set(int index, byte value) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        Preconditions.checkElementIndex(index, this.length, \"index\");\n-        this.array[index + this.startOffset] = value;\n+    @Override\n+    public void setInt(int index, int value) {\n+        this.buffer.putInt(this.bufferPosition + index, value);\n     }\n \n-    /**\n-     * Gets a value indicating whether the ByteArraySegment is read-only.\n-     *\n-     * @return The value.\n-     */\n-    public boolean isReadOnly() {\n-        return this.readOnly;\n+    @Override\n+    public void setLong(int index, long value) {\n+        this.buffer.putLong(this.bufferPosition + index, value);\n     }\n \n+    //endregion\n+\n+    //region Other Operations\n+\n     /**\n-     * Copies a specified number of bytes from the given ByteArraySegment into this ByteArraySegment.\n+     * Copies a specified number of bytes from the given {@link ArrayView} into this ByteArraySegment.\n      *\n-     * @param source       The ByteArraySegment to copy bytes from.\n+     * @param source       The {@link ArrayView} to copy bytes from.\n      * @param targetOffset The offset within this ByteArraySegment to start copying at.\n      * @param length       The number of bytes to copy.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n-    public void copyFrom(ByteArraySegment source, int targetOffset, int length) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n+    public void copyFrom(ArrayView source, int targetOffset, int length) {\n         Exceptions.checkArrayRange(targetOffset, length, this.length, \"index\", \"values.length\");\n         Preconditions.checkElementIndex(length, source.getLength() + 1, \"length\");\n \n-        System.arraycopy(source.array, source.startOffset, this.array, targetOffset + this.startOffset, length);\n+        System.arraycopy(source.array(), source.arrayOffset(), this.array(), this.bufferPosition + targetOffset, length);\n     }\n \n     /**\n-     * Copies a specified number of bytes from the given ByteArraySegment into this ByteArraySegment.\n+     * Copies a specified number of bytes from the given {@link ArrayView} into this ByteArraySegment.\n      *\n-     * @param source       The ByteArraySegment to copy bytes from.\n+     * @param source       The {@link ArrayView} to copy bytes from.\n      * @param sourceOffset The offset within source to start copying from.\n      * @param targetOffset The offset within this ByteArraySegment to start copying at.\n      * @param length       The number of bytes to copy.\n-     * @throws IllegalStateException          If the ByteArraySegment is readonly.\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n-    public void copyFrom(ByteArraySegment source, int sourceOffset, int targetOffset, int length) {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        Exceptions.checkArrayRange(sourceOffset, length, source.length, \"index\", \"values.length\");\n+    public void copyFrom(ArrayView source, int sourceOffset, int targetOffset, int length) {\n+        Exceptions.checkArrayRange(sourceOffset, length, source.getLength(), \"index\", \"values.length\");\n         Exceptions.checkArrayRange(targetOffset, length, this.length, \"index\", \"values.length\");\n         Preconditions.checkElementIndex(length, source.getLength() + 1, \"length\");\n \n-        System.arraycopy(source.array, source.startOffset + sourceOffset, this.array, this.startOffset + targetOffset, length);\n-    }\n-\n-    /**\n-     * Creates an OutputStream that can be used to write contents to this ByteArraySegment. The OutputStream returned\n-     * is a FixedByteArrayOutputStream (ByteArrayOutputStream that cannot expand) that spans the entire ByteArraySegment.\n-     *\n-     * @return The OutputStream.\n-     * @throws IllegalStateException If the ByteArraySegment is readonly.\n-     */\n-    public OutputStream getWriter() {\n-        Preconditions.checkState(!this.readOnly, \"Cannot modify a read-only ByteArraySegment.\");\n-        return new FixedByteArrayOutputStream(this.array, this.startOffset, this.length);\n-    }\n-\n-    /**\n-     * Returns a new ByteArraySegment that is a sub-segment of this ByteArraySegment. The new ByteArraySegment wraps\n-     * the same underlying byte array that this ByteArraySegment does.\n-     *\n-     * @param offset   The offset within this ByteArraySegment where the new ByteArraySegment starts.\n-     * @param length   The length of the new ByteArraySegment.\n-     * @param readOnly Whether the resulting sub-segment should be read-only.\n-     *                 Note: if this ByteArraySegment is already read-only, this argument is ignored and the resulting\n-     *                 segment is read-only\n-     * @return The new ByteArraySegment.\n-     * @throws ArrayIndexOutOfBoundsException If offset or length are invalid.\n-     */\n-    public ByteArraySegment subSegment(int offset, int length, boolean readOnly) {\n-        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n-        return new ByteArraySegment(this.array, this.startOffset + offset, length, readOnly || this.readOnly);\n+        System.arraycopy(source.array(), source.arrayOffset() + sourceOffset, this.array(), this.bufferPosition + targetOffset, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5ODkyOQ==", "bodyText": "This is bad from. Please do a conditional.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529898929", "createdAt": "2020-11-24T21:47:27Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTQzNA==", "bodyText": "Same here", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529899434", "createdAt": "2020-11-24T21:48:24Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            bb.array()[bufferOffset] = (byte) (value >>> 8 & 255);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) (value & 255);\n+        }\n+    }\n+\n+    @Override\n+    public void setInt(int offset, int value) {\n+        Exceptions.checkArrayRange(offset, Integer.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putInt(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTY1MQ==", "bodyText": "Same here", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529899651", "createdAt": "2020-11-24T21:48:49Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            bb.array()[bufferOffset] = (byte) (value >>> 8 & 255);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) (value & 255);\n+        }\n+    }\n+\n+    @Override\n+    public void setInt(int offset, int value) {\n+        Exceptions.checkArrayRange(offset, Integer.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putInt(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            // Intentionally left blank.\n+        }\n+\n+        int diff = bb.remaining() - bufferOffset;\n+        if (diff == 3) {\n+            // We can only fit 3 bytes. Write as 1 short + 2 bytes.\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            bb.array()[bufferOffset + Short.BYTES] = (byte) (value >>> 8);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) value;\n+        } else if (diff == 2) {\n+            // We can only fit 2 bytes. Write as 2 shorts\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            getBuffer(bufferId + 1, true).putShort(0, (short) value);\n+        } else {\n+            // We can only fit 1 byte. Write as 2 bytes + 1 short.\n+            bb.array()[bufferOffset] = (byte) (value >>> 24);\n+            bb = getBuffer(bufferId + 1, true);\n+            bb.array()[0] = (byte) (value >>> 16);\n+            bb.putShort(1, (short) value);\n+        }\n+    }\n+\n+    @Override\n+    public void setLong(int offset, long value) {\n+        Exceptions.checkArrayRange(offset, Long.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putLong(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwMDA4Ng==", "bodyText": "At this point it might be easier to just have a for loop", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r529900086", "createdAt": "2020-11-24T21:49:12Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -112,14 +113,126 @@ private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffse\n \n     @Override\n     public byte get(int offset) {\n-        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n-        return array == null ? 0 : array[getArrayOffset(offset)];\n+        ByteBuffer bb = getBuffer(getBufferId(offset), false); // No need to allocate array if not allocated yet.\n+        return bb == null ? 0 : bb.array()[getBufferOffset(offset)];\n     }\n \n     @Override\n     public void set(int offset, byte value) {\n-        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n-        array[getArrayOffset(offset)] = value;\n+        ByteBuffer bb = getBuffer(getBufferId(offset), true); // Need to allocate array if not allocated yet.\n+        bb.array()[getBufferOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public void setShort(int offset, short value) {\n+        Exceptions.checkArrayRange(offset, Short.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+        try {\n+            bb.putShort(bufferOffset, value);\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            bb.array()[bufferOffset] = (byte) (value >>> 8 & 255);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) (value & 255);\n+        }\n+    }\n+\n+    @Override\n+    public void setInt(int offset, int value) {\n+        Exceptions.checkArrayRange(offset, Integer.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putInt(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            // Intentionally left blank.\n+        }\n+\n+        int diff = bb.remaining() - bufferOffset;\n+        if (diff == 3) {\n+            // We can only fit 3 bytes. Write as 1 short + 2 bytes.\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            bb.array()[bufferOffset + Short.BYTES] = (byte) (value >>> 8);\n+            getBuffer(bufferId + 1, true).array()[0] = (byte) value;\n+        } else if (diff == 2) {\n+            // We can only fit 2 bytes. Write as 2 shorts\n+            bb.putShort(bufferOffset, (short) (value >>> 16));\n+            getBuffer(bufferId + 1, true).putShort(0, (short) value);\n+        } else {\n+            // We can only fit 1 byte. Write as 2 bytes + 1 short.\n+            bb.array()[bufferOffset] = (byte) (value >>> 24);\n+            bb = getBuffer(bufferId + 1, true);\n+            bb.array()[0] = (byte) (value >>> 16);\n+            bb.putShort(1, (short) value);\n+        }\n+    }\n+\n+    @Override\n+    public void setLong(int offset, long value) {\n+        Exceptions.checkArrayRange(offset, Long.BYTES, this.length, \"index\", \"length\");\n+\n+        int bufferId = getBufferId(offset);\n+        ByteBuffer bb = getBuffer(bufferId, true);\n+        int bufferOffset = getBufferOffset(offset);\n+\n+        try {\n+            bb.putLong(bufferOffset, value);\n+            return;\n+        } catch (IndexOutOfBoundsException | BufferOverflowException ex) {\n+            // Intentionally left blank.\n+        }\n+\n+        int diff = bb.remaining() - bufferOffset;\n+        if (diff == 7) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNDkzMg==", "bodyText": "It's very odd that this is called \"unsigned long\" because, as I understand it, the point of this method is so that negative numbers are sorted below positive ones when sorting by bytes. So it's not only relevant when dealing with exclusively positive numbers, if that were the case the method wouldn't be needed in the first place.\nI would term this \"sortable\" rather than unsigned, and I wouldn't make it part of this interface but a wrapper that implements all these same getInt getShort etc, so that it works with all of them.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530024932", "createdAt": "2020-11-25T00:11:15Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/StructuredReadableBuffer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+/**\n+ * {@link BufferView} whose contents can be interpreted as structured data.\n+ * See {@link StructuredWritableBuffer} for reading such data.\n+ */\n+public interface StructuredReadableBuffer extends BufferView {\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The byte at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n+     */\n+    byte get(int index);\n+\n+    /**\n+     * Gets the 16 bit Short value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Short at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    short getShort(int index);\n+\n+    /**\n+     * Gets the 32 bit Int value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Integer at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    int getInt(int index);\n+\n+    /**\n+     * Gets the 64 bit Long value at the specified index.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Long at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    long getLong(int index);\n+\n+    /**\n+     * Gets a 64 bit Unsigned Long from the specified index. This value must have been serialized using\n+     * {@link StructuredWritableBuffer#setUnsignedLong} for proper results. This method is not interoperable with\n+     * {@link StructuredWritableBuffer#setLong}.\n+     *\n+     * @param index The index to get the value at.\n+     * @return The Long at the specified index.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    default long getUnsignedLong(int index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNTE1OA==", "bodyText": "See my comment above.", "url": "https://github.com/pravega/pravega/pull/5305#discussion_r530025158", "createdAt": "2020-11-25T00:11:54Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/StructuredWritableBuffer.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+/**\n+ * Modifiable {@link BufferView} whose contents can be interpreted as structured data.\n+ * See {@link StructuredReadableBuffer} for reading such data.\n+ */\n+public interface StructuredWritableBuffer extends BufferView {\n+    /**\n+     * Sets the value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Byte value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid.\n+     */\n+    void set(int index, byte value);\n+\n+    /**\n+     * Sets a Short value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Short value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    void setShort(int index, short value);\n+\n+    /**\n+     * Sets a 32 bit Integer value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Integer value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    void setInt(int index, int value);\n+\n+    /**\n+     * Sets a 64 bit Long value at the specified index.\n+     *\n+     * @param index The index to set the value at.\n+     * @param value The Long value to set.\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    void setLong(int index, long value);\n+\n+    /**\n+     * Sets a 64 bit Unsigned Long at the specified index. This value can then be deserialized using\n+     * {@link StructuredReadableBuffer#getUnsignedLong(int)}. This method is not interoperable with\n+     * {@link StructuredReadableBuffer#getLong}.\n+     *\n+     * The advantage of serializing as Unsigned Long (vs. a normal Signed Long) is that the serialization will have the\n+     * same natural order as the input value type (i.e., if compared using a lexicographic bitwise comparator such as\n+     * BufferViewComparator, it will have the same ordering as the typical Long type).\n+     *\n+     * @param index The index to set the value at.\n+     * @param value  The (signed) value to write. The value will be converted into the range [0, 2^64-1] before\n+     *               serialization by flipping the high order bit (so positive values will begin with 1 and negative values\n+     *               will begin with 0).\n+     * @throws ArrayIndexOutOfBoundsException If index is invalid or if there is insufficient space in the array starting\n+     *                                        at the specified index to fit the given value.\n+     */\n+    default void setUnsignedLong(int index, long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c518306198cc9e8090fac9f90587bd6d948dc1"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaf68c051ed9142e56da2bf46f4c2e4e0b390eef", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/aaf68c051ed9142e56da2bf46f4c2e4e0b390eef", "committedDate": "2020-11-25T16:07:04Z", "message": "Using ByteBuffer.position.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9f6758daef34cb2049eeeb82e948dbb79e9b2be", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/c9f6758daef34cb2049eeeb82e948dbb79e9b2be", "committedDate": "2020-11-27T14:02:25Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11def26ad28d1fe2912771853ff06ba2bc93dd05", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/11def26ad28d1fe2912771853ff06ba2bc93dd05", "committedDate": "2020-11-30T15:34:54Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7368f916535edddff0fe63a1b7c68c6b480c58b7", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/7368f916535edddff0fe63a1b7c68c6b480c58b7", "committedDate": "2020-11-30T21:34:26Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63e93a8581ba43ef22832f50ad34ba53b32a9f55", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/63e93a8581ba43ef22832f50ad34ba53b32a9f55", "committedDate": "2020-12-01T22:45:39Z", "message": "Optimizing CompositeByteArraySegment\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80432df46bcbe62310113cb0e3e735562d3874cc", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/80432df46bcbe62310113cb0e3e735562d3874cc", "committedDate": "2020-12-01T22:46:09Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97805e9136065741c9f04c3cbbd1908129d3a781", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/97805e9136065741c9f04c3cbbd1908129d3a781", "committedDate": "2020-12-02T04:27:27Z", "message": "do-while -> while\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46d136f620bd951062d0b13ad8708d3005ec87e6", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/46d136f620bd951062d0b13ad8708d3005ec87e6", "committedDate": "2020-12-02T16:00:43Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa4a234cb7ae56f25f5d3d189f768fe2f486be5f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/fa4a234cb7ae56f25f5d3d189f768fe2f486be5f", "committedDate": "2020-12-02T20:49:25Z", "message": "Merge branch 'master' into issue-5296-fast-serializers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MjY3ODkw", "url": "https://github.com/pravega/pravega/pull/5305#pullrequestreview-544267890", "createdAt": "2020-12-03T18:43:17Z", "commit": {"oid": "fa4a234cb7ae56f25f5d3d189f768fe2f486be5f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3716, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}