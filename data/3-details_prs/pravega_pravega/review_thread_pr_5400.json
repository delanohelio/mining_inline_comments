{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNzk2NTg2", "number": 5400, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo1NTo1M1rOFCzpeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjoxNDozNVrOFHd2yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDg3NjczOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo1NTo1M1rOICJXcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOToxODoxNVrOIFG4KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyMTUyMw==", "bodyText": "nit: revert", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r539121523", "createdAt": "2020-12-09T08:55:53Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -11,13 +11,7 @@\n \n import io.pravega.client.admin.KeyValueTableInfo;\n import io.pravega.client.segment.impl.Segment;\n-import io.pravega.client.stream.EventStreamReader;\n-import io.pravega.client.stream.EventStreamWriter;\n-import io.pravega.client.stream.Stream;\n-import io.pravega.client.stream.StreamConfiguration;\n-import io.pravega.client.stream.StreamCut;\n-import io.pravega.client.stream.Transaction;\n-import io.pravega.client.stream.TxnFailedException;\n+import io.pravega.client.stream.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5055076fee404e93b37a738b0c9fefef2fe40ba7"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIyNjQ3Mg==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542226472", "createdAt": "2020-12-14T09:18:15Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -11,13 +11,7 @@\n \n import io.pravega.client.admin.KeyValueTableInfo;\n import io.pravega.client.segment.impl.Segment;\n-import io.pravega.client.stream.EventStreamReader;\n-import io.pravega.client.stream.EventStreamWriter;\n-import io.pravega.client.stream.Stream;\n-import io.pravega.client.stream.StreamConfiguration;\n-import io.pravega.client.stream.StreamCut;\n-import io.pravega.client.stream.Transaction;\n-import io.pravega.client.stream.TxnFailedException;\n+import io.pravega.client.stream.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyMTUyMw=="}, "originalCommit": {"oid": "5055076fee404e93b37a738b0c9fefef2fe40ba7"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMTU1MTQyOnYy", "diffSide": "RIGHT", "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/CreateReaderGroupEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQxMzoxODo1MFrOIEfGLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNToyNjowM1rOIFAZYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU3NDcwMA==", "bodyText": "should we also include the \"generation\"?", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r541574700", "createdAt": "2020-12-12T13:18:50Z", "author": {"login": "shiveshr"}, "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/CreateReaderGroupEvent.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.controller.event;\n+\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+\n+@Builder\n+@Data\n+@AllArgsConstructor\n+public class CreateReaderGroupEvent implements ControllerEvent {\n+    private static final long serialVersionUID = 1L;\n+    private final String scopeName;\n+    private final String rgName;\n+    private final long requestId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyMDI5MA==", "bodyText": "For createReaderGroup, the generation is always=0 and this is set by the createReaderGroup task in RGMetadata as part of ReaderGroupConfig.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542120290", "createdAt": "2020-12-14T05:26:03Z", "author": {"login": "pbelgundi"}, "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/CreateReaderGroupEvent.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.controller.event;\n+\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+\n+@Builder\n+@Data\n+@AllArgsConstructor\n+public class CreateReaderGroupEvent implements ControllerEvent {\n+    private static final long serialVersionUID = 1L;\n+    private final String scopeName;\n+    private final String rgName;\n+    private final long requestId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU3NDcwMA=="}, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNTQzMDU5OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMjowNDoxOVrOIE888w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOToxNTo0NFrOIFGxgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2Mzg1OQ==", "bodyText": "shouldnt add subscriber include generation number?", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542063859", "createdAt": "2020-12-14T02:04:19Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a KeyValueTable.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        log.info(\"Processing create request.\");\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               log.info(\"Adding metadata to Streams\");\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIyNDc3MA==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542224770", "createdAt": "2020-12-14T09:15:44Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a KeyValueTable.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        log.info(\"Processing create request.\");\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               log.info(\"Adding metadata to Streams\");\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2Mzg1OQ=="}, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNTQzNTQ1OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMjowNjozOFrOIE8_dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMToxNDozNVrOIFLoJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NDUwMw==", "bodyText": "this will only create the metadata for the rg stream.. it is not creating the segments..\ni suggest you invoke createRg stream method on streamMetadataTasks to do this.\nalso since create for the RG stream can also come from the users, so there can be locking contentions for creation of the stream. but its not a problem per se except that this event's processing can be delayed until the stream gets created outside this context.\nhowever, older clients will continue to create RG streams directly.. newer clients create rg streams using the new createRG api.\nso there shouldnt be a real contention of the sort.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542064503", "createdAt": "2020-12-14T02:06:38Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a KeyValueTable.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        log.info(\"Processing create request.\");\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               log.info(\"Adding metadata to Streams\");\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, null, executor);\n+                                      }, executor);\n+                                   }\n+                               return CompletableFuture.completedFuture(null);\n+                               }).thenCompose(v ->\n+                                  Futures.toVoid(streamMetadataStore.createStream(scope, NameUtils.getStreamForReaderGroup(readerGroup),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyMzkzOA==", "bodyText": "Ok. Yes sure I'll add createRGStream() to streamMetadataTasks and invoke that.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542123938", "createdAt": "2020-12-14T05:37:12Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a KeyValueTable.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        log.info(\"Processing create request.\");\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               log.info(\"Adding metadata to Streams\");\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, null, executor);\n+                                      }, executor);\n+                                   }\n+                               return CompletableFuture.completedFuture(null);\n+                               }).thenCompose(v ->\n+                                  Futures.toVoid(streamMetadataStore.createStream(scope, NameUtils.getStreamForReaderGroup(readerGroup),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NDUwMw=="}, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNDI5Mw==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542304293", "createdAt": "2020-12-14T11:14:35Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a KeyValueTable.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        log.info(\"Processing create request.\");\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               log.info(\"Adding metadata to Streams\");\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, null, executor);\n+                                      }, executor);\n+                                   }\n+                               return CompletableFuture.completedFuture(null);\n+                               }).thenCompose(v ->\n+                                  Futures.toVoid(streamMetadataStore.createStream(scope, NameUtils.getStreamForReaderGroup(readerGroup),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NDUwMw=="}, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNTQ1NjAwOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMjoxNjo0MlrOIE9J2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDo0MTo0NVrOIGOx3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NzE2Mw==", "bodyText": "do remember, our event processor has at least once processing guarantees. so the events can be replayed.\nwhich means the delete rg can be replayed.\nwe do want to make its processing idempotent and not perform an unwanted delete in a subsequent replay of the event.\nso this delete event should include the \"generation\" or starting segmentsegmentnumber of the RG to be deleted. so that when it is processed we only delete the intended RG.. if it was already deleted previously and the current RG has a higher generation number then we ignore this event and do nothing.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542067163", "createdAt": "2020-12-14T02:16:42Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQwNDUxMQ==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r543404511", "createdAt": "2020-12-15T14:41:45Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NzE2Mw=="}, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNTQ1ODQ2OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMjoxNzo1MlrOIE9LDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDo0MTo1NVrOIGOygw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NzQ3MQ==", "bodyText": "again the delete subscriber should pass the generation number so that unsubscription is also conditional and we do not unnecessarily remove a subscription unintendedly.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542067471", "createdAt": "2020-12-14T02:17:52Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      log.info(\"Inside Delete Event\");\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+               .thenCompose(configRecord -> {\n+               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                       .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+               String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+               log.info(\"Inside Delete Event, found config\");\n+               // update Stream metadata tables, if RG is a Subscriber\n+               Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+               return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                       Stream stream = Stream.of(streamIter.next());\n+                       return streamMetadataStore.deleteSubscriber(stream.getScope(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQwNDY3NQ==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r543404675", "createdAt": "2020-12-15T14:41:55Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      log.info(\"Inside Delete Event\");\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+               .thenCompose(configRecord -> {\n+               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                       .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+               String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+               log.info(\"Inside Delete Event, found config\");\n+               // update Stream metadata tables, if RG is a Subscriber\n+               Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+               return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                       Stream stream = Stream.of(streamIter.next());\n+                       return streamMetadataStore.deleteSubscriber(stream.getScope(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NzQ3MQ=="}, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNTQ2MTg5OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMjoxOTozOVrOIE9M0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMToyMDo1NFrOIFL3CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NzkyMw==", "bodyText": "again this is merely updating the metadata and not deleting the actual stream..\nuse streammetadatatasks.deletestream to actually delete the stream.\nthe caveat there is that this stream will be deleted asynchronously and this processing will wait on that to complete.. i dont particularly like that pattern.\nfor that reason it may be preferrable to delete the RG stream outside the context of the event processing.. and then posting the event to perform unsubscriptions.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542067923", "createdAt": "2020-12-14T02:19:39Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      log.info(\"Inside Delete Event\");\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+               .thenCompose(configRecord -> {\n+               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                       .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+               String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+               log.info(\"Inside Delete Event, found config\");\n+               // update Stream metadata tables, if RG is a Subscriber\n+               Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+               return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                       Stream stream = Stream.of(streamIter.next());\n+                       return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                               stream.getStreamName(), scopedRGName, null, executor);\n+                       }, executor);\n+               }\n+               return CompletableFuture.completedFuture(null);\n+               })\n+               .thenCompose(v -> {\n+                   log.info(\"Inside Delete Event, deleting metadata and stream\");\n+                   return streamMetadataStore.deleteStream(scope,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwODEwNA==", "bodyText": "Fixed to invoke streammetadatatasks.deleteStream()", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r542308104", "createdAt": "2020-12-14T11:20:54Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      log.info(\"Inside Delete Event\");\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+               .thenCompose(configRecord -> {\n+               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                       .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+               String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+               log.info(\"Inside Delete Event, found config\");\n+               // update Stream metadata tables, if RG is a Subscriber\n+               Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+               return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                       Stream stream = Stream.of(streamIter.next());\n+                       return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                               stream.getStreamName(), scopedRGName, null, executor);\n+                       }, executor);\n+               }\n+               return CompletableFuture.completedFuture(null);\n+               })\n+               .thenCompose(v -> {\n+                   log.info(\"Inside Delete Event, deleting metadata and stream\");\n+                   return streamMetadataStore.deleteStream(scope,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2NzkyMw=="}, "originalCommit": {"oid": "7bd10caa9e7390aae784f9919e050991ae631df2"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNTA4NTkxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMDo0MjozM1rOIHvbmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTo0MjoyOFrOIHxuOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk4ODA1OQ==", "bodyText": "please fix this todo", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r544988059", "createdAt": "2020-12-17T10:42:33Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -106,7 +106,9 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n         if (synchronizer.getState().getConfig().getRetentionType()\n                 .equals(ReaderGroupConfig.StreamDataRetention.MANUAL_RELEASE_AT_USER_STREAMCUT)) {\n             streamCuts.forEach((stream, cut) ->\n-                    getThrowingException(controller.updateSubscriberStreamCut(stream.getScope(), stream.getStreamName(), groupName, cut)));\n+                    // TODO: replace 0L with getConfig().generation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23cc3cc9640dee6243f4a7a14c42934e4f59a650"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyNTU5NQ==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545025595", "createdAt": "2020-12-17T11:42:28Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -106,7 +106,9 @@ public void updateRetentionStreamCut(Map<Stream, StreamCut> streamCuts) {\n         if (synchronizer.getState().getConfig().getRetentionType()\n                 .equals(ReaderGroupConfig.StreamDataRetention.MANUAL_RELEASE_AT_USER_STREAMCUT)) {\n             streamCuts.forEach((stream, cut) ->\n-                    getThrowingException(controller.updateSubscriberStreamCut(stream.getScope(), stream.getStreamName(), groupName, cut)));\n+                    // TODO: replace 0L with getConfig().generation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk4ODA1OQ=="}, "originalCommit": {"oid": "23cc3cc9640dee6243f4a7a14c42934e4f59a650"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNTA4ODU4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMDo0MzowOVrOIHvdNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTo0Mzo0NVrOIHxxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk4ODQ3MQ==", "bodyText": "same here. otherwise open a github issue and reference it here with the TODO message.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r544988471", "createdAt": "2020-12-17T10:43:09Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -481,8 +481,9 @@ void updateTruncationStreamCutIfNeeded() {\n             Optional<Map<Stream, Map<Segment, Long>>> cuts = state.getPositionsForLastCompletedCheckpoint();\n             cuts.orElseThrow(() -> new CheckpointFailedException(\"Could not get positions for last checkpoint.\"))\n                  .entrySet().forEach(entry ->\n+                        //TODO: replace 0L with rgconfig.generation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23cc3cc9640dee6243f4a7a14c42934e4f59a650"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyNjM2MA==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545026360", "createdAt": "2020-12-17T11:43:45Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -481,8 +481,9 @@ void updateTruncationStreamCutIfNeeded() {\n             Optional<Map<Stream, Map<Segment, Long>>> cuts = state.getPositionsForLastCompletedCheckpoint();\n             cuts.orElseThrow(() -> new CheckpointFailedException(\"Could not get positions for last checkpoint.\"))\n                  .entrySet().forEach(entry ->\n+                        //TODO: replace 0L with rgconfig.generation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk4ODQ3MQ=="}, "originalCommit": {"oid": "23cc3cc9640dee6243f4a7a14c42934e4f59a650"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNTI3MDgyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMToyNTowMlrOIHxFdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTo0MzozN1rOIHxw5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNTE1OQ==", "bodyText": "i would prefer if we moved this call out of event processor.. the problem is it can lead to deadlocks.. one event processing waiting on another asynchronous processing and there may not be sufficient processing slots available to process the new one as the current request holds onto a processing slot.\nthat is why i prefer that we create the RG stream and then submit the createRG event to be processed which simply manages the subscriptions.\nPS: i know that presently create stream is performed using task framework.\nan alternative here is to call createStreamBody however, that does not guarantee the mutual exclusion.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545015159", "createdAt": "2020-12-17T11:25:02Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, only if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, configRecord.getObject().getGeneration(),\n+                                                  null, executor);\n+                                      }, executor);\n+                                   }\n+                               return CompletableFuture.completedFuture(null);\n+                               }).thenCompose(v ->\n+                                  streamMetadataTasks.createRGStream(scope, NameUtils.getStreamForReaderGroup(readerGroup),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNjU1NQ==", "bodyText": "also I am ok if you open a separate github issue for this and address it immediately after we close this PR.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545016555", "createdAt": "2020-12-17T11:27:16Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, only if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, configRecord.getObject().getGeneration(),\n+                                                  null, executor);\n+                                      }, executor);\n+                                   }\n+                               return CompletableFuture.completedFuture(null);\n+                               }).thenCompose(v ->\n+                                  streamMetadataTasks.createRGStream(scope, NameUtils.getStreamForReaderGroup(readerGroup),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNTE1OQ=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyNjI3Ng==", "bodyText": "Created #5438", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545026276", "createdAt": "2020-12-17T11:43:37Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CreateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.common.Exceptions;\n+\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.ReaderGroupState;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.CreateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.Iterator;\n+\n+/**\n+ * Request handler for executing a create operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class CreateReaderGroupTask implements ReaderGroupTask<CreateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateReaderGroupEvent request) {\n+        String scope = request.getScopeName();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getVersionedReaderGroupState(scope, readerGroup,\n+                true, context, executor)\n+                .thenCompose(state -> {\n+                    if (state.getObject().equals(ReaderGroupState.CREATING)) {\n+                        String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                        return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                               .thenCompose(configRecord -> {\n+                               if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                                   .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                                   // update Stream metadata tables, only if RG is a Subscriber\n+                                   Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                                   return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, configRecord.getObject().getGeneration(),\n+                                                  null, executor);\n+                                      }, executor);\n+                                   }\n+                               return CompletableFuture.completedFuture(null);\n+                               }).thenCompose(v ->\n+                                  streamMetadataTasks.createRGStream(scope, NameUtils.getStreamForReaderGroup(readerGroup),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNTE1OQ=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNTI4ODcwOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMToyOToyOVrOIHxP9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTo0Mzo1NlrOIHxxrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNzg0NA==", "bodyText": "same comment as with create RG... again we can handle this in a separate PR.. or if we move RG creation to a separate event processor in future then it doesnt contest for the processing slots to be available (remember: each instantiation of concurrent event processor processes at most 1000 events concurrently per controller instance)..", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545017844", "createdAt": "2020-12-17T11:29:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      UUID readerGroupId = request.getReaderGroupId();\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupId(scope, readerGroup, context, executor)\n+              .thenCompose(id -> {\n+               if (!id.equals(readerGroupId)) {\n+                      log.warn(\"Skipping processing of Reader Group delete request {} as UUIDs did not match.\", requestId);\n+                      return CompletableFuture.completedFuture(null);\n+               }\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                          .thenCompose(configRecord -> {\n+                          if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                              .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                              String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                              // update Stream metadata tables, if RG is a Subscriber\n+                              Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                              return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                     Stream stream = Stream.of(streamIter.next());\n+                                     return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                                            stream.getStreamName(), scopedRGName, null, executor);\n+                                 }, executor);\n+                              }\n+                              return CompletableFuture.completedFuture(null);\n+                          })\n+                          .thenCompose(v -> streamMetadataTasks.deleteStream(scope,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyNjQ3Nw==", "bodyText": "#5438", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545026477", "createdAt": "2020-12-17T11:43:56Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      UUID readerGroupId = request.getReaderGroupId();\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupId(scope, readerGroup, context, executor)\n+              .thenCompose(id -> {\n+               if (!id.equals(readerGroupId)) {\n+                      log.warn(\"Skipping processing of Reader Group delete request {} as UUIDs did not match.\", requestId);\n+                      return CompletableFuture.completedFuture(null);\n+               }\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                          .thenCompose(configRecord -> {\n+                          if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                              .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                              String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                              // update Stream metadata tables, if RG is a Subscriber\n+                              Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                              return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                     Stream stream = Stream.of(streamIter.next());\n+                                     return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                                            stream.getStreamName(), scopedRGName, null, executor);\n+                                 }, executor);\n+                              }\n+                              return CompletableFuture.completedFuture(null);\n+                          })\n+                          .thenCompose(v -> streamMetadataTasks.deleteStream(scope,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNzg0NA=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNTI5ODI1OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateReaderGroupTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTozMTo0M1rOIHxVkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDoyNDozM1rOIH4A6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxOTI4MQ==", "bodyText": "shouldnt generation be included in deleteSubscriber too? we dont want to be deleting an unintended subscriber just because this event got replayed.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545019281", "createdAt": "2020-12-17T11:31:43Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.UpdateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a create operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class UpdateReaderGroupTask implements ReaderGroupTask<UpdateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public UpdateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final UpdateReaderGroupEvent request) {\n+        String scope = request.getScope();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+        UUID readerGroupId = request.getReaderGroupId();\n+        ImmutableSet<String> streamsToBeUnsubscribed = request.getRemoveStreams();\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getReaderGroupId(scope, readerGroup, context, executor)\n+                .thenCompose(id -> {\n+                if (!id.equals(readerGroupId)) {\n+                        log.warn(\"Skipping processing of Reader Group update request {} as UUIDs did not match.\", requestId);\n+                        return CompletableFuture.completedFuture(null);\n+                }\n+                return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                       .thenCompose(rgConfigRecord -> {\n+                       if (rgConfigRecord.getObject().isUpdating() &&\n+                          (!ReaderGroupConfig.StreamDataRetention.values()[rgConfigRecord.getObject().getRetentionTypeOrdinal()]\n+                            .equals(ReaderGroupConfig.StreamDataRetention.NONE))) {\n+                            // update Stream metadata tables, only if RG is a Subscriber\n+                            Iterator<String> streamIter = rgConfigRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                            String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                            Iterator<String> removeStreamsIter = streamsToBeUnsubscribed.stream().iterator();\n+                            return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, rgConfigRecord.getObject().getGeneration(),\n+                                                  null, executor);\n+                                      }, executor)\n+                                    .thenCompose(v -> Futures.loop(() -> removeStreamsIter.hasNext(), () -> {\n+                                        Stream stream = Stream.of(removeStreamsIter.next());\n+                                        return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                                                stream.getStreamName(), scopedRGName, null, executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyMjg1MA==", "bodyText": "The UUID check in deleteRGEvent should take care of that, but there is no harm in doing the check again in deleteSubscriber, so will add it here.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545022850", "createdAt": "2020-12-17T11:37:39Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.UpdateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a create operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class UpdateReaderGroupTask implements ReaderGroupTask<UpdateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public UpdateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final UpdateReaderGroupEvent request) {\n+        String scope = request.getScope();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+        UUID readerGroupId = request.getReaderGroupId();\n+        ImmutableSet<String> streamsToBeUnsubscribed = request.getRemoveStreams();\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getReaderGroupId(scope, readerGroup, context, executor)\n+                .thenCompose(id -> {\n+                if (!id.equals(readerGroupId)) {\n+                        log.warn(\"Skipping processing of Reader Group update request {} as UUIDs did not match.\", requestId);\n+                        return CompletableFuture.completedFuture(null);\n+                }\n+                return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                       .thenCompose(rgConfigRecord -> {\n+                       if (rgConfigRecord.getObject().isUpdating() &&\n+                          (!ReaderGroupConfig.StreamDataRetention.values()[rgConfigRecord.getObject().getRetentionTypeOrdinal()]\n+                            .equals(ReaderGroupConfig.StreamDataRetention.NONE))) {\n+                            // update Stream metadata tables, only if RG is a Subscriber\n+                            Iterator<String> streamIter = rgConfigRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                            String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                            Iterator<String> removeStreamsIter = streamsToBeUnsubscribed.stream().iterator();\n+                            return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, rgConfigRecord.getObject().getGeneration(),\n+                                                  null, executor);\n+                                      }, executor)\n+                                    .thenCompose(v -> Futures.loop(() -> removeStreamsIter.hasNext(), () -> {\n+                                        Stream stream = Stream.of(removeStreamsIter.next());\n+                                        return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                                                stream.getStreamName(), scopedRGName, null, executor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxOTI4MQ=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyODY4MQ==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545128681", "createdAt": "2020-12-17T14:24:33Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.UpdateReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a create operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class UpdateReaderGroupTask implements ReaderGroupTask<UpdateReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public UpdateReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final UpdateReaderGroupEvent request) {\n+        String scope = request.getScope();\n+        String readerGroup = request.getRgName();\n+        long requestId = request.getRequestId();\n+        UUID readerGroupId = request.getReaderGroupId();\n+        ImmutableSet<String> streamsToBeUnsubscribed = request.getRemoveStreams();\n+        final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getReaderGroupId(scope, readerGroup, context, executor)\n+                .thenCompose(id -> {\n+                if (!id.equals(readerGroupId)) {\n+                        log.warn(\"Skipping processing of Reader Group update request {} as UUIDs did not match.\", requestId);\n+                        return CompletableFuture.completedFuture(null);\n+                }\n+                return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                       .thenCompose(rgConfigRecord -> {\n+                       if (rgConfigRecord.getObject().isUpdating() &&\n+                          (!ReaderGroupConfig.StreamDataRetention.values()[rgConfigRecord.getObject().getRetentionTypeOrdinal()]\n+                            .equals(ReaderGroupConfig.StreamDataRetention.NONE))) {\n+                            // update Stream metadata tables, only if RG is a Subscriber\n+                            Iterator<String> streamIter = rgConfigRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                            String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                            Iterator<String> removeStreamsIter = streamsToBeUnsubscribed.stream().iterator();\n+                            return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                          Stream stream = Stream.of(streamIter.next());\n+                                          return streamMetadataStore.addSubscriber(stream.getScope(),\n+                                                       stream.getStreamName(), scopedRGName, rgConfigRecord.getObject().getGeneration(),\n+                                                  null, executor);\n+                                      }, executor)\n+                                    .thenCompose(v -> Futures.loop(() -> removeStreamsIter.hasNext(), () -> {\n+                                        Stream stream = Stream.of(removeStreamsIter.next());\n+                                        return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                                                stream.getStreamName(), scopedRGName, null, executor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxOTI4MQ=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNTMwMjQ5OnYy", "diffSide": "RIGHT", "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/UpdateReaderGroupEvent.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTozMjozM1rOIHxX4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDowOToxOVrOIIcxWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxOTg3NA==", "bodyText": "doesnt it also need \"add streams\" ?\nupdateRG can have new streams added and some old streams removed.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545019874", "createdAt": "2020-12-17T11:32:33Z", "author": {"login": "shiveshr"}, "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/UpdateReaderGroupEvent.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.controller.event;\n+\n+import com.google.common.collect.ImmutableSet;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+@Builder\n+@Data\n+@AllArgsConstructor\n+public class UpdateReaderGroupEvent implements ControllerEvent {\n+    private static final long serialVersionUID = 1L;\n+    private final String scope;\n+    private final String rgName;\n+    private final long requestId;\n+    private UUID readerGroupId;\n+    private ImmutableSet<String> removeStreams;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyMzgzNw==", "bodyText": "addSubscriber() is invoked on all Streams in new config.\nThis takes care of adding (new) streams and updating generation for existing Streams ( present in both old and new config)\nSo only streams to be removed need to be passed to the event.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545023837", "createdAt": "2020-12-17T11:39:25Z", "author": {"login": "pbelgundi"}, "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/UpdateReaderGroupEvent.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.controller.event;\n+\n+import com.google.common.collect.ImmutableSet;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+@Builder\n+@Data\n+@AllArgsConstructor\n+public class UpdateReaderGroupEvent implements ControllerEvent {\n+    private static final long serialVersionUID = 1L;\n+    private final String scope;\n+    private final String rgName;\n+    private final long requestId;\n+    private UUID readerGroupId;\n+    private ImmutableSet<String> removeStreams;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxOTg3NA=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU3NDY0OA==", "bodyText": "again, shouldnt we also include the generation here.. if the event is replayed we should not be unsubscribing from a stream that was added as part of a subsequent message.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545574648", "createdAt": "2020-12-18T05:03:19Z", "author": {"login": "shiveshr"}, "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/UpdateReaderGroupEvent.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.controller.event;\n+\n+import com.google.common.collect.ImmutableSet;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+@Builder\n+@Data\n+@AllArgsConstructor\n+public class UpdateReaderGroupEvent implements ControllerEvent {\n+    private static final long serialVersionUID = 1L;\n+    private final String scope;\n+    private final String rgName;\n+    private final long requestId;\n+    private UUID readerGroupId;\n+    private ImmutableSet<String> removeStreams;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxOTg3NA=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMDkwNA==", "bodyText": "Fixed. Added generation check as suggested.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r545730904", "createdAt": "2020-12-18T10:09:19Z", "author": {"login": "pbelgundi"}, "path": "shared/controller-api/src/main/java/io/pravega/shared/controller/event/UpdateReaderGroupEvent.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.controller.event;\n+\n+import com.google.common.collect.ImmutableSet;\n+import io.pravega.common.ObjectBuilder;\n+import io.pravega.common.io.serialization.RevisionDataInput;\n+import io.pravega.common.io.serialization.RevisionDataOutput;\n+import io.pravega.common.io.serialization.VersionedSerializer;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+@Builder\n+@Data\n+@AllArgsConstructor\n+public class UpdateReaderGroupEvent implements ControllerEvent {\n+    private static final long serialVersionUID = 1L;\n+    private final String scope;\n+    private final String rgName;\n+    private final long requestId;\n+    private UUID readerGroupId;\n+    private ImmutableSet<String> removeStreams;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxOTg3NA=="}, "originalCommit": {"oid": "83cfd563595f0075544135e1c6a769a764e9bd20"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzY4MjQwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNToxMTo1NlrOII8Xxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjowNTowNFrOII8sqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI0ODY0Ng==", "bodyText": "please open an issue to return generation back from controller.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546248646", "createdAt": "2020-12-19T15:11:56Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -1588,9 +1519,169 @@ private void closeChannel() {\n                 LoggerHelpers.traceLeave(log, \"getCurrentSegmentsForKeyValueTable\", traceId);\n             });\n         }\n-\n     //endregion\n \n+    // region ReaderGroups\n+    public CompletableFuture<Boolean> createReaderGroup(String scope, String rgName, final ReaderGroupConfig rgConfig) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n+        Exceptions.checkNotNullOrEmpty(rgName, \"rgName\");\n+        Preconditions.checkNotNull(rgConfig, \"rgConfig\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"createReaderGroup\", rgConfig, requestId);\n+\n+        final CompletableFuture<CreateReaderGroupStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<CreateReaderGroupStatus> callback = new RPCAsyncCallback<>(requestId, \"createReaderGroup\", scope, rgName, rgConfig);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"createReaderGroup\", scope, rgName)\n+                    .createReaderGroup(ModelHelper.decode(scope, rgName, rgConfig), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to create reader group: {}\", rgName);\n+                    throw new ControllerFailureException(\"Failed to create reader group: \" + rgName);\n+                case INVALID_RG_NAME:\n+                    log.warn(requestId, \"Illegal Reader Group Name: {}\", rgName);\n+                    throw new IllegalArgumentException(\"Illegal readergroup name: \" + rgName);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case SUCCESS:\n+                    log.info(requestId, \"ReaderGroup created successfully: {}\", rgName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status creating reader group \" + rgName\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"createReaderGroup {}/{} failed: \", scope, rgName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"createReaderGroup\", traceId, rgConfig, requestId);\n+        });\n+    }\n+\n+    public CompletableFuture<Boolean> updateReaderGroup(String scope, String rgName, final ReaderGroupConfig rgConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6d587933e1c1bcb30796f7f08785d34b6231a3"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1Mzk5NQ==", "bodyText": "Filed: #5447", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546253995", "createdAt": "2020-12-19T16:05:04Z", "author": {"login": "pbelgundi"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -1588,9 +1519,169 @@ private void closeChannel() {\n                 LoggerHelpers.traceLeave(log, \"getCurrentSegmentsForKeyValueTable\", traceId);\n             });\n         }\n-\n     //endregion\n \n+    // region ReaderGroups\n+    public CompletableFuture<Boolean> createReaderGroup(String scope, String rgName, final ReaderGroupConfig rgConfig) {\n+        Exceptions.checkNotClosed(closed.get(), this);\n+        Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n+        Exceptions.checkNotNullOrEmpty(rgName, \"rgName\");\n+        Preconditions.checkNotNull(rgConfig, \"rgConfig\");\n+        final long requestId = requestIdGenerator.get();\n+        long traceId = LoggerHelpers.traceEnter(log, \"createReaderGroup\", rgConfig, requestId);\n+\n+        final CompletableFuture<CreateReaderGroupStatus> result = this.retryConfig.runAsync(() -> {\n+            RPCAsyncCallback<CreateReaderGroupStatus> callback = new RPCAsyncCallback<>(requestId, \"createReaderGroup\", scope, rgName, rgConfig);\n+            new ControllerClientTagger(client, timeoutMillis).withTag(requestId, \"createReaderGroup\", scope, rgName)\n+                    .createReaderGroup(ModelHelper.decode(scope, rgName, rgConfig), callback);\n+            return callback.getFuture();\n+        }, this.executor);\n+        return result.thenApply(x -> {\n+            switch (x.getStatus()) {\n+                case FAILURE:\n+                    log.warn(requestId, \"Failed to create reader group: {}\", rgName);\n+                    throw new ControllerFailureException(\"Failed to create reader group: \" + rgName);\n+                case INVALID_RG_NAME:\n+                    log.warn(requestId, \"Illegal Reader Group Name: {}\", rgName);\n+                    throw new IllegalArgumentException(\"Illegal readergroup name: \" + rgName);\n+                case SCOPE_NOT_FOUND:\n+                    log.warn(requestId, \"Scope not found: {}\", scope);\n+                    throw new IllegalArgumentException(\"Scope does not exist: \" + scope);\n+                case SUCCESS:\n+                    log.info(requestId, \"ReaderGroup created successfully: {}\", rgName);\n+                    return true;\n+                case UNRECOGNIZED:\n+                default:\n+                    throw new ControllerFailureException(\"Unknown return status creating reader group \" + rgName\n+                            + \" \" + x.getStatus());\n+            }\n+        }).whenComplete((x, e) -> {\n+            if (e != null) {\n+                log.warn(requestId, \"createReaderGroup {}/{} failed: \", scope, rgName, e);\n+            }\n+            LoggerHelpers.traceLeave(log, \"createReaderGroup\", traceId, rgConfig, requestId);\n+        });\n+    }\n+\n+    public CompletableFuture<Boolean> updateReaderGroup(String scope, String rgName, final ReaderGroupConfig rgConfig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI0ODY0Ng=="}, "originalCommit": {"oid": "9e6d587933e1c1bcb30796f7f08785d34b6231a3"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzcxMDIyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNTo0NDo0NFrOII8ktA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjowMjo1NVrOII8r1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1MTk1Ng==", "bodyText": "the guarantee of eventhelper.addIndexAndSubmitTask is for one update.\na failing over of this will simply post the event. it doesnt have the inputs for the future.\nso if you actually do have intent to do multiple updates, they should be done as part of event processing and not here.\nhere we should just to do the fist step, start the operation and then post the event for it which will perform the whole execution if the processing has been started.\nhere you are doing  updateReaderGroupVersionedState followed by sealStream which in itself does a bunch of things.\ni suggest you move seal stream inside the event processing. but that is a different beast all together. but we have a new issue to take one async processing waiting on another out of the workflow.. we will handle that later. for now, simply move this there.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546251956", "createdAt": "2020-12-19T15:44:44Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -210,7 +256,217 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                     }\n                 });\n     }\n-    \n+\n+    /**\n+     * Get Reader Group Configuration.\n+     *\n+     * @param scope  Reader Group scope.\n+     * @param rgName Reader Group name.\n+     * @param contextOpt Reader Group context.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<ReaderGroupConfigResponse> getReaderGroupConfig(final String scope, final String rgName,\n+                                                                             RGOperationContext contextOpt) {\n+        final long requestId = requestTracker.getRequestIdFor(\"getReaderGroupConfig\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+          // 1. check if RG with this name exists...\n+          return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+             .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(ReaderGroupConfigResponse.newBuilder()\n+                                    .setConfig(ReaderGroupConfiguration.getDefaultInstance())\n+                                    .setStatus(ReaderGroupConfigResponse.Status.RG_NOT_FOUND).build());\n+               }\n+               final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+               return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                    .thenCompose(rgId -> streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                            .thenApply(configRecord -> ReaderGroupConfigResponse.newBuilder()\n+                                .setConfig(getRGConfigurationFromRecord(scope, rgName, configRecord.getObject(), rgId.toString()))\n+                                .setStatus(ReaderGroupConfigResponse.Status.SUCCESS).build()));\n+       });\n+      }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ReaderGroupConfiguration getRGConfigurationFromRecord(final String scope, final String rgName,\n+                                                                  final ReaderGroupConfigRecord record, final String readerGroupId) {\n+        List<StreamCut> startStreamCuts = record.getStartingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        List<StreamCut> endStreamCuts = record.getEndingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                                              .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        return ReaderGroupConfiguration.newBuilder().setScope(scope).setReaderGroupName(rgName)\n+          .setGroupRefreshTimeMillis(record.getGroupRefreshTimeMillis())\n+          .setAutomaticCheckpointIntervalMillis(record.getAutomaticCheckpointIntervalMillis())\n+          .setMaxOutstandingCheckpointRequest(record.getMaxOutstandingCheckpointRequest())\n+          .setRetentionType(record.getRetentionTypeOrdinal())\n+          .setGeneration(record.getGeneration())\n+          .addAllStartingStreamCuts(startStreamCuts)\n+          .addAllEndingStreamCuts(endStreamCuts)\n+          .setReaderGroupId(readerGroupId)\n+          .build();\n+    }\n+\n+    /**\n+     * Create Reader Group.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          Reader Group config.\n+     * @param createTimestamp Reader Group creation timestamp.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<CreateReaderGroupStatus.Status> createReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, long createTimestamp) {\n+    final long requestId = requestTracker.getRequestIdFor(\"createReaderGroup\", scope, rgName);\n+    return RetryHelper.withRetriesAsync(() -> {\n+      // 1. check if scope with this name exists...\n+      return streamMetadataStore.checkScopeExists(scope)\n+         .thenCompose(exists -> {\n+         if (!exists) {\n+                  return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SCOPE_NOT_FOUND);\n+         }\n+         //2. check state of the ReaderGroup, if found\n+         return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenCompose(state -> {\n+                if (state.equals(ReaderGroupState.UNKNOWN) || state.equals(ReaderGroupState.CREATING)) {\n+                   CreateReaderGroupEvent event = new CreateReaderGroupEvent(scope, rgName, requestId);\n+                   //3. Create Reader Group Metadata and submit event\n+                   return eventHelper.addIndexAndSubmitTask(event,\n+                              () -> streamMetadataStore.createReaderGroup(scope, rgName, config, createTimestamp, null, executor))\n+                              .thenCompose(x -> eventHelper.checkDone(() -> isRGCreated(scope, rgName, executor))\n+                              .thenApply(done -> CreateReaderGroupStatus.Status.SUCCESS));\n+                }\n+                // idempotent call\n+                return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SUCCESS);\n+             });\n+         });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isRGCreated(String scope, String rgName, Executor executor) {\n+        return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenApply(state -> {\n+                    log.debug(\"ReaderGroup State is {}\", state.toString());\n+                    return ReaderGroupState.ACTIVE.equals(state);\n+                });\n+    }\n+\n+    /**\n+     * Update Reader Group Configuration.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          New Reader Group config.\n+     * @param contextOpt      Reader Group context.\n+     * @return updation status.\n+     */\n+    public CompletableFuture<UpdateReaderGroupStatus.Status> updateReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, RGOperationContext contextOpt) {\n+        final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateReaderGroup\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+            // 1. check if Reader Group exists...\n+            return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+               .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.RG_NOT_FOUND);\n+               }\n+               //2. check for generation && ID match with existing config\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                      .thenCompose(rgConfigRecord -> {\n+                        if (rgConfigRecord.getObject().getGeneration() != config.getGeneration()) {\n+                            return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                        }\n+                        if (!rgConfigRecord.getObject().isUpdating()) {\n+                          return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                             .thenCompose(rgId -> {\n+                             if (!config.getReaderGroupId().equals(rgId)) {\n+                                 return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                             }\n+                             ImmutableSet<String> removeStreams = getStreamsToBeUnsubscribed(rgConfigRecord.getObject().getStartingStreamCuts().keySet(),\n+                             config.getStartingStreamCuts().keySet().stream().map(s -> s.getScopedName()).collect(Collectors.toSet()));\n+                             UpdateReaderGroupEvent event = new UpdateReaderGroupEvent(scope, rgName, requestId, rgId,\n+                                                                 rgConfigRecord.getObject().getGeneration() + 1, removeStreams);\n+                             //3. Create Reader Group Metadata and submit event\n+                             return eventHelper.addIndexAndSubmitTask(event,\n+                                    () -> streamMetadataStore.startRGConfigUpdate(scope, rgName, config, null, executor))\n+                                          .thenCompose(x -> eventHelper.checkDone(() -> isRGUpdated(scope, rgName, executor))\n+                                              .thenApply(done -> UpdateReaderGroupStatus.Status.SUCCESS));\n+                             });\n+                        } else {\n+                          log.warn(\"Reader group update failed as another update is in progress.\");\n+                          return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.FAILURE);\n+                        }\n+                      });\n+               });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ImmutableSet<String> getStreamsToBeUnsubscribed(final Set<String> currentConfigStreams, final Set<String> newConfigStreams) {\n+        return ImmutableSet.copyOf(currentConfigStreams.stream()\n+                .filter(s -> !newConfigStreams.contains(s)).collect(Collectors.toSet()));\n+    }\n+\n+    private CompletableFuture<Boolean> isRGUpdated(String scope, String rgName, Executor executor) {\n+            return streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, null, executor)\n+                    .thenCompose(rgConfigRecord -> {\n+                        log.debug(\"ReaderGroup Config is {}\", rgConfigRecord.getObject().isUpdating());\n+                        return CompletableFuture.completedFuture(!rgConfigRecord.getObject().isUpdating());\n+                   });\n+    }\n+\n+    /**\n+     * Delete Reader Group.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param readerGroupId   Reader Group unique identifier.\n+     * @param contextOpt      Reader Group context.\n+     * @return deletion status.\n+     */\n+    public CompletableFuture<DeleteReaderGroupStatus.Status> deleteReaderGroup(final String scope, final String rgName,\n+                                                                               final String readerGroupId,\n+                                                                               RGOperationContext contextOpt) {\n+        final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"deleteReaderGroup\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                .thenCompose(rgId -> {\n+                    if (!rgId.equals(UUID.fromString(readerGroupId))) {\n+                        return CompletableFuture.completedFuture(DeleteReaderGroupStatus.Status.RG_NOT_FOUND);\n+                    }\n+                   return streamMetadataStore.getVersionedReaderGroupState(scope, rgName, true, context, executor)\n+                            .thenCompose(versionedState -> eventHelper.addIndexAndSubmitTask(new DeleteReaderGroupEvent(scope, rgName, requestId, rgId),\n+                                      () -> startReaderGroupDelete(scope, rgName, versionedState, context))\n+                                      .thenCompose(x -> eventHelper.checkDone(() -> isRGDeleted(scope, rgName))\n+                                      .thenApply(done -> DeleteReaderGroupStatus.Status.SUCCESS)));\n+                }), e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isRGDeleted(String scope, String rgName) {\n+        return streamMetadataStore.checkReaderGroupExists(scope, rgName).thenApply(exists -> !exists);\n+    }\n+\n+    private CompletableFuture<Void> startReaderGroupDelete(final String scope, final String rgName, VersionedMetadata<ReaderGroupState> currentState,\n+                                                           RGOperationContext context) {\n+        final String rgStreamName = NameUtils.getStreamForReaderGroup(rgName);\n+        return Futures.toVoid(streamMetadataStore.updateReaderGroupVersionedState(scope, rgName,\n+           ReaderGroupState.DELETING, currentState, context, executor))\n+           .thenCompose(v -> sealStream(scope, rgStreamName, null))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6d587933e1c1bcb30796f7f08785d34b6231a3"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1Mzc4Mg==", "bodyText": "sure. Moved sealStream inside event processing", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546253782", "createdAt": "2020-12-19T16:02:55Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -210,7 +256,217 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                     }\n                 });\n     }\n-    \n+\n+    /**\n+     * Get Reader Group Configuration.\n+     *\n+     * @param scope  Reader Group scope.\n+     * @param rgName Reader Group name.\n+     * @param contextOpt Reader Group context.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<ReaderGroupConfigResponse> getReaderGroupConfig(final String scope, final String rgName,\n+                                                                             RGOperationContext contextOpt) {\n+        final long requestId = requestTracker.getRequestIdFor(\"getReaderGroupConfig\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+          // 1. check if RG with this name exists...\n+          return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+             .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(ReaderGroupConfigResponse.newBuilder()\n+                                    .setConfig(ReaderGroupConfiguration.getDefaultInstance())\n+                                    .setStatus(ReaderGroupConfigResponse.Status.RG_NOT_FOUND).build());\n+               }\n+               final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+               return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                    .thenCompose(rgId -> streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                            .thenApply(configRecord -> ReaderGroupConfigResponse.newBuilder()\n+                                .setConfig(getRGConfigurationFromRecord(scope, rgName, configRecord.getObject(), rgId.toString()))\n+                                .setStatus(ReaderGroupConfigResponse.Status.SUCCESS).build()));\n+       });\n+      }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ReaderGroupConfiguration getRGConfigurationFromRecord(final String scope, final String rgName,\n+                                                                  final ReaderGroupConfigRecord record, final String readerGroupId) {\n+        List<StreamCut> startStreamCuts = record.getStartingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        List<StreamCut> endStreamCuts = record.getEndingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                                              .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        return ReaderGroupConfiguration.newBuilder().setScope(scope).setReaderGroupName(rgName)\n+          .setGroupRefreshTimeMillis(record.getGroupRefreshTimeMillis())\n+          .setAutomaticCheckpointIntervalMillis(record.getAutomaticCheckpointIntervalMillis())\n+          .setMaxOutstandingCheckpointRequest(record.getMaxOutstandingCheckpointRequest())\n+          .setRetentionType(record.getRetentionTypeOrdinal())\n+          .setGeneration(record.getGeneration())\n+          .addAllStartingStreamCuts(startStreamCuts)\n+          .addAllEndingStreamCuts(endStreamCuts)\n+          .setReaderGroupId(readerGroupId)\n+          .build();\n+    }\n+\n+    /**\n+     * Create Reader Group.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          Reader Group config.\n+     * @param createTimestamp Reader Group creation timestamp.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<CreateReaderGroupStatus.Status> createReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, long createTimestamp) {\n+    final long requestId = requestTracker.getRequestIdFor(\"createReaderGroup\", scope, rgName);\n+    return RetryHelper.withRetriesAsync(() -> {\n+      // 1. check if scope with this name exists...\n+      return streamMetadataStore.checkScopeExists(scope)\n+         .thenCompose(exists -> {\n+         if (!exists) {\n+                  return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SCOPE_NOT_FOUND);\n+         }\n+         //2. check state of the ReaderGroup, if found\n+         return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenCompose(state -> {\n+                if (state.equals(ReaderGroupState.UNKNOWN) || state.equals(ReaderGroupState.CREATING)) {\n+                   CreateReaderGroupEvent event = new CreateReaderGroupEvent(scope, rgName, requestId);\n+                   //3. Create Reader Group Metadata and submit event\n+                   return eventHelper.addIndexAndSubmitTask(event,\n+                              () -> streamMetadataStore.createReaderGroup(scope, rgName, config, createTimestamp, null, executor))\n+                              .thenCompose(x -> eventHelper.checkDone(() -> isRGCreated(scope, rgName, executor))\n+                              .thenApply(done -> CreateReaderGroupStatus.Status.SUCCESS));\n+                }\n+                // idempotent call\n+                return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SUCCESS);\n+             });\n+         });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isRGCreated(String scope, String rgName, Executor executor) {\n+        return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenApply(state -> {\n+                    log.debug(\"ReaderGroup State is {}\", state.toString());\n+                    return ReaderGroupState.ACTIVE.equals(state);\n+                });\n+    }\n+\n+    /**\n+     * Update Reader Group Configuration.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          New Reader Group config.\n+     * @param contextOpt      Reader Group context.\n+     * @return updation status.\n+     */\n+    public CompletableFuture<UpdateReaderGroupStatus.Status> updateReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, RGOperationContext contextOpt) {\n+        final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateReaderGroup\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+            // 1. check if Reader Group exists...\n+            return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+               .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.RG_NOT_FOUND);\n+               }\n+               //2. check for generation && ID match with existing config\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                      .thenCompose(rgConfigRecord -> {\n+                        if (rgConfigRecord.getObject().getGeneration() != config.getGeneration()) {\n+                            return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                        }\n+                        if (!rgConfigRecord.getObject().isUpdating()) {\n+                          return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                             .thenCompose(rgId -> {\n+                             if (!config.getReaderGroupId().equals(rgId)) {\n+                                 return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                             }\n+                             ImmutableSet<String> removeStreams = getStreamsToBeUnsubscribed(rgConfigRecord.getObject().getStartingStreamCuts().keySet(),\n+                             config.getStartingStreamCuts().keySet().stream().map(s -> s.getScopedName()).collect(Collectors.toSet()));\n+                             UpdateReaderGroupEvent event = new UpdateReaderGroupEvent(scope, rgName, requestId, rgId,\n+                                                                 rgConfigRecord.getObject().getGeneration() + 1, removeStreams);\n+                             //3. Create Reader Group Metadata and submit event\n+                             return eventHelper.addIndexAndSubmitTask(event,\n+                                    () -> streamMetadataStore.startRGConfigUpdate(scope, rgName, config, null, executor))\n+                                          .thenCompose(x -> eventHelper.checkDone(() -> isRGUpdated(scope, rgName, executor))\n+                                              .thenApply(done -> UpdateReaderGroupStatus.Status.SUCCESS));\n+                             });\n+                        } else {\n+                          log.warn(\"Reader group update failed as another update is in progress.\");\n+                          return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.FAILURE);\n+                        }\n+                      });\n+               });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ImmutableSet<String> getStreamsToBeUnsubscribed(final Set<String> currentConfigStreams, final Set<String> newConfigStreams) {\n+        return ImmutableSet.copyOf(currentConfigStreams.stream()\n+                .filter(s -> !newConfigStreams.contains(s)).collect(Collectors.toSet()));\n+    }\n+\n+    private CompletableFuture<Boolean> isRGUpdated(String scope, String rgName, Executor executor) {\n+            return streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, null, executor)\n+                    .thenCompose(rgConfigRecord -> {\n+                        log.debug(\"ReaderGroup Config is {}\", rgConfigRecord.getObject().isUpdating());\n+                        return CompletableFuture.completedFuture(!rgConfigRecord.getObject().isUpdating());\n+                   });\n+    }\n+\n+    /**\n+     * Delete Reader Group.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param readerGroupId   Reader Group unique identifier.\n+     * @param contextOpt      Reader Group context.\n+     * @return deletion status.\n+     */\n+    public CompletableFuture<DeleteReaderGroupStatus.Status> deleteReaderGroup(final String scope, final String rgName,\n+                                                                               final String readerGroupId,\n+                                                                               RGOperationContext contextOpt) {\n+        final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"deleteReaderGroup\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                .thenCompose(rgId -> {\n+                    if (!rgId.equals(UUID.fromString(readerGroupId))) {\n+                        return CompletableFuture.completedFuture(DeleteReaderGroupStatus.Status.RG_NOT_FOUND);\n+                    }\n+                   return streamMetadataStore.getVersionedReaderGroupState(scope, rgName, true, context, executor)\n+                            .thenCompose(versionedState -> eventHelper.addIndexAndSubmitTask(new DeleteReaderGroupEvent(scope, rgName, requestId, rgId),\n+                                      () -> startReaderGroupDelete(scope, rgName, versionedState, context))\n+                                      .thenCompose(x -> eventHelper.checkDone(() -> isRGDeleted(scope, rgName))\n+                                      .thenApply(done -> DeleteReaderGroupStatus.Status.SUCCESS)));\n+                }), e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isRGDeleted(String scope, String rgName) {\n+        return streamMetadataStore.checkReaderGroupExists(scope, rgName).thenApply(exists -> !exists);\n+    }\n+\n+    private CompletableFuture<Void> startReaderGroupDelete(final String scope, final String rgName, VersionedMetadata<ReaderGroupState> currentState,\n+                                                           RGOperationContext context) {\n+        final String rgStreamName = NameUtils.getStreamForReaderGroup(rgName);\n+        return Futures.toVoid(streamMetadataStore.updateReaderGroupVersionedState(scope, rgName,\n+           ReaderGroupState.DELETING, currentState, context, executor))\n+           .thenCompose(v -> sealStream(scope, rgStreamName, null))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1MTk1Ng=="}, "originalCommit": {"oid": "9e6d587933e1c1bcb30796f7f08785d34b6231a3"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzczMDYyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjowODozOVrOII8uYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNTozMTowNVrOIJMt4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NDQzMg==", "bodyText": "this is suboptimal as copyOf will make another pass.. better idea is to create an ImmutableSetBuilder.\nthen do foreach on each element and those that dont satisfy the filter predicate, add them to the builder.", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546254432", "createdAt": "2020-12-19T16:08:39Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -210,7 +256,210 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                     }\n                 });\n     }\n-    \n+\n+    /**\n+     * Get Reader Group Configuration.\n+     *\n+     * @param scope  Reader Group scope.\n+     * @param rgName Reader Group name.\n+     * @param contextOpt Reader Group context.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<ReaderGroupConfigResponse> getReaderGroupConfig(final String scope, final String rgName,\n+                                                                             RGOperationContext contextOpt) {\n+        final long requestId = requestTracker.getRequestIdFor(\"getReaderGroupConfig\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+          // 1. check if RG with this name exists...\n+          return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+             .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(ReaderGroupConfigResponse.newBuilder()\n+                                    .setConfig(ReaderGroupConfiguration.getDefaultInstance())\n+                                    .setStatus(ReaderGroupConfigResponse.Status.RG_NOT_FOUND).build());\n+               }\n+               final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+               return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                    .thenCompose(rgId -> streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                            .thenApply(configRecord -> ReaderGroupConfigResponse.newBuilder()\n+                                .setConfig(getRGConfigurationFromRecord(scope, rgName, configRecord.getObject(), rgId.toString()))\n+                                .setStatus(ReaderGroupConfigResponse.Status.SUCCESS).build()));\n+       });\n+      }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ReaderGroupConfiguration getRGConfigurationFromRecord(final String scope, final String rgName,\n+                                                                  final ReaderGroupConfigRecord record, final String readerGroupId) {\n+        List<StreamCut> startStreamCuts = record.getStartingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        List<StreamCut> endStreamCuts = record.getEndingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                                              .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        return ReaderGroupConfiguration.newBuilder().setScope(scope).setReaderGroupName(rgName)\n+          .setGroupRefreshTimeMillis(record.getGroupRefreshTimeMillis())\n+          .setAutomaticCheckpointIntervalMillis(record.getAutomaticCheckpointIntervalMillis())\n+          .setMaxOutstandingCheckpointRequest(record.getMaxOutstandingCheckpointRequest())\n+          .setRetentionType(record.getRetentionTypeOrdinal())\n+          .setGeneration(record.getGeneration())\n+          .addAllStartingStreamCuts(startStreamCuts)\n+          .addAllEndingStreamCuts(endStreamCuts)\n+          .setReaderGroupId(readerGroupId)\n+          .build();\n+    }\n+\n+    /**\n+     * Create Reader Group.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          Reader Group config.\n+     * @param createTimestamp Reader Group creation timestamp.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<CreateReaderGroupStatus.Status> createReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, long createTimestamp) {\n+    final long requestId = requestTracker.getRequestIdFor(\"createReaderGroup\", scope, rgName);\n+    return RetryHelper.withRetriesAsync(() -> {\n+      // 1. check if scope with this name exists...\n+      return streamMetadataStore.checkScopeExists(scope)\n+         .thenCompose(exists -> {\n+         if (!exists) {\n+                  return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SCOPE_NOT_FOUND);\n+         }\n+         //2. check state of the ReaderGroup, if found\n+         return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenCompose(state -> {\n+                if (state.equals(ReaderGroupState.UNKNOWN) || state.equals(ReaderGroupState.CREATING)) {\n+                   CreateReaderGroupEvent event = new CreateReaderGroupEvent(scope, rgName, requestId);\n+                   //3. Create Reader Group Metadata and submit event\n+                   return eventHelper.addIndexAndSubmitTask(event,\n+                              () -> streamMetadataStore.createReaderGroup(scope, rgName, config, createTimestamp, null, executor))\n+                              .thenCompose(x -> eventHelper.checkDone(() -> isRGCreated(scope, rgName, executor))\n+                              .thenApply(done -> CreateReaderGroupStatus.Status.SUCCESS));\n+                }\n+                // idempotent call\n+                return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SUCCESS);\n+             });\n+         });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isRGCreated(String scope, String rgName, Executor executor) {\n+        return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenApply(state -> {\n+                    log.debug(\"ReaderGroup State is {}\", state.toString());\n+                    return ReaderGroupState.ACTIVE.equals(state);\n+                });\n+    }\n+\n+    /**\n+     * Update Reader Group Configuration.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          New Reader Group config.\n+     * @param contextOpt      Reader Group context.\n+     * @return updation status.\n+     */\n+    public CompletableFuture<UpdateReaderGroupStatus.Status> updateReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, RGOperationContext contextOpt) {\n+        final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateReaderGroup\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+            // 1. check if Reader Group exists...\n+            return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+               .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.RG_NOT_FOUND);\n+               }\n+               //2. check for generation && ID match with existing config\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                      .thenCompose(rgConfigRecord -> {\n+                        if (rgConfigRecord.getObject().getGeneration() != config.getGeneration()) {\n+                            return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                        }\n+                        if (!rgConfigRecord.getObject().isUpdating()) {\n+                          return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                             .thenCompose(rgId -> {\n+                             if (!config.getReaderGroupId().equals(rgId)) {\n+                                 return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                             }\n+                             ImmutableSet<String> removeStreams = getStreamsToBeUnsubscribed(rgConfigRecord.getObject().getStartingStreamCuts().keySet(),\n+                             config.getStartingStreamCuts().keySet().stream().map(s -> s.getScopedName()).collect(Collectors.toSet()));\n+                             UpdateReaderGroupEvent event = new UpdateReaderGroupEvent(scope, rgName, requestId, rgId,\n+                                                                 rgConfigRecord.getObject().getGeneration() + 1, removeStreams);\n+                             //3. Create Reader Group Metadata and submit event\n+                             return eventHelper.addIndexAndSubmitTask(event,\n+                                    () -> streamMetadataStore.startRGConfigUpdate(scope, rgName, config, null, executor))\n+                                          .thenCompose(x -> eventHelper.checkDone(() -> isRGUpdated(scope, rgName, executor))\n+                                              .thenApply(done -> UpdateReaderGroupStatus.Status.SUCCESS));\n+                             });\n+                        } else {\n+                          log.warn(\"Reader group update failed as another update is in progress.\");\n+                          return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.FAILURE);\n+                        }\n+                      });\n+               });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ImmutableSet<String> getStreamsToBeUnsubscribed(final Set<String> currentConfigStreams, final Set<String> newConfigStreams) {\n+        return ImmutableSet.copyOf(currentConfigStreams.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a1d92c0e77ace535836ea587139346db979788"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUxNjQ1MQ==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546516451", "createdAt": "2020-12-21T05:31:05Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java", "diffHunk": "@@ -210,7 +256,210 @@ public void initializeStreamWriters(final EventStreamClientFactory clientFactory\n                     }\n                 });\n     }\n-    \n+\n+    /**\n+     * Get Reader Group Configuration.\n+     *\n+     * @param scope  Reader Group scope.\n+     * @param rgName Reader Group name.\n+     * @param contextOpt Reader Group context.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<ReaderGroupConfigResponse> getReaderGroupConfig(final String scope, final String rgName,\n+                                                                             RGOperationContext contextOpt) {\n+        final long requestId = requestTracker.getRequestIdFor(\"getReaderGroupConfig\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+          // 1. check if RG with this name exists...\n+          return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+             .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(ReaderGroupConfigResponse.newBuilder()\n+                                    .setConfig(ReaderGroupConfiguration.getDefaultInstance())\n+                                    .setStatus(ReaderGroupConfigResponse.Status.RG_NOT_FOUND).build());\n+               }\n+               final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+               return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                    .thenCompose(rgId -> streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                            .thenApply(configRecord -> ReaderGroupConfigResponse.newBuilder()\n+                                .setConfig(getRGConfigurationFromRecord(scope, rgName, configRecord.getObject(), rgId.toString()))\n+                                .setStatus(ReaderGroupConfigResponse.Status.SUCCESS).build()));\n+       });\n+      }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ReaderGroupConfiguration getRGConfigurationFromRecord(final String scope, final String rgName,\n+                                                                  final ReaderGroupConfigRecord record, final String readerGroupId) {\n+        List<StreamCut> startStreamCuts = record.getStartingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        List<StreamCut> endStreamCuts = record.getEndingStreamCuts().entrySet().stream()\n+                .map(e -> StreamCut.newBuilder()\n+                        .setStreamInfo(StreamInfo.newBuilder().setStream(Stream.of(e.getKey()).getStreamName())\n+                                                              .setScope(Stream.of(e.getKey()).getScope()).build())\n+                        .putAllCut(e.getValue().getStreamCut()).build()).collect(Collectors.toList());\n+        return ReaderGroupConfiguration.newBuilder().setScope(scope).setReaderGroupName(rgName)\n+          .setGroupRefreshTimeMillis(record.getGroupRefreshTimeMillis())\n+          .setAutomaticCheckpointIntervalMillis(record.getAutomaticCheckpointIntervalMillis())\n+          .setMaxOutstandingCheckpointRequest(record.getMaxOutstandingCheckpointRequest())\n+          .setRetentionType(record.getRetentionTypeOrdinal())\n+          .setGeneration(record.getGeneration())\n+          .addAllStartingStreamCuts(startStreamCuts)\n+          .addAllEndingStreamCuts(endStreamCuts)\n+          .setReaderGroupId(readerGroupId)\n+          .build();\n+    }\n+\n+    /**\n+     * Create Reader Group.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          Reader Group config.\n+     * @param createTimestamp Reader Group creation timestamp.\n+     * @return creation status.\n+     */\n+    public CompletableFuture<CreateReaderGroupStatus.Status> createReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, long createTimestamp) {\n+    final long requestId = requestTracker.getRequestIdFor(\"createReaderGroup\", scope, rgName);\n+    return RetryHelper.withRetriesAsync(() -> {\n+      // 1. check if scope with this name exists...\n+      return streamMetadataStore.checkScopeExists(scope)\n+         .thenCompose(exists -> {\n+         if (!exists) {\n+                  return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SCOPE_NOT_FOUND);\n+         }\n+         //2. check state of the ReaderGroup, if found\n+         return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenCompose(state -> {\n+                if (state.equals(ReaderGroupState.UNKNOWN) || state.equals(ReaderGroupState.CREATING)) {\n+                   CreateReaderGroupEvent event = new CreateReaderGroupEvent(scope, rgName, requestId);\n+                   //3. Create Reader Group Metadata and submit event\n+                   return eventHelper.addIndexAndSubmitTask(event,\n+                              () -> streamMetadataStore.createReaderGroup(scope, rgName, config, createTimestamp, null, executor))\n+                              .thenCompose(x -> eventHelper.checkDone(() -> isRGCreated(scope, rgName, executor))\n+                              .thenApply(done -> CreateReaderGroupStatus.Status.SUCCESS));\n+                }\n+                // idempotent call\n+                return CompletableFuture.completedFuture(CreateReaderGroupStatus.Status.SUCCESS);\n+             });\n+         });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isRGCreated(String scope, String rgName, Executor executor) {\n+        return Futures.exceptionallyExpecting(streamMetadataStore.getReaderGroupState(scope, rgName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, ReaderGroupState.UNKNOWN)\n+                .thenApply(state -> {\n+                    log.debug(\"ReaderGroup State is {}\", state.toString());\n+                    return ReaderGroupState.ACTIVE.equals(state);\n+                });\n+    }\n+\n+    /**\n+     * Update Reader Group Configuration.\n+     *\n+     * @param scope           Reader Group scope.\n+     * @param rgName          Reader Group name.\n+     * @param config          New Reader Group config.\n+     * @param contextOpt      Reader Group context.\n+     * @return updation status.\n+     */\n+    public CompletableFuture<UpdateReaderGroupStatus.Status> updateReaderGroup(final String scope, final String rgName,\n+                                                                               final ReaderGroupConfig config, RGOperationContext contextOpt) {\n+        final RGOperationContext context = contextOpt == null ? streamMetadataStore.createRGContext(scope, rgName) : contextOpt;\n+        final long requestId = requestTracker.getRequestIdFor(\"updateReaderGroup\", scope, rgName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+            // 1. check if Reader Group exists...\n+            return streamMetadataStore.checkReaderGroupExists(scope, rgName)\n+               .thenCompose(exists -> {\n+               if (!exists) {\n+                  return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.RG_NOT_FOUND);\n+               }\n+               //2. check for generation && ID match with existing config\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, rgName, context, executor)\n+                      .thenCompose(rgConfigRecord -> {\n+                        if (rgConfigRecord.getObject().getGeneration() != config.getGeneration()) {\n+                            return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                        }\n+                        if (!rgConfigRecord.getObject().isUpdating()) {\n+                          return streamMetadataStore.getReaderGroupId(scope, rgName, context, executor)\n+                             .thenCompose(rgId -> {\n+                             if (!config.getReaderGroupId().equals(rgId)) {\n+                                 return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.INVALID_CONFIG);\n+                             }\n+                             ImmutableSet<String> removeStreams = getStreamsToBeUnsubscribed(rgConfigRecord.getObject().getStartingStreamCuts().keySet(),\n+                             config.getStartingStreamCuts().keySet().stream().map(s -> s.getScopedName()).collect(Collectors.toSet()));\n+                             UpdateReaderGroupEvent event = new UpdateReaderGroupEvent(scope, rgName, requestId, rgId,\n+                                                                 rgConfigRecord.getObject().getGeneration() + 1, removeStreams);\n+                             //3. Create Reader Group Metadata and submit event\n+                             return eventHelper.addIndexAndSubmitTask(event,\n+                                    () -> streamMetadataStore.startRGConfigUpdate(scope, rgName, config, null, executor))\n+                                          .thenCompose(x -> eventHelper.checkDone(() -> isRGUpdated(scope, rgName, executor))\n+                                              .thenApply(done -> UpdateReaderGroupStatus.Status.SUCCESS));\n+                             });\n+                        } else {\n+                          log.warn(\"Reader group update failed as another update is in progress.\");\n+                          return CompletableFuture.completedFuture(UpdateReaderGroupStatus.Status.FAILURE);\n+                        }\n+                      });\n+               });\n+        }, e -> Exceptions.unwrap(e) instanceof RetryableException, READER_GROUP_OPERATION_MAX_RETRIES, executor);\n+    }\n+\n+    private ImmutableSet<String> getStreamsToBeUnsubscribed(final Set<String> currentConfigStreams, final Set<String> newConfigStreams) {\n+        return ImmutableSet.copyOf(currentConfigStreams.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NDQzMg=="}, "originalCommit": {"oid": "41a1d92c0e77ace535836ea587139346db979788"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzczNTE1OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjoxNDozNVrOII8wlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNTozMDo1OFrOIJMt0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NDk5OA==", "bodyText": "should we pass the rg UUID to delete RG method and to a conditonal delete just to be extra safe? i know you check the rg id before processing the event. and the create is also linearized on this processor so they do not race per se. but still a conditional delete may be a safer thing to do. perhaps open a github issue to address this. thanks", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546254998", "createdAt": "2020-12-19T16:14:35Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      UUID readerGroupId = request.getReaderGroupId();\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupId(scope, readerGroup, context, executor)\n+              .thenCompose(id -> {\n+               if (!id.equals(readerGroupId)) {\n+                      log.warn(\"Skipping processing of Reader Group delete request {} as UUIDs did not match.\", requestId);\n+                      return CompletableFuture.completedFuture(null);\n+               }\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                          .thenCompose(configRecord -> {\n+                          if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                              .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                              String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                              // update Stream metadata tables, if RG is a Subscriber\n+                              Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                              return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                     Stream stream = Stream.of(streamIter.next());\n+                                     return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                                            stream.getStreamName(), scopedRGName, configRecord.getObject().getGeneration(), null, executor);\n+                                 }, executor);\n+                              }\n+                              return CompletableFuture.completedFuture(null);\n+                          })\n+                          .thenCompose(v -> streamMetadataTasks.sealStream(scope, NameUtils.getStreamForReaderGroup(readerGroup), null))\n+                                  .thenCompose(v -> streamMetadataTasks.deleteStream(scope,\n+                                  NameUtils.getStreamForReaderGroup(readerGroup), null)\n+                                  .thenCompose(v1 -> streamMetadataStore.deleteReaderGroup(scope, readerGroup, context, executor)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41a1d92c0e77ace535836ea587139346db979788"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUxNjQzMw==", "bodyText": "fixed", "url": "https://github.com/pravega/pravega/pull/5400#discussion_r546516433", "createdAt": "2020-12-21T05:30:58Z", "author": {"login": "pbelgundi"}, "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteReaderGroupTask.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers;\n+\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.stream.RGOperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n+import io.pravega.controller.task.Stream.StreamMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.DeleteReaderGroupEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Request handler for executing a delete operation for a ReaderGroup.\n+ */\n+@Slf4j\n+public class DeleteReaderGroupTask implements ReaderGroupTask<DeleteReaderGroupEvent> {\n+\n+    private final StreamMetadataStore streamMetadataStore;\n+    private final StreamMetadataTasks streamMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public DeleteReaderGroupTask(final StreamMetadataTasks streamMetaTasks,\n+                                 final StreamMetadataStore streamMetaStore,\n+                                 final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(streamMetaStore);\n+        Preconditions.checkNotNull(streamMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.streamMetadataStore = streamMetaStore;\n+        this.streamMetadataTasks = streamMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final DeleteReaderGroupEvent request) {\n+      String scope = request.getScope();\n+      String readerGroup = request.getRgName();\n+      long requestId = request.getRequestId();\n+      UUID readerGroupId = request.getReaderGroupId();\n+      final RGOperationContext context = streamMetadataStore.createRGContext(scope, readerGroup);\n+      return streamMetadataStore.getReaderGroupId(scope, readerGroup, context, executor)\n+              .thenCompose(id -> {\n+               if (!id.equals(readerGroupId)) {\n+                      log.warn(\"Skipping processing of Reader Group delete request {} as UUIDs did not match.\", requestId);\n+                      return CompletableFuture.completedFuture(null);\n+               }\n+               return streamMetadataStore.getReaderGroupConfigRecord(scope, readerGroup, context, executor)\n+                          .thenCompose(configRecord -> {\n+                          if (!ReaderGroupConfig.StreamDataRetention.values()[configRecord.getObject().getRetentionTypeOrdinal()]\n+                              .equals(ReaderGroupConfig.StreamDataRetention.NONE)) {\n+                              String scopedRGName = NameUtils.getScopedReaderGroupName(scope, readerGroup);\n+                              // update Stream metadata tables, if RG is a Subscriber\n+                              Iterator<String> streamIter = configRecord.getObject().getStartingStreamCuts().keySet().iterator();\n+                              return Futures.loop(() -> streamIter.hasNext(), () -> {\n+                                     Stream stream = Stream.of(streamIter.next());\n+                                     return streamMetadataStore.deleteSubscriber(stream.getScope(),\n+                                            stream.getStreamName(), scopedRGName, configRecord.getObject().getGeneration(), null, executor);\n+                                 }, executor);\n+                              }\n+                              return CompletableFuture.completedFuture(null);\n+                          })\n+                          .thenCompose(v -> streamMetadataTasks.sealStream(scope, NameUtils.getStreamForReaderGroup(readerGroup), null))\n+                                  .thenCompose(v -> streamMetadataTasks.deleteStream(scope,\n+                                  NameUtils.getStreamForReaderGroup(readerGroup), null)\n+                                  .thenCompose(v1 -> streamMetadataStore.deleteReaderGroup(scope, readerGroup, context, executor)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NDk5OA=="}, "originalCommit": {"oid": "41a1d92c0e77ace535836ea587139346db979788"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4588, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}