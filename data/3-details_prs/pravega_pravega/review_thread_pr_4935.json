{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2OTQ4Mzg4", "number": 4935, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjo1NzozMVrOEM-qVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo1NzoxMVrOENGFBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDQ1MDE1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjo1NzozMVrOGvZ2sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzoyNTo1MFrOGva2VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1OTg1Nw==", "bodyText": "FYI this is not 2Kb.", "url": "https://github.com/pravega/pravega/pull/4935#discussion_r452359857", "createdAt": "2020-07-09T16:57:31Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "diffHunk": "@@ -24,8 +24,17 @@\n  * Serializer for Key-Value Table Key Families.\n  */\n class KeyFamilySerializer {\n+    /**\n+     * Maximum length for a Key Family serialization using {@link #ENCODING}.\n+     * If this value is changed, care must be taken such that the sum of it, {@link #PREFIX_LENGTH} and\n+     * {@link TableSegment#MAXIMUM_KEY_LENGTH} do not exceed the server-side limits.\n+     */\n     @VisibleForTesting\n-    static final int MAX_KEY_FAMILY_LENGTH = 1024; // It can't be longer than TableSegment.MAX_KEY_LENGTH\n+    static final int MAX_KEY_FAMILY_LENGTH = 2096;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5d5445a0761b168134bcfff3af01c74572a64e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NjE0OA==", "bodyText": "Duh! Fixed.", "url": "https://github.com/pravega/pravega/pull/4935#discussion_r452376148", "createdAt": "2020-07-09T17:25:50Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyFamilySerializer.java", "diffHunk": "@@ -24,8 +24,17 @@\n  * Serializer for Key-Value Table Key Families.\n  */\n class KeyFamilySerializer {\n+    /**\n+     * Maximum length for a Key Family serialization using {@link #ENCODING}.\n+     * If this value is changed, care must be taken such that the sum of it, {@link #PREFIX_LENGTH} and\n+     * {@link TableSegment#MAXIMUM_KEY_LENGTH} do not exceed the server-side limits.\n+     */\n     @VisibleForTesting\n-    static final int MAX_KEY_FAMILY_LENGTH = 1024; // It can't be longer than TableSegment.MAX_KEY_LENGTH\n+    static final int MAX_KEY_FAMILY_LENGTH = 2096;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1OTg1Nw=="}, "originalCommit": {"oid": "7e5d5445a0761b168134bcfff3af01c74572a64e"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU0Mjk4OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzoyMzoyMFrOGvaw5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo0NzowMFrOGvlaRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NDc1OA==", "bodyText": "This seems particularly inefficient. Supposing there are N items to be retrieved and a fixed number fit in a batch this is O(n^2) because the first call gets all N and throws all but the first batch away. The second fetches N-batch and throws all but the next batch away etc.\nWe should figure out a way to pass down a limit to the get call, even if it is not exact. It's better to reply with more smaller messages which are efficient than maximizing our wirecommand size out in the reply.", "url": "https://github.com/pravega/pravega/pull/4935#discussion_r452374758", "createdAt": "2020-07-09T17:23:20Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -710,8 +717,11 @@ public void readTable(final WireCommands.ReadTable readTable) {\n         val timer = new Timer();\n         tableStore.get(segment, keys, TIMEOUT)\n                 .thenAccept(values -> {\n-                    connection.send(new WireCommands.TableRead(readTable.getRequestId(), segment, getTableEntriesCommand(keys, values)));\n-                    this.tableStatsRecorder.getKeys(readTable.getSegment(), keys.size(), timer.getElapsed());\n+                    // NOTE: getTableEntriesCommand will truncate the result to prevent it from exceeding MAX_TABLE_RESPONSE_SIZE.\n+                    // In such a situation, not all requested items will be returned to the caller; only the head of the list will.\n+                    WireCommands.TableEntries response = getTableEntriesCommand(readTable.getRequestId(), keys, values);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e5d5445a0761b168134bcfff3af01c74572a64e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDY2Mg==", "bodyText": "I agree with this. However I am not sure how easy it is to do this with the current RawClient that expects a single response for a request.\nI filed #4936 to research a way to handle these situations. This may also help iterators too (i.e., to avoid a flurry of request-replies for each iterator iteration).", "url": "https://github.com/pravega/pravega/pull/4935#discussion_r452380662", "createdAt": "2020-07-09T17:33:48Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -710,8 +717,11 @@ public void readTable(final WireCommands.ReadTable readTable) {\n         val timer = new Timer();\n         tableStore.get(segment, keys, TIMEOUT)\n                 .thenAccept(values -> {\n-                    connection.send(new WireCommands.TableRead(readTable.getRequestId(), segment, getTableEntriesCommand(keys, values)));\n-                    this.tableStatsRecorder.getKeys(readTable.getSegment(), keys.size(), timer.getElapsed());\n+                    // NOTE: getTableEntriesCommand will truncate the result to prevent it from exceeding MAX_TABLE_RESPONSE_SIZE.\n+                    // In such a situation, not all requested items will be returned to the caller; only the head of the list will.\n+                    WireCommands.TableEntries response = getTableEntriesCommand(readTable.getRequestId(), keys, values);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NDc1OA=="}, "originalCommit": {"oid": "7e5d5445a0761b168134bcfff3af01c74572a64e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0OTE4OQ==", "bodyText": "I reworked this part. Check out the updated description for details.", "url": "https://github.com/pravega/pravega/pull/4935#discussion_r452549189", "createdAt": "2020-07-09T23:47:00Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -710,8 +717,11 @@ public void readTable(final WireCommands.ReadTable readTable) {\n         val timer = new Timer();\n         tableStore.get(segment, keys, TIMEOUT)\n                 .thenAccept(values -> {\n-                    connection.send(new WireCommands.TableRead(readTable.getRequestId(), segment, getTableEntriesCommand(keys, values)));\n-                    this.tableStatsRecorder.getKeys(readTable.getSegment(), keys.size(), timer.getElapsed());\n+                    // NOTE: getTableEntriesCommand will truncate the result to prevent it from exceeding MAX_TABLE_RESPONSE_SIZE.\n+                    // In such a situation, not all requested items will be returned to the caller; only the head of the list will.\n+                    WireCommands.TableEntries response = getTableEntriesCommand(readTable.getRequestId(), keys, values);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3NDc1OA=="}, "originalCommit": {"oid": "7e5d5445a0761b168134bcfff3af01c74572a64e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTY2NTMyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo1NzoxMVrOGvllfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo1NzozNlrOGvpF1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1MjA2Mg==", "bodyText": "remove?", "url": "https://github.com/pravega/pravega/pull/4935#discussion_r452552062", "createdAt": "2020-07-09T23:57:11Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentImpl.java", "diffHunk": "@@ -138,11 +145,37 @@ public void close() {\n     @Override\n     public CompletableFuture<List<TableSegmentEntry>> get(@NonNull Iterator<ByteBuf> keys) {\n         val wireKeys = rawKeysToWireCommand(keys);\n+        val resultBuilder = new GetResultBuilder(wireKeys);\n+        CompletableFuture<Void> result;\n+        if (wireKeys.size() <= MAX_GET_KEY_BATCH_SIZE) {\n+            // The entire request can be satisfied using a single call.\n+            result = fetchSlice(resultBuilder);\n+        } else {\n+            // The request has to be split into multiple calls and then combined.\n+            val processor = new OrderedProcessor<Void>(MAX_GET_CONCURRENT_REQUESTS, this.connectionFactory.getInternalExecutor());\n+            val futures = new ArrayList<CompletableFuture<Void>>();\n+            int index = 0;\n+            while (index < wireKeys.size()) {\n+                final int sliceStart = index;\n+                final int sliceLength = Math.min(MAX_GET_KEY_BATCH_SIZE, wireKeys.size() - sliceStart);\n+                futures.add(processor.execute(() -> fetchSlice(resultBuilder.slice(sliceStart, sliceStart + sliceLength))));\n+                //futures.add(fetchSlice(resultBuilder.slice(index, index + sliceLength)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd6015b378a081f9c06b1f128d9077be8cdeab4f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTQ5NQ==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4935#discussion_r452609495", "createdAt": "2020-07-10T03:57:36Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentImpl.java", "diffHunk": "@@ -138,11 +145,37 @@ public void close() {\n     @Override\n     public CompletableFuture<List<TableSegmentEntry>> get(@NonNull Iterator<ByteBuf> keys) {\n         val wireKeys = rawKeysToWireCommand(keys);\n+        val resultBuilder = new GetResultBuilder(wireKeys);\n+        CompletableFuture<Void> result;\n+        if (wireKeys.size() <= MAX_GET_KEY_BATCH_SIZE) {\n+            // The entire request can be satisfied using a single call.\n+            result = fetchSlice(resultBuilder);\n+        } else {\n+            // The request has to be split into multiple calls and then combined.\n+            val processor = new OrderedProcessor<Void>(MAX_GET_CONCURRENT_REQUESTS, this.connectionFactory.getInternalExecutor());\n+            val futures = new ArrayList<CompletableFuture<Void>>();\n+            int index = 0;\n+            while (index < wireKeys.size()) {\n+                final int sliceStart = index;\n+                final int sliceLength = Math.min(MAX_GET_KEY_BATCH_SIZE, wireKeys.size() - sliceStart);\n+                futures.add(processor.execute(() -> fetchSlice(resultBuilder.slice(sliceStart, sliceStart + sliceLength))));\n+                //futures.add(fetchSlice(resultBuilder.slice(index, index + sliceLength)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1MjA2Mg=="}, "originalCommit": {"oid": "dd6015b378a081f9c06b1f128d9077be8cdeab4f"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4788, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}