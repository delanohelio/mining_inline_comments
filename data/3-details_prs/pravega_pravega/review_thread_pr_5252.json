{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyODgyOTUz", "number": 5252, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMDowNjo0MlrOE1BorQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzowMzo0MVrOE4ZJlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MDM2NzgxOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableExtensionConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMDowNjo0MlrOHtEy_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMDozNjo0MlrOHtutRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyNjU1OA==", "bodyText": "did not understand why multiplied by 4", "url": "https://github.com/pravega/pravega/pull/5252#discussion_r517026558", "createdAt": "2020-11-04T00:06:42Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableExtensionConfig.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.tables.TableAttributes;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeoutException;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+/**\n+ * Configuration for {@link ContainerTableExtensionImpl} and sub-components.\n+ */\n+@Data\n+@Builder\n+class TableExtensionConfig {\n+    /**\n+     * The maximum unindexed length ({@link SegmentProperties#getLength() - {@link TableAttributes#INDEX_OFFSET}}) of a\n+     * Segment for which {@link ContainerKeyIndex} {@code triggerCacheTailIndex} can be invoked.\n+     */\n+    @Builder.Default\n+    private int maxTailCachePreIndexLength = EntrySerializer.MAX_BATCH_SIZE * 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6623fdeb1e35a03fa96e14e7837b67491fd3bb6"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIyMg==", "bodyText": "MaxBatchSize == 32MB (32 * MaxEntrySize).\nI wrote 128MB as a function of MaxBatchSize, and implicitly as a function of MaxEntrySize.", "url": "https://github.com/pravega/pravega/pull/5252#discussion_r517713222", "createdAt": "2020-11-05T00:36:42Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableExtensionConfig.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.tables;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.SegmentProperties;\n+import io.pravega.segmentstore.contracts.tables.TableAttributes;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeoutException;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+/**\n+ * Configuration for {@link ContainerTableExtensionImpl} and sub-components.\n+ */\n+@Data\n+@Builder\n+class TableExtensionConfig {\n+    /**\n+     * The maximum unindexed length ({@link SegmentProperties#getLength() - {@link TableAttributes#INDEX_OFFSET}}) of a\n+     * Segment for which {@link ContainerKeyIndex} {@code triggerCacheTailIndex} can be invoked.\n+     */\n+    @Builder.Default\n+    private int maxTailCachePreIndexLength = EntrySerializer.MAX_BATCH_SIZE * 4;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyNjU1OA=="}, "originalCommit": {"oid": "e6623fdeb1e35a03fa96e14e7837b67491fd3bb6"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTY3NTE3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/AsyncSemaphore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzowMjozNlrOHySSOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzowMjozNlrOHySSOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDQyNA==", "bodyText": "I feel like this should take a threadpool to run the tasks on. I seems a bit strange that they get run in the thread that calls release.", "url": "https://github.com/pravega/pravega/pull/5252#discussion_r522490424", "createdAt": "2020-11-12T23:02:36Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/concurrent/AsyncSemaphore.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.Exceptions;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A synchronization primitive that allows executing arbitrary (concurrent) tasks, where each task requires a well-known\n+ * number of credits, subject to a total number of credits being available. Each task's successful execution will \"borrow\"\n+ * its share of credits, and a task cannot execute if the number of credits available is insufficient. Credits may be\n+ * restored externally using the {@link #release} method.\n+ *\n+ * This is similar to {@link java.util.concurrent.Semaphore}, except that this class allows for asynchronous processing\n+ * and each task can request an arbitrary number of credits. It can be useful in solving problems making use of the\n+ * Leaky Bucket Algorithm (https://en.wikipedia.org/wiki/Leaky_bucket).\n+ */\n+@ThreadSafe\n+@Slf4j\n+public class AsyncSemaphore implements AutoCloseable {\n+    //region Members\n+\n+    private final long totalCredits;\n+    private final String logId;\n+    @GuardedBy(\"queue\")\n+    private long usedCredits;\n+    @GuardedBy(\"queue\")\n+    private final ArrayDeque<PendingTask> queue;\n+    @GuardedBy(\"queue\")\n+    private boolean closed;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link AsyncSemaphore} class.\n+     *\n+     * @param totalCredits Total number of available credits.\n+     * @param usedCredits  Initial number of used credits.\n+     * @param logId        A log-friendly identifier for this {@link AsyncSemaphore}.\n+     */\n+    public AsyncSemaphore(long totalCredits, long usedCredits, String logId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b438989d7c8345e4fae19d55c9993d876074f22"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTY3NzY3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/concurrent/AsyncSemaphore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzowMzo0MVrOHySTsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzowMzo0MVrOHySTsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDgwMA==", "bodyText": "It would be good if we could automate calling this so that the caller cannot forget. IE by chaining it's invocation on the future returned for example.", "url": "https://github.com/pravega/pravega/pull/5252#discussion_r522490800", "createdAt": "2020-11-12T23:03:41Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/concurrent/AsyncSemaphore.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.Exceptions;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A synchronization primitive that allows executing arbitrary (concurrent) tasks, where each task requires a well-known\n+ * number of credits, subject to a total number of credits being available. Each task's successful execution will \"borrow\"\n+ * its share of credits, and a task cannot execute if the number of credits available is insufficient. Credits may be\n+ * restored externally using the {@link #release} method.\n+ *\n+ * This is similar to {@link java.util.concurrent.Semaphore}, except that this class allows for asynchronous processing\n+ * and each task can request an arbitrary number of credits. It can be useful in solving problems making use of the\n+ * Leaky Bucket Algorithm (https://en.wikipedia.org/wiki/Leaky_bucket).\n+ */\n+@ThreadSafe\n+@Slf4j\n+public class AsyncSemaphore implements AutoCloseable {\n+    //region Members\n+\n+    private final long totalCredits;\n+    private final String logId;\n+    @GuardedBy(\"queue\")\n+    private long usedCredits;\n+    @GuardedBy(\"queue\")\n+    private final ArrayDeque<PendingTask> queue;\n+    @GuardedBy(\"queue\")\n+    private boolean closed;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link AsyncSemaphore} class.\n+     *\n+     * @param totalCredits Total number of available credits.\n+     * @param usedCredits  Initial number of used credits.\n+     * @param logId        A log-friendly identifier for this {@link AsyncSemaphore}.\n+     */\n+    public AsyncSemaphore(long totalCredits, long usedCredits, String logId) {\n+        Preconditions.checkArgument(totalCredits > 0, \"totalCredits must be a positive integer\");\n+        Preconditions.checkArgument(usedCredits >= 0, \"usedCredits must be a non-negative integer\");\n+        this.totalCredits = totalCredits;\n+        this.usedCredits = usedCredits;\n+        this.logId = logId;\n+        this.queue = new ArrayDeque<>();\n+        this.closed = false;\n+    }\n+\n+    //endregion\n+\n+    //region AutoCloseable Implementation\n+\n+    @Override\n+    public void close() {\n+        List<PendingTask> toCancel = null;\n+        synchronized (this.queue) {\n+            if (!this.closed) {\n+                toCancel = new ArrayList<>(this.queue);\n+                this.queue.clear();\n+                this.usedCredits = 0;\n+                this.closed = true;\n+            }\n+        }\n+\n+        if (toCancel != null && !toCancel.isEmpty()) {\n+            log.debug(\"AsyncSemaphore[{}]: Closing. Cancelling {} task(s).\", logId, toCancel.size());\n+            toCancel.forEach(task -> task.result.cancel(true));\n+        }\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Executes the given task which requires the given number of credits.\n+     *\n+     * If there are sufficient credits available for this task to run, it will be invoked synchronously and the returned\n+     * result is directly provided by the given task.\n+     *\n+     * If there are insufficient credits available for this task to run, it will be queued up and executed when credits\n+     * become available. There is no prioritization of queued tasks - they are triggered in the order in which they\n+     * are queued up.\n+     *\n+     * If the {@code force} flag is set, then the task will be invoked synchronously, even if there are insufficient\n+     * credits. In this case, the {@link #getUsedCredits()} will exceed the max allowed credits and no other (non-forced)\n+     * task will be allowed to execute until {@link #getUsedCredits()} falls below the max allowed.\n+     *\n+     * A task will allocate the requested credits when it is triggered. If the task fails (synchronously or asynchronously),\n+     * then the requested credits are automatically released back into the pool. If the task succeeds, the credits will\n+     * remain.\n+     *\n+     * @param task    A {@link Supplier} that, when invoked, will execute the task.\n+     * @param credits The number of credits this task requires.\n+     * @param force   If true, the task will be executed synchronously regardless of how many credits are available. The\n+     *                task's credits are still recorded in this case.\n+     * @param <T>     Return type.\n+     * @return A CompletableFuture that, when completed, will contain the result of the executed task. If the task failed\n+     * or was rejected (i.e., due to {@link AsyncSemaphore} closing), it will be failed with the appropriate exception.\n+     */\n+    public <T> CompletableFuture<T> run(@NonNull Supplier<CompletableFuture<T>> task, long credits, boolean force) {\n+        Preconditions.checkArgument(credits >= 0 && credits <= this.totalCredits,\n+                \"credits must be a non-negative number smaller than or equal to %s.\", this.totalCredits);\n+\n+        PendingTask<T> pt;\n+        synchronized (this.queue) {\n+            Exceptions.checkNotClosed(this.closed, this);\n+            if (force || canExecute(credits)) {\n+                pt = null;\n+                this.usedCredits += credits;\n+                log.trace(\"AsyncSemaphore[{}]: Task run. Credits={}, TotalUsedCredits={}, Forced={}.\", this.logId, credits, this.usedCredits, force);\n+            } else {\n+                // Insufficient credits; need to queue up and execute when more becomes available.\n+                pt = new PendingTask<>(credits, task);\n+                this.queue.addLast(pt);\n+                log.debug(\"AsyncSemaphore[{}]: Task blocked. Credits={}, TotalUsedCredits={}, QueueSize={}.\",\n+                        this.logId, credits, this.usedCredits, this.queue.size());\n+            }\n+        }\n+\n+        if (pt == null) {\n+            // We have more credits than what this task requires. Execute now without queuing.\n+            return execute(task, credits);\n+        } else {\n+            // This wil be completed when its associated task is executed.\n+            return pt.result;\n+        }\n+    }\n+\n+    /**\n+     * Releases a number of credits back into the pool and initiates the execution of any pending tasks that are now\n+     * eligible to run.\n+     *\n+     * @param credits The number of credits to release. This number will be capped at the number of currently used\n+     *                credits ({@link #getUsedCredits()}).\n+     */\n+    public void release(long credits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b438989d7c8345e4fae19d55c9993d876074f22"}, "originalPosition": 159}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4742, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}