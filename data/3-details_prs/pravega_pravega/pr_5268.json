{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2OTg1MTUw", "number": 5268, "title": "Issue 5260: (SegmentStore) Adjustable Operation Priority Levels", "bodyText": "Change log description\n\nAdded the ability to differentiate between segments based on their Segment Type.\nAdded the ability to prioritize Operations based on the owning Segment Segment Type and Operation Type\nIdentifying all Table Segments (Sorted and not sorted) as their own Segment Type.\nDesignating Segment Container Metadata Segments as \"System Segment\".\nDesignating Storage Metadata Segments as \"System Critical\" segments\n\nPurpose of the change\nFixes #5260.\nWhat the code does\n\nSegmentType\n\nDefines the Format (Basic, Table Segment, Sorted Table Segment) and Role (Internal, Critical, System) of the Segment.\nThis is passed via the API (to make it mandatory), but internally it's stored in an unmodifiable Core Attribute. This attribute may not be changed after the segment is created.\nFor backwards compatibility (segments created prior to 0.9), SegmentType provides a method to infer type from attributes.\nWired up everywhere Segments are created (PravegaRequestProcessor, TableMetadataStore, TableBasedMetadataStore (SLTS)) to pass in the correct type.\n\n\nOperationType\n\nEach Operation in the Segment store that gets added to DurableLog has a type. As of now, we only differentiate between Normal and Deletion (more may be added later).\n\n\nOperationPriority\n\nDefined various levels of Priority for Operations. Please refer to the class (enum) itself and the associated Javadoc for descriptions.\nProvided a PriorityCalculator that takes in a SegmentType and OperationType and produces an OperationPriority. Please refer to this class' Javadoc for details.\n\n\nStreamSegmentContainer and DurableLog changes\n\nUsing PriorityCalculator to assign priorities to all operations that are sent to DurableLog\nThis priority is sent downstream to the OperationProcessor (i.e., DurableLog is just a pass-through for this)\n\n\nOperationProcessor and Throttler changes\n\nCreated a PriorityBlockingDrainingQueue that works exactly like the BlockingDrainingQueue that it replaces, except that it wraps around multiple internal queues, based on priority levels. This is used for Operations with higher priority to \"jump the line\" and be placed ahead of lower-priority operations.\nIf an Operation with an OperationPriority that indicates IsThrottlingExempt is placed in this queue, then the Throttler will be notified to interrupt any ongoing throttling activities. Such operations will not be subject to throttling, even if the conditions are set for said throttling to happen. If throttling must indeed happen, the Operation Processor will only allow those operations that are exempt from throttling from going through (no leaking).\n\n\nStreamSegmentStore and TableStore\n\nUpdated createSegment APIs to require SegmentType. Replaced obsolete args with SegmentType (which is inclusive of those args).\nThis caused a large number of (test) files to require touching, hence the high \"Files changed\" count for this PR.\n\n\n\nHow to verify it\nUnit tests and system tests must pass.\nNew unit tests have been added to verify new functionality.", "createdAt": "2020-10-20T17:44:30Z", "url": "https://github.com/pravega/pravega/pull/5268", "merged": true, "mergeCommit": {"oid": "7e8a26133281a86ca8823c4665fd7d2fb836eeb1"}, "closed": true, "closedAt": "2020-11-05T15:16:40Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTMmANAH2gAyNTA2OTg1MTUwOjAwMDIxNjgzZTEwZTI2YjQyZGNlYTUwNjA4MmJlZTc1NDI5Nzc4NzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZYk2lgFqTUyMzg2NDk5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "00021683e10e26b42dcea506082bee7542977875", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/00021683e10e26b42dcea506082bee7542977875", "committedDate": "2020-10-16T20:42:10Z", "message": "Defined OperationPriority.\nCreated PriorityBlockingDrainingQueue (+tests).\nIntegrated with CompletableOperation (+tests)\nIntegrated with OperationProcessor (no tests yet).\nIntegrated with DurableLog (no tests yet).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87fcc9368d1149a673dad70402b38258c16c2887", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/87fcc9368d1149a673dad70402b38258c16c2887", "committedDate": "2020-10-16T23:29:07Z", "message": "Throttler: added a way to temporarily suspend throttling.\nOperationProcessor: wired up Throttler suspension (+ unit tests).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "438c729dae67e71ee82f1cb938e25fa8c4a87528", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/438c729dae67e71ee82f1cb938e25fa8c4a87528", "committedDate": "2020-10-17T13:41:14Z", "message": "Throttler: not going in a loop if max==true and suspended.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee690e453c4bf526de3b2780a4f72c76492dc5e6", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/ee690e453c4bf526de3b2780a4f72c76492dc5e6", "committedDate": "2020-10-19T15:24:04Z", "message": "DeleteSegmentOperations have OperationPriority.Critical.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2f95f0debe7d2413d3db9431cb313be0ee25855", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b2f95f0debe7d2413d3db9431cb313be0ee25855", "committedDate": "2020-10-20T01:06:13Z", "message": "Attributes.ATTRIBUTE_SEGMENT_TYPE is used to store SegmentMetadata.getType. This is refreshed every time the SegmentMetadata is activated (loaded from a checkpoint) or from the MetadataStore (via StreamSegmentMapOperation).\nThis attribute is immutable once the segment is created. Some of its values may be inferred from existing attributes.\n\nStreamSegmentStore: Updated createStreamSegment to accept a SegmentType.\nTableStore: Updated createdSegment to accept SegmentType instead of \"boolean sorted\".\n\nPravegaRequestProcessor, TableBasedMetadataStore, TableMetadataStore: setting correct SegmentTypes on all created segments.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1811935163cd13c681cb2e49be28ee7baaef38c", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d1811935163cd13c681cb2e49be28ee7baaef38c", "committedDate": "2020-10-20T17:31:09Z", "message": "All Segment Store Operations have OperationType. Deletion is the most exciting one.\nAdded OperationPriority.High - reserved for non-critical system segments.\nAdded PriorityCalculator that helps figure out operation priorities. Wired up in StreamSegmentContainer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eb78b8b36e57832ca2bcdc75079a42d49bfa27f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/2eb78b8b36e57832ca2bcdc75079a42d49bfa27f", "committedDate": "2020-10-20T17:42:59Z", "message": "Retired OperationLog.add (without priority).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f6234a492400f28546c855fd1ee67e5f171228b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/2f6234a492400f28546c855fd1ee67e5f171228b", "committedDate": "2020-10-20T17:43:16Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5260-qos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19a3e88e13d3cbae6d018a23dca2e390a58ad9c5", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/19a3e88e13d3cbae6d018a23dca2e390a58ad9c5", "committedDate": "2020-10-20T20:21:05Z", "message": "Updated unit tests for StreamSegmentContainer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c0d62922e139b56a629d5511a12a9890d3af2e6", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/6c0d62922e139b56a629d5511a12a9890d3af2e6", "committedDate": "2020-10-22T00:00:44Z", "message": "Merge branch 'master' into issue-5260-qos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/70799524c8943a0bd347079a91c22919d6da2e43", "committedDate": "2020-10-28T17:17:00Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5260-qos\n\n# Conflicts:\n#\tsegmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImplTests.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc3OTg3", "url": "https://github.com/pravega/pravega/pull/5268#pullrequestreview-521877987", "createdAt": "2020-11-02T18:08:57Z", "commit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODowODo1OFrOHsQHnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxOTo0NToxMlrOHsTMMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MzQ4NA==", "bodyText": "Should we add back the createSegment(String segmentName, Duration timeout)  overload that creates normal segments?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516163484", "createdAt": "2020-11-02T18:08:58Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -65,38 +66,23 @@\n      */\n     int MAXIMUM_VALUE_LENGTH = 1024 * 1024 - MAXIMUM_KEY_LENGTH;\n \n-    /**\n-     * Creates a new Segment and marks it as a Table Segment. This will be a non-sorted Table Segment.\n-     * See {@link #createSegment(String, boolean, Duration)} (invoked with sorted:=false).\n-     * This segment may not be used for Streaming purposes (i.e., it cannot be used with {@link StreamSegmentStore}).\n-     *\n-     * @param segmentName The name of the Table Segment to create.\n-     * @param timeout     Timeout for the operation.\n-     * @return A CompletableFuture that, when completed normally, will indicate the operation completed. If the operation\n-     * failed, the future will be failed with the causing exception. Notable Exceptions:\n-     * <ul>\n-     * <li>{@link StreamSegmentExistsException} If the Segment does exist (whether as a Table Segment or Stream Segment).\n-     * </ul>\n-     */\n-    default CompletableFuture<Void> createSegment(String segmentName, Duration timeout) {\n-        return createSegment(segmentName, false, timeout);\n-    }\n-\n     /**\n      * Creates a new Segment and marks it as a Table Segment.\n      * This segment may not be used for Streaming purposes (i.e., it cannot be used with {@link StreamSegmentStore}).\n      *\n      * @param segmentName The name of the Table Segment to create.\n-     * @param sorted      EXPERIMENTAL. If true, the created Table Segment will be a Sorted Table Segment, otherwise it\n-     *                    will be a plain Hash Table. See {@link TableStore} Javadoc for difference between the two.\n+     * @param segmentType Type of Segment to Create. If not already specified, this will automatically set the\n+     *                    {@link  SegmentType#isTableSegment()} to true. If {@link  SegmentType#isSortedTableSegment()}\n+     *                    is true, this will create a Sorted Table Segment (EXPERIMENTAL), otherwise it will be a plain\n+     *                    Hash Table. See {@link TableStore} Javadoc for difference between the two.\n      * @param timeout     Timeout for the operation.\n      * @return A CompletableFuture that, when completed normally, will indicate the operation completed. If the operation\n      * failed, the future will be failed with the causing exception. Notable Exceptions:\n      * <ul>\n      * <li>{@link StreamSegmentExistsException} If the Segment does exist (whether as a Table Segment or Stream Segment).\n      * </ul>\n      */\n-    CompletableFuture<Void> createSegment(String segmentName, boolean sorted, Duration timeout);\n+    CompletableFuture<Void> createSegment(String segmentName, SegmentType segmentType, Duration timeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NjcxNQ==", "bodyText": "cannot be modified", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516166715", "createdAt": "2020-11-02T18:14:53Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/Attributes.java", "diffHunk": "@@ -98,6 +98,22 @@\n      */\n     public static final UUID ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO = new UUID(CORE_ATTRIBUTE_ID_PREFIX, 8);\n \n+    /**\n+     * Defines an attribute that is used to store the Segment's Type ({@link SegmentType#getValue()}.\n+     * This attribute cannot be modified once set on the Segment.\n+     */\n+    public static final UUID ATTRIBUTE_SEGMENT_TYPE = new UUID(CORE_ATTRIBUTE_ID_PREFIX, TABLE_ATTRIBUTES_START_OFFSET - 1);\n+\n+    /**\n+     * Determines whether the given attribute may NOT be modified once originally set on the Segment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2ODI0Mw==", "bodyText": "why TABLE_ATTRIBUTES_START_OFFSET - 1 ?  why not 9?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516168243", "createdAt": "2020-11-02T18:17:32Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/Attributes.java", "diffHunk": "@@ -98,6 +98,22 @@\n      */\n     public static final UUID ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO = new UUID(CORE_ATTRIBUTE_ID_PREFIX, 8);\n \n+    /**\n+     * Defines an attribute that is used to store the Segment's Type ({@link SegmentType#getValue()}.\n+     * This attribute cannot be modified once set on the Segment.\n+     */\n+    public static final UUID ATTRIBUTE_SEGMENT_TYPE = new UUID(CORE_ATTRIBUTE_ID_PREFIX, TABLE_ATTRIBUTES_START_OFFSET - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MDI4Mw==", "bodyText": "why not ROLE_CRITICAL = 0b0100_0000L | ROLE_INTERNAL also?\nWhat is the difference between internal and system ?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516170283", "createdAt": "2020-11-02T18:21:08Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/SegmentType.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.contracts;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.segmentstore.contracts.tables.TableAttributes;\n+import java.util.Map;\n+import java.util.UUID;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Defines Segment Types. A Segment Type is a combination of Formats (how data are stored internally) and Roles (how is\n+ * the Segment used and how does the Segment Store rely on it).\n+ */\n+@RequiredArgsConstructor\n+public class SegmentType {\n+    //region Flags\n+\n+    /*\n+     * Note to developers: DO NOT CHANGE the number (bit) representations of the fields below. They are used for bitwise\n+     * concatenation and their values are stored as Segment Attributes. Changing them would break backwards compatibility.\n+     * Adding new values is OK. Do not reuse retired values. Carefully consider the addition of new values as there are\n+     * a maximum of 64 flags that can be set using this scheme.\n+     */\n+    @VisibleForTesting\n+    static final long FORMAT_BASIC = 0b0000_0000L;\n+    @VisibleForTesting\n+    static final long FORMAT_TABLE_SEGMENT = 0b0000_0001L;\n+    @VisibleForTesting\n+    static final long FORMAT_SORTED_TABLE_SEGMENT = 0b0000_0010L | FORMAT_TABLE_SEGMENT;\n+    @VisibleForTesting\n+    static final long ROLE_INTERNAL = 0b0001_0000L;\n+    @VisibleForTesting\n+    static final long ROLE_SYSTEM = 0b0010_0000L | ROLE_INTERNAL;\n+    @VisibleForTesting\n+    static final long ROLE_CRITICAL = 0b0100_0000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4Mjg3Mw==", "bodyText": "predicates?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516182873", "createdAt": "2020-11-02T18:44:46Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/contracts/src/test/java/io/pravega/segmentstore/contracts/SegmentTypeTests.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.contracts;\n+\n+import io.pravega.segmentstore.contracts.tables.TableAttributes;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.UUID;\n+import java.util.function.Predicate;\n+import lombok.val;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Unit tests for the {@link SegmentType} class.\n+ */\n+public class SegmentTypeTests {\n+\n+    /**\n+     * Tests all {@link SegmentType}s with a single value.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBuilder() {\n+        checkBuilder(SegmentType.builder().build(), SegmentType.FORMAT_BASIC);\n+        checkBuilder(SegmentType.builder().tableSegment().build(), SegmentType.FORMAT_TABLE_SEGMENT, SegmentType::isTableSegment);\n+        checkBuilder(SegmentType.builder().sortedTableSegment().build(), SegmentType.FORMAT_SORTED_TABLE_SEGMENT,\n+                SegmentType::isTableSegment, SegmentType::isSortedTableSegment);\n+        checkBuilder(SegmentType.builder().internal().build(), SegmentType.ROLE_INTERNAL, SegmentType::isInternal);\n+        checkBuilder(SegmentType.builder().system().build(), SegmentType.ROLE_SYSTEM, SegmentType::isSystem, SegmentType::isInternal);\n+        checkBuilder(SegmentType.builder().critical().build(), SegmentType.ROLE_CRITICAL, SegmentType::isCritical);\n+    }\n+\n+    /**\n+     * Tests {@link SegmentType#fromAttributes} and {@link SegmentType#intoAttributes}.\n+     */\n+    @Test\n+    public void testToFromAttributes() {\n+        val empty = SegmentType.fromAttributes(Collections.emptyMap());\n+        Assert.assertEquals(\"Empty attributes. \", SegmentType.FORMAT_BASIC, empty.getValue());\n+\n+        val baseType = SegmentType.builder().critical().internal().system().build();\n+        val segmentAttributes = new HashMap<UUID, Long>();\n+        Assert.assertTrue(baseType.intoAttributes(segmentAttributes));\n+        Assert.assertFalse(baseType.intoAttributes(segmentAttributes));\n+\n+        val nonTableSegment = SegmentType.fromAttributes(segmentAttributes);\n+        Assert.assertEquals(\"Non-table segment.\", baseType, nonTableSegment);\n+\n+        segmentAttributes.put(TableAttributes.INDEX_OFFSET, 0L);\n+        val simpleTableSegment = SegmentType.fromAttributes(segmentAttributes);\n+        val expectedSimpleSegment = SegmentType.builder(baseType).tableSegment().build();\n+        Assert.assertEquals(\"Simple Table Segment.\", expectedSimpleSegment, simpleTableSegment);\n+\n+        segmentAttributes.put(TableAttributes.SORTED, Attributes.BOOLEAN_FALSE);\n+        Assert.assertEquals(\"Simple Table Segment (Sorted==False).\", expectedSimpleSegment, SegmentType.fromAttributes(segmentAttributes));\n+\n+        segmentAttributes.put(TableAttributes.SORTED, Attributes.BOOLEAN_TRUE);\n+        val sortedTableSegment = SegmentType.fromAttributes(segmentAttributes);\n+        val expectedSortedSegment = SegmentType.builder(expectedSimpleSegment).sortedTableSegment().build();\n+        Assert.assertEquals(\"Sorted Table Segment.\", expectedSortedSegment, sortedTableSegment);\n+    }\n+\n+    private void checkBuilder(SegmentType type, long expectedValue, Predicate<SegmentType>... mustBeTrue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4ODQ3NA==", "bodyText": "Can we add these as static constants to SegmentType itself?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516188474", "createdAt": "2020-11-02T18:55:11Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -132,6 +133,9 @@\n     private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(PravegaRequestProcessor.class));\n     private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n     private static final String EMPTY_STACK_TRACE = \"\";\n+    private static final SegmentType STREAM_SEGMENT = SegmentType.builder().build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5Njc2Mg==", "bodyText": "I am not sure I understood what is happening here. In earlier line we overwrote this.type from attributes, then why would this if condition ever be true?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516196762", "createdAt": "2020-11-02T19:11:32Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/StreamSegmentMetadata.java", "diffHunk": "@@ -297,6 +299,14 @@ public synchronized void updateAttributes(Map<UUID, Long> attributes) {\n         });\n     }\n \n+    @Override\n+    public synchronized void refreshType() {\n+        this.type = SegmentType.fromAttributes(this.coreAttributes);\n+        if (this.type.intoAttributes(this.coreAttributes)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwMTg0Mg==", "bodyText": "This could be a static method.\nThere is no state here.", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516201842", "createdAt": "2020-11-02T19:22:04Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/PriorityCalculator.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.logs;\n+\n+import io.pravega.segmentstore.contracts.SegmentType;\n+import io.pravega.segmentstore.server.logs.operations.OperationPriority;\n+import io.pravega.segmentstore.server.logs.operations.OperationType;\n+\n+/**\n+ * Calculates {@link OperationPriority} based on various factors.\n+ */\n+public final class PriorityCalculator {\n+\n+    /**\n+     * Determines an {@link OperationPriority} appropriate for the given {@link SegmentType} and {@link OperationType}.\n+     *\n+     * <pre>\n+     *\n+     * SegmentType       | OperationType | Priority\n+     * ------------------+---------------+----------------\n+     * System & Critical | (any)         | {@link OperationPriority#SystemCritical}\n+     * Critical          | (any)         | {@link OperationPriority#Critical}\n+     * (any)             | Deletion      | {@link OperationPriority#Critical}\n+     * System            | Normal        | {@link OperationPriority#High}\n+     * (all other combinations)          | {@link OperationPriority#Normal}\n+     *\n+     * </pre>\n+     *\n+     * @param segmentType   {@link SegmentType} that the Operation applies to.\n+     * @param operationType Operation's {@link OperationType}.\n+     * @return A {@link OperationPriority}.\n+     */\n+    public OperationPriority getPriority(SegmentType segmentType, OperationType operationType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwODk5NA==", "bodyText": "why not \"refresh\" it in updateAttributes itself?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516208994", "createdAt": "2020-11-02T19:35:50Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/ContainerMetadataUpdateTransaction.java", "diffHunk": "@@ -468,6 +468,7 @@ private void updateMetadata(StreamSegmentMapOperation mapping, UpdateableSegment\n         }\n \n         metadata.updateAttributes(mapping.getAttributes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMDE3Mw==", "bodyText": "PriorityCalculator.getPriority could be static. We could avoid some allocations here.", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516210173", "createdAt": "2020-11-02T19:38:15Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/StorageWriterFactory.java", "diffHunk": "@@ -107,13 +110,15 @@ public int getId() {\n         }\n \n         @Override\n-        public CompletableFuture<Void> notifyAttributesPersisted(long segmentId, long rootPointer, long lastSequenceNumber, Duration timeout) {\n+        public CompletableFuture<Void> notifyAttributesPersisted(long segmentId, SegmentType segmentType, long rootPointer,\n+                                                                 long lastSequenceNumber, Duration timeout) {\n             List<AttributeUpdate> updates = Arrays.asList(\n                     new AttributeUpdate(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, AttributeUpdateType.ReplaceIfGreater, rootPointer),\n                     new AttributeUpdate(Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO, AttributeUpdateType.Replace, lastSequenceNumber));\n             UpdateAttributesOperation op = new UpdateAttributesOperation(segmentId, updates);\n             op.setInternal(true); // This is internally generated, so we want to ensure it's accepted even on a sealed segment.\n-            return this.operationLog.add(op, timeout);\n+            OperationPriority priority = new PriorityCalculator().getPriority(segmentType, op.getType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjg2Mw==", "bodyText": "Will this really cover al valid combinations?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516212863", "createdAt": "2020-11-02T19:43:30Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/MetadataStoreTestBase.java", "diffHunk": "@@ -80,16 +82,22 @@ protected int getThreadPoolSize() {\n     @Test\n     public void testCreateSegment() {\n         final int segmentCount = 50;\n+        val segmentTypes = Arrays.asList(\n+                SegmentType.builder().build(),\n+                SegmentType.builder().system().build(),\n+                SegmentType.builder().sortedTableSegment().build(),\n+                SegmentType.builder().critical().internal().build());\n \n         @Cleanup\n         TestContext context = createTestContext();\n \n         // Create some Segments and verify they are properly created and registered.\n         for (int i = 0; i < segmentCount; i++) {\n             String segmentName = getName(i);\n+            val segmentType = segmentTypes.get(i % segmentTypes.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMzgxMA==", "bodyText": "why can't updateAttributes itself do what refresh is doing?\nI think it will make it less error prone.", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516213810", "createdAt": "2020-11-02T19:45:12Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/StreamSegmentMetadataTests.java", "diffHunk": "@@ -41,6 +43,45 @@\n     @Rule\n     public Timeout globalTimeout = Timeout.seconds(10);\n \n+    /**\n+     * Tests {@link StreamSegmentMetadata#getType()} and {@link StreamSegmentMetadata#refreshType()}.\n+     */\n+    @Test\n+    public void testSegmentType() {\n+        SegmentType expectedType = SegmentType.builder().build();\n+        StreamSegmentMetadata metadata = new StreamSegmentMetadata(SEGMENT_NAME, SEGMENT_ID, CONTAINER_ID);\n+        Assert.assertEquals(\"Unexpected value for non-initialized type.\", expectedType, metadata.getType());\n+\n+        // Segment type exists in Core attributes.\n+        expectedType = SegmentType.builder().critical().internal().build();\n+        metadata.updateAttributes(Collections.singletonMap(Attributes.ATTRIBUTE_SEGMENT_TYPE, expectedType.getValue()));\n+        metadata.refreshType();\n+        Assert.assertEquals(\"Unexpected value for single type.\", expectedType, metadata.getType());\n+\n+        // Segment type exists in Core attributes, but other attributes indicate this is a Table Segment.\n+        expectedType = SegmentType.builder(expectedType).tableSegment().build();\n+        metadata.updateAttributes(Collections.singletonMap(TableAttributes.INDEX_OFFSET, 0L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70799524c8943a0bd347079a91c22919d6da2e43"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41e1e46b425df79b734e70f449f11fac2940d34d", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/41e1e46b425df79b734e70f449f11fac2940d34d", "committedDate": "2020-11-03T15:44:47Z", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d72267b2f0f6872733c96149802ab277597ce7b1", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d72267b2f0f6872733c96149802ab277597ce7b1", "committedDate": "2020-11-03T15:47:42Z", "message": "Merge branch 'master' into issue-5260-qos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzg5MTkz", "url": "https://github.com/pravega/pravega/pull/5268#pullrequestreview-522789193", "createdAt": "2020-11-03T18:55:23Z", "commit": {"oid": "d72267b2f0f6872733c96149802ab277597ce7b1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODo1OTozMVrOHs8byA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTowMzo0MlrOHs8k6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4OTU0NA==", "bodyText": "Can new item with higher priority be inserted between getFirstIndex and getQueue?\nMore importantly does it matter in this case that we skipped over higher priority item in this case? If not then at least add a comment that explains the behavior.", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516889544", "createdAt": "2020-11-03T18:59:31Z", "author": {"login": "sachin-j-joshi"}, "path": "common/src/main/java/io/pravega/common/util/PriorityBlockingDrainingQueue.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import lombok.val;\n+\n+/**\n+ * {@link AbstractDrainingQueue} implementation with multiple priority levels. Supports up to {@link Byte#MAX_VALUE}\n+ * priority levels, with Priority 0 being the highest.\n+ * <p>\n+ * Important notes:\n+ * - {@link #poll(int)} and {@link #take(int)} will return items with the highest available priority and will never mix\n+ * items with different priorities. That means that, even if there are more items (with lower priority), those will not\n+ * be included in the result even if the requested number of items exceeds what we can return. These (lower priority) items\n+ * may be retrieved using a subsequent call (assuming no higher priority items are added in the meantime).\n+ *\n+ * @param <T> Type of item,\n+ */\n+public class PriorityBlockingDrainingQueue<T extends PriorityBlockingDrainingQueue.Item> extends AbstractDrainingQueue<T> {\n+    //region Members.\n+    private final ArrayDeque[] queues;\n+    private int firstIndex;\n+    private int size;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link PriorityBlockingDrainingQueue} class.\n+     *\n+     * @param maxPriorityValue Maximum allowed priority value.\n+     */\n+    public PriorityBlockingDrainingQueue(byte maxPriorityValue) {\n+        Preconditions.checkArgument(maxPriorityValue >= 0, \"maxPriorityLevel must be a value between 0 and %s.\", Byte.MAX_VALUE);\n+        this.queues = new ArrayDeque[maxPriorityValue + 1];\n+        this.firstIndex = 0;\n+        this.size = 0;\n+    }\n+\n+    //endregion\n+\n+    //region AbstractDrainingQueue Implementation\n+\n+    @Override\n+    protected void addInternal(T item) {\n+        byte p = item.getPriorityValue();\n+        Preconditions.checkArgument(p >= 0 && p < this.queues.length,\n+                \"Item.getPriority() must be a value between 0 (inclusive) and %s (exclusive).\", this.queues.length);\n+        getOrCreateQueue(p).add(item);\n+        this.size++;\n+        if (this.firstIndex > p) {\n+            this.firstIndex = p;\n+        }\n+    }\n+\n+    @Override\n+    protected int sizeInternal() {\n+        return this.size;\n+    }\n+\n+    @Override\n+    protected T peekInternal() {\n+        if (this.size == 0) {\n+            return null;\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        return getQueue(fi).peekFirst();\n+    }\n+\n+    @Override\n+    protected Queue<T> fetch(int maxCount) {\n+        if (this.size == 0) {\n+            return new ArrayDeque<>(0);\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d72267b2f0f6872733c96149802ab277597ce7b1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTY1OA==", "bodyText": "If all queues are empty then we'll return -1 .\nThis will result in index out of bound", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516891658", "createdAt": "2020-11-03T19:03:20Z", "author": {"login": "sachin-j-joshi"}, "path": "common/src/main/java/io/pravega/common/util/PriorityBlockingDrainingQueue.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import lombok.val;\n+\n+/**\n+ * {@link AbstractDrainingQueue} implementation with multiple priority levels. Supports up to {@link Byte#MAX_VALUE}\n+ * priority levels, with Priority 0 being the highest.\n+ * <p>\n+ * Important notes:\n+ * - {@link #poll(int)} and {@link #take(int)} will return items with the highest available priority and will never mix\n+ * items with different priorities. That means that, even if there are more items (with lower priority), those will not\n+ * be included in the result even if the requested number of items exceeds what we can return. These (lower priority) items\n+ * may be retrieved using a subsequent call (assuming no higher priority items are added in the meantime).\n+ *\n+ * @param <T> Type of item,\n+ */\n+public class PriorityBlockingDrainingQueue<T extends PriorityBlockingDrainingQueue.Item> extends AbstractDrainingQueue<T> {\n+    //region Members.\n+    private final ArrayDeque[] queues;\n+    private int firstIndex;\n+    private int size;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link PriorityBlockingDrainingQueue} class.\n+     *\n+     * @param maxPriorityValue Maximum allowed priority value.\n+     */\n+    public PriorityBlockingDrainingQueue(byte maxPriorityValue) {\n+        Preconditions.checkArgument(maxPriorityValue >= 0, \"maxPriorityLevel must be a value between 0 and %s.\", Byte.MAX_VALUE);\n+        this.queues = new ArrayDeque[maxPriorityValue + 1];\n+        this.firstIndex = 0;\n+        this.size = 0;\n+    }\n+\n+    //endregion\n+\n+    //region AbstractDrainingQueue Implementation\n+\n+    @Override\n+    protected void addInternal(T item) {\n+        byte p = item.getPriorityValue();\n+        Preconditions.checkArgument(p >= 0 && p < this.queues.length,\n+                \"Item.getPriority() must be a value between 0 (inclusive) and %s (exclusive).\", this.queues.length);\n+        getOrCreateQueue(p).add(item);\n+        this.size++;\n+        if (this.firstIndex > p) {\n+            this.firstIndex = p;\n+        }\n+    }\n+\n+    @Override\n+    protected int sizeInternal() {\n+        return this.size;\n+    }\n+\n+    @Override\n+    protected T peekInternal() {\n+        if (this.size == 0) {\n+            return null;\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        return getQueue(fi).peekFirst();\n+    }\n+\n+    @Override\n+    protected Queue<T> fetch(int maxCount) {\n+        if (this.size == 0) {\n+            return new ArrayDeque<>(0);\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d72267b2f0f6872733c96149802ab277597ce7b1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTg4MQ==", "bodyText": "what happens when all queues are empty?", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516891881", "createdAt": "2020-11-03T19:03:42Z", "author": {"login": "sachin-j-joshi"}, "path": "common/src/main/java/io/pravega/common/util/PriorityBlockingDrainingQueue.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import lombok.val;\n+\n+/**\n+ * {@link AbstractDrainingQueue} implementation with multiple priority levels. Supports up to {@link Byte#MAX_VALUE}\n+ * priority levels, with Priority 0 being the highest.\n+ * <p>\n+ * Important notes:\n+ * - {@link #poll(int)} and {@link #take(int)} will return items with the highest available priority and will never mix\n+ * items with different priorities. That means that, even if there are more items (with lower priority), those will not\n+ * be included in the result even if the requested number of items exceeds what we can return. These (lower priority) items\n+ * may be retrieved using a subsequent call (assuming no higher priority items are added in the meantime).\n+ *\n+ * @param <T> Type of item,\n+ */\n+public class PriorityBlockingDrainingQueue<T extends PriorityBlockingDrainingQueue.Item> extends AbstractDrainingQueue<T> {\n+    //region Members.\n+    private final ArrayDeque[] queues;\n+    private int firstIndex;\n+    private int size;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link PriorityBlockingDrainingQueue} class.\n+     *\n+     * @param maxPriorityValue Maximum allowed priority value.\n+     */\n+    public PriorityBlockingDrainingQueue(byte maxPriorityValue) {\n+        Preconditions.checkArgument(maxPriorityValue >= 0, \"maxPriorityLevel must be a value between 0 and %s.\", Byte.MAX_VALUE);\n+        this.queues = new ArrayDeque[maxPriorityValue + 1];\n+        this.firstIndex = 0;\n+        this.size = 0;\n+    }\n+\n+    //endregion\n+\n+    //region AbstractDrainingQueue Implementation\n+\n+    @Override\n+    protected void addInternal(T item) {\n+        byte p = item.getPriorityValue();\n+        Preconditions.checkArgument(p >= 0 && p < this.queues.length,\n+                \"Item.getPriority() must be a value between 0 (inclusive) and %s (exclusive).\", this.queues.length);\n+        getOrCreateQueue(p).add(item);\n+        this.size++;\n+        if (this.firstIndex > p) {\n+            this.firstIndex = p;\n+        }\n+    }\n+\n+    @Override\n+    protected int sizeInternal() {\n+        return this.size;\n+    }\n+\n+    @Override\n+    protected T peekInternal() {\n+        if (this.size == 0) {\n+            return null;\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        return getQueue(fi).peekFirst();\n+    }\n+\n+    @Override\n+    protected Queue<T> fetch(int maxCount) {\n+        if (this.size == 0) {\n+            return new ArrayDeque<>(0);\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        val q = getQueue(fi);\n+\n+        int count = Math.min(maxCount, q.size());\n+        ArrayDeque<T> result = new ArrayDeque<>(count);\n+        while (result.size() < count) {\n+            result.addLast(q.pollFirst());\n+        }\n+\n+        this.size -= result.size();\n+        return result;\n+\n+    }\n+\n+    //endregion\n+\n+    //region Helper methods.\n+\n+    private int getFirstIndex() {\n+        for (; this.firstIndex < this.queues.length; this.firstIndex++) {\n+            val q = getQueue(this.firstIndex);\n+            if (q != null && !q.isEmpty()) {\n+                return this.firstIndex;\n+            }\n+        }\n+\n+        assert this.size > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d72267b2f0f6872733c96149802ab277597ce7b1"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzODY0OTky", "url": "https://github.com/pravega/pravega/pull/5268#pullrequestreview-523864992", "createdAt": "2020-11-05T02:03:19Z", "commit": {"oid": "d72267b2f0f6872733c96149802ab277597ce7b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3910, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}