{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5Mzk0NTc5", "number": 5317, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozNDoxNFrOE33TaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDozMzo1NFrOE4GVSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDEzMjI1OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozNDoxNFrOHxdTSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxMjozMFrOHxztBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjM0Ng==", "bodyText": "How can you have GuardedBy and a public getter at the same time? You cannot guarantee thread safety like this. You need to provide APIs that access this while holding locks.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521622346", "createdAt": "2020-11-11T20:34:14Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -26,18 +35,31 @@\n import org.apache.bookkeeper.net.CommonConfigurationKeys;\n import org.apache.curator.framework.CuratorFramework;\n \n+import javax.annotation.concurrent.GuardedBy;\n+\n /**\n  * Factory for BookKeeperLogs.\n  */\n @Slf4j\n public class BookKeeperLogFactory implements DurableDataLogFactory {\n     //region Members\n \n+    // Period of inspection to meet the maximum number of log creation attempts for a given container.\n+    private static final Duration LOG_CREATION_INSPECTION_PERIOD = Duration.ofSeconds(60);\n+    // Maximum number of log creation attempts for a given container before considering resetting the BK client.\n+    private static final int MAX_CREATE_ATTEMPTS_PER_LOG = 2;\n+\n     private final String namespace;\n     private final CuratorFramework zkClient;\n     private final AtomicReference<BookKeeper> bookKeeper;\n     private final BookKeeperConfig config;\n     private final ScheduledExecutorService executor;\n+    @GuardedBy(\"this\")\n+    @Getter(AccessLevel.PACKAGE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk4OTM4Mw==", "bodyText": "Ok, moved the Getter to a explicit method tagged with @VisibleForTesting. We need access to that only for testing purposes.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521989383", "createdAt": "2020-11-12T10:12:30Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -26,18 +35,31 @@\n import org.apache.bookkeeper.net.CommonConfigurationKeys;\n import org.apache.curator.framework.CuratorFramework;\n \n+import javax.annotation.concurrent.GuardedBy;\n+\n /**\n  * Factory for BookKeeperLogs.\n  */\n @Slf4j\n public class BookKeeperLogFactory implements DurableDataLogFactory {\n     //region Members\n \n+    // Period of inspection to meet the maximum number of log creation attempts for a given container.\n+    private static final Duration LOG_CREATION_INSPECTION_PERIOD = Duration.ofSeconds(60);\n+    // Maximum number of log creation attempts for a given container before considering resetting the BK client.\n+    private static final int MAX_CREATE_ATTEMPTS_PER_LOG = 2;\n+\n     private final String namespace;\n     private final CuratorFramework zkClient;\n     private final AtomicReference<BookKeeper> bookKeeper;\n     private final BookKeeperConfig config;\n     private final ScheduledExecutorService executor;\n+    @GuardedBy(\"this\")\n+    @Getter(AccessLevel.PACKAGE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjM0Ng=="}, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDEzMzY3OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozNDozOFrOHxdUIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxMzoxNVrOHxzu7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjU2MQ==", "bodyText": "Same here. Never expose Atomic* directly; use APIs.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521622561", "createdAt": "2020-11-11T20:34:38Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -26,18 +35,31 @@\n import org.apache.bookkeeper.net.CommonConfigurationKeys;\n import org.apache.curator.framework.CuratorFramework;\n \n+import javax.annotation.concurrent.GuardedBy;\n+\n /**\n  * Factory for BookKeeperLogs.\n  */\n @Slf4j\n public class BookKeeperLogFactory implements DurableDataLogFactory {\n     //region Members\n \n+    // Period of inspection to meet the maximum number of log creation attempts for a given container.\n+    private static final Duration LOG_CREATION_INSPECTION_PERIOD = Duration.ofSeconds(60);\n+    // Maximum number of log creation attempts for a given container before considering resetting the BK client.\n+    private static final int MAX_CREATE_ATTEMPTS_PER_LOG = 2;\n+\n     private final String namespace;\n     private final CuratorFramework zkClient;\n     private final AtomicReference<BookKeeper> bookKeeper;\n     private final BookKeeperConfig config;\n     private final ScheduledExecutorService executor;\n+    @GuardedBy(\"this\")\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Integer, LogInitializationRecord> logInitializationTracker = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    @Getter(AccessLevel.PACKAGE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk4OTg2OA==", "bodyText": "Fixed as mentioned above.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521989868", "createdAt": "2020-11-12T10:13:15Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -26,18 +35,31 @@\n import org.apache.bookkeeper.net.CommonConfigurationKeys;\n import org.apache.curator.framework.CuratorFramework;\n \n+import javax.annotation.concurrent.GuardedBy;\n+\n /**\n  * Factory for BookKeeperLogs.\n  */\n @Slf4j\n public class BookKeeperLogFactory implements DurableDataLogFactory {\n     //region Members\n \n+    // Period of inspection to meet the maximum number of log creation attempts for a given container.\n+    private static final Duration LOG_CREATION_INSPECTION_PERIOD = Duration.ofSeconds(60);\n+    // Maximum number of log creation attempts for a given container before considering resetting the BK client.\n+    private static final int MAX_CREATE_ATTEMPTS_PER_LOG = 2;\n+\n     private final String namespace;\n     private final CuratorFramework zkClient;\n     private final AtomicReference<BookKeeper> bookKeeper;\n     private final BookKeeperConfig config;\n     private final ScheduledExecutorService executor;\n+    @GuardedBy(\"this\")\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Integer, LogInitializationRecord> logInitializationTracker = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    @Getter(AccessLevel.PACKAGE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjU2MQ=="}, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDEzODU4OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozNjoxNFrOHxdXEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxNDoxM1rOHxzxRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMzMxNQ==", "bodyText": "Take logInitializationTracker.get(logId) and stash it in a local variable. Then compare it against null in the if above and reuse that variable. This should reduce the number of get calls into that HashMap.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521623315", "createdAt": "2020-11-11T20:36:14Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -169,5 +193,74 @@ private BookKeeper startBookKeeperClient() throws Exception {\n                          .build();\n     }\n \n+    /**\n+     * Recreate the Bookkeeper client if a given log exhibits MAX_CREATE_ATTEMPTS_PER_LOG creation attempts (as a proxy\n+     * for Container recoveries) within the period of time defined in LOG_CREATION_INSPECTION_PERIOD.\n+     *\n+     * @param logId Id of the log being restarted.\n+     */\n+    private void tryResetBookkeeperClient(int logId) {\n+        synchronized (this) {\n+            if (logInitializationTracker.containsKey(logId)) {\n+                // Account for a restart of the Bookkeeper log.\n+                logInitializationTracker.get(logId).incrementLogCreations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MDQ2OQ==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521990469", "createdAt": "2020-11-12T10:14:13Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -169,5 +193,74 @@ private BookKeeper startBookKeeperClient() throws Exception {\n                          .build();\n     }\n \n+    /**\n+     * Recreate the Bookkeeper client if a given log exhibits MAX_CREATE_ATTEMPTS_PER_LOG creation attempts (as a proxy\n+     * for Container recoveries) within the period of time defined in LOG_CREATION_INSPECTION_PERIOD.\n+     *\n+     * @param logId Id of the log being restarted.\n+     */\n+    private void tryResetBookkeeperClient(int logId) {\n+        synchronized (this) {\n+            if (logInitializationTracker.containsKey(logId)) {\n+                // Account for a restart of the Bookkeeper log.\n+                logInitializationTracker.get(logId).incrementLogCreations();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMzMxNQ=="}, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDE0NDE4OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozODowMVrOHxdaXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxNDozMVrOHxzyLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNDE1Nw==", "bodyText": "This will result in double logging. Whomever is invoking this method will absolutely log it as well.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521624157", "createdAt": "2020-11-11T20:38:01Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -169,5 +193,74 @@ private BookKeeper startBookKeeperClient() throws Exception {\n                          .build();\n     }\n \n+    /**\n+     * Recreate the Bookkeeper client if a given log exhibits MAX_CREATE_ATTEMPTS_PER_LOG creation attempts (as a proxy\n+     * for Container recoveries) within the period of time defined in LOG_CREATION_INSPECTION_PERIOD.\n+     *\n+     * @param logId Id of the log being restarted.\n+     */\n+    private void tryResetBookkeeperClient(int logId) {\n+        synchronized (this) {\n+            if (logInitializationTracker.containsKey(logId)) {\n+                // Account for a restart of the Bookkeeper log.\n+                logInitializationTracker.get(logId).incrementLogCreations();\n+                // If the number of restarts for a single container is meets the threshold, let's reset the BK client.\n+                if (logInitializationTracker.get(logId).isBookkeeperClientResetNeeded()\n+                        && lastBookkeeperClientReset.get().getElapsed().compareTo(LOG_CREATION_INSPECTION_PERIOD) > 0) {\n+                    try {\n+                        log.info(\"Start creating Bookkeeper client in reset.\");\n+                        BookKeeper newClient = startBookKeeperClient();\n+                        // If we have been able to create a new client successfully, reset the current one and update timer.\n+                        log.info(\"Successfully created new Bookkeeper client, setting it as the new one to use.\");\n+                        BookKeeper oldClient = this.bookKeeper.getAndSet(newClient);\n+                        lastBookkeeperClientReset.set(new Timer());\n+                        // Lastly, attempt to close the old client.\n+                        log.info(\"Attempting to close old client.\");\n+                        oldClient.close();\n+                    } catch (Exception e) {\n+                        log.error(\"Failure resetting the Bookkeeper client: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MDcwMw==", "bodyText": "Removed first log line.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521990703", "createdAt": "2020-11-12T10:14:31Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -169,5 +193,74 @@ private BookKeeper startBookKeeperClient() throws Exception {\n                          .build();\n     }\n \n+    /**\n+     * Recreate the Bookkeeper client if a given log exhibits MAX_CREATE_ATTEMPTS_PER_LOG creation attempts (as a proxy\n+     * for Container recoveries) within the period of time defined in LOG_CREATION_INSPECTION_PERIOD.\n+     *\n+     * @param logId Id of the log being restarted.\n+     */\n+    private void tryResetBookkeeperClient(int logId) {\n+        synchronized (this) {\n+            if (logInitializationTracker.containsKey(logId)) {\n+                // Account for a restart of the Bookkeeper log.\n+                logInitializationTracker.get(logId).incrementLogCreations();\n+                // If the number of restarts for a single container is meets the threshold, let's reset the BK client.\n+                if (logInitializationTracker.get(logId).isBookkeeperClientResetNeeded()\n+                        && lastBookkeeperClientReset.get().getElapsed().compareTo(LOG_CREATION_INSPECTION_PERIOD) > 0) {\n+                    try {\n+                        log.info(\"Start creating Bookkeeper client in reset.\");\n+                        BookKeeper newClient = startBookKeeperClient();\n+                        // If we have been able to create a new client successfully, reset the current one and update timer.\n+                        log.info(\"Successfully created new Bookkeeper client, setting it as the new one to use.\");\n+                        BookKeeper oldClient = this.bookKeeper.getAndSet(newClient);\n+                        lastBookkeeperClientReset.set(new Timer());\n+                        // Lastly, attempt to close the old client.\n+                        log.info(\"Attempting to close old client.\");\n+                        oldClient.close();\n+                    } catch (Exception e) {\n+                        log.error(\"Failure resetting the Bookkeeper client: \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNDE1Nw=="}, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDE1NTIzOnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDo0MDo1M1rOHxdgvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxNDo0OVrOHxzy1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNTc5MQ==", "bodyText": "Why do you subclass from this?\nCan't you do it like we test BookKeeperLog? We should have everything we need there.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521625791", "createdAt": "2020-11-11T20:40:53Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.impl.bookkeeper;\n+\n+import io.pravega.common.Timer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import org.apache.bookkeeper.client.api.BookKeeper;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.curator.RetryPolicy;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Test to exercise the re-creation of the Bookkeeper client upon successive log creation attempts.\n+ */\n+public class BookkeeperLogFactoryTests extends BookKeeperClusterTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MDg3MA==", "bodyText": "Moved the test to BookkeeperLogTests.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521990870", "createdAt": "2020-11-12T10:14:49Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.impl.bookkeeper;\n+\n+import io.pravega.common.Timer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import org.apache.bookkeeper.client.api.BookKeeper;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.curator.RetryPolicy;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Test to exercise the re-creation of the Bookkeeper client upon successive log creation attempts.\n+ */\n+public class BookkeeperLogFactoryTests extends BookKeeperClusterTestCase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNTc5MQ=="}, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDE1Nzg5OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDo0MTo0NVrOHxdifg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxNTo0MFrOHxz0-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjIzOA==", "bodyText": "If you do not need to subclass from BookKeeperClusterTestCase, then you can subclass from ThreadPooledTestSuite which will take care of your executor for you.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521626238", "createdAt": "2020-11-11T20:41:45Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.impl.bookkeeper;\n+\n+import io.pravega.common.Timer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import org.apache.bookkeeper.client.api.BookKeeper;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.curator.RetryPolicy;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Test to exercise the re-creation of the Bookkeeper client upon successive log creation attempts.\n+ */\n+public class BookkeeperLogFactoryTests extends BookKeeperClusterTestCase {\n+\n+    private ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(2, \"test\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MTQxOQ==", "bodyText": "Fixed by moving the test to BookkeeperLogTests.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521991419", "createdAt": "2020-11-12T10:15:40Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.impl.bookkeeper;\n+\n+import io.pravega.common.Timer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import org.apache.bookkeeper.client.api.BookKeeper;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.curator.RetryPolicy;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Test to exercise the re-creation of the Bookkeeper client upon successive log creation attempts.\n+ */\n+public class BookkeeperLogFactoryTests extends BookKeeperClusterTestCase {\n+\n+    private ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(2, \"test\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjIzOA=="}, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDE2MDc3OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDo0Mjo0NFrOHxdkUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxNzowNVrOHxz4ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjcwNg==", "bodyText": "Use ManualTimer. You can set the time as you wish.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521626706", "createdAt": "2020-11-11T20:42:44Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.impl.bookkeeper;\n+\n+import io.pravega.common.Timer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import org.apache.bookkeeper.client.api.BookKeeper;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.curator.RetryPolicy;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Test to exercise the re-creation of the Bookkeeper client upon successive log creation attempts.\n+ */\n+public class BookkeeperLogFactoryTests extends BookKeeperClusterTestCase {\n+\n+    private ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(2, \"test\");\n+\n+    public BookkeeperLogFactoryTests() {\n+        super(1);\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseConf.setLedgerManagerFactoryClassName(\"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\");\n+        this.baseClientConf.setLedgerManagerFactoryClassName(\"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\");\n+        Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+        boolean successfulSetup = false;\n+        while (interfaces.hasMoreElements()) {\n+            try {\n+                super.setUp();\n+                successfulSetup = true;\n+                break;\n+            } catch (Exception e) {\n+                // On some environments, using default interface does not allow to resolve the host name. We keep\n+                // iterating over existing interfaces to start the Bookkeeper cluster.\n+                super.tearDown();\n+                this.baseConf.setListeningInterface(interfaces.nextElement().getName());\n+            }\n+        }\n+        assert successfulSetup;\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        ExecutorServiceHelpers.shutdown(executorService);\n+    }\n+\n+    @Test\n+    public void testBookkeeperClientReCreation() throws Exception {\n+        BookKeeperConfig bookKeeperConfig = BookKeeperConfig.builder()\n+                .with(BookKeeperConfig.BK_ACK_QUORUM_SIZE, 1)\n+                .with(BookKeeperConfig.BK_LEDGER_PATH, \"/ledgers\")\n+                .with(BookKeeperConfig.ZK_METADATA_PATH, \"ledgers\")\n+                .with(BookKeeperConfig.BK_ENSEMBLE_SIZE, 1)\n+                .with(BookKeeperConfig.BK_WRITE_QUORUM_SIZE, 1)\n+                .with(BookKeeperConfig.ZK_ADDRESS, zkUtil.getZooKeeperConnectString())\n+                .build();\n+        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3, 10000);\n+        CuratorFramework zkClient = CuratorFrameworkFactory.builder()\n+                .connectString(zkUtil.getZooKeeperConnectString())\n+                .retryPolicy(retryPolicy)\n+                .sessionTimeoutMs(30000)\n+                .build();\n+        zkClient.start();\n+        BookKeeperLogFactory factory = new BookKeeperLogFactory(bookKeeperConfig, zkClient, this.executorService);\n+        // Initialize the log, and therefore the Bookkeeper client.\n+        factory.initialize();\n+        // Set a timer with a longer period than the inspection period to allow client re-creation.\n+        factory.getLastBookkeeperClientReset().set(new OldTimer());\n+        BookKeeper oldBookkeeperClient = factory.getBookKeeperClient();\n+        // Create a log the first time.\n+        Assert.assertNull(factory.getLogInitializationTracker().get(0));\n+        factory.createDebugLogWrapper(0);\n+        // The first time we create the log the Bookkeeper client should be the same and the record for this log should\n+        // be initialized.\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        Assert.assertNotNull(factory.getLogInitializationTracker().get(0));\n+        // From this point onwards, the second attempt to create the same log within the inspection period should lead\n+        // to a Bookkeeper client recreation.\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertNotEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        // Get a reference to the new Bookkeeper client.\n+        oldBookkeeperClient = factory.getBookKeeperClient();\n+        // The timer for this log should have been updated, so even if there are more initialization attempts, they should\n+        // not lead to a new Bookkeeper client re-creation until the inspection period expires.\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+    }\n+\n+    static class OldTimer extends Timer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MjMzMA==", "bodyText": "I tried, but this forces me to add another dependency to segmentstore:storage:impl, so I think that just adding this mock, tiny class has less impact to the project.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r521992330", "createdAt": "2020-11-12T10:17:05Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookkeeperLogFactoryTests.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.impl.bookkeeper;\n+\n+import io.pravega.common.Timer;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import org.apache.bookkeeper.client.api.BookKeeper;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.curator.RetryPolicy;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.net.NetworkInterface;\n+import java.util.Enumeration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Test to exercise the re-creation of the Bookkeeper client upon successive log creation attempts.\n+ */\n+public class BookkeeperLogFactoryTests extends BookKeeperClusterTestCase {\n+\n+    private ScheduledExecutorService executorService = ExecutorServiceHelpers.newScheduledThreadPool(2, \"test\");\n+\n+    public BookkeeperLogFactoryTests() {\n+        super(1);\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.baseConf.setLedgerManagerFactoryClassName(\"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\");\n+        this.baseClientConf.setLedgerManagerFactoryClassName(\"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\");\n+        Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+        boolean successfulSetup = false;\n+        while (interfaces.hasMoreElements()) {\n+            try {\n+                super.setUp();\n+                successfulSetup = true;\n+                break;\n+            } catch (Exception e) {\n+                // On some environments, using default interface does not allow to resolve the host name. We keep\n+                // iterating over existing interfaces to start the Bookkeeper cluster.\n+                super.tearDown();\n+                this.baseConf.setListeningInterface(interfaces.nextElement().getName());\n+            }\n+        }\n+        assert successfulSetup;\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        ExecutorServiceHelpers.shutdown(executorService);\n+    }\n+\n+    @Test\n+    public void testBookkeeperClientReCreation() throws Exception {\n+        BookKeeperConfig bookKeeperConfig = BookKeeperConfig.builder()\n+                .with(BookKeeperConfig.BK_ACK_QUORUM_SIZE, 1)\n+                .with(BookKeeperConfig.BK_LEDGER_PATH, \"/ledgers\")\n+                .with(BookKeeperConfig.ZK_METADATA_PATH, \"ledgers\")\n+                .with(BookKeeperConfig.BK_ENSEMBLE_SIZE, 1)\n+                .with(BookKeeperConfig.BK_WRITE_QUORUM_SIZE, 1)\n+                .with(BookKeeperConfig.ZK_ADDRESS, zkUtil.getZooKeeperConnectString())\n+                .build();\n+        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3, 10000);\n+        CuratorFramework zkClient = CuratorFrameworkFactory.builder()\n+                .connectString(zkUtil.getZooKeeperConnectString())\n+                .retryPolicy(retryPolicy)\n+                .sessionTimeoutMs(30000)\n+                .build();\n+        zkClient.start();\n+        BookKeeperLogFactory factory = new BookKeeperLogFactory(bookKeeperConfig, zkClient, this.executorService);\n+        // Initialize the log, and therefore the Bookkeeper client.\n+        factory.initialize();\n+        // Set a timer with a longer period than the inspection period to allow client re-creation.\n+        factory.getLastBookkeeperClientReset().set(new OldTimer());\n+        BookKeeper oldBookkeeperClient = factory.getBookKeeperClient();\n+        // Create a log the first time.\n+        Assert.assertNull(factory.getLogInitializationTracker().get(0));\n+        factory.createDebugLogWrapper(0);\n+        // The first time we create the log the Bookkeeper client should be the same and the record for this log should\n+        // be initialized.\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        Assert.assertNotNull(factory.getLogInitializationTracker().get(0));\n+        // From this point onwards, the second attempt to create the same log within the inspection period should lead\n+        // to a Bookkeeper client recreation.\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertNotEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        // Get a reference to the new Bookkeeper client.\n+        oldBookkeeperClient = factory.getBookKeeperClient();\n+        // The timer for this log should have been updated, so even if there are more initialization attempts, they should\n+        // not lead to a new Bookkeeper client re-creation until the inspection period expires.\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+        factory.createDebugLogWrapper(0);\n+        Assert.assertEquals(oldBookkeeperClient, factory.getBookKeeperClient());\n+    }\n+\n+    static class OldTimer extends Timer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjcwNg=="}, "originalCommit": {"oid": "c00bf55224e0929e12881a18321ac082f9303b6e"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MjU5NDY0OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDozMzo1NFrOHx0i0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDo1OTowM1rOHx1fCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAwMzE1Mw==", "bodyText": "this \"close()\" will fail all of the pending operations\nIIUC with this change we are going to close the BK client even if it is not needed", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r522003153", "createdAt": "2020-11-12T10:33:54Z", "author": {"login": "eolivelli"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -169,5 +189,84 @@ private BookKeeper startBookKeeperClient() throws Exception {\n                          .build();\n     }\n \n+    /**\n+     * Recreate the Bookkeeper client if a given log exhibits MAX_CREATE_ATTEMPTS_PER_LOG creation attempts (as a proxy\n+     * for Container recoveries) within the period of time defined in LOG_CREATION_INSPECTION_PERIOD.\n+     *\n+     * @param logId Id of the log being restarted.\n+     */\n+    private void tryResetBookkeeperClient(int logId) {\n+        synchronized (this) {\n+            LogInitializationRecord record = logInitializationTracker.get(logId);\n+            if (record != null) {\n+                // Account for a restart of the Bookkeeper log.\n+                record.incrementLogCreations();\n+                // If the number of restarts for a single container is meets the threshold, let's reset the BK client.\n+                if (record.isBookkeeperClientResetNeeded()\n+                        && lastBookkeeperClientReset.get().getElapsed().compareTo(LOG_CREATION_INSPECTION_PERIOD) > 0) {\n+                    try {\n+                        log.info(\"Start creating Bookkeeper client in reset.\");\n+                        BookKeeper newClient = startBookKeeperClient();\n+                        // If we have been able to create a new client successfully, reset the current one and update timer.\n+                        log.info(\"Successfully created new Bookkeeper client, setting it as the new one to use.\");\n+                        BookKeeper oldClient = this.bookKeeper.getAndSet(newClient);\n+                        lastBookkeeperClientReset.set(new Timer());\n+                        // Lastly, attempt to close the old client.\n+                        log.info(\"Attempting to close old client.\");\n+                        oldClient.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b751e267b0b7257063e45dca5379b0ce0742abc"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAwNzY4Ng==", "bodyText": "@eolivelli correct, this defensive mechanism is going to reset the Bookkeeper client (shared across all containers) if we detect X number of restarts for a given container within a period of time T. I understand that this is not the ideal way to handle this problem, but this may be a temporarily solution to the problem reported in the issue until this is fixed: apache/bookkeeper#2482. In parallel, we are working on another solution related to better set the TCP_USER_TIMEOUT as suggested by @fpj. If that works, maybe we do not need to merge this PR.", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r522007686", "createdAt": "2020-11-12T10:41:13Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -169,5 +189,84 @@ private BookKeeper startBookKeeperClient() throws Exception {\n                          .build();\n     }\n \n+    /**\n+     * Recreate the Bookkeeper client if a given log exhibits MAX_CREATE_ATTEMPTS_PER_LOG creation attempts (as a proxy\n+     * for Container recoveries) within the period of time defined in LOG_CREATION_INSPECTION_PERIOD.\n+     *\n+     * @param logId Id of the log being restarted.\n+     */\n+    private void tryResetBookkeeperClient(int logId) {\n+        synchronized (this) {\n+            LogInitializationRecord record = logInitializationTracker.get(logId);\n+            if (record != null) {\n+                // Account for a restart of the Bookkeeper log.\n+                record.incrementLogCreations();\n+                // If the number of restarts for a single container is meets the threshold, let's reset the BK client.\n+                if (record.isBookkeeperClientResetNeeded()\n+                        && lastBookkeeperClientReset.get().getElapsed().compareTo(LOG_CREATION_INSPECTION_PERIOD) > 0) {\n+                    try {\n+                        log.info(\"Start creating Bookkeeper client in reset.\");\n+                        BookKeeper newClient = startBookKeeperClient();\n+                        // If we have been able to create a new client successfully, reset the current one and update timer.\n+                        log.info(\"Successfully created new Bookkeeper client, setting it as the new one to use.\");\n+                        BookKeeper oldClient = this.bookKeeper.getAndSet(newClient);\n+                        lastBookkeeperClientReset.set(new Timer());\n+                        // Lastly, attempt to close the old client.\n+                        log.info(\"Attempting to close old client.\");\n+                        oldClient.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAwMzE1Mw=="}, "originalCommit": {"oid": "2b751e267b0b7257063e45dca5379b0ce0742abc"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxODU2OA==", "bodyText": "I see, thanks for your clarification", "url": "https://github.com/pravega/pravega/pull/5317#discussion_r522018568", "createdAt": "2020-11-12T10:59:03Z", "author": {"login": "eolivelli"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogFactory.java", "diffHunk": "@@ -169,5 +189,84 @@ private BookKeeper startBookKeeperClient() throws Exception {\n                          .build();\n     }\n \n+    /**\n+     * Recreate the Bookkeeper client if a given log exhibits MAX_CREATE_ATTEMPTS_PER_LOG creation attempts (as a proxy\n+     * for Container recoveries) within the period of time defined in LOG_CREATION_INSPECTION_PERIOD.\n+     *\n+     * @param logId Id of the log being restarted.\n+     */\n+    private void tryResetBookkeeperClient(int logId) {\n+        synchronized (this) {\n+            LogInitializationRecord record = logInitializationTracker.get(logId);\n+            if (record != null) {\n+                // Account for a restart of the Bookkeeper log.\n+                record.incrementLogCreations();\n+                // If the number of restarts for a single container is meets the threshold, let's reset the BK client.\n+                if (record.isBookkeeperClientResetNeeded()\n+                        && lastBookkeeperClientReset.get().getElapsed().compareTo(LOG_CREATION_INSPECTION_PERIOD) > 0) {\n+                    try {\n+                        log.info(\"Start creating Bookkeeper client in reset.\");\n+                        BookKeeper newClient = startBookKeeperClient();\n+                        // If we have been able to create a new client successfully, reset the current one and update timer.\n+                        log.info(\"Successfully created new Bookkeeper client, setting it as the new one to use.\");\n+                        BookKeeper oldClient = this.bookKeeper.getAndSet(newClient);\n+                        lastBookkeeperClientReset.set(new Timer());\n+                        // Lastly, attempt to close the old client.\n+                        log.info(\"Attempting to close old client.\");\n+                        oldClient.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAwMzE1Mw=="}, "originalCommit": {"oid": "2b751e267b0b7257063e45dca5379b0ce0742abc"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4524, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}