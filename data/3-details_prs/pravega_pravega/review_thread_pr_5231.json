{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3NjYwNzM2", "number": 5231, "reviewThreads": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1MToyOVrOEtjRQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDo0MjoyMVrOE33eKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MTk5MjMyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1MToyOVrOHhZ1fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODoyMToxMVrOHkC9Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4ODM1MA==", "bodyText": "what is this change for?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504788350", "createdAt": "2020-10-14T15:51:29Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -416,7 +486,7 @@ public void getURI(SegmentId request, StreamObserver<NodeUri> responseObserver)\n         log.info(\"getURI called for segment {}/{}/{}.\", request.getStreamInfo().getScope(),\n                 request.getStreamInfo().getStream(), request.getSegmentId());\n         authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorization(\n-                authorizationResource.ofStreamInScope(request.getStreamInfo().getScope(), request.getStreamInfo().getStream()),\n+                StreamAuthParams.toResourceString(request.getStreamInfo().getScope(), request.getStreamInfo().getStream()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU1OTIyNw==", "bodyText": "This change is for making sure that the resource string is adapted based on whether the stream is internal/external and the type of resource it represents. All that logic is encapsulated within StreamAuthParams.toResourceString() so that that auth-specific logic doesn't leak into the business logic contained in this code in the Controller Service implementation.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507559227", "createdAt": "2020-10-19T08:21:11Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -416,7 +486,7 @@ public void getURI(SegmentId request, StreamObserver<NodeUri> responseObserver)\n         log.info(\"getURI called for segment {}/{}/{}.\", request.getStreamInfo().getScope(),\n                 request.getStreamInfo().getStream(), request.getSegmentId());\n         authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorization(\n-                authorizationResource.ofStreamInScope(request.getStreamInfo().getScope(), request.getStreamInfo().getStream()),\n+                StreamAuthParams.toResourceString(request.getStreamInfo().getScope(), request.getStreamInfo().getStream()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4ODM1MA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MTk5NzUxOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1MjozOVrOHhZ4sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODozNTowMVrOHkDgsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4OTE3MQ==", "bodyText": "why do we need a differentiation here? for example a readergroup's state synchronizer is an internal stream.. but depending on the api being invoked the user may or may not have the authorization permission.. so would rg stream be treated as \"stream\" and \"internal stream\" interchangably depending on the context?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504789171", "createdAt": "2020-10-14T15:52:39Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResource.java", "diffHunk": "@@ -101,4 +113,13 @@\n      * @throws IllegalArgumentException if {@code scopeName} or {@code kvtName} are empty\n      */\n     String ofKeyValueTableInScope(String scopeName, String kvtName);\n+\n+    /**\n+     * Creates a resource representation for use in authorization of actions related to the specified internal stream.\n+     *\n+     * @param scopeName the name of the scope\n+     * @param streamName the name of the internal stream\n+     * @return a string representing the resource\n+     */\n+    String ofInternalStream(String scopeName, String streamName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2ODMwNw==", "bodyText": "Firstly, about the differentiation between the internal vs. external streams. The intent is:\n\nTo treat resource groups and watermarks as resources in their own right and distinguish them from regular streams. This is so that users can  be assigned ACLs that authorize them to perform Controller operations on them.\nFor all internal streams, enable write operations with read permissions, provided the config allows for it.\nThis PDP explains the overall context in more detail.\n\nSecondly, for the question below\n\n... would rg stream be treated as \"stream\" and \"internal stream\" interchangeably depending on the context?\n\nNo, the intent is to always authorize a resource the same way across all operations. If the code doesn't do that, it'd be a flaw.\nDoes that answer your question @shiveshr?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507568307", "createdAt": "2020-10-19T08:35:01Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResource.java", "diffHunk": "@@ -101,4 +113,13 @@\n      * @throws IllegalArgumentException if {@code scopeName} or {@code kvtName} are empty\n      */\n     String ofKeyValueTableInScope(String scopeName, String kvtName);\n+\n+    /**\n+     * Creates a resource representation for use in authorization of actions related to the specified internal stream.\n+     *\n+     * @param scopeName the name of the scope\n+     * @param streamName the name of the internal stream\n+     * @return a string representing the resource\n+     */\n+    String ofInternalStream(String scopeName, String streamName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4OTE3MQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjAxNDQwOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1NjowOFrOHhaDAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxODo0MzoyMlrOHnZrcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MTgwOA==", "bodyText": "if this is set to false can user never make any write operations with read permissions on reader group streams?\nshould we keep this as a service level setting or a per stream setting?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504791808", "createdAt": "2020-10-14T15:56:08Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -101,14 +103,19 @@\n     // Send to the client server traces on error message replies.\n     private final boolean replyWithStackTraceOnError;\n \n+    private final boolean isInternalWritesWithReadPermEnabled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU3MzkxMA==", "bodyText": "True, the current configuration is broadly applied - all internal streams can be written to with \"read\" permissions if this config is true, otherwise, they'll require \"write\" permissions.\nMaking it tunable at a stream-level can provide more flexibility. However, it could also hurt usability - presumably, users shall have to make another explicit choice and it wouldn't be easy for them to determine what to do. And, they'd have to understand a bit more about internal workings for being able to decide what to do.\nI'd say we should keep the coarse-grained config as of now, and introduce more granular config if need be at a later point. What do you say?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507573910", "createdAt": "2020-10-19T08:43:39Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -101,14 +103,19 @@\n     // Send to the client server traces on error message replies.\n     private final boolean replyWithStackTraceOnError;\n \n+    private final boolean isInternalWritesWithReadPermEnabled;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MTgwOA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA3NzIzNQ==", "bodyText": "IMHO, it is really a system wide setting that the admin/operator installing Pravega decides.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r511077235", "createdAt": "2020-10-23T18:43:22Z", "author": {"login": "sarlaccpit"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -101,14 +103,19 @@\n     // Send to the client server traces on error message replies.\n     private final boolean replyWithStackTraceOnError;\n \n+    private final boolean isInternalWritesWithReadPermEnabled;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MTgwOA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjAyMTY4OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1NzozN1rOHhaHew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOToxNDo1NFrOHkFGPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Mjk1NQ==", "bodyText": "should we make a special case for internal \"resources\" in this fashion.\ni can understand an rg resource or watermark resource for creation api.. but subsequent to that the clients access these streams for their segmetns using the same get/successor apis which would treat them as \"stream\" resource.\nright?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504792955", "createdAt": "2020-10-14T15:57:37Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU5NDMwMA==", "bodyText": "The streamResource represents the resource in a \"stream\", even for reader groups (prn:://scope:myScope/stream:_RGmyApp) and watermarks that we otherwise treat as resources in their own right (like prn:://scope:myScope/reader-group:myApp).\nThe streamResource (like prn:://scope:myScope/stream:_RGmyApp) is what is used in the claims in the delegation token and Segment Store processes it upon appends/reads. However, the Controller uses prn:://scope:myScope/reader-group:myApp  for any authorization. I kept it that way so that the Segment Store doesn't need to perform a lot of translation in the read/write path to account for the differentiation.\nHope that answers your question.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507594300", "createdAt": "2020-10-19T09:14:54Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Mjk1NQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjAyNTY1OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1ODozMFrOHhaKCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOToyNjoxNFrOHkFiVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MzYxMQ==", "bodyText": "for older clients would request.getRequestedPermission be empty or can it be null?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504793611", "createdAt": "2020-10-14T15:58:30Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")\n+            // and `_MARK` for internal streams. We use the same strings in delegation tokens sent to Segment Store,\n+            // while we use resource tags lie \"reader-group\" (ex: \"prn:://scope:myScope/reader-group:myApp)\n+            // and \"watermark\" for authorization in Controller.\n+            String streamResource = authParams.streamResourceString();\n+\n+            // This is for backward compatibility.\n+            if (request.getRequestedPermission().equals(\"\") && authParams.isStreamUserDefined()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwMTQ5NQ==", "bodyText": "I suppose it should be empty, since its a new String based field in the protobuf schema which should take an empty value when the server parses the message coming from an older client that doesn't populate it:\nmessage StreamInfo {\n    string scope = 1;\n    string stream = 2;\n    string requestedPermission = 3;\n}\n\nAccording to https://developers.google.com/protocol-buffers/docs/proto3,\n\n...\nWhen a message is parsed, if the encoded message does not contain a particular singular element, the corresponding field in the parsed object is set to the default value for that field. These defaults are type-specific:\nFor strings, the default value is the empty string.\n...\n\nDoes that make sense?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507601495", "createdAt": "2020-10-19T09:26:14Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")\n+            // and `_MARK` for internal streams. We use the same strings in delegation tokens sent to Segment Store,\n+            // while we use resource tags lie \"reader-group\" (ex: \"prn:://scope:myScope/reader-group:myApp)\n+            // and \"watermark\" for authorization in Controller.\n+            String streamResource = authParams.streamResourceString();\n+\n+            // This is for backward compatibility.\n+            if (request.getRequestedPermission().equals(\"\") && authParams.isStreamUserDefined()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MzYxMQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjA1MzU0OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjowNTowNVrOHhabvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODozMzozNVrOHnEGKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODE0Mw==", "bodyText": "can defaulting the permission to read have adverse consequence on old clients?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504798143", "createdAt": "2020-10-14T16:05:05Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")\n+            // and `_MARK` for internal streams. We use the same strings in delegation tokens sent to Segment Store,\n+            // while we use resource tags lie \"reader-group\" (ex: \"prn:://scope:myScope/reader-group:myApp)\n+            // and \"watermark\" for authorization in Controller.\n+            String streamResource = authParams.streamResourceString();\n+\n+            // This is for backward compatibility.\n+            if (request.getRequestedPermission().equals(\"\") && authParams.isStreamUserDefined()) {\n+                return this.grpcAuthHelper.checkAuthorizationAndCreateToken(streamResource,\n+                        AuthHandler.Permissions.READ);\n+            }\n+\n+            // The resource string that'll be used in the delegation token for use of the segment store\n+            final String tokenResource;\n+\n+            // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+            // will be allowed to perform the specified operation.\n+            final AuthHandler.Permissions tokenPermission;\n+\n+            if (authParams.isStreamUserDefined()) {\n+                // The operation itself requires the caller to possess read permissions.\n+                AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = PermissionsHelper.parse(request.getRequestedPermission(),\n+                        AuthHandler.Permissions.READ);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcyMzYyNQ==", "bodyText": "I've significantly modified the code now. Please take a look at the revised code. Older clients will now be authorized for READ_UPDATE as earlier so that both read and write paths will continue to work despite them not sending requested permission.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510723625", "createdAt": "2020-10-23T08:33:35Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")\n+            // and `_MARK` for internal streams. We use the same strings in delegation tokens sent to Segment Store,\n+            // while we use resource tags lie \"reader-group\" (ex: \"prn:://scope:myScope/reader-group:myApp)\n+            // and \"watermark\" for authorization in Controller.\n+            String streamResource = authParams.streamResourceString();\n+\n+            // This is for backward compatibility.\n+            if (request.getRequestedPermission().equals(\"\") && authParams.isStreamUserDefined()) {\n+                return this.grpcAuthHelper.checkAuthorizationAndCreateToken(streamResource,\n+                        AuthHandler.Permissions.READ);\n+            }\n+\n+            // The resource string that'll be used in the delegation token for use of the segment store\n+            final String tokenResource;\n+\n+            // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+            // will be allowed to perform the specified operation.\n+            final AuthHandler.Permissions tokenPermission;\n+\n+            if (authParams.isStreamUserDefined()) {\n+                // The operation itself requires the caller to possess read permissions.\n+                AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = PermissionsHelper.parse(request.getRequestedPermission(),\n+                        AuthHandler.Permissions.READ);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODE0Mw=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEwNDExOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoxNjo1M1rOHha7uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyMDoxMlrOHi2x8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjMzMQ==", "bodyText": "Formatting: This can fit on one line.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504806331", "createdAt": "2020-10-14T16:16:53Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -369,13 +371,15 @@\n     void close();\n \n     /**\n-     * Refreshes an expired/non-existent delegation token.\n+     * Obtains a delegation token from the server.\n      *\n-     * @param scope      Scope of the stream.\n+     * @param scope Scope of the stream.\n      * @param streamName Name of the stream.\n+     * @param accessOperation The requested permission.\n      * @return The delegation token for the given stream.\n      */\n-    CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName);\n+    CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxMTE1NA==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506311154", "createdAt": "2020-10-16T11:20:12Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -369,13 +371,15 @@\n     void close();\n \n     /**\n-     * Refreshes an expired/non-existent delegation token.\n+     * Obtains a delegation token from the server.\n      *\n-     * @param scope      Scope of the stream.\n+     * @param scope Scope of the stream.\n      * @param streamName Name of the stream.\n+     * @param accessOperation The requested permission.\n      * @return The delegation token for the given stream.\n      */\n-    CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName);\n+    CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjMzMQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEwNTExOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoxNzowNlrOHha8ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyMzoxN1rOHi26RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjUwMQ==", "bodyText": "Formatting: Revert indentation.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504806501", "createdAt": "2020-10-14T16:17:06Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -1254,7 +1254,7 @@ private void closeChannel() {\n         final CompletableFuture<DelegationToken> result = this.retryConfig.runAsync(() -> {\n             RPCAsyncCallback<DelegationToken> callback = new RPCAsyncCallback<>(traceId, \"getOrRefreshDelegationTokenFor\", scope, streamName);\n             client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS)\n-                  .getDelegationToken(ModelHelper.createStreamInfo(scope, streamName), callback);\n+                    .getDelegationToken(ModelHelper.createStreamInfo(scope, streamName, accessOperation), callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxMzI4NQ==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506313285", "createdAt": "2020-10-16T11:23:17Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -1254,7 +1254,7 @@ private void closeChannel() {\n         final CompletableFuture<DelegationToken> result = this.retryConfig.runAsync(() -> {\n             RPCAsyncCallback<DelegationToken> callback = new RPCAsyncCallback<>(traceId, \"getOrRefreshDelegationTokenFor\", scope, streamName);\n             client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS)\n-                  .getDelegationToken(ModelHelper.createStreamInfo(scope, streamName), callback);\n+                    .getDelegationToken(ModelHelper.createStreamInfo(scope, streamName, accessOperation), callback);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjUwMQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEwNzkxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoxNzo1MVrOHha-Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyMzozNlrOHi27Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjk1NA==", "bodyText": "Can you have the other method you overloaded call into this one?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504806954", "createdAt": "2020-10-14T16:17:51Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -377,6 +379,17 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n+    public static final StreamInfo createStreamInfo(final String scope, final String stream,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxMzUxNQ==", "bodyText": "Yeah, that makes sense. Changed it.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506313515", "createdAt": "2020-10-16T11:23:36Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -377,6 +379,17 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n+    public static final StreamInfo createStreamInfo(final String scope, final String stream,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjk1NA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjExODE4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyMDoyOFrOHhbE3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNDoyMFrOHi29mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwODY3MQ==", "bodyText": "Undo or remove commented out code.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504808671", "createdAt": "2020-10-14T16:20:28Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java", "diffHunk": "@@ -188,7 +188,7 @@ void removeSegmentWriter(Segment segment) {\n     }\n \n     private void createMissingWriters(Consumer<Segment> segmentSealedCallBack) {\n-        tokenProvider.populateToken(currentSegments.getDelegationToken());\n+        // tokenProvider.populateToken(currentSegments.getDelegationToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDEzNw==", "bodyText": "Removed.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314137", "createdAt": "2020-10-16T11:24:20Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java", "diffHunk": "@@ -188,7 +188,7 @@ void removeSegmentWriter(Segment segment) {\n     }\n \n     private void createMissingWriters(Consumer<Segment> segmentSealedCallBack) {\n-        tokenProvider.populateToken(currentSegments.getDelegationToken());\n+        // tokenProvider.populateToken(currentSegments.getDelegationToken());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwODY3MQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEyMTI4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableFactoryImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyMToxNFrOHhbG2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToyODoyM1rOHr8WwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ==", "bodyText": "This isn't so simple. KeyValueTable clients can be used for both reading or writing. What if someone just wants to read from KVTs?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504809179", "createdAt": "2020-10-14T16:21:14Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableFactoryImpl.java", "diffHunk": "@@ -38,7 +39,7 @@\n             @NonNull String keyValueTableName, @NonNull Serializer<KeyT> keySerializer,\n             @NonNull Serializer<ValueT> valueSerializer, @NonNull KeyValueTableClientConfiguration clientConfiguration) {\n         val kvt = new KeyValueTableInfo(this.scope, keyValueTableName);\n-        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName());\n+        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName(), AccessOperation.WRITE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MTA4Mw==", "bodyText": "@andreipaduroiu how do you suggest we handle this?\nOne possibility I see is to let the caller specify the intended access operation (READ, WRITE, or READ_WRITE). If left unspecified, default it to READ_WRITE (both read and WRITE)?\nAlternatively, we could leave it as-is and enhance it later when we support distinguishing write-only from read_write. As of now, both WRITE and READ_WRITE  are interpreted as READ_UPDATE (both reads and writes) on the server-side.\n\n  \n    \n      pravega/shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java\n    \n    \n        Lines 30 to 31\n      in\n      6d27990\n    \n    \n    \n    \n\n        \n          \n           } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) { \n        \n\n        \n          \n               return AuthHandler.Permissions.READ_UPDATE;", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510771083", "createdAt": "2020-10-23T09:54:11Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableFactoryImpl.java", "diffHunk": "@@ -38,7 +39,7 @@\n             @NonNull String keyValueTableName, @NonNull Serializer<KeyT> keySerializer,\n             @NonNull Serializer<ValueT> valueSerializer, @NonNull KeyValueTableClientConfiguration clientConfiguration) {\n         val kvt = new KeyValueTableInfo(this.scope, keyValueTableName);\n-        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName());\n+        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName(), AccessOperation.WRITE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyODk2Mg==", "bodyText": "one alternative is -- client requests a read and read_update token lazily.\nfor example, when any \"create/update/remove\" api on kvt is called, if a write token exists, its used, else its explicitly requested.\nsimilarly when a read/iterate api is called on kvt, a read token is requested once and used henceforth.\nif users are unauthorized for updates, their attempts to update the table may fail but they will still be able to read.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515828962", "createdAt": "2020-11-02T09:10:12Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableFactoryImpl.java", "diffHunk": "@@ -38,7 +39,7 @@\n             @NonNull String keyValueTableName, @NonNull Serializer<KeyT> keySerializer,\n             @NonNull Serializer<ValueT> valueSerializer, @NonNull KeyValueTableClientConfiguration clientConfiguration) {\n         val kvt = new KeyValueTableInfo(this.scope, keyValueTableName);\n-        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName());\n+        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName(), AccessOperation.WRITE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzOTY4MQ==", "bodyText": "I'm not sure what the use case would be, but a generic one would be that one an application A maintains a table that another application B consumes data from. A read-only table would allow a client only to perform gets on an existing table, while read_update would enable it to perform all operations.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515839681", "createdAt": "2020-11-02T09:28:23Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableFactoryImpl.java", "diffHunk": "@@ -38,7 +39,7 @@\n             @NonNull String keyValueTableName, @NonNull Serializer<KeyT> keySerializer,\n             @NonNull Serializer<ValueT> valueSerializer, @NonNull KeyValueTableClientConfiguration clientConfiguration) {\n         val kvt = new KeyValueTableInfo(this.scope, keyValueTableName);\n-        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName());\n+        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName(), AccessOperation.WRITE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEyOTEwOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyMzoxNFrOHhbLyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNDozOVrOHi2-ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDQ0MA==", "bodyText": "Please use some api in NameUtils. No code outside of that class should hardcoded these special strings.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504810440", "createdAt": "2020-10-14T16:23:14Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -58,10 +60,29 @@ public String ofReaderGroupInScope(String scopeName, String readerGroupName) {\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_READERGROUP, readerGroupName);\n     }\n \n+    @Override\n+    public String ofWatermarkInScope(String scopeName, String watermarkName) {\n+        Exceptions.checkNotNullOrEmpty(scopeName, \"scopeName\");\n+        Exceptions.checkNotNullOrEmpty(watermarkName, \"watermarkName\");\n+        return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_WATERMARK, watermarkName);\n+    }\n+\n     @Override\n     public String ofKeyValueTableInScope(String scopeName, String keyValueTableName) {\n         Exceptions.checkNotNullOrEmpty(scopeName, \"scopeName\");\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        // Internal stream names start with either `_RG` (reader groups) or `_MARK` (watermarks).\n+        if (streamName.startsWith(\"_RG\")) {\n+            return ofReaderGroupInScope(scopeName, streamName.replace(\"_RG\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDQwMw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314403", "createdAt": "2020-10-16T11:24:39Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -58,10 +60,29 @@ public String ofReaderGroupInScope(String scopeName, String readerGroupName) {\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_READERGROUP, readerGroupName);\n     }\n \n+    @Override\n+    public String ofWatermarkInScope(String scopeName, String watermarkName) {\n+        Exceptions.checkNotNullOrEmpty(scopeName, \"scopeName\");\n+        Exceptions.checkNotNullOrEmpty(watermarkName, \"watermarkName\");\n+        return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_WATERMARK, watermarkName);\n+    }\n+\n     @Override\n     public String ofKeyValueTableInScope(String scopeName, String keyValueTableName) {\n         Exceptions.checkNotNullOrEmpty(scopeName, \"scopeName\");\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        // Internal stream names start with either `_RG` (reader groups) or `_MARK` (watermarks).\n+        if (streamName.startsWith(\"_RG\")) {\n+            return ofReaderGroupInScope(scopeName, streamName.replace(\"_RG\", \"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDQ0MA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEzMTU2OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyMzo1MVrOHhbNPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNToxMVrOHi3AQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDgxMw==", "bodyText": "What does this special string mean? Again, consider using NameUtils. If your method is not there, please add it.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504810813", "createdAt": "2020-10-14T16:23:51Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.security.auth;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.auth.AuthHandler;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A helper class used for processing auth params for streams.\n+ */\n+@Slf4j\n+public class StreamAuthParams {\n+\n+    private static final AuthorizationResource AUTH_RESOURCE = new AuthorizationResourceImpl();\n+\n+    private final String scope;\n+    private final String stream;\n+    private final boolean isInternalWritesWithReadPermEnabled;\n+\n+    @VisibleForTesting\n+    @Getter\n+    private final boolean isInternalStream;\n+\n+    @VisibleForTesting\n+    StreamAuthParams(@NonNull String scope, @NonNull String stream) {\n+        this(scope, stream, true);\n+    }\n+\n+    public StreamAuthParams(@NonNull String scope, @NonNull String stream, boolean isInternalWritesWithReadPermEnabled) {\n+        this.scope = scope;\n+        this.stream = stream;\n+        this.isInternalWritesWithReadPermEnabled = isInternalWritesWithReadPermEnabled;\n+        if (stream.startsWith(\"_\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDgxNw==", "bodyText": "Sure, I've modified it to use NameUtils. I wasn't aware of that class. :)", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314817", "createdAt": "2020-10-16T11:25:11Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.security.auth;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.auth.AuthHandler;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A helper class used for processing auth params for streams.\n+ */\n+@Slf4j\n+public class StreamAuthParams {\n+\n+    private static final AuthorizationResource AUTH_RESOURCE = new AuthorizationResourceImpl();\n+\n+    private final String scope;\n+    private final String stream;\n+    private final boolean isInternalWritesWithReadPermEnabled;\n+\n+    @VisibleForTesting\n+    @Getter\n+    private final boolean isInternalStream;\n+\n+    @VisibleForTesting\n+    StreamAuthParams(@NonNull String scope, @NonNull String stream) {\n+        this(scope, stream, true);\n+    }\n+\n+    public StreamAuthParams(@NonNull String scope, @NonNull String stream, boolean isInternalWritesWithReadPermEnabled) {\n+        this.scope = scope;\n+        this.stream = stream;\n+        this.isInternalWritesWithReadPermEnabled = isInternalWritesWithReadPermEnabled;\n+        if (stream.startsWith(\"_\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDgxMw=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEzMjExOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyMzo1OFrOHhbNkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNToyMlrOHi3AyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDg5Nw==", "bodyText": "here too", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504810897", "createdAt": "2020-10-14T16:23:58Z", "author": {"login": "andreipaduroiu"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.security.auth;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.auth.AuthHandler;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A helper class used for processing auth params for streams.\n+ */\n+@Slf4j\n+public class StreamAuthParams {\n+\n+    private static final AuthorizationResource AUTH_RESOURCE = new AuthorizationResourceImpl();\n+\n+    private final String scope;\n+    private final String stream;\n+    private final boolean isInternalWritesWithReadPermEnabled;\n+\n+    @VisibleForTesting\n+    @Getter\n+    private final boolean isInternalStream;\n+\n+    @VisibleForTesting\n+    StreamAuthParams(@NonNull String scope, @NonNull String stream) {\n+        this(scope, stream, true);\n+    }\n+\n+    public StreamAuthParams(@NonNull String scope, @NonNull String stream, boolean isInternalWritesWithReadPermEnabled) {\n+        this.scope = scope;\n+        this.stream = stream;\n+        this.isInternalWritesWithReadPermEnabled = isInternalWritesWithReadPermEnabled;\n+        if (stream.startsWith(\"_\")) {\n+            this.isInternalStream = true;\n+        } else {\n+            this.isInternalStream = false;\n+        }\n+    }\n+\n+    public AuthHandler.Permissions requiredPermissionForWrites() {\n+        if (this.isInternalStream) {\n+            if (this.isInternalWritesWithReadPermEnabled) {\n+                return AuthHandler.Permissions.READ;\n+            } else {\n+                return AuthHandler.Permissions.READ_UPDATE;\n+            }\n+        } else {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        }\n+    }\n+\n+    public String resourceString() {\n+        return toResourceString(this.scope, this.stream);\n+    }\n+\n+    public String streamResourceString() {\n+        return AUTH_RESOURCE.ofStreamInScope(scope, stream);\n+    }\n+\n+    private static String toResourceString(String scope, String stream, boolean isStreamInternal) {\n+        return isStreamInternal ? AUTH_RESOURCE.ofInternalStream(scope, stream) :\n+                AUTH_RESOURCE.ofStreamInScope(scope, stream);\n+    }\n+\n+    public static String toResourceString(String scope, String stream) {\n+        return toResourceString(scope, stream, stream.startsWith(\"_\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDk1Mw==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314953", "createdAt": "2020-10-16T11:25:22Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.security.auth;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.auth.AuthHandler;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A helper class used for processing auth params for streams.\n+ */\n+@Slf4j\n+public class StreamAuthParams {\n+\n+    private static final AuthorizationResource AUTH_RESOURCE = new AuthorizationResourceImpl();\n+\n+    private final String scope;\n+    private final String stream;\n+    private final boolean isInternalWritesWithReadPermEnabled;\n+\n+    @VisibleForTesting\n+    @Getter\n+    private final boolean isInternalStream;\n+\n+    @VisibleForTesting\n+    StreamAuthParams(@NonNull String scope, @NonNull String stream) {\n+        this(scope, stream, true);\n+    }\n+\n+    public StreamAuthParams(@NonNull String scope, @NonNull String stream, boolean isInternalWritesWithReadPermEnabled) {\n+        this.scope = scope;\n+        this.stream = stream;\n+        this.isInternalWritesWithReadPermEnabled = isInternalWritesWithReadPermEnabled;\n+        if (stream.startsWith(\"_\")) {\n+            this.isInternalStream = true;\n+        } else {\n+            this.isInternalStream = false;\n+        }\n+    }\n+\n+    public AuthHandler.Permissions requiredPermissionForWrites() {\n+        if (this.isInternalStream) {\n+            if (this.isInternalWritesWithReadPermEnabled) {\n+                return AuthHandler.Permissions.READ;\n+            } else {\n+                return AuthHandler.Permissions.READ_UPDATE;\n+            }\n+        } else {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        }\n+    }\n+\n+    public String resourceString() {\n+        return toResourceString(this.scope, this.stream);\n+    }\n+\n+    public String streamResourceString() {\n+        return AUTH_RESOURCE.ofStreamInScope(scope, stream);\n+    }\n+\n+    private static String toResourceString(String scope, String stream, boolean isStreamInternal) {\n+        return isStreamInternal ? AUTH_RESOURCE.ofInternalStream(scope, stream) :\n+                AUTH_RESOURCE.ofStreamInScope(scope, stream);\n+    }\n+\n+    public static String toResourceString(String scope, String stream) {\n+        return toResourceString(scope, stream, stream.startsWith(\"_\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDg5Nw=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEzNDY4OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyNDozOFrOHhbPKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNTozN1rOHi3Bfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTMwNw==", "bodyText": "and here", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504811307", "createdAt": "2020-10-14T16:24:38Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -146,7 +146,7 @@ public void setupAppend(SetupAppend setupAppend) {\n             try {\n                 JsonWebToken token = tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n-                        AuthHandler.Permissions.READ_UPDATE);\n+                        newSegment.contains(\"/_\") ? AuthHandler.Permissions.READ : AuthHandler.Permissions.READ_UPDATE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNTEzNQ==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506315135", "createdAt": "2020-10-16T11:25:37Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -146,7 +146,7 @@ public void setupAppend(SetupAppend setupAppend) {\n             try {\n                 JsonWebToken token = tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n-                        AuthHandler.Permissions.READ_UPDATE);\n+                        newSegment.contains(\"/_\") ? AuthHandler.Permissions.READ : AuthHandler.Permissions.READ_UPDATE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTMwNw=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjEzODg2OnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyNTozOFrOHhbRvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNjoxNlrOHi3Dbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTk2Ng==", "bodyText": "Clearly define what the behavior of this is. What is the most restrictive level that this implies?\nConsider documenting the same for the other ones too so that whomever uses these understands what to expect.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504811966", "createdAt": "2020-10-14T16:25:38Z", "author": {"login": "andreipaduroiu"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+    /**\n+     * Not known.\n+     */\n+    UNKNOWN,\n+\n+    /**\n+     * Any operation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNTYzMQ==", "bodyText": "I've modified the documentation in the class. Please see if it looks better now.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506315631", "createdAt": "2020-10-16T11:26:16Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+    /**\n+     * Not known.\n+     */\n+    UNKNOWN,\n+\n+    /**\n+     * Any operation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTk2Ng=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjE0MDE4OnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyNTo1N1rOHhbSpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNzoyNFrOHi3HKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjE5OA==", "bodyText": "You may want to specify this applies exclusively to KeyValueTables/Table Segments.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504812198", "createdAt": "2020-10-14T16:25:57Z", "author": {"login": "andreipaduroiu"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+    /**\n+     * Not known.\n+     */\n+    UNKNOWN,\n+\n+    /**\n+     * Any operation.\n+     */\n+    ANY,\n+\n+    /**\n+     * Represents reads.\n+     */\n+    READ,\n+\n+    /**\n+     * Represents inserts, updates and deletes.\n+     */\n+    WRITE,\n+\n+    /**\n+     * Represents reads and writes (inserts, updates and deletes).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNjU4NA==", "bodyText": "No, they don't apply to exclusively to Key Value Tables/Table segments and are used broadly.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506316584", "createdAt": "2020-10-16T11:27:24Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+    /**\n+     * Not known.\n+     */\n+    UNKNOWN,\n+\n+    /**\n+     * Any operation.\n+     */\n+    ANY,\n+\n+    /**\n+     * Represents reads.\n+     */\n+    READ,\n+\n+    /**\n+     * Represents inserts, updates and deletes.\n+     */\n+    WRITE,\n+\n+    /**\n+     * Represents reads and writes (inserts, updates and deletes).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjE5OA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjE0MTM1OnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyNjoxM1rOHhbTbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNzozN1rOHi3H7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjM5Ng==", "bodyText": "Include the argument too. IT will help with debugging.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504812396", "createdAt": "2020-10-14T16:26:13Z", "author": {"login": "andreipaduroiu"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) ||\n+                accessOperation.equals(AccessOperation.READ_UPDATE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNjc4MA==", "bodyText": "Yeah, that was a miss. Fixed.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506316780", "createdAt": "2020-10-16T11:27:37Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) ||\n+                accessOperation.equals(AccessOperation.READ_UPDATE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjM5Ng=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MjE0MTkwOnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoyNjoyNVrOHhbT1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyNzo1MVrOHi3Irg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjUwMQ==", "bodyText": "Strings.isEmpty?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504812501", "createdAt": "2020-10-14T16:26:25Z", "author": {"login": "andreipaduroiu"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) ||\n+                accessOperation.equals(AccessOperation.READ_UPDATE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate\");\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(@NonNull String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (accessOperationStr.equals(\"\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNjk3NA==", "bodyText": "Sure, I've changed it now.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506316974", "createdAt": "2020-10-16T11:27:51Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) ||\n+                accessOperation.equals(AccessOperation.READ_UPDATE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate\");\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(@NonNull String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (accessOperationStr.equals(\"\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjUwMQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDI4NTc5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNDoxNzozOFrOHhwKfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMToyODoxM1rOHi3Jrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NDE3NQ==", "bodyText": "Preconditions.checkNotNull(accessOperation)", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505154175", "createdAt": "2020-10-15T04:17:38Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "diffHunk": "@@ -66,13 +70,14 @@\n     @Getter(AccessLevel.PACKAGE)\n     private final AtomicReference<CompletableFuture<Void>> tokenRefreshFuture = new AtomicReference<>();\n \n-    JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName) {\n+    JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName, AccessOperation accessOperation) {\n         this(controllerClient, scopeName, streamName, ConfigurationOptionsExtractor.extractInt(\n-                REFRESH_THRESHOLD_SYSTEM_PROPERTY, REFRESH_THRESHOLD_ENV_VARIABLE, DEFAULT_REFRESH_THRESHOLD_SECONDS));\n+                REFRESH_THRESHOLD_SYSTEM_PROPERTY, REFRESH_THRESHOLD_ENV_VARIABLE, DEFAULT_REFRESH_THRESHOLD_SECONDS),\n+                accessOperation);\n     }\n \n     private JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName,\n-                                 int refreshThresholdInSeconds) {\n+                                 int refreshThresholdInSeconds, AccessOperation accessOperation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNzIzMA==", "bodyText": "Sure, done.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506317230", "createdAt": "2020-10-16T11:28:13Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "diffHunk": "@@ -66,13 +70,14 @@\n     @Getter(AccessLevel.PACKAGE)\n     private final AtomicReference<CompletableFuture<Void>> tokenRefreshFuture = new AtomicReference<>();\n \n-    JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName) {\n+    JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName, AccessOperation accessOperation) {\n         this(controllerClient, scopeName, streamName, ConfigurationOptionsExtractor.extractInt(\n-                REFRESH_THRESHOLD_SYSTEM_PROPERTY, REFRESH_THRESHOLD_ENV_VARIABLE, DEFAULT_REFRESH_THRESHOLD_SECONDS));\n+                REFRESH_THRESHOLD_SYSTEM_PROPERTY, REFRESH_THRESHOLD_ENV_VARIABLE, DEFAULT_REFRESH_THRESHOLD_SECONDS),\n+                accessOperation);\n     }\n \n     private JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName,\n-                                 int refreshThresholdInSeconds) {\n+                                 int refreshThresholdInSeconds, AccessOperation accessOperation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NDE3NQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDI5NTc0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNDoyMzo1OVrOHhwQVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODo0OTo0NFrOHnEsvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NTY2OA==", "bodyText": "This would cause the SegmentOutputStream created by the RevisionedStreamClient to have READ permissions right ?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505155668", "createdAt": "2020-10-15T04:23:59Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "diffHunk": "@@ -213,9 +214,8 @@ public ClientFactoryImpl(String scope, Controller controller, ConnectionPool con\n     private <T> RevisionedStreamClient<T> createRevisionedStreamClient(Segment segment, Serializer<T> serializer,\n                                                                        SynchronizerConfig config) {\n         EventSegmentReader in = inFactory.createEventReaderForSegment(segment, config.getReadBufferSize());\n-        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),\n-                                                                                                          segment.getStreamName()), RuntimeException::new);\n-        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(delegationToken, controller, segment);\n+        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(controller, segment,\n+                AccessOperation.READ);\n         ConditionalOutputStream cond = condFactory.createConditionalOutputStream(segment, delegationTokenProvider, config.getEventWriterConfig());\n         SegmentMetadataClient meta = metaFactory.createSegmentMetadataClient(segment, delegationTokenProvider);\n         return new RevisionedStreamClientImpl<>(segment, in, outFactory, cond, meta, serializer, config.getEventWriterConfig(), delegationTokenProvider);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDczMzUwMA==", "bodyText": "Yes, that is right. That's no issue though as the segment store shall allow writes to internal streams with READ permissions (for the Controller, a configuration determines whether it is allowed or not):\n\n  \n    \n      pravega/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java\n    \n    \n         Line 150\n      in\n      2798cba\n    \n    \n    \n    \n\n        \n          \n           newSegment.contains(NameUtils.INTERNAL_STREAM_IDENTIFYING_PATTERN) ?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510733500", "createdAt": "2020-10-23T08:49:44Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "diffHunk": "@@ -213,9 +214,8 @@ public ClientFactoryImpl(String scope, Controller controller, ConnectionPool con\n     private <T> RevisionedStreamClient<T> createRevisionedStreamClient(Segment segment, Serializer<T> serializer,\n                                                                        SynchronizerConfig config) {\n         EventSegmentReader in = inFactory.createEventReaderForSegment(segment, config.getReadBufferSize());\n-        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),\n-                                                                                                          segment.getStreamName()), RuntimeException::new);\n-        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(delegationToken, controller, segment);\n+        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(controller, segment,\n+                AccessOperation.READ);\n         ConditionalOutputStream cond = condFactory.createConditionalOutputStream(segment, delegationTokenProvider, config.getEventWriterConfig());\n         SegmentMetadataClient meta = metaFactory.createSegmentMetadataClient(segment, delegationTokenProvider);\n         return new RevisionedStreamClientImpl<>(segment, in, outFactory, cond, meta, serializer, config.getEventWriterConfig(), delegationTokenProvider);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NTY2OA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDMwMDQxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNDoyNjo0N1rOHhwTAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODo1NzozNFrOHr7SHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjM1NQ==", "bodyText": "SegmentMetadataCLient can truncate a Stream. Is \"READ\" permission enough to do this ?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505156355", "createdAt": "2020-10-15T04:26:47Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java", "diffHunk": "@@ -63,7 +64,7 @@\n     public SegmentMetadataClientImpl(Segment segment, Controller controller, ConnectionPool connectionPool,\n                                      String delegationToken) {\n         this(segment, controller, connectionPool,\n-                DelegationTokenProviderFactory.create(delegationToken, controller, segment));\n+                DelegationTokenProviderFactory.create(delegationToken, controller, segment, AccessOperation.READ));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDczNjk3Mw==", "bodyText": "This particular constructor seems to be used for testing only. I've pushed a change documenting that.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510736973", "createdAt": "2020-10-23T08:55:29Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java", "diffHunk": "@@ -63,7 +64,7 @@\n     public SegmentMetadataClientImpl(Segment segment, Controller controller, ConnectionPool connectionPool,\n                                      String delegationToken) {\n         this(segment, controller, connectionPool,\n-                DelegationTokenProviderFactory.create(delegationToken, controller, segment));\n+                DelegationTokenProviderFactory.create(delegationToken, controller, segment, AccessOperation.READ));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjM1NQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyMjExMA==", "bodyText": "since the constructor is \"public\", it can potentially be used in other contexts. maybe we make it package private?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515822110", "createdAt": "2020-11-02T08:57:34Z", "author": {"login": "shiveshr"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java", "diffHunk": "@@ -63,7 +64,7 @@\n     public SegmentMetadataClientImpl(Segment segment, Controller controller, ConnectionPool connectionPool,\n                                      String delegationToken) {\n         this(segment, controller, connectionPool,\n-                DelegationTokenProviderFactory.create(delegationToken, controller, segment));\n+                DelegationTokenProviderFactory.create(delegationToken, controller, segment, AccessOperation.READ));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjM1NQ=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDMwMjE3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNDoyNzo1M1rOHhwT_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNDoyNzo1M1rOHhwT_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjYwNQ==", "bodyText": "Same question as above.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505156605", "createdAt": "2020-10-15T04:27:53Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -322,8 +323,7 @@ private StreamCut computeEndStreamCut(Stream stream, Map<Segment, Long> endSegme\n                     totalLength += endPositions.get(s);\n                 } else {\n                     if (tokenProvider == null) {\n-                        tokenProvider = DelegationTokenProviderFactory.create(\n-                                unreadVal.getDelegationToken(), controller, s);\n+                        tokenProvider = DelegationTokenProviderFactory.create(controller, s, AccessOperation.READ);\n                     }\n                     @Cleanup\n                     SegmentMetadataClient metadataClient = metaFactory.createSegmentMetadataClient(s, tokenProvider);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDMxMTE0OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNDozMzoxOFrOHhwZEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToxNDoxNFrOHr71Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NzkwNA==", "bodyText": "we should add a comment to explain this config...", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505157904", "createdAt": "2020-10-15T04:33:18Z", "author": {"login": "shrids"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,8 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNzk1NQ==", "bodyText": "Sure, I've added a comment to explain it now.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506317955", "createdAt": "2020-10-16T11:29:08Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,8 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NzkwNA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMTEwMw==", "bodyText": "perhaps its good to define what we mean by internal streams here..\nis it streams that system creates for its own uses - controller's streams?\nor is it system streams created to provide user applications some funciton.\neven here we have two types of resources -\n\nmetadata tables\nreadergroup streams and watermark stream\n\n2 is something that user application has access to while 1 should be completely hidden from them.\niiuc you are referring to 2. right?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515831103", "createdAt": "2020-11-02T09:14:14Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,8 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NzkwNA=="}, "originalCommit": {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzk1ODEwOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjowOToyMFrOHpx9Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDoxOTo1M1rOHqVLvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MjA5OQ==", "bodyText": "This makes the client depend on jaxb-api and jaxb-runtime. Are these needed for this change to work? If not please find a way to reconfigure things so the client isn't pulling these in.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r513572099", "createdAt": "2020-10-28T16:09:20Z", "author": {"login": "tkaitchuck"}, "path": "build.gradle", "diffHunk": "@@ -250,6 +255,7 @@ project('client') {\n         compile project(':shared:authplugin')\n         compile project(':shared:protocol')\n         compile project(\":shared:controller-api\")\n+        compile project(\":shared:security\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f10cb538f5ac89a4c6f15985178479feac095aab"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0OTMwOQ==", "bodyText": "These two jaxb dependencies seem to not be needed anymore, so I've removed these now. As for the client depending on the :shared:security project, we have introduced a new class AccessOperation that belongs to this shared project, as it is used in both the client and the server.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r514149309", "createdAt": "2020-10-29T10:19:53Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -250,6 +255,7 @@ project('client') {\n         compile project(':shared:authplugin')\n         compile project(':shared:protocol')\n         compile project(\":shared:controller-api\")\n+        compile project(\":shared:security\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MjA5OQ=="}, "originalCommit": {"oid": "f10cb538f5ac89a4c6f15985178479feac095aab"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODAwMTYxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjoxODozNFrOHpyYrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo1MjoxM1rOHr9PEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTE4MQ==", "bodyText": "This is not read-only. The revisioned stream client is used for writes.\nThis is called from the public API above, not for internal streams.\nPlease add unit / integration tests such that this sort of bug would be caught.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r513579181", "createdAt": "2020-10-28T16:18:34Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "diffHunk": "@@ -213,9 +214,8 @@ public ClientFactoryImpl(String scope, Controller controller, ConnectionPool con\n     private <T> RevisionedStreamClient<T> createRevisionedStreamClient(Segment segment, Serializer<T> serializer,\n                                                                        SynchronizerConfig config) {\n         EventSegmentReader in = inFactory.createEventReaderForSegment(segment, config.getReadBufferSize());\n-        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),\n-                                                                                                          segment.getStreamName()), RuntimeException::new);\n-        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(delegationToken, controller, segment);\n+        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(controller, segment,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f10cb538f5ac89a4c6f15985178479feac095aab"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDI4Nw==", "bodyText": "Ok. I've modified the access operation to read_write to reflect that.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r514150287", "createdAt": "2020-10-29T10:21:29Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "diffHunk": "@@ -213,9 +214,8 @@ public ClientFactoryImpl(String scope, Controller controller, ConnectionPool con\n     private <T> RevisionedStreamClient<T> createRevisionedStreamClient(Segment segment, Serializer<T> serializer,\n                                                                        SynchronizerConfig config) {\n         EventSegmentReader in = inFactory.createEventReaderForSegment(segment, config.getReadBufferSize());\n-        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),\n-                                                                                                          segment.getStreamName()), RuntimeException::new);\n-        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(delegationToken, controller, segment);\n+        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(controller, segment,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTE4MQ=="}, "originalCommit": {"oid": "f10cb538f5ac89a4c6f15985178479feac095aab"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1NDA5OQ==", "bodyText": "Also, I've added a number of tests to supplement the many existing tests we already have for Auth.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515854099", "createdAt": "2020-11-02T09:52:13Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "diffHunk": "@@ -213,9 +214,8 @@ public ClientFactoryImpl(String scope, Controller controller, ConnectionPool con\n     private <T> RevisionedStreamClient<T> createRevisionedStreamClient(Segment segment, Serializer<T> serializer,\n                                                                        SynchronizerConfig config) {\n         EventSegmentReader in = inFactory.createEventReaderForSegment(segment, config.getReadBufferSize());\n-        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),\n-                                                                                                          segment.getStreamName()), RuntimeException::new);\n-        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(delegationToken, controller, segment);\n+        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(controller, segment,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTE4MQ=="}, "originalCommit": {"oid": "f10cb538f5ac89a4c6f15985178479feac095aab"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjM4MDQ4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzo1MTowN1rOHr5SGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDozMzoyMVrOHr-wdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc4OTMzOA==", "bodyText": "Does NONE mean that this is requesting a token with the default authorization for the operation (MRP in the PDP)?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515789338", "createdAt": "2020-11-02T07:51:07Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -957,7 +958,7 @@ private Boolean handleScaleResponse(Stream stream, ScaleResponse response, long\n \n         final CompletableFuture<SegmentsAtTime> result = this.retryConfig.runAsync(() -> {\n             RPCAsyncCallback<SegmentsAtTime> callback = new RPCAsyncCallback<>(traceId, \"getSegmentsAtTime\", stream, timestamp);\n-            StreamInfo streamInfo = ModelHelper.createStreamInfo(stream.getScope(), stream.getStreamName());\n+            StreamInfo streamInfo = ModelHelper.createStreamInfo(stream.getScope(), stream.getStreamName(), AccessOperation.NONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg3OTAzMA==", "bodyText": "Actually, we are using this to tell the server that the client doesn't need a delegation token to be prepared and sent back. Older clients'll not set it, so the server will continue to return delegation tokens. Newer clients will not receive the token, due to this change.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515879030", "createdAt": "2020-11-02T10:33:21Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -957,7 +958,7 @@ private Boolean handleScaleResponse(Stream stream, ScaleResponse response, long\n \n         final CompletableFuture<SegmentsAtTime> result = this.retryConfig.runAsync(() -> {\n             RPCAsyncCallback<SegmentsAtTime> callback = new RPCAsyncCallback<>(traceId, \"getSegmentsAtTime\", stream, timestamp);\n-            StreamInfo streamInfo = ModelHelper.createStreamInfo(stream.getScope(), stream.getStreamName());\n+            StreamInfo streamInfo = ModelHelper.createStreamInfo(stream.getScope(), stream.getStreamName(), AccessOperation.NONE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc4OTMzOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjM5NDU4OnYy", "diffSide": "RIGHT", "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzo1NTo1MVrOHr5aRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDozNzozNlrOHr-6Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTQyOQ==", "bodyText": "I don't understand why this mark prefix needs to be made public.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515791429", "createdAt": "2020-11-02T07:55:51Z", "author": {"login": "fpj"}, "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -132,7 +135,7 @@\n     /**\n      * Prefix for identifying system created mark segments for storing watermarks. \n      */\n-    @Getter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PUBLIC)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4MTUxNA==", "bodyText": "The reason for making this public is that we are not using the getter in io.pravega.controller.server.security.auth.StreamAuthParams class.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515881514", "createdAt": "2020-11-02T10:37:36Z", "author": {"login": "ravisharda"}, "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -132,7 +135,7 @@\n     /**\n      * Prefix for identifying system created mark segments for storing watermarks. \n      */\n-    @Getter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PUBLIC)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTQyOQ=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQwMDkyOnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzo1Nzo0NVrOHr5d1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwODoyNDozMlrOHvGiYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg==", "bodyText": "Although this makes sense, the terminology does not match what is in the PDP. The PDP refers to MRP and RP, which are about permissions, there is no reference to access operations. Perhaps it needs to be reflected in the PDP?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515792342", "createdAt": "2020-11-02T07:57:45Z", "author": {"login": "fpj"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4OTAwNA==", "bodyText": "Yes, I shall update the PDP later to reflect some of the changes in this PR.\nTo share a bit more context on this:\nThis class is a shared class to represent operations (READ, WRITE, READ_WRITE) being performed. It is similar to the AuthHandler.Permissions enum, which takes on values NONE, READ, READ_UPDATE).\n\n  \n    \n      pravega/shared/authplugin/src/main/java/io/pravega/auth/AuthHandler.java\n    \n    \n        Lines 34 to 37\n      in\n      3b0068f\n    \n    \n    \n    \n\n        \n          \n           enum Permissions { \n        \n\n        \n          \n               NONE, \n        \n\n        \n          \n               READ, \n        \n\n        \n          \n               READ_UPDATE \n        \n    \n  \n\n\nThis new AccessOperation was needed for these reasons:\n\nUsing an AuthHandler AuthHandler.Permissions class in the Client-side'd look awkward.\nAccess operations are things like read, write, delete, update, etc. Permissions reflect things like allow, deny, etc. Right now I've kept the permission enum as is. The client only uses AccessOperation, the server translates it to the corresponding AuthHandler.Permissions. At a later time when we further refine the authorization model, we'll have some flexibility in defining additional operations.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515889004", "createdAt": "2020-11-02T10:51:00Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNzQ4Mw==", "bodyText": "Ok, to confirm my understanding, you see AuthHandler.Permissions and AccessOperation diverging in the future, so it makes no sense to try to consolidate the enums, is it right?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518937483", "createdAt": "2020-11-06T18:44:18Z", "author": {"login": "fpj"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MTMwMQ==", "bodyText": "IMO, eventually AccessOperation should replace AuthHandler.Permissions altogether. Right now, the client only uses the former, and the server uses both (maps the former to the latter). That'd be too big a change, so I've left the latter for now.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519151301", "createdAt": "2020-11-07T08:13:01Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MjIyNg==", "bodyText": "I've created a new issue to track that future change: #5309.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519152226", "createdAt": "2020-11-07T08:24:32Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjQwMjUxOnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzo1ODoyMlrOHr5ewg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDo1NDoyNFrOHr_fkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjU3OA==", "bodyText": "In which cases would I want to grant write permission but not read?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515792578", "createdAt": "2020-11-02T07:58:22Z", "author": {"login": "fpj"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+\n+    /**\n+     * Doesn't represent any specific operation, and allows the caller to make it explicit that any access operation.\n+     * It is primarily meant for use in tests.\n+     */\n+    ANY,\n+\n+    /**\n+     * Represents reads.\n+     */\n+    READ,\n+\n+    /**\n+     * Represents inserts, updates and deletes.\n+     */\n+    WRITE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MTA5MA==", "bodyText": "Say, you want users to append to the stream, but not read from it. (That's not supported as of now.)\nIn the client where we specify these operations, I've tried to reflect the intended operation precisely as WRITE or READ_WRITE.  Right now, both WRITE and READ_WRITE are interpreted as READ_UPDATE in the Controller. Still, this makes it easy to distinguish those operations later if we need to, apart from making the operation more explicit.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515891090", "createdAt": "2020-11-02T10:54:24Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+\n+    /**\n+     * Doesn't represent any specific operation, and allows the caller to make it explicit that any access operation.\n+     * It is primarily meant for use in tests.\n+     */\n+    ANY,\n+\n+    /**\n+     * Represents reads.\n+     */\n+    READ,\n+\n+    /**\n+     * Represents inserts, updates and deletes.\n+     */\n+    WRITE,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjU3OA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjYxNjQwOnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTowMjoxNVrOHr7ckQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwOTo0MjoyNlrOHvG7vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ==", "bodyText": "I'm wondering whether returning the default permissions is the right thing to do. If the string is illegal and we return the default, then aren't we implicitly assuming that the default is what the caller wants? It might be a better approach to error it out.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515824785", "createdAt": "2020-11-02T09:02:15Z", "author": {"login": "fpj"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;\n+        }\n+        try {\n+            return toAuthHandlerPermissions(AccessOperation.valueOf(accessOperationStr));\n+        } catch (IllegalArgumentException e) {\n+            return defaultPermissions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5OTAyNA==", "bodyText": "This method is quite like the Java System.getProperty\u200b(String key, String def). It takes a default value as input and returns that if it is unable to parse. The usage of this method is in StreamAuthParams, which sets the default as READ, based on the purpose it in turn is used in ControllerServiceImpl.\nDoes that sound good to you?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516399024", "createdAt": "2020-11-03T02:36:17Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;\n+        }\n+        try {\n+            return toAuthHandlerPermissions(AccessOperation.valueOf(accessOperationStr));\n+        } catch (IllegalArgumentException e) {\n+            return defaultPermissions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzOTc1MA==", "bodyText": "Say we are trying to get a permission to read_update, and for some reason the string is messed up. Say that the default permission is read, in which case this is returning a read permission. Assuming a scenario like this is possible,  transparently returning the default sounds problematic because that's not the intention.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518939750", "createdAt": "2020-11-06T18:48:56Z", "author": {"login": "fpj"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;\n+        }\n+        try {\n+            return toAuthHandlerPermissions(AccessOperation.valueOf(accessOperationStr));\n+        } catch (IllegalArgumentException e) {\n+            return defaultPermissions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1ODcxNg==", "bodyText": "Ok. I've modified the code to throw the exception as-is when a value is present but cannot be parsed.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519158716", "createdAt": "2020-11-07T09:42:26Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;\n+        }\n+        try {\n+            return toAuthHandlerPermissions(AccessOperation.valueOf(accessOperationStr));\n+        } catch (IllegalArgumentException e) {\n+            return defaultPermissions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjYzMTYyOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTowNjo0NVrOHr7l0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0MDozN1rOHu1VYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNzE1NA==", "bodyText": "This feels hacky. Could the delegation token instead contain specific authorization for the internal stream that needs to be written to? This current way is amplifying a read authorization, which I'm not convinced is a good approach.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515827154", "createdAt": "2020-11-02T09:06:45Z", "author": {"login": "fpj"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -146,7 +147,8 @@ public void setupAppend(SetupAppend setupAppend) {\n             try {\n                 JsonWebToken token = tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n-                        AuthHandler.Permissions.READ_UPDATE);\n+                        newSegment.contains(NameUtils.INTERNAL_STREAM_IDENTIFYING_PATTERN) ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDM2OA==", "bodyText": "Sure, I've changed the implementation now such that the delegation token is assigned the appropriate authorization. Please see if it looks better.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518870368", "createdAt": "2020-11-06T16:40:37Z", "author": {"login": "ravisharda"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -146,7 +147,8 @@ public void setupAppend(SetupAppend setupAppend) {\n             try {\n                 JsonWebToken token = tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n-                        AuthHandler.Permissions.READ_UPDATE);\n+                        newSegment.contains(NameUtils.INTERNAL_STREAM_IDENTIFYING_PATTERN) ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNzE1NA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjY4MzgxOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "isResolved": false, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToyMDo0NVrOHr8Eig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMToxMDo0MlrOHyOgAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA==", "bodyText": "Reader Group synchronizer and Mark streams are internal streams, but they have one very important difference. The former is written directly by clients (readers) while the latter is written by the controller. For the Mark stream, what we need to authorize is that controller tracks the requests to note time from the writer, and the writer is already expected to have write access. A reader will only be reading to the Mark stream, not writing to it.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515835018", "createdAt": "2020-11-02T09:20:45Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDQ0NA==", "bodyText": "For watermark streams we authorize against the corresponding stream:\n\n  \n    \n      pravega/controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java\n    \n    \n        Lines 75 to 76\n      in\n      11daa62\n    \n    \n    \n    \n\n        \n          \n           } else if (streamName.startsWith(NameUtils.getMARK_PREFIX())) { \n        \n\n        \n          \n               return ofStreamInScope(scopeName, streamName.replace(NameUtils.getMARK_PREFIX(), \"\")); \n        \n    \n  \n\n\nDoes that look OK?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518880444", "createdAt": "2020-11-06T16:57:14Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MDcwMw==", "bodyText": "My point is that in principle no client needs to write to the mark stream, only the controller writes to the mark stream. We shouldn't be granting the client authorization to write to that stream if it doesn't need it.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518940703", "createdAt": "2020-11-06T18:50:45Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1OTEzMQ==", "bodyText": "The segment store also authorizes the controller's requests, so it must have permissions to write to that watermark stream. Since the client doesn't invoke the operation, it wouldn't be authorized for the mark stream or issued a delegation token containing the authorization. Does that address your question, or am I missing something?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519159131", "createdAt": "2020-11-07T09:47:25Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE5ODExOA==", "bodyText": "I'm not sure it addresses my question. The controller appends to the mark stream, and I think you are saying that the controller appending to the mark stream also requires authorization. This part makes sense.\nThe next question I have is how the controller is authorized to append to the mark stream. The controller consolidates in a single stream cut the marks from a group of writers, so it can't be transitively authorized with the token of a single writer. In fact, I'm wondering if its authorization should have anything to do with the authorization of the writers as a controller instance should be able to perform operations against the segment store as long as it can demonstrate that it is a legitimate controller. If a controller has been authenticated as a legitimate controller, then it can be authorized as such to perform operations against the segment store. What am I missing?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519198118", "createdAt": "2020-11-07T17:18:13Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc1NDQ1Ng==", "bodyText": "I don't know exactly what/how appends are facilitated by the controller and made by the segment store, so I don't know the answers to all the questions above. @shiveshr / @tkaitchuck could you please chime in?\nBased on my experiments, I had seen that the reads from a stream'd fail if the user didn't have permissions on the corresponding mark stream. Please see references to _MARK stream in this PDP.\nSince mark streams are an internal construct, I had modified the code to authorize against the corresponding stream in this PR, based on my discussion with @shiveshr. My understanding is that for a stream myscope/mystream we create a corresponding mark stream myscope/_MARKmystream.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519754456", "createdAt": "2020-11-09T11:57:21Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3MjgzMQ==", "bodyText": "@fpj is correct.\nwriters need to be authorized for read-update on base stream to be able to call notetime.\nwriters do not request for a delegation token for calling notetime as they do not write directly to mark stream.\nController uses the \"master\" delegation token for all writes to all metadata tables and mark streams. So it has permissions by default for writing to any internal stream. Note: for table calls it creates the master delegation token. for client calls (e.g. request stream reader and writer, mark's revisioned stream client, it uses the ClientConfig which loads the creds from the environment which gives it the controller creds for talking to segment store).\n@ravisharda can you please confirm the following:\nif any client application with \"READ_UPDATE\" permission on base stream requests READ_UPDATE on mark stream, do you grant it?\ni think with these changes it would presently do it.\nalthough nowhere in the code does a user application request for write permissions on a mark stream.. but our authorization is not preventing that explicitly which it should. right?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520272831", "createdAt": "2020-11-10T04:05:00Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNjk2OA==", "bodyText": "@shiveshr yes, if the client requests for a delegation token (via getDelegationToken call) with READ_UPDATE permissions for a mark stream, we validate that the client has READ_UPDATE permission on the corresponding stream and return a delegation token enabling the client to read from/write to that mark stream. We aren't preventing that from happening as of now.\nIf clients have no business requesting for delegation tokens for mark streams, I can add logic to prevent that from happening. What do you say?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521016968", "createdAt": "2020-11-11T02:00:31Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMTUyOQ==", "bodyText": "we should prevent them from requesting read_update.\nreaders still need \"read\" permissions on it to read from mark stream.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521021529", "createdAt": "2020-11-11T02:07:10Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMzNTY2NQ==", "bodyText": "I've made the change in the latest commit that I just pushed. Please take a look. Here's what it does:\n\nIf the client calls getDelegationToken for read permissions on mark streams, it authorizes the user and returns one.\nIf the client calls getDelegationToken for write permissions on mark streams, it rejects the request with an authorization exception.\nIf the client calls getDelegationToken for mark streams, without specifying the access operation, it authorizes the client for reads and returns a delegation token with read permissions.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521335665", "createdAt": "2020-11-11T12:50:05Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyODQxNg==", "bodyText": "There is one point I'd like to clarify, see this:\n#5231 (comment)", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522428416", "createdAt": "2020-11-12T21:10:42Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjY4NzQ4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToyMTo0NVrOHr8GuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwOToyODoxN1rOHvG24Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw==", "bodyText": "... null is equivalent to NONE?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515835577", "createdAt": "2020-11-02T09:21:45Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -416,10 +418,18 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n-    public static final StreamInfo createStreamInfo(final String scope, final String stream) {\n+    public static final StreamInfo createStreamInfo(final String scope, final String stream, AccessOperation accessOperation) {\n         Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n         Exceptions.checkNotNullOrEmpty(stream, \"stream\");\n-        return StreamInfo.newBuilder().setScope(scope).setStream(stream).build();\n+        StreamInfo.Builder builder = StreamInfo.newBuilder().setScope(scope).setStream(stream);\n+        if (accessOperation != null) {\n+            builder.setRequestedPermission(accessOperation.name());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3Mjk4Nw==", "bodyText": "No, not really. Older clients will not set the access operation, so the server will not receive a requested permission in the input message.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518872987", "createdAt": "2020-11-06T16:44:53Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -416,10 +418,18 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n-    public static final StreamInfo createStreamInfo(final String scope, final String stream) {\n+    public static final StreamInfo createStreamInfo(final String scope, final String stream, AccessOperation accessOperation) {\n         Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n         Exceptions.checkNotNullOrEmpty(stream, \"stream\");\n-        return StreamInfo.newBuilder().setScope(scope).setStream(stream).build();\n+        StreamInfo.Builder builder = StreamInfo.newBuilder().setScope(scope).setStream(stream);\n+        if (accessOperation != null) {\n+            builder.setRequestedPermission(accessOperation.name());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyMDg4OQ==", "bodyText": "Ok, so null is for backward compatibility?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518920889", "createdAt": "2020-11-06T18:11:49Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -416,10 +418,18 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n-    public static final StreamInfo createStreamInfo(final String scope, final String stream) {\n+    public static final StreamInfo createStreamInfo(final String scope, final String stream, AccessOperation accessOperation) {\n         Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n         Exceptions.checkNotNullOrEmpty(stream, \"stream\");\n-        return StreamInfo.newBuilder().setScope(scope).setStream(stream).build();\n+        StreamInfo.Builder builder = StreamInfo.newBuilder().setScope(scope).setStream(stream);\n+        if (accessOperation != null) {\n+            builder.setRequestedPermission(accessOperation.name());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1NzQ3Mw==", "bodyText": "Yes.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519157473", "createdAt": "2020-11-07T09:28:17Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -416,10 +418,18 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n-    public static final StreamInfo createStreamInfo(final String scope, final String stream) {\n+    public static final StreamInfo createStreamInfo(final String scope, final String stream, AccessOperation accessOperation) {\n         Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n         Exceptions.checkNotNullOrEmpty(stream, \"stream\");\n-        return StreamInfo.newBuilder().setScope(scope).setStream(stream).build();\n+        StreamInfo.Builder builder = StreamInfo.newBuilder().setScope(scope).setStream(stream);\n+        if (accessOperation != null) {\n+            builder.setRequestedPermission(accessOperation.name());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjY5Mjc3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToyMzoxMFrOHr8J7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoyMjowNFrOHseTRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjM5OQ==", "bodyText": "Typo in th server.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515836399", "createdAt": "2020-11-02T09:23:10Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "diffHunk": "@@ -35,25 +36,28 @@ public static DelegationTokenProvider createWithEmptyToken() {\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param scopeName the name of the scope tied to the segment, for which a delegation token is to be obtained\n      * @param streamName the name of the stream tied to the segment, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTg0NA==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516395844", "createdAt": "2020-11-03T02:22:04Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "diffHunk": "@@ -35,25 +36,28 @@ public static DelegationTokenProvider createWithEmptyToken() {\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param scopeName the name of the scope tied to the segment, for which a delegation token is to be obtained\n      * @param streamName the name of the stream tied to the segment, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjM5OQ=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjY5MzU3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToyMzoyMlrOHr8KZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoyMjoxN1rOHseTcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjUxNw==", "bodyText": "Same typo.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515836517", "createdAt": "2020-11-02T09:23:22Z", "author": {"login": "fpj"}, "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "diffHunk": "@@ -35,25 +36,28 @@ public static DelegationTokenProvider createWithEmptyToken() {\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param scopeName the name of the scope tied to the segment, for which a delegation token is to be obtained\n      * @param streamName the name of the stream tied to the segment, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server\n      * @return a new {@link DelegationTokenProvider} instance\n      * @throws NullPointerException if {@code controller}, {@code scopeName} or {@code streamName} is null\n      * @throws IllegalArgumentException if {@code scopeName} or {@code streamName} is empty\n      */\n     @VisibleForTesting\n-    public static DelegationTokenProvider create(Controller controller, String scopeName, String streamName) {\n-        return create(null, controller, scopeName, streamName);\n+    public static DelegationTokenProvider create(Controller controller, String scopeName, String streamName,\n+                                                 AccessOperation accessOperation) {\n+        return create(null, controller, scopeName, streamName, accessOperation);\n     }\n \n     /**\n      * Creates a {@link DelegationTokenProvider} instance with null delegation token.\n      *\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param segment the {@link Segment}, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTg4OA==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516395888", "createdAt": "2020-11-03T02:22:17Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "diffHunk": "@@ -35,25 +36,28 @@ public static DelegationTokenProvider createWithEmptyToken() {\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param scopeName the name of the scope tied to the segment, for which a delegation token is to be obtained\n      * @param streamName the name of the stream tied to the segment, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server\n      * @return a new {@link DelegationTokenProvider} instance\n      * @throws NullPointerException if {@code controller}, {@code scopeName} or {@code streamName} is null\n      * @throws IllegalArgumentException if {@code scopeName} or {@code streamName} is empty\n      */\n     @VisibleForTesting\n-    public static DelegationTokenProvider create(Controller controller, String scopeName, String streamName) {\n-        return create(null, controller, scopeName, streamName);\n+    public static DelegationTokenProvider create(Controller controller, String scopeName, String streamName,\n+                                                 AccessOperation accessOperation) {\n+        return create(null, controller, scopeName, streamName, accessOperation);\n     }\n \n     /**\n      * Creates a {@link DelegationTokenProvider} instance with null delegation token.\n      *\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param segment the {@link Segment}, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjUxNw=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjcwMTE4OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToyNTowM1rOHr8OpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo1ODoyM1rOHr9dtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNzYwNA==", "bodyText": "i am sorry, i think i had asked this earlier too - why do we authorize for both minimum permissions and requested permissions successively.. isnt minimum permission redundant in that case?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515837604", "createdAt": "2020-11-02T09:25:03Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -345,21 +360,106 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n \n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested =\n+                request.getRequestedPermission().equals(AccessOperation.NONE.toString()) ? false : true;\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    request.getRequestedPermission(), this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isRequestedPermissionEmpty()) {\n+                // For backward compatibility: Older clients will not populate requested permission.\n+                log.info(\"Requested permission was empty for request with scope {} and stream {}\", request.getScope(),\n+                        request.getStream());\n+                return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+            } else {\n+                log.debug(\"Requested permission was {} for request with scope {} and stream {}\",\n+                        request.getRequestedPermission(), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1Nzg0NA==", "bodyText": "The minimum permissions is the permission required to make this call. The requested permission is the permission the caller wants to be assigned in the delegation token.\nIn most cases, the calling code from the client will ask for one of these:\n\nREAD - in which case authorization is only done for READ\nREAD_WRITE or WRITE - in which case authorization is only done for READ_UPDATE\nNo permission - in which case the default/backward compatibility rule applies.\n\nThis particular piece of code is for other unexpected cases. Here's an example: \n  \n    \n      pravega/controller/src/test/java/io/pravega/controller/server/rpc/grpc/v1/InMemoryControllerServiceImplTest.java\n    \n    \n         Line 170\n      in\n      ed3f57f\n    \n    \n    \n    \n\n        \n          \n           public void supplierCreatesTokenWithReadWhenRequestedPermissionIsUnexpected() {", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515857844", "createdAt": "2020-11-02T09:58:23Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -345,21 +360,106 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n \n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested =\n+                request.getRequestedPermission().equals(AccessOperation.NONE.toString()) ? false : true;\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    request.getRequestedPermission(), this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isRequestedPermissionEmpty()) {\n+                // For backward compatibility: Older clients will not populate requested permission.\n+                log.info(\"Requested permission was empty for request with scope {} and stream {}\", request.getScope(),\n+                        request.getStream());\n+                return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+            } else {\n+                log.debug(\"Requested permission was {} for request with scope {} and stream {}\",\n+                        request.getRequestedPermission(), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNzYwNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjcwNzU2OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOToyNjoyNFrOHr8SNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoyMToyN1rOHseSvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzODUxNw==", "bodyText": "wouldnt requested permission for older clients be null?\nshould we invert this check to avoid NPE?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515838517", "createdAt": "2020-11-02T09:26:24Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -380,20 +480,35 @@ public void getEpochSegments(GetEpochSegmentsRequest request, StreamObserver<Seg\n \n     @Override\n     public void getSegments(GetSegmentsRequest request, StreamObserver<SegmentsAtTime> responseObserver) {\n-        log.debug(\"getSegments called for stream \" + request.getStreamInfo().getScope() + \"/\" +\n-                request.getStreamInfo().getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getStreamInfo().getScope(),\n-                        request.getStreamInfo().getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getSegments\", request.getStreamInfo().getScope(),\n-                            request.getStreamInfo().getStream());\n-                    return controllerService.getSegmentsAtHead(request.getStreamInfo().getScope(),\n-                            request.getStreamInfo().getStream())\n+        final StreamInfo streamInfo = request.getStreamInfo();\n+        final String scope = streamInfo.getScope();\n+        final String stream = streamInfo.getStream();\n+        log.debug(\"getSegments called for stream \" + scope + \"/\" + stream);\n+\n+        final boolean isDelegationTokenRequested =\n+                streamInfo.getRequestedPermission().equals(AccessOperation.NONE.toString()) ? false : true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTcwOA==", "bodyText": "Yes, thanks for spotting the bug. I've made the change now.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516395708", "createdAt": "2020-11-03T02:21:27Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -380,20 +480,35 @@ public void getEpochSegments(GetEpochSegmentsRequest request, StreamObserver<Seg\n \n     @Override\n     public void getSegments(GetSegmentsRequest request, StreamObserver<SegmentsAtTime> responseObserver) {\n-        log.debug(\"getSegments called for stream \" + request.getStreamInfo().getScope() + \"/\" +\n-                request.getStreamInfo().getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getStreamInfo().getScope(),\n-                        request.getStreamInfo().getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getSegments\", request.getStreamInfo().getScope(),\n-                            request.getStreamInfo().getStream());\n-                    return controllerService.getSegmentsAtHead(request.getStreamInfo().getScope(),\n-                            request.getStreamInfo().getStream())\n+        final StreamInfo streamInfo = request.getStreamInfo();\n+        final String scope = streamInfo.getScope();\n+        final String stream = streamInfo.getStream();\n+        log.debug(\"getSegments called for stream \" + scope + \"/\" + stream);\n+\n+        final boolean isDelegationTokenRequested =\n+                streamInfo.getRequestedPermission().equals(AccessOperation.NONE.toString()) ? false : true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzODUxNw=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjcyNDI1OnYy", "diffSide": "RIGHT", "path": "client/src/test/resources/logback-test.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTozMDoyOFrOHr8b_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoyMjozOVrOHseTxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MTAyMg==", "bodyText": "This sounds like a good change, but out of scope and I'd rather not do it silently as part of this PR.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515841022", "createdAt": "2020-11-02T09:30:28Z", "author": {"login": "fpj"}, "path": "client/src/test/resources/logback-test.xml", "diffHunk": "@@ -17,7 +17,7 @@\n         </encoder>\n     </appender>\n \n-    <root level=\"DEBUG\">\n+    <root level=\"INFO\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTk3NA==", "bodyText": "True - I had pushed this change by mistake, and have now reverted it.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516395974", "createdAt": "2020-11-03T02:22:39Z", "author": {"login": "ravisharda"}, "path": "client/src/test/resources/logback-test.xml", "diffHunk": "@@ -17,7 +17,7 @@\n         </encoder>\n     </appender>\n \n-    <root level=\"DEBUG\">\n+    <root level=\"INFO\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MTAyMg=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjczNjUxOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "isResolved": false, "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTozMzozMlrOHr8jEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTowMTozOFrOHvy5KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA==", "bodyText": "One major problem I see with configuring it this way is that it will be difficult for a user to understand what to do about it. It is rather counterintuitive and the tradeoffs are not very clear. What would be the argument against always giving write access to the reader group synchronizer stream instead of adding this parameter?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515842834", "createdAt": "2020-11-02T09:33:32Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTgxNw==", "bodyText": "@fpj, I am not sure if you meant what you said, which is \"always give write access\" or you meant \"require write access\".\nI don't think we can \"give\" write access automatically.   The reason why we want to be able to preserve the \"you need READ_UPDATE to touch/mutate this ReaderGroup\" behavior is for these types of deployments where:\n\nenvironments where low level granular \"ahead of time\" acl provisioning is not possible due to the fact that the resources, scopes, streams, reader groups, are not known ahead of time.\nthere is a conscious intent to apply ACLs at the scope level because it's easier to manage for the admin, who does not have to worry about new streams getting created and having to micro manage at that level.  Scopes are more viewed like \"teams\" or \"tenants\".\n\nFor that reason, heavy use of wild cards is required usually at the scope level.  That means that if \"READ\" allowed access to reader groups in general, reader subjects could be interfering with each other.\nAn example of this is when members of a team called \"compute1\" scope for which was created so they can run their own applications etc.   chris is part of that team.\nThere's also a \"compute2\" team/scope with a jack user in it.\nThere is also a team called marketdata with a scope and streams into which stock market data was ingested etc.\nThe desire is that members from compute1 and compute2 can read any streams (present and future) from marketdata but not alter any data. Additionally not be able to mess with reader groups synchronizer states in marketdata or reader groups from the other team's scope.\nACLs would look like this:\nREAD on prn://scope:marketdata/* and READ_UPDATE on prn://scope:compute1/* to chris\nREAD on prn://scope:marketdata/* and READ_UPDATE on prn://scope:compute1/* to jack\n\nchris can read marketata/streamXYZ and is tracking its RG state in compute1/...\njack can read marketata/streamXYZ and is tracking its RG state in compute2/...\nIt is assumed that if chris's friend maddy, with common READ_UPDATE rights on compute1 enters the picture, she can see and update the RG that chris created.  But she's part of the same team.  That is ok).  jack however, is prevented from accessing chris and maddy's RGs, while still benefiting from accessing marketdata's streams.\nIf the READ on prn://scope:marketdata/* was allowing mutation of reader groups, then in theory chris and jack could create reader groups there and mess with each other's reader groups. So in this use case, it's best to remain with the \"Mutation/access to Reader groups is still protected by READ_UPDATE\", such that chris and jack are forced to put their reader groups in their own team scopes.\nThe flag that's added in this PR, when set to false, allows the above to work.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518235817", "createdAt": "2020-11-05T17:39:01Z", "author": {"login": "sarlaccpit"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNjcxNA==", "bodyText": "@sarlaccpit thanks for patiently explaining the reasoning behind the option. If a user is granted permission to read from a stream, then it should be automatically granted permission to write to the corresponding reader group stream because without that it can't be part of the reader group. Anything that is needed for a user to be able to read from a stream from an authorization perspective needs to be included in the read authorization, otherwise, from a usability perspective, it won't look very good. The option we are discussing is fairly obscure.\nThe use of wildcards you describe makes sense. If users with read authorization can create reader groups, then they would be messing up with their own reader group. If that's undesirable, which is reasonable, then perhaps we can require read_update to create a reader group, and only read to join.\nOne point I don't understand: what happens if a reader group is configured to read from stream A and B, and a given reader that tries to join is only authorized to read from A? I suppose it won't be able to join the reader group.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518936714", "createdAt": "2020-11-06T18:42:38Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MTYwNQ==", "bodyText": "The nuances of join versus create, wrt Read group do make sense.   Although that seems like part of what @ravisharda is likely planning in the future; which is the addition of finer grained permissions, beyond READ and READ_UPDATE which admittedly are not fine grain enough (in general that is, not just for reader groups).  One can imagine the need for things like DELETE, and also WRITE_ONLY (append only) that I have seen mentioned in other context.\nBut I don't think this is part of this PR (which is already ambitious as it is :).   So @ravisharda can correct me, but basically READ_UPDATE on the reader group basically means: use the reader group and do what you need with it.\nFor the question of the reader group tracking multiple streams, not all of which you may have access to.   Again, @ravisharda  can say best, but I believe the permission on the reader group is what the focus is, the reader group being its own entity.   The fact it's related to streams is sort of an aside I think?  Meaning, at the end of the day, when the client tries to access stream a or stream b, it'll be confronted to whether or not it has access for these streams then.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518941605", "createdAt": "2020-11-06T18:52:27Z", "author": {"login": "sarlaccpit"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MDg2NQ==", "bodyText": "@fpj To help make what @sarlaccpit says above a bit more concrete, let me share a couple of examples from the newly added integration tests:\nThe following lines from a test that uses read-only permissions to read data from a stream, shows the low-level permissions - all READ permissions - on the stream, on the reader group and on the scope - required for reading from the stream:\n\n  \n    \n      pravega/test/integration/src/test/java/io/pravega/test/integration/ReadWithReadPermissionsTest.java\n    \n    \n        Lines 71 to 74\n      in\n      11daa62\n    \n    \n    \n    \n\n        \n          \n           passwordInputFileEntries.put(\"reader\", String.join(\";\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData,READ\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/stream:StockPriceUpdates,READ\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ\" \n        \n    \n  \n\n\nThe above is true by default. If you turn a flag on (discussed earlier), reading data from a stream will continue to require READ_UPDATE permissions (as they do today):\n\n  \n    \n      pravega/test/integration/src/test/java/io/pravega/test/integration/ReadWithReadPermissionsTest.java\n    \n    \n        Lines 88 to 93\n      in\n      11daa62\n    \n    \n    \n    \n\n        \n          \n           passwordInputFileEntries.put(\"reader\", String.join(\";\", \n        \n\n        \n          \n                   // READ_UPDATE on scope needed for creating internal streams since we configure \"internal writes with \n        \n\n        \n          \n                   // read permissions\" to false later (during instantiation of the ClusterWrapper object). \n        \n\n        \n          \n                   \"prn::/scope:MarketData,READ_UPDATE\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/stream:StockPriceUpdates,READ\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE\" \n        \n    \n  \n\n\nHope that clarifies.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519150865", "createdAt": "2020-11-07T08:07:23Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE5NzI2MQ==", "bodyText": "I believe I understand what the two of you are saying, but why do we need the option? Said differently, if we remove the configuration option and have only the behavior of requiring read permission to write to internal streams, then what bad things are going to happen?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519197261", "createdAt": "2020-11-07T17:08:15Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQzNzMyOA==", "bodyText": "The initial idea of this PR was to require read permissions for internal streams. But then @sarlaccpit explained a situation where that could be problematic for the platform where this feature would be used. He has explained it in one of the comments above - copying a fragment for reference:\n\nThe desire is that members from compute1 and compute2 can read any streams (present and future) from marketdata but not alter any data. Additionally not be able to mess with reader groups synchronizer states in marketdata or reader groups from the other team's scope.\n\nDoes that help?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519437328", "createdAt": "2020-11-08T15:34:08Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0Mjk1NA==", "bodyText": "Just adding a quick nuance on \"situation where that could be problematic for the platform where this feature would be used\".\nI'd say it'd be problematic for any environments that use the pravega scope as the main unit of authorization.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519442954", "createdAt": "2020-11-08T15:53:45Z", "author": {"login": "sarlaccpit"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0NDAyNA==", "bodyText": "It does not help much because you are trying to convince me that the behavior you are trying to implement makes sense, while the problem for me is not the behavior you are trying to implement, but instead how this PR is proposing to implement it.\nThere are two important points for me:\n\nIn that comment, there is an implicit assumption that the use of the wildcard will lead to all state synchronizer streams and reader groups to be readable. We clearly don't want that. We want that a user that is granted permission to read from a given stream (or set of streams via wildcard) is able to only read from those streams and participate in corresponding reader groups. There is even the question of whether a user authorized to read from a given stream can join any reader group reading from that streams. I'd claim that it shouldn't be like that.\nI'm not convinced we need this configuration flag.  As I see it, you can implement the behavior you want without having this flag, which I find confusing from the point of view of a user. I don't understand why we would want to give the user the ability to turn it on and off.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519444024", "createdAt": "2020-11-08T16:02:58Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzY4OQ==", "bodyText": "Regarding the first point:\n\nWe want that a user that is granted permission to read from a given stream (or set of streams via wildcard) is able to only read from those streams and participate in corresponding reader groups.\n\nYes, a subject (a user) can only read from streams that it has read access to.\nNot sure what you mean by \"corresponding\" reader groups. Reader groups (RG) are independent w.r.t. authorization. The user must have access to te RG stream as well:\n\nsay prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ (by default or if the Controller config controller.security.auth.internalStreams.writesWithReadPermissions.enable is true)\nprn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE (if the same config is turned off)\n\nRegarding the second point:\n\nI'm not convinced we need this configuration flag. As I see it, you can implement the behavior you want without having this flag, which I find confusing from the point of view of a user. I don't understand why we would want to give the user the ability to turn it on and off.\n\nIt's really an admin-level config, with a sensible default. The default config lets readers read from a stream with read-only permissions (as shown below), while allowing the admins control over what the readers can read:\nprn::/scope:MarketData,READ;prn::/scope:MarketData/stream:StockPriceUpdates,READ;prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ\nWhen the flag is turned off, the same user requires this ACL to read data:\nprn::/scope:MarketData,READ_UPDATE;prn::/scope:MarketData/stream:StockPriceUpdates,READ;prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE\nFor systems that use Pravega authorizations at a scope level using wildcards, the config value of false can be useful:\n\nUser Bob has READ_UPDATE permission on BobScope*. He can create an RG under BobScope, create new streams under BobScope and read/write to any streams there.\nUser Alice has READ_UPDATE permission on AliceScope*, and she can create an RG under AliceScope, create new streams under AliceScope and read/write to any streams there.\nAlice also has READ permission on BobScope*, and therefore her RG AliceRg created for her in AliceScope can be used to read from BobScope/BobStream. Everything until here is possible in both configurations)\nHowever, since the config is off in this deployment, she cannot create RGs or join any other existing RGs in BobScope. If this config was set as default/true, she could.\n\nHope that clarifies.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519527689", "createdAt": "2020-11-09T02:56:53Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc2NDkxNA==", "bodyText": "I'm still not seeing a justification for supporting different behavior. The clarification only explains that there is a use case that limits the participation in reader groups for a principal that is authorized to read. It makes sense to limit participation in reader groups, so I'm wondering why we want to support the other behavior.\nAs for the reader group authorization options:\nprn::/scope:MarketData/reader-group:PriceChangeCalculator,READ\nprn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE\n\nMy confusion comes from the fact that if READ_UPDATE is expected, then what does it mean to use READ in an ACL for a reader group. The same for the other case. A reader group in principle can't be read-only. A principal is either authorized to join a reader group or not.  If it is authorized, then it must be able to read and write... or, are you thinking that requesting a checkpoint is a read-only activity that can be performed by a principal with read-only access to the reader group?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519764914", "createdAt": "2020-11-09T12:17:28Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4NDk0MQ==", "bodyText": "My confusion comes from the fact that if READ_UPDATE is expected, then what does it mean to use READ in an ACL for a reader group.\n\nSince clients post RG state into the RG internal stream, even just reading data required READ_UPDATE permissions on the RG stream. In this PR, that behavior is dependent on whether the controller.security.auth.internalStreams.writesWithReadPermissions.enable is on/off. If it is on, just READ permission is sufficient, otherwise READ_UPDATE is required.\n\nA principal is either authorized to join a reader group or not. If it is authorized, then it must be able to read and write... or, are you thinking that requesting a checkpoint is a read-only activity that can be performed by a principal with read-only access to the reader group?\n\nThe intent has been to allow RG checkpointing using read permissions, while  providing a configuration to disable that globally (for systems that use scope-level authorizations so that admins have greater control, as explained earlier).", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519784941", "createdAt": "2020-11-09T12:54:30Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg3ODk1Mg==", "bodyText": "To add a bit more context, the flag is useful for systems that use Pravega authorizations at the level of Pravega scopes along with wildcards for child resources like resource groups and streams (as explained earlier in the chain). Ideally, we'd want any external authorization policies applied at that level to be mapped to finer-grained authorizations applied by Pravega at the level of Controller and Segment Store operations.\nHowever, Pravega doesn't support an important feature in this regard: a way of notifying external access control systems (like Keycloak) of creation/updation/deletion of fine-grained resources like streams, reader groups, etc. In the absence of that feature, mapping coarse-grained authorization policies to fine-grained operation-level authorizations is impractical, and that explains the use of wildcards at scope-level that @sarlaccpit was referring to earlier. I think we should live with this new config  until we have a solution for this problem. Once we have a resource lifecycle events notification mechism, we could remove this config later.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519878952", "createdAt": "2020-11-09T15:01:38Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, "originalCommit": {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njg3NzEyOnYy", "diffSide": "RIGHT", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNDoyMzozNFrOHveiyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNDozNzo1NFrOHveurw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0NTU0Ng==", "bodyText": "Does this imply that the older client talking to the newer controller server would get default permissions?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519545546", "createdAt": "2020-11-09T04:23:34Z", "author": {"login": "shrids"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else if (accessOperation.equals(AccessOperation.NONE)) {\n+            return AuthHandler.Permissions.NONE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0ODIxMw==", "bodyText": "The way we use this is as follows:\n\nIf the client is an old one, it doesn\u2019t set requested permission, so the server authorized the client for permissions used earlier.\nIf the client is a new one, and doesn\u2019t specify a specific permission as requested permission, we use the default permission. Otherwise, we use the requested permissions.\n\nHope that clarifies.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519548213", "createdAt": "2020-11-09T04:36:05Z", "author": {"login": "ravisharda"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else if (accessOperation.equals(AccessOperation.NONE)) {\n+            return AuthHandler.Permissions.NONE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0NTU0Ng=="}, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0ODU5MQ==", "bodyText": "Thanks @ravisharda", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519548591", "createdAt": "2020-11-09T04:37:54Z", "author": {"login": "shrids"}, "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else if (accessOperation.equals(AccessOperation.NONE)) {\n+            return AuthHandler.Permissions.NONE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0NTU0Ng=="}, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjkzNzY0OnYy", "diffSide": "RIGHT", "path": "shared/controller-api/src/main/proto/Controller.proto", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNTowNDowMVrOHvfFBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDozMjo1OVrOHwWLAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1NDMwOQ==", "bodyText": "Would using an enum simplify the code further?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519554309", "createdAt": "2020-11-09T05:04:01Z", "author": {"login": "shrids"}, "path": "shared/controller-api/src/main/proto/Controller.proto", "diffHunk": "@@ -279,6 +279,7 @@ message ContinuationToken {\n message StreamInfo {\n     string scope = 1;\n     string stream = 2;\n+    string requestedPermission = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2MjE0NQ==", "bodyText": "Yes, that\u2019d help. Will do so.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519562145", "createdAt": "2020-11-09T05:35:36Z", "author": {"login": "ravisharda"}, "path": "shared/controller-api/src/main/proto/Controller.proto", "diffHunk": "@@ -279,6 +279,7 @@ message ContinuationToken {\n message StreamInfo {\n     string scope = 1;\n     string stream = 2;\n+    string requestedPermission = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1NDMwOQ=="}, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1Njk2Mw==", "bodyText": "I've just pushed changes for modifying the datatype of this field to enum. I've also renamed it to AccessOperation, to better represent it's intent.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520456963", "createdAt": "2020-11-10T10:32:59Z", "author": {"login": "ravisharda"}, "path": "shared/controller-api/src/main/proto/Controller.proto", "diffHunk": "@@ -279,6 +279,7 @@ message ContinuationToken {\n message StreamInfo {\n     string scope = 1;\n     string stream = 2;\n+    string requestedPermission = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1NDMwOQ=="}, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTg5NDAzOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxODowNDo0MVrOHv7EYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMTowODowMFrOHwXiUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxMjg5OQ==", "bodyText": "I don't understand this. If shared:security compiles without withoutJaxb then why is it a dependency in the first place?\nIf there is some class that uses it as a runtime dependency and that is not needed by the client, then it should be removed as a dependency and added to the appropriate packages which actually use it.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520012899", "createdAt": "2020-11-09T18:04:41Z", "author": {"login": "tkaitchuck"}, "path": "build.gradle", "diffHunk": "@@ -271,7 +279,7 @@ project('client') {\n         compile project(':shared:authplugin')\n         compile project(':shared:protocol')\n         compile project(\":shared:controller-api\")\n-\n+        compile project(\":shared:security\"), withoutJaxb", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3OTMxNQ==", "bodyText": "I tried to remove the JAXB dependency from the shared:security module, but then realized it is necessary for the io.jsonwebtoken dependency. Without it, some of the tests fail (Issue #3937).\nSince Jwt helper in the module isn't used in the client, I've explicitly excluded Jaxb (as well as JJWT dependency now) module.\nHope that clarifies.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520479315", "createdAt": "2020-11-10T11:08:00Z", "author": {"login": "ravisharda"}, "path": "build.gradle", "diffHunk": "@@ -271,7 +279,7 @@ project('client') {\n         compile project(':shared:authplugin')\n         compile project(':shared:protocol')\n         compile project(\":shared:controller-api\")\n-\n+        compile project(\":shared:security\"), withoutJaxb", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxMjg5OQ=="}, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTk0MzA1OnYy", "diffSide": "RIGHT", "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxODoxODowNVrOHv7ihw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMToxODoyNlrOHwX62w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMDYxNQ==", "bodyText": "This conflicts with the fact that / is used a separator between scope and stream.\nWhere is this used?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520020615", "createdAt": "2020-11-09T18:18:05Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -34,6 +34,9 @@\n     // The prefix which has to be appended to streams created internally for readerGroups.\n     public static final String READER_GROUP_STREAM_PREFIX = INTERNAL_NAME_PREFIX + \"RG\";\n \n+    // The string which may be used to identify whether a segment is part of an internal stream.\n+    public static final String INTERNAL_STREAM_IDENTIFYING_PATTERN = \"/\" + INTERNAL_NAME_PREFIX;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ4NTU5NQ==", "bodyText": "This happened to be unused code after some of the recent changes. I've removed it now in the latest commit I just pushed.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520485595", "createdAt": "2020-11-10T11:18:26Z", "author": {"login": "ravisharda"}, "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -34,6 +34,9 @@\n     // The prefix which has to be appended to streams created internally for readerGroups.\n     public static final String READER_GROUP_STREAM_PREFIX = INTERNAL_NAME_PREFIX + \"RG\";\n \n+    // The string which may be used to identify whether a segment is part of an internal stream.\n+    public static final String INTERNAL_STREAM_IDENTIFYING_PATTERN = \"/\" + INTERNAL_NAME_PREFIX;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMDYxNQ=="}, "originalCommit": {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTU5MjEyOnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNzo1NDozNFrOHxYHBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQxNjoxODowOVrOHzL-gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA==", "bodyText": "This question somewhat depends on the answer of the previous one. Should we more broadly be checking whether a principal is requesting READ_UPDATE authorization on internal + mark streams? Or are we checking it elsewhere?\nAlso, if delegation tokens generated here are also used by the controller, then are we limiting access to mark streams by the controller?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521537284", "createdAt": "2020-11-11T17:54:34Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc2ODUxOA==", "bodyText": "...Or are we checking it elsewhere?\n\nWe are checking for external/internal streams via this condition:\n\n  \n    \n      pravega/controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java\n    \n    \n         Line 445\n      in\n      fe8f7f5\n    \n    \n    \n    \n\n        \n          \n           if (authParams.isStreamUserDefined()) { \n        \n    \n  \n\n\nAccordingly, line 470 is hit only if the stream is an internal stream.\n\nAlso, if delegation tokens generated here are also used by the controller, then are we limiting access to mark streams by the controller?\n\nThe Controller obtains the delegation token via the LocalController (a client class), which doesn't make the gRPC call, but rather invokes a local call:\n\n  \n    \n      pravega/controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java\n    \n    \n         Line 521\n      in\n      fe8f7f5\n    \n    \n    \n    \n\n        \n          \n           public CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName, AccessOperation accessOperation) {", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521768518", "createdAt": "2020-11-12T01:56:04Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyNjcwOQ==", "bodyText": "Ok, I understand that the controller gets its delegation tokens elsewhere. On mark streams, given that we are saying that internal streams might be accessed by external clients for debug/administration, this is the behavior I'd expect:\n1- If a client is requesting permission to READ_UPDATE a stream S, then it will not get automatically permission to READ_UPDATE the corresponding mark stream of S.\n2- If a client is requesting READ_UPDATE access to a mark stream explicitly, say for debugging/administration purposes like with other internal streams, then it authorizes the access in the case the access configuration allows it.\nI'm not sure we are making a distinction between these two scenarios, and I'm trying to make sure that we are not blocking access to mark streams for say admin tools while access to other internal streams is authorized.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522426709", "createdAt": "2020-11-12T21:07:17Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY1OTc4MA==", "bodyText": "1- If a client is requesting permission to READ_UPDATE a stream S, then it will not get automatically permission to READ_UPDATE the corresponding mark stream of S.\n\nThat is true. We only return a delegation token for the resource (stream, etc.) that the client has explicitly requested it for.\nClients are now blocked by the server from getting a delegation token with READ_UPDATE for a mark stream. This means, if a client requests a token for a markstream with READ_UPDATE, they will encounter an error.\n\n2- If a client is requesting READ_UPDATE access to a mark stream explicitly, say for debugging/administration purposes like with other internal streams, then it authorizes the access in the case the access configuration allows it.\n\nClients are allowed to obtain a delegation token with READ on a mark stream, but not READ_UPDATE (which will be blocked). Since we definitively know clients have no business requesting for READ_UPDATE to a mark-stream, we'd rather block it right now and open it up later if and when the need arises.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522659780", "createdAt": "2020-11-13T05:20:16Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc1Mjk0Nw==", "bodyText": "It is correct that regular clients have no business writing to a mark stream, I'm +1 for not grating READ_UPDATE access like that.\nI'm concerned that we might not be doing it for internal streams consistently, which might be necessary for administration/recovery purposes. This is not a case of a regular user trying to append to/read from a stream, but an administrator trying to understand or fix a problem. In such cases, is it a possibility that the administrator might need to have READ_UPDATE access to one or more mark streams?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522752947", "createdAt": "2020-11-13T07:55:11Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3MzQyNg==", "bodyText": "In this PR, I\u2019ve changed how delegation tokens are authorized for mark streams (they now require access on the corresponding streams), so based on a previous discussion that mark streams are not writable by clients, I\u2019ve blocked writes to them. In the future if the need arises for clients to write to them, we can enable that with due consideration.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522873426", "createdAt": "2020-11-13T10:50:31Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3NDA3Mg==", "bodyText": "I don\u2019t want to make such a change for all internal streams, as that\u2019s be a much broader change, and something that\u2019s out of scope of this PR.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522874072", "createdAt": "2020-11-13T10:51:48Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3NzM1OA==", "bodyText": "Yes, we should first classify the internal streams into three categories -\n\ninternal streams created for fulfilling a user function and users have full control over it (e.g. reader group streams).\ninternal stream created for fulfilling a user function but users dont have write access to it (e.g. mark stream).\ninternal streams that controller process creates for its own purposes. users have no business looking at or doing anything to do with these streams.\n\nFirst and second streams are already covered by these changes as a special case.\nFor third, we should not prevent READ_UPDATE requests on authorization. this is because segment store also posts events into them. And admin tool may also require READ_UPDATE to allow them to post events to initiate some work to remedy some bad state in the system.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522877358", "createdAt": "2020-11-13T10:58:04Z", "author": {"login": "shiveshr"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg5ODM1MA==", "bodyText": "Would it make sense to create an issue to define and implement an authorization model for internal streams?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522898350", "createdAt": "2020-11-13T11:41:14Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzNzkxMA==", "bodyText": "Yes, I will do so later.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522937910", "createdAt": "2020-11-13T13:06:10Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzNTY1MQ==", "bodyText": "An issue to capture the open item we discussed last.\n#5332", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r523435651", "createdAt": "2020-11-14T16:18:09Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDE1OTc2OnYy", "diffSide": "RIGHT", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDo0MjoyMVrOHxdjqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMzoxNjozM1rOHyYPKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA==", "bodyText": "This else block starting at line 464 is about internal streams. Are the tokens produced here both for the use of application clients and the controller? For application clients, is there a case in which we want to authorize them to read from internal streams that are not mark streams,(e.g., streams the controller use with its workflows)? Is it for some debug or recovery scenario?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521626538", "createdAt": "2020-11-11T20:42:21Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc2OTM1NA==", "bodyText": "... Are the tokens produced here both for the use of application clients and the controller?\n\nNo, only application clients making the gRPC call will arrive here. The Controller itself uses LocalController as I mentioned in the previous comment.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521769354", "createdAt": "2020-11-12T01:58:52Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3MDQ0Nw==", "bodyText": "For application clients, is there a case in which we want to authorize them to read from internal streams that are not mark streams,(e.g., streams the controller use with its workflows)? Is it for some debug or recovery scenario?\n\nThe reader group stream is an example of internal stream that application clients may access (usually via the client library). For mark streams, I've now blocked any request for delegation tokens with READ_UPDATE permission, but allow READ.\nI don't know the answer for other types of internal streams, but the older code allowed a gRPC client to obtain delegation tokens for any external or internal stream, provided the user was authorized for READ_UPDATE.\nDoes that answer your question?", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521770447", "createdAt": "2020-11-12T02:02:40Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxNTcyMA==", "bodyText": "Sure, it makes sense to authorize read and write access for say debug/administration/recovery purposes.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522415720", "createdAt": "2020-11-12T20:46:33Z", "author": {"login": "fpj"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU4Nzk0NA==", "bodyText": "Yes, that's right.", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522587944", "createdAt": "2020-11-13T03:16:33Z", "author": {"login": "ravisharda"}, "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}, "originalCommit": {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922"}, "originalPosition": 208}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4725, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}