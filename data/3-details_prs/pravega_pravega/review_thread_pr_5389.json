{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNDg0NTgw", "number": 5389, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxODoxOTo1OFrOFA68Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDozMjoxNlrOFBzwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTEwMDE0OnYy", "diffSide": "RIGHT", "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxODoxOTo1OFrOH_cjkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNDowNDozOFrOIAVFFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI5MDE5Mw==", "bodyText": "You should clean this up", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r536290193", "createdAt": "2020-12-04T18:19:58Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "diffHunk": "@@ -94,4 +127,81 @@ public void writeAndReadBackAMessageWithTlsAndAuthEnabledServer() {\n         String readMessage = TestUtils.readNextEventMessage(scopeName, streamName, readerClientConfig, readerGroupName);\n         assertEquals(testMessage, readMessage);\n     }\n+\n+    @SneakyThrows\n+    @Test\n+    public void restApiInvocationWithSecurityEnabled() {\n+        String restApiUser = \"rest-api-user\";\n+        String restApiUserPwd = \"super-secret\";\n+\n+        final Map<String, String> passwordInputFileEntries = new HashMap<>();\n+        passwordInputFileEntries.put(\"restApiUser\", \"prn::*,READ_UPDATE\");\n+\n+        // Setup and start the cluster\n+        @Cleanup\n+        ClusterWrapper cluster = ClusterWrapper.builder()\n+                .controllerRestEnabled(true)\n+\n+                // Auth related configs\n+                .authEnabled(true)\n+                .passwordAuthHandlerEntries(TestUtils.preparePasswordInputFileEntries(passwordInputFileEntries, restApiUserPwd))\n+\n+                // TLS related configs\n+                .tlsEnabled(true)\n+                .tlsServerCertificatePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_CERT_FILE_NAME)\n+                .tlsServerKeyPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_PRIVATE_KEY_FILE_NAME)\n+                .tlsHostVerificationEnabled(false)\n+                .tlsServerKeystorePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_KEYSTORE_NAME)\n+                .tlsServerKeystorePasswordPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_PASSWORD_FILE_NAME)\n+\n+                .build();\n+        cluster.start();\n+\n+        // Setup REST client config\n+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();\n+        clientConfig.register(JacksonJsonProvider.class);\n+        clientConfig.property(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n+        clientConfig.register(HttpAuthenticationFeature.basic(restApiUser, restApiUserPwd));\n+\n+        // Prepare a TLS context with truststore containing the signing CA's vertificate\n+        KeyStore trustStore = createTrustStore(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_CA_CERT_FILE_NAME);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(trustStore);\n+        SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+        tlsContext.init(null, tmf.getTrustManagers(), null);\n+\n+        // Instantiate the REST client\n+        javax.ws.rs.client.Client client = ClientBuilder.newBuilder()\n+                        .withConfig(clientConfig)\n+                        .sslContext(tlsContext)\n+                        .build();\n+\n+        String restServerURI = cluster.controllerRestUri();\n+        log.info(\"REST Server URI: {}\", restServerURI);\n+\n+        // Invoke the REST operation\n+        String resourceURl = new StringBuilder(restServerURI).append(\"/ping\").toString();\n+        WebTarget webTarget = client.target(resourceURl);\n+        Invocation.Builder builder = webTarget.request();\n+\n+        // Check if the response was as expected\n+        Response response = builder.get();\n+        assertEquals(\"Response to /ping was not OK\", OK.getStatusCode(), response.getStatus());\n+        log.info(\"Ping successful.\");\n+    }\n+\n+    //region Unit test\n+    @Test\n+    public void setsDefaultValuesWhenBuilderSpecifiesNoValues() {\n+        ClusterWrapper objectUnderTest = ClusterWrapper.builder().build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a065875e2d792cc14efec6521bd1b82434d4835e"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIxNjI3Ng==", "bodyText": "Ok. I've removed the unit tests from this integration test class in the latest commit. Have pushed the assertions for checking default values into an integration test above.", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537216276", "createdAt": "2020-12-07T04:04:38Z", "author": {"login": "ravisharda"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "diffHunk": "@@ -94,4 +127,81 @@ public void writeAndReadBackAMessageWithTlsAndAuthEnabledServer() {\n         String readMessage = TestUtils.readNextEventMessage(scopeName, streamName, readerClientConfig, readerGroupName);\n         assertEquals(testMessage, readMessage);\n     }\n+\n+    @SneakyThrows\n+    @Test\n+    public void restApiInvocationWithSecurityEnabled() {\n+        String restApiUser = \"rest-api-user\";\n+        String restApiUserPwd = \"super-secret\";\n+\n+        final Map<String, String> passwordInputFileEntries = new HashMap<>();\n+        passwordInputFileEntries.put(\"restApiUser\", \"prn::*,READ_UPDATE\");\n+\n+        // Setup and start the cluster\n+        @Cleanup\n+        ClusterWrapper cluster = ClusterWrapper.builder()\n+                .controllerRestEnabled(true)\n+\n+                // Auth related configs\n+                .authEnabled(true)\n+                .passwordAuthHandlerEntries(TestUtils.preparePasswordInputFileEntries(passwordInputFileEntries, restApiUserPwd))\n+\n+                // TLS related configs\n+                .tlsEnabled(true)\n+                .tlsServerCertificatePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_CERT_FILE_NAME)\n+                .tlsServerKeyPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_PRIVATE_KEY_FILE_NAME)\n+                .tlsHostVerificationEnabled(false)\n+                .tlsServerKeystorePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_KEYSTORE_NAME)\n+                .tlsServerKeystorePasswordPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_PASSWORD_FILE_NAME)\n+\n+                .build();\n+        cluster.start();\n+\n+        // Setup REST client config\n+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();\n+        clientConfig.register(JacksonJsonProvider.class);\n+        clientConfig.property(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n+        clientConfig.register(HttpAuthenticationFeature.basic(restApiUser, restApiUserPwd));\n+\n+        // Prepare a TLS context with truststore containing the signing CA's vertificate\n+        KeyStore trustStore = createTrustStore(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_CA_CERT_FILE_NAME);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(trustStore);\n+        SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+        tlsContext.init(null, tmf.getTrustManagers(), null);\n+\n+        // Instantiate the REST client\n+        javax.ws.rs.client.Client client = ClientBuilder.newBuilder()\n+                        .withConfig(clientConfig)\n+                        .sslContext(tlsContext)\n+                        .build();\n+\n+        String restServerURI = cluster.controllerRestUri();\n+        log.info(\"REST Server URI: {}\", restServerURI);\n+\n+        // Invoke the REST operation\n+        String resourceURl = new StringBuilder(restServerURI).append(\"/ping\").toString();\n+        WebTarget webTarget = client.target(resourceURl);\n+        Invocation.Builder builder = webTarget.request();\n+\n+        // Check if the response was as expected\n+        Response response = builder.get();\n+        assertEquals(\"Response to /ping was not OK\", OK.getStatusCode(), response.getStatus());\n+        log.info(\"Ping successful.\");\n+    }\n+\n+    //region Unit test\n+    @Test\n+    public void setsDefaultValuesWhenBuilderSpecifiesNoValues() {\n+        ClusterWrapper objectUnderTest = ClusterWrapper.builder().build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI5MDE5Mw=="}, "originalCommit": {"oid": "a065875e2d792cc14efec6521bd1b82434d4835e"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MzAyODk1OnYy", "diffSide": "RIGHT", "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwOToyMTozNlrOIAdKLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDo0NDozN1rOIAgnVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM0ODY1Mw==", "bodyText": "cleanup using client.close()", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537348653", "createdAt": "2020-12-07T09:21:36Z", "author": {"login": "shrids"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "diffHunk": "@@ -94,4 +136,66 @@ public void writeAndReadBackAMessageWithTlsAndAuthEnabledServer() {\n         String readMessage = TestUtils.readNextEventMessage(scopeName, streamName, readerClientConfig, readerGroupName);\n         assertEquals(testMessage, readMessage);\n     }\n+\n+    @SneakyThrows\n+    @Test\n+    public void restApiInvocationWithSecurityEnabled() {\n+        String restApiUser = \"rest-api-user\";\n+        String restApiUserPwd = \"super-secret\";\n+\n+        final Map<String, String> passwordInputFileEntries = new HashMap<>();\n+        passwordInputFileEntries.put(\"restApiUser\", \"prn::*,READ_UPDATE\");\n+\n+        // Setup and start the cluster\n+        @Cleanup\n+        ClusterWrapper cluster = ClusterWrapper.builder()\n+                .controllerRestEnabled(true)\n+\n+                // Auth related configs\n+                .authEnabled(true)\n+                .passwordAuthHandlerEntries(TestUtils.preparePasswordInputFileEntries(passwordInputFileEntries, restApiUserPwd))\n+\n+                // TLS related configs\n+                .tlsEnabled(true)\n+                .tlsServerCertificatePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_CERT_FILE_NAME)\n+                .tlsServerKeyPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_PRIVATE_KEY_FILE_NAME)\n+                .tlsHostVerificationEnabled(false)\n+                .tlsServerKeystorePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_KEYSTORE_NAME)\n+                .tlsServerKeystorePasswordPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_PASSWORD_FILE_NAME)\n+\n+                .build();\n+        cluster.start();\n+\n+        // Setup REST client config\n+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();\n+        clientConfig.register(JacksonJsonProvider.class);\n+        clientConfig.property(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n+        clientConfig.register(HttpAuthenticationFeature.basic(restApiUser, restApiUserPwd));\n+\n+        // Prepare a TLS context with truststore containing the signing CA's vertificate\n+        KeyStore trustStore = createTrustStore(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_CA_CERT_FILE_NAME);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(trustStore);\n+        SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+        tlsContext.init(null, tmf.getTrustManagers(), null);\n+\n+        // Instantiate the REST client\n+        javax.ws.rs.client.Client client = ClientBuilder.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d249edb83f0e6eb802c1317520dafa8ee946945"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwNTI3MA==", "bodyText": "Thanks for catching it - missed it.", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537405270", "createdAt": "2020-12-07T10:44:37Z", "author": {"login": "ravisharda"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "diffHunk": "@@ -94,4 +136,66 @@ public void writeAndReadBackAMessageWithTlsAndAuthEnabledServer() {\n         String readMessage = TestUtils.readNextEventMessage(scopeName, streamName, readerClientConfig, readerGroupName);\n         assertEquals(testMessage, readMessage);\n     }\n+\n+    @SneakyThrows\n+    @Test\n+    public void restApiInvocationWithSecurityEnabled() {\n+        String restApiUser = \"rest-api-user\";\n+        String restApiUserPwd = \"super-secret\";\n+\n+        final Map<String, String> passwordInputFileEntries = new HashMap<>();\n+        passwordInputFileEntries.put(\"restApiUser\", \"prn::*,READ_UPDATE\");\n+\n+        // Setup and start the cluster\n+        @Cleanup\n+        ClusterWrapper cluster = ClusterWrapper.builder()\n+                .controllerRestEnabled(true)\n+\n+                // Auth related configs\n+                .authEnabled(true)\n+                .passwordAuthHandlerEntries(TestUtils.preparePasswordInputFileEntries(passwordInputFileEntries, restApiUserPwd))\n+\n+                // TLS related configs\n+                .tlsEnabled(true)\n+                .tlsServerCertificatePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_CERT_FILE_NAME)\n+                .tlsServerKeyPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_PRIVATE_KEY_FILE_NAME)\n+                .tlsHostVerificationEnabled(false)\n+                .tlsServerKeystorePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_KEYSTORE_NAME)\n+                .tlsServerKeystorePasswordPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_PASSWORD_FILE_NAME)\n+\n+                .build();\n+        cluster.start();\n+\n+        // Setup REST client config\n+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();\n+        clientConfig.register(JacksonJsonProvider.class);\n+        clientConfig.property(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n+        clientConfig.register(HttpAuthenticationFeature.basic(restApiUser, restApiUserPwd));\n+\n+        // Prepare a TLS context with truststore containing the signing CA's vertificate\n+        KeyStore trustStore = createTrustStore(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_CA_CERT_FILE_NAME);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(trustStore);\n+        SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+        tlsContext.init(null, tmf.getTrustManagers(), null);\n+\n+        // Instantiate the REST client\n+        javax.ws.rs.client.Client client = ClientBuilder.newBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM0ODY1Mw=="}, "originalCommit": {"oid": "7d249edb83f0e6eb802c1317520dafa8ee946945"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDQwMzkwOnYy", "diffSide": "RIGHT", "path": "test/integration/src/main/java/io/pravega/test/integration/demo/ClusterWrapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDozMTozMVrOIAphrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDo0Njo1MVrOIAqQAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1MTI3Ng==", "bodyText": "Why did you move this method? I have another PR in flight touching this class and it's going to conflict with this one because of this change", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537551276", "createdAt": "2020-12-07T14:31:31Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/main/java/io/pravega/test/integration/demo/ClusterWrapper.java", "diffHunk": "@@ -122,30 +137,64 @@\n \n     private ClusterWrapper() {}\n \n-    public void initialize() {\n+    @SneakyThrows\n+    public void start() {\n+        if (this.isAuthEnabled() && passwordAuthHandlerEntries == null) {\n+            this.passwordAuthHandlerEntries = Arrays.asList(defaultAuthHandlerEntry());\n+        }\n+        if (this.controllerRestEnabled && this.controllerRestPort <= 0) {\n+            this.controllerRestPort = TestUtils.getAvailableListenPort();\n+        }\n+        startZookeeper();\n+        log.info(\"Started Zookeeper\");\n+        startSegmentStore();\n+        log.info(\"Started Segment store\");\n+        startController();\n+        log.info(\"Started Controller\");\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b00f95c0245861e410b3e69298c1f7f49f44fe8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU2MzEzOQ==", "bodyText": "Since I was enhancing this class, I thought it'd be a good opportunity to move around methods so that public and private methods are collocated.", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537563139", "createdAt": "2020-12-07T14:46:51Z", "author": {"login": "ravisharda"}, "path": "test/integration/src/main/java/io/pravega/test/integration/demo/ClusterWrapper.java", "diffHunk": "@@ -122,30 +137,64 @@\n \n     private ClusterWrapper() {}\n \n-    public void initialize() {\n+    @SneakyThrows\n+    public void start() {\n+        if (this.isAuthEnabled() && passwordAuthHandlerEntries == null) {\n+            this.passwordAuthHandlerEntries = Arrays.asList(defaultAuthHandlerEntry());\n+        }\n+        if (this.controllerRestEnabled && this.controllerRestPort <= 0) {\n+            this.controllerRestPort = TestUtils.getAvailableListenPort();\n+        }\n+        startZookeeper();\n+        log.info(\"Started Zookeeper\");\n+        startSegmentStore();\n+        log.info(\"Started Segment store\");\n+        startController();\n+        log.info(\"Started Controller\");\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1MTI3Ng=="}, "originalCommit": {"oid": "9b00f95c0245861e410b3e69298c1f7f49f44fe8"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDQwODIxOnYy", "diffSide": "RIGHT", "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDozMjoxNlrOIApkCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNTowMzoxNVrOIArERA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1MTg4Mg==", "bodyText": "Do any of these need cleaning up?", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537551882", "createdAt": "2020-12-07T14:32:16Z", "author": {"login": "andreipaduroiu"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "diffHunk": "@@ -94,4 +136,69 @@ public void writeAndReadBackAMessageWithTlsAndAuthEnabledServer() {\n         String readMessage = TestUtils.readNextEventMessage(scopeName, streamName, readerClientConfig, readerGroupName);\n         assertEquals(testMessage, readMessage);\n     }\n+\n+    @SneakyThrows\n+    @Test\n+    public void restApiInvocationWithSecurityEnabled() {\n+        String restApiUser = \"rest-api-user\";\n+        String restApiUserPwd = \"super-secret\";\n+\n+        final Map<String, String> passwordInputFileEntries = new HashMap<>();\n+        passwordInputFileEntries.put(\"restApiUser\", \"prn::*,READ_UPDATE\");\n+\n+        // Setup and start the cluster\n+        @Cleanup\n+        ClusterWrapper cluster = ClusterWrapper.builder()\n+                .controllerRestEnabled(true)\n+\n+                // Auth related configs\n+                .authEnabled(true)\n+                .passwordAuthHandlerEntries(TestUtils.preparePasswordInputFileEntries(passwordInputFileEntries, restApiUserPwd))\n+\n+                // TLS related configs\n+                .tlsEnabled(true)\n+                .tlsServerCertificatePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_CERT_FILE_NAME)\n+                .tlsServerKeyPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_PRIVATE_KEY_FILE_NAME)\n+                .tlsHostVerificationEnabled(false)\n+                .tlsServerKeystorePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_KEYSTORE_NAME)\n+                .tlsServerKeystorePasswordPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_PASSWORD_FILE_NAME)\n+\n+                .build();\n+        cluster.start();\n+\n+        // Setup REST client config\n+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();\n+        clientConfig.register(JacksonJsonProvider.class);\n+        clientConfig.property(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n+        clientConfig.register(HttpAuthenticationFeature.basic(restApiUser, restApiUserPwd));\n+\n+        // Prepare a TLS context with truststore containing the signing CA's vertificate\n+        KeyStore trustStore = createTrustStore(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_CA_CERT_FILE_NAME);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(trustStore);\n+        SSLContext tlsContext = SSLContext.getInstance(\"TLS\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b00f95c0245861e410b3e69298c1f7f49f44fe8"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU2NTg5Mg==", "bodyText": "It looks good to me. It's creating a truststore containing the CA certificate, so that the server certificate can be trusted by the client.", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537565892", "createdAt": "2020-12-07T14:50:11Z", "author": {"login": "ravisharda"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "diffHunk": "@@ -94,4 +136,69 @@ public void writeAndReadBackAMessageWithTlsAndAuthEnabledServer() {\n         String readMessage = TestUtils.readNextEventMessage(scopeName, streamName, readerClientConfig, readerGroupName);\n         assertEquals(testMessage, readMessage);\n     }\n+\n+    @SneakyThrows\n+    @Test\n+    public void restApiInvocationWithSecurityEnabled() {\n+        String restApiUser = \"rest-api-user\";\n+        String restApiUserPwd = \"super-secret\";\n+\n+        final Map<String, String> passwordInputFileEntries = new HashMap<>();\n+        passwordInputFileEntries.put(\"restApiUser\", \"prn::*,READ_UPDATE\");\n+\n+        // Setup and start the cluster\n+        @Cleanup\n+        ClusterWrapper cluster = ClusterWrapper.builder()\n+                .controllerRestEnabled(true)\n+\n+                // Auth related configs\n+                .authEnabled(true)\n+                .passwordAuthHandlerEntries(TestUtils.preparePasswordInputFileEntries(passwordInputFileEntries, restApiUserPwd))\n+\n+                // TLS related configs\n+                .tlsEnabled(true)\n+                .tlsServerCertificatePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_CERT_FILE_NAME)\n+                .tlsServerKeyPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_PRIVATE_KEY_FILE_NAME)\n+                .tlsHostVerificationEnabled(false)\n+                .tlsServerKeystorePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_KEYSTORE_NAME)\n+                .tlsServerKeystorePasswordPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_PASSWORD_FILE_NAME)\n+\n+                .build();\n+        cluster.start();\n+\n+        // Setup REST client config\n+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();\n+        clientConfig.register(JacksonJsonProvider.class);\n+        clientConfig.property(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n+        clientConfig.register(HttpAuthenticationFeature.basic(restApiUser, restApiUserPwd));\n+\n+        // Prepare a TLS context with truststore containing the signing CA's vertificate\n+        KeyStore trustStore = createTrustStore(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_CA_CERT_FILE_NAME);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(trustStore);\n+        SSLContext tlsContext = SSLContext.getInstance(\"TLS\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1MTg4Mg=="}, "originalCommit": {"oid": "9b00f95c0245861e410b3e69298c1f7f49f44fe8"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU3NjUxNg==", "bodyText": "Also, this is where we read certs from files, and we close the stream there:\n\n  \n    \n      pravega/common/src/main/java/io/pravega/common/util/CertificateUtils.java\n    \n    \n        Lines 40 to 47\n      in\n      2e70f87\n    \n    \n    \n    \n\n        \n          \n           public static X509Certificate[] extractCerts(String certFilePath) \n        \n\n        \n          \n                   throws CertificateException, IOException { \n        \n\n        \n          \n               Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\"); \n        \n\n        \n          \n            \n        \n\n        \n          \n               try (FileInputStream is = new FileInputStream(new File(certFilePath))) { \n        \n\n        \n          \n                   return extractCerts(is); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           }", "url": "https://github.com/pravega/pravega/pull/5389#discussion_r537576516", "createdAt": "2020-12-07T15:03:15Z", "author": {"login": "ravisharda"}, "path": "test/integration/src/test/java/io/pravega/test/integration/ClusterWrapperTest.java", "diffHunk": "@@ -94,4 +136,69 @@ public void writeAndReadBackAMessageWithTlsAndAuthEnabledServer() {\n         String readMessage = TestUtils.readNextEventMessage(scopeName, streamName, readerClientConfig, readerGroupName);\n         assertEquals(testMessage, readMessage);\n     }\n+\n+    @SneakyThrows\n+    @Test\n+    public void restApiInvocationWithSecurityEnabled() {\n+        String restApiUser = \"rest-api-user\";\n+        String restApiUserPwd = \"super-secret\";\n+\n+        final Map<String, String> passwordInputFileEntries = new HashMap<>();\n+        passwordInputFileEntries.put(\"restApiUser\", \"prn::*,READ_UPDATE\");\n+\n+        // Setup and start the cluster\n+        @Cleanup\n+        ClusterWrapper cluster = ClusterWrapper.builder()\n+                .controllerRestEnabled(true)\n+\n+                // Auth related configs\n+                .authEnabled(true)\n+                .passwordAuthHandlerEntries(TestUtils.preparePasswordInputFileEntries(passwordInputFileEntries, restApiUserPwd))\n+\n+                // TLS related configs\n+                .tlsEnabled(true)\n+                .tlsServerCertificatePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_CERT_FILE_NAME)\n+                .tlsServerKeyPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_PRIVATE_KEY_FILE_NAME)\n+                .tlsHostVerificationEnabled(false)\n+                .tlsServerKeystorePath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_SERVER_KEYSTORE_NAME)\n+                .tlsServerKeystorePasswordPath(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_PASSWORD_FILE_NAME)\n+\n+                .build();\n+        cluster.start();\n+\n+        // Setup REST client config\n+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();\n+        clientConfig.register(JacksonJsonProvider.class);\n+        clientConfig.property(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n+        clientConfig.register(HttpAuthenticationFeature.basic(restApiUser, restApiUserPwd));\n+\n+        // Prepare a TLS context with truststore containing the signing CA's vertificate\n+        KeyStore trustStore = createTrustStore(TestUtils.pathToConfig() + SecurityConfigDefaults.TLS_CA_CERT_FILE_NAME);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(trustStore);\n+        SSLContext tlsContext = SSLContext.getInstance(\"TLS\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1MTg4Mg=="}, "originalCommit": {"oid": "9b00f95c0245861e410b3e69298c1f7f49f44fe8"}, "originalPosition": 156}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4573, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}