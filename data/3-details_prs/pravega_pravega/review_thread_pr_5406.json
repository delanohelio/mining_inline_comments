{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzOTkxNjM0", "number": 5406, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzozNTo0MVrOFCCu1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDowMjo0N1rOFCDO2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njg2MjMwOnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzozNTo0MVrOIA_18Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzozNTo0MVrOIA_18Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNjkxMw==", "bodyText": "Let's add a debug/warn log here so we can keep track of such cases.", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537916913", "createdAt": "2020-12-07T23:35:41Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -502,15 +515,63 @@ private long deserializeValue(ByteArraySegment value) {\n                         \"Attribute Index Segment has not been created yet. Cannot read %d byte(s) from offset (%d).\",\n                         length, offset)));\n             }\n-        } else {\n-            byte[] buffer = new byte[length];\n-            return this.storage.read(handle, offset, buffer, 0, length, timeout)\n-                               .thenApplyAsync(bytesRead -> {\n-                                   Preconditions.checkArgument(length == bytesRead, \"Unexpected number of bytes read.\");\n-                                   storeInCache(offset, buffer);\n-                                   return new ByteArraySegment(buffer);\n-                               }, this.executor);\n         }\n+\n+        return readPageFromStorage(handle, offset, length, timeout);\n+    }\n+\n+    /**\n+     * Reads a BTreeIndex page from Storage and inserts its into the cache (no cache lookups are performed).\n+     * Handles read concurrency on the same page by piggybacking on existing running reads on that page (identified by\n+     * page offset). If more than one concurrent request is issued for the same page, only one will be sent to Storage,\n+     * and subsequent ones will be attached to the original one.\n+     *\n+     * @param handle  {@link SegmentHandle} to read from.\n+     * @param offset  Page offset.\n+     * @param length  Page length.\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that will contain the result.\n+     */\n+    @VisibleForTesting\n+    CompletableFuture<ByteArraySegment> readPageFromStorage(SegmentHandle handle, long offset, int length, Duration timeout) {\n+        PendingRead pr;\n+        synchronized (this.pendingReads) {\n+            pr = this.pendingReads.get(offset);\n+            if (pr == null) {\n+                // Nobody else waiting for this offset. Register ourselves.\n+                pr = new PendingRead(offset, length);\n+                pr.completion.whenComplete((r, ex) -> {\n+                    // Cleanup.\n+                    synchronized (this.pendingReads) {\n+                        this.pendingReads.remove(offset);\n+                    }\n+                });\n+                this.pendingReads.put(offset, pr);\n+            } else if (pr.length < length) {\n+                // Somehow the previous request wanted to read less than us. This shouldn't be the case, yet it is\n+                // a situation we should handle. In his case, we will not be recording the PendingRead.\n+                pr = new PendingRead(offset, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njk0NDI1OnYy", "diffSide": "RIGHT", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDowMjo0N1rOIBAjNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoxMjoyMFrOIBAxwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyODUwMQ==", "bodyText": "What happens when page is evicted ?\nI think here when page is evicted from cache we need to remove that offset from pendingReads , otherwise next time we need to reload the page again we'll have a stale completed future from the last time and we won't really read anything - leaving cache with missing data.", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537928501", "createdAt": "2020-12-08T00:02:47Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -502,15 +515,63 @@ private long deserializeValue(ByteArraySegment value) {\n                         \"Attribute Index Segment has not been created yet. Cannot read %d byte(s) from offset (%d).\",\n                         length, offset)));\n             }\n-        } else {\n-            byte[] buffer = new byte[length];\n-            return this.storage.read(handle, offset, buffer, 0, length, timeout)\n-                               .thenApplyAsync(bytesRead -> {\n-                                   Preconditions.checkArgument(length == bytesRead, \"Unexpected number of bytes read.\");\n-                                   storeInCache(offset, buffer);\n-                                   return new ByteArraySegment(buffer);\n-                               }, this.executor);\n         }\n+\n+        return readPageFromStorage(handle, offset, length, timeout);\n+    }\n+\n+    /**\n+     * Reads a BTreeIndex page from Storage and inserts its into the cache (no cache lookups are performed).\n+     * Handles read concurrency on the same page by piggybacking on existing running reads on that page (identified by\n+     * page offset). If more than one concurrent request is issued for the same page, only one will be sent to Storage,\n+     * and subsequent ones will be attached to the original one.\n+     *\n+     * @param handle  {@link SegmentHandle} to read from.\n+     * @param offset  Page offset.\n+     * @param length  Page length.\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that will contain the result.\n+     */\n+    @VisibleForTesting\n+    CompletableFuture<ByteArraySegment> readPageFromStorage(SegmentHandle handle, long offset, int length, Duration timeout) {\n+        PendingRead pr;\n+        synchronized (this.pendingReads) {\n+            pr = this.pendingReads.get(offset);\n+            if (pr == null) {\n+                // Nobody else waiting for this offset. Register ourselves.\n+                pr = new PendingRead(offset, length);\n+                pr.completion.whenComplete((r, ex) -> {\n+                    // Cleanup.\n+                    synchronized (this.pendingReads) {\n+                        this.pendingReads.remove(offset);\n+                    }\n+                });\n+                this.pendingReads.put(offset, pr);\n+            } else if (pr.length < length) {\n+                // Somehow the previous request wanted to read less than us. This shouldn't be the case, yet it is\n+                // a situation we should handle. In his case, we will not be recording the PendingRead.\n+                pr = new PendingRead(offset, length);\n+            } else {\n+                // Piggyback on the existing read.\n+                return pr.completion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMjIyNA==", "bodyText": "Oops my bad.\nNever mind - I now see it is removed on line 546. Thanks", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537932224", "createdAt": "2020-12-08T00:12:20Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -502,15 +515,63 @@ private long deserializeValue(ByteArraySegment value) {\n                         \"Attribute Index Segment has not been created yet. Cannot read %d byte(s) from offset (%d).\",\n                         length, offset)));\n             }\n-        } else {\n-            byte[] buffer = new byte[length];\n-            return this.storage.read(handle, offset, buffer, 0, length, timeout)\n-                               .thenApplyAsync(bytesRead -> {\n-                                   Preconditions.checkArgument(length == bytesRead, \"Unexpected number of bytes read.\");\n-                                   storeInCache(offset, buffer);\n-                                   return new ByteArraySegment(buffer);\n-                               }, this.executor);\n         }\n+\n+        return readPageFromStorage(handle, offset, length, timeout);\n+    }\n+\n+    /**\n+     * Reads a BTreeIndex page from Storage and inserts its into the cache (no cache lookups are performed).\n+     * Handles read concurrency on the same page by piggybacking on existing running reads on that page (identified by\n+     * page offset). If more than one concurrent request is issued for the same page, only one will be sent to Storage,\n+     * and subsequent ones will be attached to the original one.\n+     *\n+     * @param handle  {@link SegmentHandle} to read from.\n+     * @param offset  Page offset.\n+     * @param length  Page length.\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that will contain the result.\n+     */\n+    @VisibleForTesting\n+    CompletableFuture<ByteArraySegment> readPageFromStorage(SegmentHandle handle, long offset, int length, Duration timeout) {\n+        PendingRead pr;\n+        synchronized (this.pendingReads) {\n+            pr = this.pendingReads.get(offset);\n+            if (pr == null) {\n+                // Nobody else waiting for this offset. Register ourselves.\n+                pr = new PendingRead(offset, length);\n+                pr.completion.whenComplete((r, ex) -> {\n+                    // Cleanup.\n+                    synchronized (this.pendingReads) {\n+                        this.pendingReads.remove(offset);\n+                    }\n+                });\n+                this.pendingReads.put(offset, pr);\n+            } else if (pr.length < length) {\n+                // Somehow the previous request wanted to read less than us. This shouldn't be the case, yet it is\n+                // a situation we should handle. In his case, we will not be recording the PendingRead.\n+                pr = new PendingRead(offset, length);\n+            } else {\n+                // Piggyback on the existing read.\n+                return pr.completion;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyODUwMQ=="}, "originalCommit": {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4595, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}