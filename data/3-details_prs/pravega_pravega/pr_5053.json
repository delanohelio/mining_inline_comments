{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NjI5NjQ1", "number": 5053, "title": "Issue 5039: (SegmentStore) RollingStorage can trim Header Chunk on FileSystemStorage", "bodyText": "Change log description\n\nAdded generic API to \"atomically replace\" a Storage segment contents with provided data.\nMaking use of this API in RollingStorage to trim Header Chunk after a Segment Truncation that removes one or more chunks.\nThis has only been implemented for FileSystemStorage and only if filesystem.replace.enable is set to true.\n\nPurpose of the change\nFixes #5039.\nWhat the code does\n\nSyncStorage: added some APIs to explicitly check for and enable atomic replace support.\n\nThe withReplaceSupport has been added to make sure that only code that actually requires this feature uses it and to prevent any associated overhead and/or side effects from spilling over to other types of segment chunks\n\n\nRollingStorage\n\nUsing base SyncStorage for all data chunk manipulation (same as before).\nUsing SyncStorage.withStorageSupport (if available) for Header Chunk manipulation.\nReplacing Header Chunk with updated one after each Segment Truncation that deletes chunks.\n\n\nFileSystemStorage\n\nImplemented a FileSystemStorageWithReplaceSupport derived class that enables atomic replace. Please refer to this class' documentation for methodology.\nSince this operation is multi-step and non-atomic, we need to handle the fallout from any partially executed operation and recover that the next time we use the touched segment.\nIt is due to this recovery process that the best place to encapsulate this feature is at the LTS Storage adapter level, and it is also due to this that we should restrict it to Header Chunks alone (this extra code may add slight runtime overhead for frequently used data chunks - Header LTS operations are a fraction of total LTS operations).\n\n\n\nTHIS DOES NOT AFFECT ChunkStorageProvider. It is restricted to RollingStorage alone.\nHow to verify it\nAll tests must pass.\nNew tests added to verify functionality.", "createdAt": "2020-08-10T17:19:14Z", "url": "https://github.com/pravega/pravega/pull/5053", "merged": true, "mergeCommit": {"oid": "71f6a5e0045a76da08ffdb3868f2c7e9e9d2f666"}, "closed": true, "closedAt": "2020-08-17T15:37:10Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8onVJAH2gAyNDY1NjI5NjQ1OjE3M2U1YzZhYTYzYzY1NDA4NDc3YTU4MjM1OWEzYmNjZjM4OWE4MmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-1vmkgH2gAyNDY1NjI5NjQ1OjJmNTAzNWQzNzg2MjIwODJiMTQ3NmRiZmE5ODFhMDQ1MTZiNjQwZmQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "173e5c6aa63c65408477a582359a3bccf389a82a", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/173e5c6aa63c65408477a582359a3bccf389a82a", "committedDate": "2020-08-07T18:20:42Z", "message": "Added ability to \"atomically\" replace files in FileSystemStorage. No unit tests yet.\nRollingStorage: Partially wired in the replace-enabled SyncStorage. Not yet wired up for truncation.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "294649cbc6dc7af055e748efda756278b8d26b48", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/294649cbc6dc7af055e748efda756278b8d26b48", "committedDate": "2020-08-07T21:24:04Z", "message": "Unit tests for FileSystemStorage.FileSystemStorageWithReplace. Several bugs were fixed as well.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d44db476ff46a6b28e903784dc3f028e7fe93b46", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d44db476ff46a6b28e903784dc3f028e7fe93b46", "committedDate": "2020-08-07T21:29:29Z", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fc78bd4e25551f870f82b5f24b90751aa8f43a0", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/9fc78bd4e25551f870f82b5f24b90751aa8f43a0", "committedDate": "2020-08-10T17:10:34Z", "message": "Integrated in RollingStorage.\nAdded enable/disable config setting.\nUnit tests.\nIntegration tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "728de99d4a9fa1c61bb9dc67ca20fbd89d724f55", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/728de99d4a9fa1c61bb9dc67ca20fbd89d724f55", "committedDate": "2020-08-10T19:12:49Z", "message": "Code coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b24c90f94879d78425af426fc43bb7068ae73e65", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b24c90f94879d78425af426fc43bb7068ae73e65", "committedDate": "2020-08-10T19:13:55Z", "message": "Code coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "committedDate": "2020-08-10T19:14:28Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-5039-trim-header-file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzYzNTQ3", "url": "https://github.com/pravega/pravega/pull/5053#pullrequestreview-465763547", "createdAt": "2020-08-12T09:53:26Z", "commit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo1MzoyNlrOG_aQRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDo0MzoyOFrOG_bz7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MzYyMg==", "bodyText": "It might be a big annoying change, but I'd rather adhere to standard terminology and use rename instead of replace. The rename operation according to the standard (POSIX - IEEE Std 1003.1-2017) says [1]:\n\nIf the link named by the new argument exists, it shall be removed and old renamed to new\n\nso it captures the semantics we want. We are not trying to follow the standard strictly here, but sticking to terminology.\n[1] https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469143622", "createdAt": "2020-08-12T09:53:26Z", "author": {"login": "fpj"}, "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/SyncStorage.java", "diffHunk": "@@ -216,6 +216,40 @@ default SegmentHandle create(String streamSegmentName, SegmentRollingPolicy roll\n      */\n     boolean supportsTruncation();\n \n+    /**\n+     * Gets a value indicating whether this {@link SyncStorage} implementation can replace whole Segments with new contents.\n+     *\n+     * @return True or false.\n+     */\n+    default boolean supportsReplace() {\n+        return false;\n+    }\n+\n+    /**\n+     * Replaces a Segment with the given contents.  Please refer to the actual implementing class for more details with\n+     * respect to behavior, atomicity and recovery mechanisms.\n+     *\n+     * @param segment A {@link SegmentHandle} representing the Segment to replace.\n+     * @param contents A {@link BufferView} representing the new contents of the Segment.\n+     * @throws StreamSegmentNotExistsException When the given Segment does not exist in Storage.\n+     * @throws StorageNotPrimaryException      When this Storage instance is no longer primary for this Segment (it was\n+     *                                         fenced out).\n+     * @throws UnsupportedOperationException   If {@link #supportsReplace()} returns false.\n+     */\n+    default void replace(SegmentHandle segment, BufferView contents) throws StreamSegmentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0ODkyMQ==", "bodyText": "Since this case is not the regular, expected path, I'd say this log message is at least info.", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469148921", "createdAt": "2020-08-12T10:03:04Z", "author": {"login": "fpj"}, "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6"}, "originalPosition": 398}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1MDQyMw==", "bodyText": "Same suggestion about the severity of the log message.", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469150423", "createdAt": "2020-08-12T10:06:01Z", "author": {"login": "fpj"}, "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);\n+                    super.doDelete(super.doOpenWrite(tmpSegmentName));\n+                } else {\n+                    // Temp file exists, but the segment file does not. This may be the result of an incomplete replace,\n+                    // in which case we need to finalize that one to prevent deleting (what could be) the only persisted\n+                    // copy of our data.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Finalizing before new replace attempt.\", segmentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MjI2OA==", "bodyText": "When we say On Windows..., is it referring to the Windows implementation of the JVM or a Windows file system (FAT, NTFS)? I ask because it is the LTS implementation that needs to implement rename, right?\nAlso, is the behavior reflected here documented anywhere we can point to or was this validated manually?", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469162268", "createdAt": "2020-08-12T10:29:13Z", "author": {"login": "fpj"}, "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);\n+                    super.doDelete(super.doOpenWrite(tmpSegmentName));\n+                } else {\n+                    // Temp file exists, but the segment file does not. This may be the result of an incomplete replace,\n+                    // in which case we need to finalize that one to prevent deleting (what could be) the only persisted\n+                    // copy of our data.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Finalizing before new replace attempt.\", segmentName);\n+                    finalizeRename(tmpSegmentName, segmentName);\n+                }\n+            } else if (!baseExists) {\n+                throw new StreamSegmentNotExistsException(segmentName);\n+            }\n+\n+            // Write given contents to temp file.\n+            val tmpHandle = super.doCreate(tmpSegmentName);\n+            try {\n+                super.doWrite(tmpHandle, 0, contents.getReader(), contents.getLength());\n+                if (shouldReseal) {\n+                    super.doSeal(tmpHandle);\n+                }\n+            } catch (Exception ex) {\n+                log.warn(\"Unable to write to temporary file when attempting to replace '{}'. Original file has not been touched. Cleaning up.\",\n+                        segmentName, ex);\n+                super.doDelete(tmpHandle);\n+                throw ex;\n+            }\n+\n+            // Sanity check #1 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(tmpSegmentName).getLength() == contents.getLength();\n+\n+            // Rename file. After this is done, the replace operation is complete.\n+            finalizeRename(tmpSegmentName, segmentName);\n+\n+            // Sanity check #2 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(segmentName).getLength() == contents.getLength();\n+            return null;\n+        }\n+\n+        @SneakyThrows(StreamSegmentReplaceException.class)\n+        private void finalizeRename(String fromSegmentName, String toSegmentName) {\n+            val fromFile = getPath(fromSegmentName).toFile().getAbsoluteFile();\n+            val toFile = getPath(toSegmentName).toFile().getAbsoluteFile();\n+            boolean renamed = fromFile.renameTo(toFile);\n+            if (!renamed) {\n+                // On Windows, renameTo does not replace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6"}, "originalPosition": 442}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2NjA0Mw==", "bodyText": "Maybe add a debug or trace log to record the rename.", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469166043", "createdAt": "2020-08-12T10:36:52Z", "author": {"login": "fpj"}, "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);\n+                    super.doDelete(super.doOpenWrite(tmpSegmentName));\n+                } else {\n+                    // Temp file exists, but the segment file does not. This may be the result of an incomplete replace,\n+                    // in which case we need to finalize that one to prevent deleting (what could be) the only persisted\n+                    // copy of our data.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Finalizing before new replace attempt.\", segmentName);\n+                    finalizeRename(tmpSegmentName, segmentName);\n+                }\n+            } else if (!baseExists) {\n+                throw new StreamSegmentNotExistsException(segmentName);\n+            }\n+\n+            // Write given contents to temp file.\n+            val tmpHandle = super.doCreate(tmpSegmentName);\n+            try {\n+                super.doWrite(tmpHandle, 0, contents.getReader(), contents.getLength());\n+                if (shouldReseal) {\n+                    super.doSeal(tmpHandle);\n+                }\n+            } catch (Exception ex) {\n+                log.warn(\"Unable to write to temporary file when attempting to replace '{}'. Original file has not been touched. Cleaning up.\",\n+                        segmentName, ex);\n+                super.doDelete(tmpHandle);\n+                throw ex;\n+            }\n+\n+            // Sanity check #1 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(tmpSegmentName).getLength() == contents.getLength();\n+\n+            // Rename file. After this is done, the replace operation is complete.\n+            finalizeRename(tmpSegmentName, segmentName);\n+\n+            // Sanity check #2 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(segmentName).getLength() == contents.getLength();\n+            return null;\n+        }\n+\n+        @SneakyThrows(StreamSegmentReplaceException.class)\n+        private void finalizeRename(String fromSegmentName, String toSegmentName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6"}, "originalPosition": 437}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2OTEzNA==", "bodyText": "This is the only call that feels odd when comparing to the other calls in the interface. To be able to get rid of it, we would need to make FileSystemStorage support it directly rather than have a derived class FileSystemStorageWithReplace, which seems possible and it is not clear to me whether it is incorrect or simply undesirable.", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469169134", "createdAt": "2020-08-12T10:43:28Z", "author": {"login": "fpj"}, "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/SyncStorage.java", "diffHunk": "@@ -216,6 +216,40 @@ default SegmentHandle create(String streamSegmentName, SegmentRollingPolicy roll\n      */\n     boolean supportsTruncation();\n \n+    /**\n+     * Gets a value indicating whether this {@link SyncStorage} implementation can replace whole Segments with new contents.\n+     *\n+     * @return True or false.\n+     */\n+    default boolean supportsReplace() {\n+        return false;\n+    }\n+\n+    /**\n+     * Replaces a Segment with the given contents.  Please refer to the actual implementing class for more details with\n+     * respect to behavior, atomicity and recovery mechanisms.\n+     *\n+     * @param segment A {@link SegmentHandle} representing the Segment to replace.\n+     * @param contents A {@link BufferView} representing the new contents of the Segment.\n+     * @throws StreamSegmentNotExistsException When the given Segment does not exist in Storage.\n+     * @throws StorageNotPrimaryException      When this Storage instance is no longer primary for this Segment (it was\n+     *                                         fenced out).\n+     * @throws UnsupportedOperationException   If {@link #supportsReplace()} returns false.\n+     */\n+    default void replace(SegmentHandle segment, BufferView contents) throws StreamSegmentException {\n+        throw new UnsupportedOperationException(\"replace() is not implemented\");\n+    }\n+\n+    /**\n+     * Returns a new {@link SyncStorage} instance for the same Storage type as this one, but with {@link #replace} support\n+     * enabled. If there is no such implementation, this instance is returned.\n+     *\n+     * @return Either this instance or a new {@link SyncStorage} instance based on this one that can perform replaces.\n+     */\n+    default SyncStorage withReplaceSupport() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "144d7770ccbd19b340e4a23552d89a9179d09571", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/144d7770ccbd19b340e4a23552d89a9179d09571", "committedDate": "2020-08-12T15:13:20Z", "message": "More logging.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ab3905766b9d2bc9aeafb3262f720819d8078ef", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/4ab3905766b9d2bc9aeafb3262f720819d8078ef", "committedDate": "2020-08-12T22:27:36Z", "message": "Merge branch 'master' into issue-5039-trim-header-file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9cf0cc375fd247b4e30dd7b1dfb6d0dd919500b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b9cf0cc375fd247b4e30dd7b1dfb6d0dd919500b", "committedDate": "2020-08-13T14:40:30Z", "message": "Merge branch 'master' into issue-5039-trim-header-file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODQzNjI2", "url": "https://github.com/pravega/pravega/pull/5053#pullrequestreview-466843626", "createdAt": "2020-08-13T14:56:21Z", "commit": {"oid": "b9cf0cc375fd247b4e30dd7b1dfb6d0dd919500b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDo1NjoyMVrOHAPa8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDo1NjoyMVrOHAPa8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxNDcwNw==", "bodyText": "To confirm one thing: are we omitting this configuration in config.properties intentionally?\nAlso, is the full property name filesystem.replace.enable?\nAnd, to be consistent with other properties, it should be enable rather than enabled.", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r470014707", "createdAt": "2020-08-13T14:56:21Z", "author": {"login": "fpj"}, "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorageConfig.java", "diffHunk": "@@ -24,6 +24,7 @@\n     //region Config Names\n \n     public static final Property<String> ROOT = Property.named(\"root\", \"/fs/\");\n+    public static final Property<Boolean> REPLACE_ENABLED = Property.named(\"replace.enabled\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9cf0cc375fd247b4e30dd7b1dfb6d0dd919500b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c94bf9974d48d2fc01dac7ff76401c0d92e106d7", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/c94bf9974d48d2fc01dac7ff76401c0d92e106d7", "committedDate": "2020-08-13T15:34:47Z", "message": "Fixed config property name.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODkyMjY1", "url": "https://github.com/pravega/pravega/pull/5053#pullrequestreview-466892265", "createdAt": "2020-08-13T15:49:15Z", "commit": {"oid": "c94bf9974d48d2fc01dac7ff76401c0d92e106d7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "821e52427fcf8ee2f999e089544f8f6fd9313e83", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/821e52427fcf8ee2f999e089544f8f6fd9313e83", "committedDate": "2020-08-13T22:09:25Z", "message": "Merge branch 'master' into issue-5039-trim-header-file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cc55788c7ba3e6a598c86057671da01b2107827", "author": {"user": {"login": "fpj", "name": "Flavio Junqueira"}}, "url": "https://github.com/pravega/pravega/commit/3cc55788c7ba3e6a598c86057671da01b2107827", "committedDate": "2020-08-14T10:13:50Z", "message": "Merge branch 'master' into issue-5039-trim-header-file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f5035d378622082b1476dbfa981a04516b640fd", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/2f5035d378622082b1476dbfa981a04516b640fd", "committedDate": "2020-08-14T14:46:21Z", "message": "Merge branch 'master' into issue-5039-trim-header-file"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4028, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}