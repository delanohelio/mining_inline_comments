{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyOTc2MjA2", "number": 4768, "title": "Issue 4774: Optimize reader computations", "bodyText": "Change log description\nThis PR saves up compute cycles for a reader by minimizing and optimizing calls to several costly functions related to manage its internal state.\nPurpose of the change\nFixes #4774.\nWhat the code does\nThis PR attempts to minimize the number of calls to the following methods:\n\n\ndoesReaderOwnTooManySegments(): This method calculates whether a reader is owning too many segments, so it can release them and let other readers to acquire them. However, this method involves a non-negligible computation and is being evaluated on a per-event read basis (readNextEventInternal() -> updateGroupStateIfNeeded() -> acquireNewSegmentsIfNeeded() -> shouldAcquireSegment()). This PR drastically reduces the number of calls to this method by executing it only when the appropriate timers are consumed.\n\n\nWe now also reuse the same segment ranges map in EventStreamReaderImpl for multiple PositionImpl objects, until there is a change in segments. When this happens, we just create a new ranges map (i.e., this map has a \"copy-on-write\" behavior).\n\n\ngetCheckpointForReader(): In method shouldAcquireSegment(), readers also execute getCheckpointForReader(). The number of calls to this method has been reduced by executing it only when the appropriate timers are consumed. Besides, the actual implementation of this method has been optimized (e.g., keeping a sorted list of checkpoints for reader to directly get the min checkpoint).\n\n\ngetPosition(): The other important performance bottleneck is the execution of getPosition() per event read. Before, this method was called twice per event read (in readNextEventInternal() as part of the return object of the function and in updateGroupStateIfNeeded()). This PR reduces drastically the number of calls to this method as follows:\n\nEventStreamReaderImpl has now two new fields called ownedSegments and segmentOffsetUpdates that will be used to build PositionImpl objects.\nWe cannot avoid \"refreshing\" ownedSegments and segmentOffsetUpdates every time that there is a change in the segments owned for a reader (e.g., truncation, checkpoint, end of segment,...). This has a similar cost to the former getPosition() method, but it happens rarely compared to the number of event read.\nWhenever there is no change in the segments owned for a reader (general case), is when the optimization comes into play. In this case, EventStreamReaderImpl keeps ownedSegments in the same state and for every new event read it appends a new element in segmentOffsetUpdates, indicating the new offset for the event read on a segment. As you may infer, this has a constant cost (i.e., one list append) compared to the previous call to getPosition() which required to generate the new ownedSegments map per event read (the cost of creating this map is in turn related to the number of owned segments). While there is no change in the segments, EventStreamReaderImpl can buffer up to MAX_BUFFERED_SEGMENT_OFFSET_UPDATES of segment updates.\nThe PositionImpl class contains two new fields: i) one to refer to segmentOffsetUpdates list and ii) another (called version) to determine the updates that should be applied for this particular PositionImpl object. That is, while N PositionImpl objects with refer to the same list of segmentOffsetUpdates, they will build their internal state by applying a subset of these updates to represent the actual point at which the event at hand was read. Moreover, the application of such updates of offsets to the internal state of PositionImpl will be executed lazily, only if this PositionImpl is used.\n\n\n\nIn terms of performance, this PR increases between 3x (1 segment) to 4x (16 segments) the throughput of a reader for small events (e.g., 100B).\nHow to verify it\nAdded new tests to verify the behavior of PositionImpl and CopyOnWriteMapUtils classes. Rest of tests should be passing as before. System tests are passing (2/2).", "createdAt": "2020-05-04T14:11:13Z", "url": "https://github.com/pravega/pravega/pull/4768", "merged": true, "mergeCommit": {"oid": "e3d71202d057be75fbcca27cbef1963195626d60"}, "closed": true, "closedAt": "2020-06-08T17:14:08Z", "author": {"login": "RaulGracia"}, "timelineItems": {"totalCount": 83, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceEjFSgBqjMzMDEzNDY3NDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpSlbagH2gAyNDEyOTc2MjA2Ojg0YjEwZWIxOThjMjlhYWJiMTcxZThlYmY1ODQ5MWYyZTVjZmNlMjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2ODczMDI4", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-406873028", "createdAt": "2020-05-06T18:21:04Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyMTowNFrOGRftew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyNzo1MFrOGRf9FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw==", "bodyText": "Using a member variable is error prone. (In fact there is a case this logic does not cover: if the segments change as a result of calling updateGroupStateIfNeeded, the next time through the above while loop it will pass in stale data resulting in an invalid state.)\nInstead it may be better to just use a local variables by computing the position on 128 an passing it into updateGroupStateIfNeeded, then modifying the offset for the segment read from before returning it.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r420998523", "createdAt": "2020-05-06T18:21:04Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +156,8 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        lastPosition = getPosition();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDY4Nw==", "bodyText": "I optimized this method, I don't think this reordering is needed anymore.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421000687", "createdAt": "2020-05-06T18:24:42Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -339,15 +348,15 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n             if (acquireTimer.hasRemaining()) {\n                 return false;\n             }\n-            if (state.getCheckpointForReader(readerId) != null) {\n-                return false;\n-            }\n             if (state.getNumberOfUnassignedSegments() == 0) {\n                 if (doesReaderOwnTooManySegments(state)) {\n                     acquireTimer.reset(calculateAcquireTime(readerId, state));\n                 }\n                 return false;\n             }\n+            if (state.getCheckpointForReader(readerId) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjUxNw==", "bodyText": "I am confused by this, because this method should only be invoked once per checkpoint interval. If that's set to say 20sec then this new time logic is totally redundant. Am I missing something?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421002517", "createdAt": "2020-05-06T18:27:50Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -213,13 +216,19 @@ Segment findSegmentToReleaseIfRequired() {\n      * the reader with the least assigned to it.\n      */\n     private boolean doesReaderOwnTooManySegments(ReaderGroupState state) {\n-        Map<String, Double> sizesOfAssignemnts = state.getRelativeSizes();\n+        // The previous calculation for this method is cached during TIME_UNIT to prevent excessive per-event computations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDA1MzA2", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-408405306", "createdAt": "2020-05-08T17:41:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo0MTowN1rOGStviA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo1NTowOVrOGSuKnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA==", "bodyText": "Replace this with a standard for loop. It will be faster.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422277000", "createdAt": "2020-05-08T17:41:07Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -97,12 +97,12 @@ void beginNewCheckpoint(String checkpointId, Set<String> currentReaders, Map<Seg\n     }\n     \n     String getCheckpointForReader(String readerName) {\n-        OptionalInt min = getCheckpointsForReader(readerName).stream().mapToInt(checkpoints::indexOf).min();\n-        if (min.isPresent()) {\n-            return checkpoints.get(min.getAsInt());\n-        } else {\n+        List<String> checkpointsForReader = getCheckpointsForReader(readerName);\n+        if (checkpointsForReader.isEmpty()) {\n             return null;\n         }\n+        OptionalInt min = checkpointsForReader.stream().mapToInt(checkpoints::indexOf).min();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzQ1NQ==", "bodyText": "This does not need to be an atomic reference, it is guarded by the readers lock, so it can be re-assigned.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422277455", "createdAt": "2020-05-08T17:42:05Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -73,16 +74,19 @@\n     private boolean closed;\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n+    // Ranges map is heavily used to build Position objects that are returned to the client. While there is no change\n+    // in segment distribution, we reuse the same map instance for performance reasons. But this map should have a\n+    // copy-on-write behavior to do not impact all the Position objects referencing the previous version of it.\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private final AtomicReference<Map<Segment, Range>> ranges = new AtomicReference<>(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3ODE3Nw==", "bodyText": "Let's make ownedSegments a List<Entry<Segment, Long>> and adapt positionImpl to store this. This will be much cheaper to construct.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422278177", "createdAt": "2020-05-08T17:43:34Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -172,11 +179,12 @@ private void blockFor(long timeoutMs) {\n     }\n \n     private PositionInternal getPosition() {\n-        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments);\n+        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments.size() + readers.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MTEzOQ==", "bodyText": "I think we can avoid this. See my comments below.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422281139", "createdAt": "2020-05-08T17:49:29Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +156,8 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        lastPosition = getPosition();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw=="}, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MzkzMw==", "bodyText": "Rather than passing this in, we can probably avoid creating it all together. position is used in four places:\n\non line 209 where the reader is checkpointing. (This is rare and we can call getPosition() inside of this if without concern)\non line 218. This is the same situation as the above. It only occurs on checkpoint.\nwhen calling acquireSegmentsIfNeeded. However this method doesn't actually use the position passed in unless a timer has passed. So perhaps having this method call shouldAquireSegment first would avoid the need for position most of the time.\nupdateLagIfNeeded here the situation is the same as the above, it's based on a timer. So we could easily have a block that does:\n\nif (shouldAquireSegment() || shouldUpdateLag()) {\n    PositionImpl position = getPosition();\n    // The code currently in lines 231-235 here.\n}", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422283933", "createdAt": "2020-05-08T17:55:09Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -196,8 +204,7 @@ private PositionInternal getPosition() {\n      * have been persisted.\n      */\n     @GuardedBy(\"readers\")\n-    private String updateGroupStateIfNeeded() throws ReaderNotInReaderGroupException {\n-        PositionInternal position = (lastPosition == null) ? getPosition() : lastPosition;\n+    private String updateGroupStateIfNeeded(PositionInternal position) throws ReaderNotInReaderGroupException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDE2NjMx", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-408416631", "createdAt": "2020-05-08T17:58:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo1ODo0OFrOGSuSDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowMzowMVrOGSuZ8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NTgzOQ==", "bodyText": "Also if the checkpoints can be ordered, we can eliminate this loop all together and just take the first element from the list.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422285839", "createdAt": "2020-05-08T17:58:48Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -97,12 +97,12 @@ void beginNewCheckpoint(String checkpointId, Set<String> currentReaders, Map<Seg\n     }\n     \n     String getCheckpointForReader(String readerName) {\n-        OptionalInt min = getCheckpointsForReader(readerName).stream().mapToInt(checkpoints::indexOf).min();\n-        if (min.isPresent()) {\n-            return checkpoints.get(min.getAsInt());\n-        } else {\n+        List<String> checkpointsForReader = getCheckpointsForReader(readerName);\n+        if (checkpointsForReader.isEmpty()) {\n             return null;\n         }\n+        OptionalInt min = checkpointsForReader.stream().mapToInt(checkpoints::indexOf).min();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA=="}, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjQ0Mg==", "bodyText": "Let's just make this into a class of it's own. It muddies things to have it here.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422286442", "createdAt": "2020-05-08T17:59:54Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -377,14 +386,36 @@ public Type fetchEvent(EventPointer pointer) throws NoSuchEventException {\n             return ImmutableList.copyOf(readers);\n         }\n     }\n-    \n+\n+    // Ranges management region", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjgxMQ==", "bodyText": "HashMap already provides a constructor that does these two lines.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422286811", "createdAt": "2020-05-08T18:00:45Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -377,14 +386,36 @@ public Type fetchEvent(EventPointer pointer) throws NoSuchEventException {\n             return ImmutableList.copyOf(readers);\n         }\n     }\n-    \n+\n+    // Ranges management region\n+\n     @VisibleForTesting\n     Map<Segment, Range> getRanges() {\n         synchronized (readers) {\n-            return ImmutableMap.copyOf(ranges);\n+            return ImmutableMap.copyOf(ranges.get());\n         }\n     }\n \n+    private void copyOnPutSegmentRange(Segment segment, Range range) {\n+        Map<Segment, Range> newRanges = copyRanges();\n+        newRanges.put(segment, range);\n+        ranges.set(newRanges);\n+    }\n+\n+    private void copyOnRemoveSegmentRange(Segment segment) {\n+        Map<Segment, Range> newRanges = copyRanges();\n+        newRanges.remove(segment);\n+        ranges.set(newRanges);\n+    }\n+\n+    private Map<Segment, Range> copyRanges() {\n+        Map<Segment, Range> newRanges = new HashMap<>(2 * ranges.get().size());\n+        newRanges.putAll(ranges.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4Nzg1Ng==", "bodyText": "Shouldn't that be Preconditions.checkArgument(multiplier >= 1, ...", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422287856", "createdAt": "2020-05-08T18:03:01Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -405,7 +403,9 @@ private int calculateNumSegmentsToAcquire(ReaderGroupState state) {\n \n     @VisibleForTesting\n     static Duration calculateAcquireTime(String readerId, ReaderGroupState state) {\n-        return TIME_UNIT.multipliedBy(state.getNumberOfReaders() - state.getRanking(readerId));\n+        int multiplier = state.getNumberOfReaders() - state.getRanking(readerId);\n+        Preconditions.checkArgument(multiplier >= TIME_UNIT.getSeconds(), \"Invalid acquire timer multiplier\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDQ2NTU5", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-408446559", "createdAt": "2020-05-08T18:46:52Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0Njo1MlrOGSvviQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo1MDo0MlrOGSv3BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwOTc2OQ==", "bodyText": "I think we can move the isReaderOnline check to below the acquireTimer.hasRemaining check.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422309769", "createdAt": "2020-05-08T18:46:52Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -343,9 +343,7 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n                 return false;\n             }\n             if (state.getNumberOfUnassignedSegments() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxMTY4NA==", "bodyText": "Having a shouldAquireSegment() on groupstate would also make this method more efficient because the call to getLag() (above) could be avoided if we don't actually need to acquire a segment.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422311684", "createdAt": "2020-05-08T18:50:42Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -272,14 +281,14 @@ private boolean acquireSegmentsIfNeeded(PositionInternal position) throws Reader\n                 long endOffset = groupState.getEndOffsetForSegment(newSegment.getKey().getSegment());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjY3OTM0", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-413267934", "createdAt": "2020-05-18T04:44:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNDo0NDowOFrOGWnXmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNToyNjowNFrOGWn7kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2Njg3NA==", "bodyText": "we can use the pattern checkpointIndex.compute(host, k -> { if k == null  } )", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426366874", "createdAt": "2020-05-18T04:44:08Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3NjA4MA==", "bodyText": "Given that ranges is guarded by readers   @GuardedBy(\"readers\") why do we need to create a copy? isn't it redundant ?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426376080", "createdAt": "2020-05-18T05:26:04Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -240,7 +277,7 @@ private void releaseSegmentsIfNeeded(PositionInternal position) throws ReaderNot\n             if (reader != null) {\n                 if (groupState.releaseSegment(segment, reader.getOffset(), getLag(), position)) {\n                     readers.remove(reader);\n-                    ranges.remove(reader.getSegmentId());\n+                    ranges = CopyOnWriteMapUtils.remove(ranges, reader.getSegmentId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNDU0NDcw", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-413454470", "createdAt": "2020-05-18T10:10:34Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDoxMDozNFrOGWwg_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDozNjo0MlrOGWxXiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUxNjczMg==", "bodyText": "the maps need to be wrapped with java.util.Collections#unmodifiableMap and the updates should be wrapped with Collections.unmodifiableList().", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426516732", "createdAt": "2020-05-18T10:10:34Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +168,18 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        addSegmentOffsetUpdateIfNeeded(segment, offset + length);\n+        return new EventReadImpl<>(deserializer.deserialize(buffer),\n+                PositionImpl.builder().ownedSegments(ownedSegments).segmentRanges(ranges).updatesToSegmentOffsets(segmentOffsetUpdates).build(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMDY5Nw==", "bodyText": "ownedSegments can be modified by the different thread while iterating here.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426530697", "createdAt": "2020-05-18T10:36:42Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -66,26 +75,29 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n \n     @Override\n     public Set<Segment> getOwnedSegments() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableSet(ownedSegments.keySet());\n     }\n \n     @Override\n     public Map<Segment, Long> getOwnedSegmentsWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableMap(ownedSegments);\n     }\n     \n     @Override\n     Map<SegmentWithRange, Long> getOwnedSegmentRangesWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         HashMap<SegmentWithRange, Long> result = new HashMap<>();\n         for (Entry<Segment, Long> entry : ownedSegments.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MjE1NDgy", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-415215482", "createdAt": "2020-05-20T10:52:43Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMDo1Mjo0NFrOGYGCPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMDo1Mjo0NFrOGYGCPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxNzg4Nw==", "bodyText": "This isn't exactly threadsafe, right? updateToSegmentOffsets can be modified in the EventStreamReaderImpl thread. Yeah, the elements are added to segmentOffsetUpdates  under a lock and the code reads only until this.version. I always try to avoid this pattern.\n@tkaitchuck  @RaulGracia thoughts?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r427917887", "createdAt": "2020-05-20T10:52:44Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +230,20 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments.set(new HashMap<>(ownedSegments.get()));\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.get().put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 161}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2ODU3MDkz", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-416857093", "createdAt": "2020-05-22T12:01:42Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a3cf0f106d3a75e7cd4063adf1077196823dae6", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/6a3cf0f106d3a75e7cd4063adf1077196823dae6", "committedDate": "2020-05-22T16:05:27Z", "message": "Reduce number of calls to doesReaderOwnTooManySegments\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49280700ad582291a307763ade2f86bf0aa1de9d", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/49280700ad582291a307763ade2f86bf0aa1de9d", "committedDate": "2020-05-22T16:05:28Z", "message": "Relate the frequency of segment load checks to the reader group state update period\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "674a28343fc0eb0879b81097050cbb5cf4fa81d0", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/674a28343fc0eb0879b81097050cbb5cf4fa81d0", "committedDate": "2020-05-22T16:05:28Z", "message": "Exploit lazy evaluation to avoid extra executions of acquireSegmentsIfNeeded.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e04373f849fb3fe4c041f88d3093ea93a49c8342", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/e04373f849fb3fe4c041f88d3093ea93a49c8342", "committedDate": "2020-05-22T16:05:29Z", "message": "Reduce number of getCheckpointForReader executions.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75dc939b0f312ffaca04da82e6f9e6e3562eea29", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/75dc939b0f312ffaca04da82e6f9e6e3562eea29", "committedDate": "2020-05-22T16:05:30Z", "message": "Undo change in condition.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b32b27de8b8197e5e3cac4e78aa5a86e8d2cf95", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/2b32b27de8b8197e5e3cac4e78aa5a86e8d2cf95", "committedDate": "2020-05-22T16:05:30Z", "message": "Use release timer instead of fetchStateTimer, as it may not give opportunities for execution to doesReaderOwnTooManySegments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f21982ddf6850a756c81db8e5d37f82d1e42b977", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/f21982ddf6850a756c81db8e5d37f82d1e42b977", "committedDate": "2020-05-22T16:05:31Z", "message": "Add precondition check on the minimum amount of acquire time.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b223cacab5b7bb9d676692f26d788f366517135b", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/b223cacab5b7bb9d676692f26d788f366517135b", "committedDate": "2020-05-22T16:05:32Z", "message": "Add a timer to control the number of doesReaderOwnTooManySegments executions.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51ba4a49ff4ea706b67c18e23eb9916fce889290", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/51ba4a49ff4ea706b67c18e23eb9916fce889290", "committedDate": "2020-05-22T16:05:32Z", "message": "Reduce watermarking related compute cycles if watermarking is not enabled.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "081c0b0ac446d0595fa985e1254ffd99e98e8426", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/081c0b0ac446d0595fa985e1254ffd99e98e8426", "committedDate": "2020-05-22T16:05:33Z", "message": "Undo condition change based on watermarking readers.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a7bcf83a14bb3be8f29e2015cff870156553923", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/9a7bcf83a14bb3be8f29e2015cff870156553923", "committedDate": "2020-05-22T16:05:33Z", "message": "Cache result of doesReaderOwnTooManySegments to do not execute it so frequently.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f432709d02031d350dda7f92e11539fe27dc7f0", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/5f432709d02031d350dda7f92e11539fe27dc7f0", "committedDate": "2020-05-22T16:05:35Z", "message": "Fix comment.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e070ae05b0eb724a23f186bbbac79079727dc66", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/0e070ae05b0eb724a23f186bbbac79079727dc66", "committedDate": "2020-05-22T16:05:36Z", "message": "Removed unnecessary else in condition.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5622a1e2e951144286b1e2ee44ff6b2f2b854e9", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/c5622a1e2e951144286b1e2ee44ff6b2f2b854e9", "committedDate": "2020-05-22T16:05:36Z", "message": "Fix checkstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b0683907031998d373fadc518408280bc8bb41e", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/9b0683907031998d373fadc518408280bc8bb41e", "committedDate": "2020-05-22T16:05:37Z", "message": "Test reusing last getPostion call.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "254799955167e45a2af3e29e9965849de940228f", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/254799955167e45a2af3e29e9965849de940228f", "committedDate": "2020-05-22T16:05:37Z", "message": "Update lastPosition upon a segment change in updateGroupStateIfNeeded().\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e64bf9696d1ed1e99286f75af7412d63b2f47ab9", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/e64bf9696d1ed1e99286f75af7412d63b2f47ab9", "committedDate": "2020-05-22T16:05:38Z", "message": "Update last position after end of segment or segment truncated.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d79279032c5df7ffaa8d829008825d9b9b52597", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/1d79279032c5df7ffaa8d829008825d9b9b52597", "committedDate": "2020-05-22T16:05:38Z", "message": "Attempting some improvements on getCheckpointForReader and re-using segment ranges without creating new maps for every event.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af307dcf42d3b0816cb08c13934cd3e26176e657", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/af307dcf42d3b0816cb08c13934cd3e26176e657", "committedDate": "2020-05-22T16:05:39Z", "message": "Fix tests.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c239531c5fe2489c10452d1750ab9d820cc19f7", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/5c239531c5fe2489c10452d1750ab9d820cc19f7", "committedDate": "2020-05-22T16:05:40Z", "message": "Most changes from PR comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faccb9438e07c67d04bbe01f4a2ac6adf6fe92ab", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/faccb9438e07c67d04bbe01f4a2ac6adf6fe92ab", "committedDate": "2020-05-22T16:05:40Z", "message": "Minor changes.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e3d424c8a99759e87f0c54d3b37aa23718c69a0", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/4e3d424c8a99759e87f0c54d3b37aa23718c69a0", "committedDate": "2020-05-22T16:05:41Z", "message": "Fixed import.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "699b3430d771f0e025a2626d0f83cb2b2af9ff47", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/699b3430d771f0e025a2626d0f83cb2b2af9ff47", "committedDate": "2020-05-22T16:05:41Z", "message": "Changed precondition check based on PR comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e65350829153ad7064f757a64bfc65603989d53a", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/e65350829153ad7064f757a64bfc65603989d53a", "committedDate": "2020-05-22T16:05:42Z", "message": "Fix checkstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df31859f3010f1f51eca24d208c1203155864ca2", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/df31859f3010f1f51eca24d208c1203155864ca2", "committedDate": "2020-05-22T16:05:42Z", "message": "Added test class for copy-on-write utility class.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e880adaa1457c4253e1c373078ccf50f22f69769", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/e880adaa1457c4253e1c373078ccf50f22f69769", "committedDate": "2020-05-22T16:05:43Z", "message": "Exploratory analysis for batched segment offset updates.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc78ecaa1ce78a2158d05fb665c142a8421be570", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/dc78ecaa1ce78a2158d05fb665c142a8421be570", "committedDate": "2020-05-22T16:05:43Z", "message": "Continue working on lazy batched updates for offset segments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51002fd47fa8ab5d81e16a32c4729e6585b131e7", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/51002fd47fa8ab5d81e16a32c4729e6585b131e7", "committedDate": "2020-05-22T16:05:44Z", "message": "Fixed race condition in test.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e305d01921d5fb921add6c7cf271eff12093fbd3", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/e305d01921d5fb921add6c7cf271eff12093fbd3", "committedDate": "2020-05-22T16:05:45Z", "message": "Make equals and hashcode in PositionImpl to apply segment offset updates if needed. Added PositionImpl tests.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e50cf7b32a0e8bd856f9be88f4f5bf6530615af4", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/e50cf7b32a0e8bd856f9be88f4f5bf6530615af4", "committedDate": "2020-05-22T16:05:45Z", "message": "Fix checkstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dff29578e25b5c6086e713ae9ee0c6ce7511c619", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/dff29578e25b5c6086e713ae9ee0c6ce7511c619", "committedDate": "2020-05-22T16:05:46Z", "message": "Added new test for PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2514e2ede13ea2ed28d00fce87571f36eff42c91", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/2514e2ede13ea2ed28d00fce87571f36eff42c91", "committedDate": "2020-05-22T16:05:47Z", "message": "Clean up ownedSegments and segmentOffsetUpdates on closeAt().\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cb09eec2d2ed8bfc7f7ab7c83367cca26b62d83", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/2cb09eec2d2ed8bfc7f7ab7c83367cca26b62d83", "committedDate": "2020-05-22T16:05:47Z", "message": "Added tests for Position object returned to application in EventStreamReaderImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbc73dcf64c79445eb655964b5ddd53f78bd270f", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/fbc73dcf64c79445eb655964b5ddd53f78bd270f", "committedDate": "2020-05-22T16:05:48Z", "message": "Make objects passed to PositionImpl immutable.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a02a05e98b73080ba765d440c65559baaae4973", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/2a02a05e98b73080ba765d440c65559baaae4973", "committedDate": "2020-05-22T16:05:48Z", "message": "Make objects passed to PositionImpl immutable in the builder method itself.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61bf190bbe015145bc8670b4dfc50b0b458721dc", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/61bf190bbe015145bc8670b4dfc50b0b458721dc", "committedDate": "2020-05-22T16:05:49Z", "message": "Fixed chackstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9096ebf28f7b41e5cf0c41782d9aa66bd61275bb", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/9096ebf28f7b41e5cf0c41782d9aa66bd61275bb", "committedDate": "2020-05-22T16:05:49Z", "message": "No need for AtomicReference in PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "committedDate": "2020-05-22T16:47:22Z", "message": "Delete extra space.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTk4NTEw", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-417198510", "createdAt": "2020-05-22T21:46:00Z", "commit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTo0NjowMFrOGZkcWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowOTozN1rOGZlEiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDY2NA==", "bodyText": "These names are just uuids for the most part, this sort of sorting is meaningless. The time order is the order they are in the checkpoints list. If the list for each host can be maintained in this order (Should be easy as it is the natural order in which they are added) then there is no need to sort, and we can just get the first element every time.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429464664", "createdAt": "2020-05-22T21:46:00Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());\n                 checkpointsForHost.add(checkpointId);\n             }\n         }\n+        // Sort checkpoints per reader so we have fast access based on time ordering.\n+        for (List<String> checkpointsForHost: checkpointIndex.values()) {\n+            checkpointsForHost.sort(String::compareTo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw==", "bodyText": "Given the constants you selected this is going to add ~30MB of memory overhead per reader in a user's application. I don't consider this tradeoff worthwhile. See above for how we can avoid this.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429471903", "createdAt": "2020-05-22T22:00:04Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -22,23 +22,28 @@\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n import lombok.Builder;\n-import lombok.EqualsAndHashCode;\n import lombok.SneakyThrows;\n \n import static io.pravega.common.io.serialization.RevisionDataOutput.COMPACT_LONG_MAX;\n \n-@EqualsAndHashCode(callSuper = false)\n public class PositionImpl extends PositionInternal {\n \n     private static final PositionSerializer SERIALIZER = new PositionSerializer();\n-    private final Map<Segment, Long> ownedSegments;\n+    private Map<Segment, Long> ownedSegments;\n     private final Map<Segment, Range> segmentRanges;\n \n+    // If this field is set, it means that we will need to apply the updates on the ownedSegments.\n+    private transient List<Entry<Segment, Long>> updatesToSegmentOffsets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng==", "bodyText": "This computation is wrong. The updatesToSegmentOffsets list is passed in without copying it. This means that if a caller holds onto one position object, and then calls readNext the first position object will be updated and have the wrong value. Please add a test for this.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429473356", "createdAt": "2020-05-22T22:02:17Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {\n+        this.ownedSegments = Collections.unmodifiableMap(ownedSegments);\n+        this.updatesToSegmentOffsets = Collections.unmodifiableList((updatesToSegmentOffsets == null) ? Collections.emptyList() : updatesToSegmentOffsets);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzY0Ng==", "bodyText": "How?! This is all static methods?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429473646", "createdAt": "2020-05-22T22:03:25Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+@NotThreadSafe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDQ1Nw==", "bodyText": "The semantics of which of these collections are copied or not should be spelled out in a javadoc. It would avoid the bug below.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429474457", "createdAt": "2020-05-22T22:07:09Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDk1Mw==", "bodyText": "Because a copy is needed anyway (see comments below) this is actually going to make things slower. It would be better to simply in the getPosition() method iterate over the readers and construct the List<Entry<Segment, Long>> with only one entry per-segment. This is faster, avoids both of the need collections here, and the need to try to cache the position object.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429474953", "createdAt": "2020-05-22T22:09:37Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +62,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to do not generate Position objects on every event read, we define a base map of segments and\n+    // then a batch of updates to the offsets of these segments, one per event read. Internally, the Position object can\n+    // derive the right offsets at which the event was read by lazily replying such updates up to the point it was read.\n+    private static final long MAX_BUFFERED_SEGMENT_OFFSET_UPDATES = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e24c4400fb98a32029d91c76a88d1abad63709a", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/2e24c4400fb98a32029d91c76a88d1abad63709a", "committedDate": "2020-05-25T11:23:46Z", "message": "Address review comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e0cd7c79e8ee73024742aab059d19a00e31fbd0", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/2e0cd7c79e8ee73024742aab059d19a00e31fbd0", "committedDate": "2020-05-25T11:25:36Z", "message": "Address review comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74d69aafeca84ed43a0ec3907671866797ff8623", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/74d69aafeca84ed43a0ec3907671866797ff8623", "committedDate": "2020-05-25T11:26:11Z", "message": "Make CopyOnWriteMapUtils final.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NjUwMTQ4", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-418650148", "createdAt": "2020-05-26T20:21:45Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDoyMTo0NVrOGau8Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDo0MzozMFrOGavotw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY4NTI0Ng==", "bodyText": "This lock is not guarding updatesToSegmentOffsets because it is shared by many objects.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430685246", "createdAt": "2020-05-26T20:21:45Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MjUxNQ==", "bodyText": "@shrids 's intuition was correct. This call to updatesToSegmentOffsets.get(i) is not thread safe. The list may not be synchronized in any way between the thread calling readNextEvent and the thread calling this method. As such this could endup reading garbage data.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430692515", "createdAt": "2020-05-26T20:35:00Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null || this.updatesToSegmentOffsets.isEmpty()) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments = new HashMap<>(ownedSegments);\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5Mzk5Nw==", "bodyText": "No. That map will be ~30mb and there is one per EventStreamReader.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430693997", "createdAt": "2020-05-26T20:37:44Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -22,23 +22,28 @@\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n import lombok.Builder;\n-import lombok.EqualsAndHashCode;\n import lombok.SneakyThrows;\n \n import static io.pravega.common.io.serialization.RevisionDataOutput.COMPACT_LONG_MAX;\n \n-@EqualsAndHashCode(callSuper = false)\n public class PositionImpl extends PositionInternal {\n \n     private static final PositionSerializer SERIALIZER = new PositionSerializer();\n-    private final Map<Segment, Long> ownedSegments;\n+    private Map<Segment, Long> ownedSegments;\n     private final Map<Segment, Range> segmentRanges;\n \n+    // If this field is set, it means that we will need to apply the updates on the ownedSegments.\n+    private transient List<Entry<Segment, Long>> updatesToSegmentOffsets;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5NjYzMQ==", "bodyText": "Perhaps I am missing something, but I don't see any actual concurrency in the test.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430696631", "createdAt": "2020-05-26T20:43:30Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {\n+        this.ownedSegments = Collections.unmodifiableMap(ownedSegments);\n+        this.updatesToSegmentOffsets = Collections.unmodifiableList((updatesToSegmentOffsets == null) ? Collections.emptyList() : updatesToSegmentOffsets);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9508aba3c43c065ca91ea8a5b586983f93259810", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/9508aba3c43c065ca91ea8a5b586983f93259810", "committedDate": "2020-05-28T11:26:46Z", "message": "Ensure that segmentOffsetUpdatesList is structurally immutable and improved test.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "9508aba3c43c065ca91ea8a5b586983f93259810", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/9508aba3c43c065ca91ea8a5b586983f93259810", "committedDate": "2020-05-28T11:26:46Z", "message": "Ensure that segmentOffsetUpdatesList is structurally immutable and improved test.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a19c3981fd831b63f67cae159bc60057c1ef5008", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/a19c3981fd831b63f67cae159bc60057c1ef5008", "committedDate": "2020-05-28T19:35:29Z", "message": "Add javadoc to builder method in PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "a19c3981fd831b63f67cae159bc60057c1ef5008", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/a19c3981fd831b63f67cae159bc60057c1ef5008", "committedDate": "2020-05-28T19:35:29Z", "message": "Add javadoc to builder method in PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b5e9b72c4836f140ed3f183df87124155d3a67b", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/4b5e9b72c4836f140ed3f183df87124155d3a67b", "committedDate": "2020-05-29T06:48:30Z", "message": "Minor improvements in comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "4b5e9b72c4836f140ed3f183df87124155d3a67b", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/4b5e9b72c4836f140ed3f183df87124155d3a67b", "committedDate": "2020-05-29T06:48:30Z", "message": "Minor improvements in comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22202507353957beebe2c36116476019e31bf5d2", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/22202507353957beebe2c36116476019e31bf5d2", "committedDate": "2020-05-29T18:15:18Z", "message": "Cache in memory scoped segment name instead of constructing on each call as it is checked on each event read.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMTk4MTkx", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-422198191", "createdAt": "2020-06-01T21:33:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMTozMzo1OFrOGda6Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMjowMDoxMFrOGdbjoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjc0Mg==", "bodyText": "This optimization may burn us for users which serialize the position objects. (This is recommended behaviour and required for exactly once delivery). Please verify this solution actually improves performance in that case, and not just the no-op processing case. If it makes things significantly worse, then I don't think we should pursue it to improve performance for some users at the expense of others.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433502742", "createdAt": "2020-06-01T21:33:58Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +63,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to avoid creating a new ownedSegments map per event read, we define a base map of segments and", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzYxMA==", "bodyText": "This annotation does not actually hold anymore. There are paths to read from this not guarded by the 'readers' lock. If you want to keep this approach please make a threadsafe datastructure in common which follows this model. Then this class will simply have a final member and no annotation will be required.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433503610", "createdAt": "2020-06-01T21:36:03Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -74,12 +81,18 @@\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private Map<Segment, Range> ranges = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private final Map<Segment, Long> sealedSegments = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private Sequence lastRead;\n     @GuardedBy(\"readers\")\n+    private Map<Segment, Long> ownedSegments = new HashMap<>();\n+    @GuardedBy(\"readers\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzM3Ng==", "bodyText": "Rather than externalizing the logic, I would rather have it internalized to a single class. For example can we Make a CopyOnWriteHashMap which internally does the copies? Because this would allow callers to not need to understand the details of the implementation.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433513376", "createdAt": "2020-06-01T22:00:10Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+public final class CopyOnWriteMapUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bdee85459be6912be2d744e259344df52c02b5e", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/4bdee85459be6912be2d744e259344df52c02b5e", "committedDate": "2020-06-03T11:38:11Z", "message": "Optimize lazy construction of PositionImpl object state.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "4bdee85459be6912be2d744e259344df52c02b5e", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/4bdee85459be6912be2d744e259344df52c02b5e", "committedDate": "2020-06-03T11:38:11Z", "message": "Optimize lazy construction of PositionImpl object state.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c509a43880596e4b386d49124c8a59318175352", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/6c509a43880596e4b386d49124c8a59318175352", "committedDate": "2020-06-03T13:28:14Z", "message": "Fix spotbugs.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "6c509a43880596e4b386d49124c8a59318175352", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/6c509a43880596e4b386d49124c8a59318175352", "committedDate": "2020-06-03T13:28:14Z", "message": "Fix spotbugs.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a940b202da3953dc2709778781a1942a911b65e4", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/a940b202da3953dc2709778781a1942a911b65e4", "committedDate": "2020-06-05T11:16:20Z", "message": "Replaced CopyOnWriteMapUtils by a CopyOnWriteMap implementation. Removed GuardedBy annotation from ranges, ownedSegments and segmentOffsetUpdates as they may be (safely) accessed by PositionImpl objects.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "a940b202da3953dc2709778781a1942a911b65e4", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/a940b202da3953dc2709778781a1942a911b65e4", "committedDate": "2020-06-05T11:16:20Z", "message": "Replaced CopyOnWriteMapUtils by a CopyOnWriteMap implementation. Removed GuardedBy annotation from ranges, ownedSegments and segmentOffsetUpdates as they may be (safely) accessed by PositionImpl objects.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d893db7f75b24d4355e58dfbc5bb4425b320b794", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/d893db7f75b24d4355e58dfbc5bb4425b320b794", "committedDate": "2020-06-05T11:17:06Z", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6083baf57ad00acec0b3a185b752d4c8600703c", "author": {"user": {"login": "tkaitchuck", "name": "Tom Kaitchuck"}}, "url": "https://github.com/pravega/pravega/commit/d6083baf57ad00acec0b3a185b752d4c8600703c", "committedDate": "2020-06-05T23:38:43Z", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjkxNTcw", "url": "https://github.com/pravega/pravega/pull/4768#pullrequestreview-425691570", "createdAt": "2020-06-06T00:31:55Z", "commit": {"oid": "d6083baf57ad00acec0b3a185b752d4c8600703c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26a7aa54b591bfe9da25b6732199104c263a2dab", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/26a7aa54b591bfe9da25b6732199104c263a2dab", "committedDate": "2020-06-06T13:54:24Z", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0716c66578965c4ae5ee56bc948f77189057c5cc", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/0716c66578965c4ae5ee56bc948f77189057c5cc", "committedDate": "2020-06-08T10:17:15Z", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcc1a8079f20db280948ff617c6d45c5f132aaf9", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/bcc1a8079f20db280948ff617c6d45c5f132aaf9", "committedDate": "2020-06-08T15:09:22Z", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84b10eb198c29aabb171e8ebf58491f2e5cfce27", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/84b10eb198c29aabb171e8ebf58491f2e5cfce27", "committedDate": "2020-06-08T15:56:09Z", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3454, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}