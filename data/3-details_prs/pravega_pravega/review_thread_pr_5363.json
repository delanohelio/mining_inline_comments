{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1NDQwNjcz", "number": 5363, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzozNzo1OFrOE8cKEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzozNzo1OFrOE8cKEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODExMzQ3OnYy", "diffSide": "RIGHT", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ReadIndexCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzozNzo1OFrOH4jpXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzo0OTozNVrOH4j6Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NjMzMw==", "bodyText": "Guava cache is synchronized. Why are you re-synchronizing?", "url": "https://github.com/pravega/pravega/pull/5363#discussion_r529066333", "createdAt": "2020-11-23T23:37:58Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ReadIndexCache.java", "diffHunk": "@@ -86,59 +65,35 @@ public ReadIndexCache(int maxIndexedSegments, int maxIndexedChunksPerSegment, in\n      * @param streamSegmentName Name of the segment.\n      * @return Read index corresponding to the given segment. A new empty index is created if it doesn't already exist.\n      */\n-    private SegmentReadIndex getSegmentReadIndex(String streamSegmentName) {\n-        SegmentReadIndex readIndex = segmentsToReadIndexMap.get(streamSegmentName);\n-\n-        if (null == readIndex) {\n-            // Evict segments if required.\n-            if (maxIndexedSegments < segmentsToReadIndexMap.size() + 1 || maxIndexedChunks < totalChunkCount.get() + 1) {\n-                evictSegmentsFromOldestGeneration();\n+    private SegmentReadIndex getSegmentReadIndex(String streamSegmentName, boolean createIfNotPresent) {\n+        SegmentReadIndex readIndex = segmentsReadIndexCache.getIfPresent(streamSegmentName);\n+        if (null == readIndex && createIfNotPresent) {\n+            synchronized (segmentsReadIndexCache) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7da2f175f53b58ae8372eab25deb63b75c04b30"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2OTE3MQ==", "bodyText": "Multiple threads might find that entry does not exist and might race to create the entry for the first time. (This code is invoked only once per segment). If that happens then only one instance wins and other thread is holding on to a dangling reference that will be garbage collected - thus basically loosing updates.\nI did not find clean putIfNotPresent equivalent method.", "url": "https://github.com/pravega/pravega/pull/5363#discussion_r529069171", "createdAt": "2020-11-23T23:45:29Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ReadIndexCache.java", "diffHunk": "@@ -86,59 +65,35 @@ public ReadIndexCache(int maxIndexedSegments, int maxIndexedChunksPerSegment, in\n      * @param streamSegmentName Name of the segment.\n      * @return Read index corresponding to the given segment. A new empty index is created if it doesn't already exist.\n      */\n-    private SegmentReadIndex getSegmentReadIndex(String streamSegmentName) {\n-        SegmentReadIndex readIndex = segmentsToReadIndexMap.get(streamSegmentName);\n-\n-        if (null == readIndex) {\n-            // Evict segments if required.\n-            if (maxIndexedSegments < segmentsToReadIndexMap.size() + 1 || maxIndexedChunks < totalChunkCount.get() + 1) {\n-                evictSegmentsFromOldestGeneration();\n+    private SegmentReadIndex getSegmentReadIndex(String streamSegmentName, boolean createIfNotPresent) {\n+        SegmentReadIndex readIndex = segmentsReadIndexCache.getIfPresent(streamSegmentName);\n+        if (null == readIndex && createIfNotPresent) {\n+            synchronized (segmentsReadIndexCache) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NjMzMw=="}, "originalCommit": {"oid": "a7da2f175f53b58ae8372eab25deb63b75c04b30"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3MDYxNA==", "bodyText": "SimpleCache has putIfAbsent. Check it out", "url": "https://github.com/pravega/pravega/pull/5363#discussion_r529070614", "createdAt": "2020-11-23T23:49:35Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ReadIndexCache.java", "diffHunk": "@@ -86,59 +65,35 @@ public ReadIndexCache(int maxIndexedSegments, int maxIndexedChunksPerSegment, in\n      * @param streamSegmentName Name of the segment.\n      * @return Read index corresponding to the given segment. A new empty index is created if it doesn't already exist.\n      */\n-    private SegmentReadIndex getSegmentReadIndex(String streamSegmentName) {\n-        SegmentReadIndex readIndex = segmentsToReadIndexMap.get(streamSegmentName);\n-\n-        if (null == readIndex) {\n-            // Evict segments if required.\n-            if (maxIndexedSegments < segmentsToReadIndexMap.size() + 1 || maxIndexedChunks < totalChunkCount.get() + 1) {\n-                evictSegmentsFromOldestGeneration();\n+    private SegmentReadIndex getSegmentReadIndex(String streamSegmentName, boolean createIfNotPresent) {\n+        SegmentReadIndex readIndex = segmentsReadIndexCache.getIfPresent(streamSegmentName);\n+        if (null == readIndex && createIfNotPresent) {\n+            synchronized (segmentsReadIndexCache) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NjMzMw=="}, "originalCommit": {"oid": "a7da2f175f53b58ae8372eab25deb63b75c04b30"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4551, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}