{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNjgxNTYy", "number": 4485, "title": "Issue 4451: (SegmentStore) Enhancing Segment Attribute Tier 2 Sync", "bodyText": "Change log description\n\nStoring Segment Attribute BTreeIndex Root Pointer as a Core Attribute on the parent segment, every time the BTreeIndex is updated.\nSplit out the Tier 2 Attribute sync logic out of SegmentAggregator into its own class (AttributeAggregator).\nAllowing certain UpdateAttributeOperations to be executed after the Segment is sealed.\n\nPurpose of the change\nFixes #4451.\nWhat the code does\n\nSegment Attribute BTreeIndex Root Pointer\n\nChanged BTreeIndex to return the offset of the root page with every update. The upstream code (StorageWriter and sub-components) will take this value and store it in a core attribute (Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER).\nUpon recovery, the BTreeIndex is initialized with both the Attribute Segment Length (as before) and the root pointer value (if available). The BTreeIndex will use the root pointer to initialize and if not available, it uses the length to infer that (for backwards compatibility).\nThis helps with the situations when a BTreeIndex update was only partially written to Tier 2, in which case a subsequent recovery would have been unable to reinitialize the index. By storing the root offset after the write is complete we guarantee to always have a working view/version of the BTree to use.\n\n\nAllowing certain UpdateSegmentAttributeOperations to execute after the segment is sealed\n\nThis is necessary because we may seal the segment immediately after updating some attributes on it, so by the time those attributes are sync-ed to Tier 2, it would be impossible to update the Root Pointer in the Segment's Metadata (due to it being sealed), which would cause us to not be able to access the latest updates in that BTreeIndex.\nAdded a flag to this operation to mark it as Internal. If it is internal and only updates core attributes, then it is allowed to be executed after a segment is sealed. (Note that Core Attributes have a different lifecycle than extended attributes; they are always pinned to memory and, when the segment is evicted, they are stored in the Segment's Metadata, not in the BTreeIndex).\n\n\nSplitting Tier 2 data sync and Attribute Sync\n\nSegmentAggregator was getting too big and complex and it was becoming hard to provide specialized handling for Tier 2 Attribute Sync.\nCreated AttributeAggregator which aggregates attributes and only persists them to Tier2 when certain flush conditions are met (either time-based or when a minimum number of attributes are accumulated). This should significantly reduce the number of BTreeIndex updates, thus keeping its size small(er) and improving Tier 2 data sync (previously, every Tier 2 data sync would require writing both the segment data and attribute data, which could slow things down).\nThe AttributeAggregator asynchronously updates the core attributes (ATTRIBUTE_SEGMENT_ROOT_POINTER and ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO) to avoid a situation where it would be subject to Tier 1 throttling (which would essentially deadlock the StorageWriter and Tier 1).\nThe StorageWriter now has 3 processors for each Segment: SegmentAggregator, AttributeAggregator and WriterTableSegmentProcessor (the latter only for Table Segments). Each of these is passed every operation in the DurableLog and such an operation is acked/truncated out of DurableLog/Tier1 only after all processors have successfully sync-ed it to Tier2. (This functionality was already present and was not added as part of this change).\n\n\n\nHow to verify it\nAll existing and new tests must pass. System and longevity tests must pass as well.", "createdAt": "2020-01-11T01:48:51Z", "url": "https://github.com/pravega/pravega/pull/4485", "merged": true, "mergeCommit": {"oid": "4f578e270cd298587a9f867a84aa5c2b24a33359"}, "closed": true, "closedAt": "2020-01-18T00:33:15Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb42iCCAH2gAyMzYxNjgxNTYyOmQxYWU1MDg0NDZiOWE0YzhkNTViMzM3MDYzMDUxZTYxNTI1MTkxN2M=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7XWPNAFqTM0NDg5MzMzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d1ae508446b9a4c8d55b337063051e615251917c", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d1ae508446b9a4c8d55b337063051e615251917c", "committedDate": "2020-01-10T04:06:44Z", "message": "BTreeIndex exposes and uses a RootPointer which can be stored externally to aid in recovery.\nSegmentAggregator makes use of this to handle partial updates that made it to Storage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10bb1fa4d85d0cbf8d5cad0bafbb864daafe0299", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/10bb1fa4d85d0cbf8d5cad0bafbb864daafe0299", "committedDate": "2020-01-10T16:51:28Z", "message": "Excluding new attribute from unit test checks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3335227cd6f2ae58b59449f23b7ac762431ad0b", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d3335227cd6f2ae58b59449f23b7ac762431ad0b", "committedDate": "2020-01-11T00:19:55Z", "message": "Created AttributeAggregator with all the logic to move Extended Attribute Updates from the DurableLog to Storage/AttributeIndex.\n\nThis is not wired up yet, nor is the same functionality removed from SegmentAggregator.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b3db6abe4464e1bf77803acade2fcff4035e6eb", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/0b3db6abe4464e1bf77803acade2fcff4035e6eb", "committedDate": "2020-01-11T01:47:09Z", "message": "Removed attribute logic from SegmentAggregator. Wired AttributeAggregator into StorageWriter.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTA5NTc0", "url": "https://github.com/pravega/pravega/pull/4485#pullrequestreview-341509574", "createdAt": "2020-01-11T07:23:39Z", "commit": {"oid": "0b3db6abe4464e1bf77803acade2fcff4035e6eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwNzoyMzozOVrOFcktPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwNzoyMzozOVrOFcktPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUwNTg1Mg==", "bodyText": "Will some sort of compare-and-set help here in preventing races?\nYou know the expected previous state", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r365505852", "createdAt": "2020-01-11T07:23:39Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/util/btree/BTreeIndex.java", "diffHunk": "@@ -790,14 +792,17 @@ private ByteArraySegment generateMinKey() {\n         long rootMinOffset = lastPage.getMinOffset();\n         assert rootMinOffset >= 0 : \"root.MinOffset not set\";\n         return this.write.apply(pages, oldOffsets, rootMinOffset, timeout)\n-                         .thenApply(indexLength -> setState(indexLength, rootOffset, rootLength).length);\n+                .thenApply(indexLength -> {\n+                    setState(indexLength, rootOffset, rootLength);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b3db6abe4464e1bf77803acade2fcff4035e6eb"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0233471c2867278244443b41065f3af860ce9a8d", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/0233471c2867278244443b41065f3af860ce9a8d", "committedDate": "2020-01-11T17:05:38Z", "message": "Tweaked some unit tests. Added some logging.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b2b4bffddd9889bb81eac71e953f28cdb465d96", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/3b2b4bffddd9889bb81eac71e953f28cdb465d96", "committedDate": "2020-01-11T18:00:12Z", "message": "More unit test coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "487f138756384e26684e4514bbd0ccfcfc6d494f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/487f138756384e26684e4514bbd0ccfcfc6d494f", "committedDate": "2020-01-11T21:48:20Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd7c6308bf7677a0932a53a67df5b2775595ba7", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/cfd7c6308bf7677a0932a53a67df5b2775595ba7", "committedDate": "2020-01-12T16:43:12Z", "message": "Added attributes to every append operation in SelfTester.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6585e11edc479bf6fa2c83f122ff1aac28b0bc74", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/6585e11edc479bf6fa2c83f122ff1aac28b0bc74", "committedDate": "2020-01-12T21:55:44Z", "message": "Now accepting select UpdateAttributesOperations after the segment is sealed.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7ee03a9d06329e27768fd3afeac63bbc190c3ec", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/f7ee03a9d06329e27768fd3afeac63bbc190c3ec", "committedDate": "2020-01-13T08:19:57Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82935cdc6168cbc849d67f61ba7804b38d63ab3c", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/82935cdc6168cbc849d67f61ba7804b38d63ab3c", "committedDate": "2020-01-13T09:14:44Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bc18b447b56971a907c7ceda10650c359397d93", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/3bc18b447b56971a907c7ceda10650c359397d93", "committedDate": "2020-01-13T23:33:56Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04f40b5fd8e2b20d2767421ced5d2a84c4f38e87", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/04f40b5fd8e2b20d2767421ced5d2a84c4f38e87", "committedDate": "2020-01-14T11:28:15Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "406dd99c34b5a38ec1626829510e57c1c1f92a02", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/406dd99c34b5a38ec1626829510e57c1c1f92a02", "committedDate": "2020-01-14T17:01:50Z", "message": "Resetting flush timer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d651fcb2702e7e1ba924d3fac0edc66afc70e5af", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/d651fcb2702e7e1ba924d3fac0edc66afc70e5af", "committedDate": "2020-01-15T02:23:53Z", "message": "AttributeAggregator is now updating Root Pointers in Core Attributes asynchronously (to avoid slowing down due to throttling).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48d173e5819c8e36978b150206bb13ee94ff49e4", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/48d173e5819c8e36978b150206bb13ee94ff49e4", "committedDate": "2020-01-15T20:03:39Z", "message": "Javadoc\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a28552a4c43e6f0e106cbb4e85cc7a4ccfd7cf1", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/0a28552a4c43e6f0e106cbb4e85cc7a4ccfd7cf1", "committedDate": "2020-01-15T21:50:08Z", "message": "Passing traceObjectId for better logging.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/6b3310d901a8a209c496900f4418f56b17138d90", "committedDate": "2020-01-15T21:55:42Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjI4NDM4", "url": "https://github.com/pravega/pravega/pull/4485#pullrequestreview-343628438", "createdAt": "2020-01-16T01:34:33Z", "commit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMTozNDozM1rOFeLqHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMTo1NDoxM1rOFeL69A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5MjYwNQ==", "bodyText": "It seems odd to configure a minimum in terms of a count without also providing some sort of bound. Like maybe based on time. Otherwise it could sit unflushed indefinitely.", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367192605", "createdAt": "2020-01-16T01:34:33Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/WriterConfig.java", "diffHunk": "@@ -52,6 +53,12 @@\n     @Getter\n     private final Duration flushThresholdTime;\n \n+    /**\n+     * The minimum number of attributes that should accumulate before flushing them into the Attribute Index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5Mzg2MA==", "bodyText": "This should be an immutable list.", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367193860", "createdAt": "2020-01-16T01:40:05Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/writer/AttributeAggregatorTests.java", "diffHunk": "@@ -0,0 +1,784 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.writer;\n+\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.AttributeUpdateType;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentSealedException;\n+import io.pravega.segmentstore.server.DataCorruptionException;\n+import io.pravega.segmentstore.server.ManualTimer;\n+import io.pravega.segmentstore.server.MetadataBuilder;\n+import io.pravega.segmentstore.server.SegmentOperation;\n+import io.pravega.segmentstore.server.UpdateableContainerMetadata;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.WriterFlushResult;\n+import io.pravega.segmentstore.server.logs.operations.AttributeUpdaterOperation;\n+import io.pravega.segmentstore.server.logs.operations.CachedStreamSegmentAppendOperation;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import io.pravega.segmentstore.server.logs.operations.StorageOperation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentAppendOperation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentSealOperation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentTruncateOperation;\n+import io.pravega.segmentstore.server.logs.operations.UpdateAttributesOperation;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.ErrorInjector;\n+import io.pravega.test.common.IntentionalException;\n+import io.pravega.test.common.ThreadPooledTestSuite;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import lombok.Cleanup;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.val;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Unit test for the {@link AttributeAggregator} class.\n+ */\n+public class AttributeAggregatorTests extends ThreadPooledTestSuite {\n+    private static final int CONTAINER_ID = 0;\n+    private static final long SEGMENT_ID = 123;\n+    private static final String SEGMENT_NAME = \"Segment\";\n+    private static final byte[] APPEND_DATA = SEGMENT_NAME.getBytes();\n+    private static final UUID CORE_ATTRIBUTE_ID = Attributes.EVENT_COUNT;\n+    private static final List<UUID> EXTENDED_ATTRIBUTE_IDS = IntStream.range(0, 20).mapToObj(i -> UUID.randomUUID()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDEwNw==", "bodyText": "This should be an immutable set.", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367194107", "createdAt": "2020-01-16T01:41:15Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/StreamSegmentContainerTests.java", "diffHunk": "@@ -143,6 +145,11 @@\n  * DurableDataLog.\n  */\n public class StreamSegmentContainerTests extends ThreadPooledTestSuite {\n+    /**\n+     * Auto-generated attributes which are not set externally but maintained internally. To ease our testing, we will\n+     * exclude these from all our checks.\n+     */\n+    private static final Collection<UUID> AUTO_ATTRIBUTES = Sets.newHashSet(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDU5Nw==", "bodyText": "Between this and the Javadoc at the top of the file it seems like maybe a refactoring is due.", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367194597", "createdAt": "2020-01-16T01:43:27Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java", "diffHunk": "@@ -331,26 +322,23 @@ public String toString() {\n     @Override\n     public void add(SegmentOperation operation) throws DataCorruptionException {\n         ensureInitializedAndNotClosed();\n+        if (!(operation instanceof StorageOperation)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NTA4NA==", "bodyText": "Would an enum be better here?", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367195084", "createdAt": "2020-01-16T01:45:47Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/AttributeAggregator.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.writer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.AbstractTimer;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.StreamSegmentMergedException;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentSealedException;\n+import io.pravega.segmentstore.server.DataCorruptionException;\n+import io.pravega.segmentstore.server.SegmentOperation;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.WriterFlushResult;\n+import io.pravega.segmentstore.server.WriterSegmentProcessor;\n+import io.pravega.segmentstore.server.logs.operations.AttributeUpdaterOperation;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentSealOperation;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Aggregates Attribute Updates for a specific Segment.\n+ *\n+ * This class handles the following operations on a Segment: Attribute Updates (extended attributes only) and Sealing\n+ * the Attribute Index. Any Attribute Index deletions are handled by {@link SegmentAggregator}.\n+ */\n+@Slf4j\n+class AttributeAggregator implements WriterSegmentProcessor, AutoCloseable {\n+    //region Members\n+\n+    private final UpdateableSegmentMetadata metadata;\n+    private final WriterConfig config;\n+    private final AbstractTimer timer;\n+    private final Executor executor;\n+    private final String traceObjectId;\n+    private final WriterDataSource dataSource;\n+    private final AtomicReference<Duration> lastFlush;\n+    private final State state;\n+    private final AtomicBoolean closed;\n+    private final AtomicReference<RootPointerInfo> lastRootPointer;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link AttributeAggregator} class.\n+     *\n+     * @param segmentMetadata The Metadata for the Segment to construct this Aggregator for.\n+     * @param dataSource      The {@link WriterDataSource} to use.\n+     * @param config          The {@link WriterConfig} to use.\n+     * @param timer           An {@link AbstractTimer} to use to determine elapsed time.\n+     * @param executor        An Executor to use for async operations.\n+     */\n+    AttributeAggregator(@NonNull UpdateableSegmentMetadata segmentMetadata, @NonNull WriterDataSource dataSource,\n+                        @NonNull WriterConfig config, @NonNull AbstractTimer timer, @NonNull Executor executor) {\n+        this.metadata = segmentMetadata;\n+        this.config = config;\n+        this.dataSource = dataSource;\n+        this.timer = timer;\n+        this.executor = executor;\n+        this.lastFlush = new AtomicReference<>(timer.getElapsed());\n+\n+        Preconditions.checkArgument(this.metadata.getContainerId() == dataSource.getId(), \"SegmentMetadata.ContainerId is different from WriterDataSource.Id\");\n+        this.traceObjectId = String.format(\"AttributeAggregator[%d-%d]\", this.metadata.getContainerId(), this.metadata.getId());\n+        this.state = new State(segmentMetadata.getAttributes().getOrDefault(Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO, Operation.NO_SEQUENCE_NUMBER));\n+        this.closed = new AtomicBoolean();\n+        this.lastRootPointer = new AtomicReference<>();\n+    }\n+\n+    //endregion\n+\n+    //region AutoCloseable Implementation\n+\n+    @Override\n+    public void close() {\n+        this.closed.set(true);\n+    }\n+\n+    //endregion\n+\n+    //region WriterSegmentProcessor Implementation\n+\n+    @Override\n+    public long getLowestUncommittedSequenceNumber() {\n+        if (this.lastRootPointer.get() == null) {\n+            // There is no async pending update for the root pointer attribute. The LUSN is whatever we accumulated in\n+            // our buffers (if nothing, then this will return Operation.NO_SEQUENCE_NUMBER).\n+            return this.state.getFirstSequenceNumber();\n+        } else {\n+            // There is an async pending update for the root pointer attribute. The LUSN can be calculated based off\n+            // whatever we were last able to acknowledge.\n+            long lpsn = this.state.getLastPersistedSequenceNumber();\n+            return lpsn == Operation.NO_SEQUENCE_NUMBER ? this.state.getFirstSequenceNumber() : lpsn + 1;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return this.closed.get();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"[%d: %s] Count = %d, LUSN = %d, LastSeqNo = %d, LastFlush = %ds\", this.metadata.getId(), this.metadata.getName(),\n+                this.state.size(), getLowestUncommittedSequenceNumber(), this.state.getLastSequenceNumber(), getElapsedSinceLastFlush().toMillis() / 1000);\n+    }\n+\n+    /**\n+     * Adds the given SegmentOperation to the Aggregator.\n+     *\n+     * @param operation the Operation to add.\n+     * @throws DataCorruptionException  If the validation of the given Operation indicates a possible data corruption in\n+     *                                  the code (offset gaps, out-of-order operations, etc.)\n+     * @throws IllegalArgumentException If the validation of the given Operation indicates a possible non-corrupting bug\n+     *                                  in the code.\n+     */\n+    @Override\n+    public void add(SegmentOperation operation) throws DataCorruptionException {\n+        Exceptions.checkNotClosed(isClosed(), this);\n+        Preconditions.checkArgument(\n+                operation.getStreamSegmentId() == this.metadata.getId(),\n+                \"Operation '%s' refers to a different Segment than this one (%s).\", operation, this.metadata.getId());\n+        if (isSegmentDeleted()) {\n+            return;\n+        }\n+\n+        boolean processed = false;\n+        if (operation instanceof StreamSegmentSealOperation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NjkxNg==", "bodyText": "The other members of this class are atomics and this is a normal hashmap which is accessed by include without any synchronization. This looks like a bug.", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367196916", "createdAt": "2020-01-16T01:54:13Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/AttributeAggregator.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.writer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.AbstractTimer;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.StreamSegmentMergedException;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentSealedException;\n+import io.pravega.segmentstore.server.DataCorruptionException;\n+import io.pravega.segmentstore.server.SegmentOperation;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.WriterFlushResult;\n+import io.pravega.segmentstore.server.WriterSegmentProcessor;\n+import io.pravega.segmentstore.server.logs.operations.AttributeUpdaterOperation;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentSealOperation;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Aggregates Attribute Updates for a specific Segment.\n+ *\n+ * This class handles the following operations on a Segment: Attribute Updates (extended attributes only) and Sealing\n+ * the Attribute Index. Any Attribute Index deletions are handled by {@link SegmentAggregator}.\n+ */\n+@Slf4j\n+class AttributeAggregator implements WriterSegmentProcessor, AutoCloseable {\n+    //region Members\n+\n+    private final UpdateableSegmentMetadata metadata;\n+    private final WriterConfig config;\n+    private final AbstractTimer timer;\n+    private final Executor executor;\n+    private final String traceObjectId;\n+    private final WriterDataSource dataSource;\n+    private final AtomicReference<Duration> lastFlush;\n+    private final State state;\n+    private final AtomicBoolean closed;\n+    private final AtomicReference<RootPointerInfo> lastRootPointer;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link AttributeAggregator} class.\n+     *\n+     * @param segmentMetadata The Metadata for the Segment to construct this Aggregator for.\n+     * @param dataSource      The {@link WriterDataSource} to use.\n+     * @param config          The {@link WriterConfig} to use.\n+     * @param timer           An {@link AbstractTimer} to use to determine elapsed time.\n+     * @param executor        An Executor to use for async operations.\n+     */\n+    AttributeAggregator(@NonNull UpdateableSegmentMetadata segmentMetadata, @NonNull WriterDataSource dataSource,\n+                        @NonNull WriterConfig config, @NonNull AbstractTimer timer, @NonNull Executor executor) {\n+        this.metadata = segmentMetadata;\n+        this.config = config;\n+        this.dataSource = dataSource;\n+        this.timer = timer;\n+        this.executor = executor;\n+        this.lastFlush = new AtomicReference<>(timer.getElapsed());\n+\n+        Preconditions.checkArgument(this.metadata.getContainerId() == dataSource.getId(), \"SegmentMetadata.ContainerId is different from WriterDataSource.Id\");\n+        this.traceObjectId = String.format(\"AttributeAggregator[%d-%d]\", this.metadata.getContainerId(), this.metadata.getId());\n+        this.state = new State(segmentMetadata.getAttributes().getOrDefault(Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO, Operation.NO_SEQUENCE_NUMBER));\n+        this.closed = new AtomicBoolean();\n+        this.lastRootPointer = new AtomicReference<>();\n+    }\n+\n+    //endregion\n+\n+    //region AutoCloseable Implementation\n+\n+    @Override\n+    public void close() {\n+        this.closed.set(true);\n+    }\n+\n+    //endregion\n+\n+    //region WriterSegmentProcessor Implementation\n+\n+    @Override\n+    public long getLowestUncommittedSequenceNumber() {\n+        if (this.lastRootPointer.get() == null) {\n+            // There is no async pending update for the root pointer attribute. The LUSN is whatever we accumulated in\n+            // our buffers (if nothing, then this will return Operation.NO_SEQUENCE_NUMBER).\n+            return this.state.getFirstSequenceNumber();\n+        } else {\n+            // There is an async pending update for the root pointer attribute. The LUSN can be calculated based off\n+            // whatever we were last able to acknowledge.\n+            long lpsn = this.state.getLastPersistedSequenceNumber();\n+            return lpsn == Operation.NO_SEQUENCE_NUMBER ? this.state.getFirstSequenceNumber() : lpsn + 1;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return this.closed.get();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"[%d: %s] Count = %d, LUSN = %d, LastSeqNo = %d, LastFlush = %ds\", this.metadata.getId(), this.metadata.getName(),\n+                this.state.size(), getLowestUncommittedSequenceNumber(), this.state.getLastSequenceNumber(), getElapsedSinceLastFlush().toMillis() / 1000);\n+    }\n+\n+    /**\n+     * Adds the given SegmentOperation to the Aggregator.\n+     *\n+     * @param operation the Operation to add.\n+     * @throws DataCorruptionException  If the validation of the given Operation indicates a possible data corruption in\n+     *                                  the code (offset gaps, out-of-order operations, etc.)\n+     * @throws IllegalArgumentException If the validation of the given Operation indicates a possible non-corrupting bug\n+     *                                  in the code.\n+     */\n+    @Override\n+    public void add(SegmentOperation operation) throws DataCorruptionException {\n+        Exceptions.checkNotClosed(isClosed(), this);\n+        Preconditions.checkArgument(\n+                operation.getStreamSegmentId() == this.metadata.getId(),\n+                \"Operation '%s' refers to a different Segment than this one (%s).\", operation, this.metadata.getId());\n+        if (isSegmentDeleted()) {\n+            return;\n+        }\n+\n+        boolean processed = false;\n+        if (operation instanceof StreamSegmentSealOperation) {\n+            this.state.seal();\n+            processed = true;\n+        } else if (operation instanceof AttributeUpdaterOperation) {\n+            AttributeUpdaterOperation op = (AttributeUpdaterOperation) operation;\n+            if (this.state.hasSeal()) {\n+                if (op.isInternal() && op.hasOnlyCoreAttributes()) {\n+                    log.debug(\"{}: Ignored internal operation on sealed segment {}.\", this.traceObjectId, operation);\n+                    return;\n+                } else {\n+                    throw new DataCorruptionException(String.format(\"Illegal operation for a sealed Segment; received '%s'.\", operation));\n+                }\n+            }\n+\n+            processed = this.state.include(op);\n+        }\n+\n+        if (processed) {\n+            log.debug(\"{}: Add {}; OpCount={}.\", this.traceObjectId, operation, this.state.size());\n+        }\n+    }\n+\n+    /**\n+     * Gets a value indicating whether a call to {@link #flush} is required given the current state of this aggregator.\n+     */\n+    @Override\n+    public boolean mustFlush() {\n+        if (isSegmentDeleted()) {\n+            // There isn't more that we can do.\n+            return false;\n+        }\n+\n+        return this.state.hasSeal()\n+                || this.state.size() >= this.config.getFlushAttributesThreshold()\n+                || (this.state.size() > 0 && getElapsedSinceLastFlush().compareTo(this.config.getFlushThresholdTime()) >= 0);\n+    }\n+\n+    /**\n+     * Flushes the contents of the Aggregator to the Storage.\n+     *\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that, when completed, will contain a summary of the flush operation. If any errors\n+     * occurred during the flush, the Future will be completed with the appropriate exception.\n+     */\n+    @Override\n+    public CompletableFuture<WriterFlushResult> flush(Duration timeout) {\n+        Exceptions.checkNotClosed(isClosed(), this);\n+        if (!mustFlush()) {\n+            return CompletableFuture.completedFuture(new WriterFlushResult());\n+        }\n+\n+        TimeoutTimer timer = new TimeoutTimer(timeout);\n+        CompletableFuture<Void> result = handleAttributeException(persistPendingAttributes(\n+                this.state.getAttributes(), this.state.getLastSequenceNumber(), timer));\n+        if (this.state.hasSeal()) {\n+            result = result.thenComposeAsync(v -> handleAttributeException(sealAttributes(timer)));\n+        }\n+\n+        return result.thenApply(v -> {\n+            if (this.state.size() > 0) {\n+                log.debug(\"{}: Flushed. Count={}, SeqNo={}-{}.\", this.traceObjectId, this.state.size(),\n+                        this.state.getFirstSequenceNumber(), this.state.getLastSequenceNumber());\n+            }\n+\n+            WriterFlushResult r = new WriterFlushResult();\n+            r.withFlushedAttributes(this.state.size());\n+            this.state.acceptChanges();\n+            this.lastFlush.set(this.timer.getElapsed());\n+            return r;\n+        });\n+    }\n+\n+    //endregion\n+\n+    //region Helpers\n+\n+    private CompletableFuture<Void> persistPendingAttributes(Map<UUID, Long> attributes, long lastSeqNo, TimeoutTimer timer) {\n+        if (attributes.isEmpty()) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+\n+        return this.dataSource.persistAttributes(this.metadata.getId(), attributes, timer.getRemaining())\n+                .thenAcceptAsync(rootPointer -> queueRootPointerUpdate(rootPointer, lastSeqNo), this.executor);\n+    }\n+\n+    private CompletableFuture<Void> sealAttributes(TimeoutTimer timer) {\n+        log.debug(\"{}: Sealing Attribute Index.\", this.traceObjectId);\n+        return this.dataSource.sealAttributes(this.metadata.getId(), timer.getRemaining());\n+    }\n+\n+    public void queueRootPointerUpdate(long newRootPointer, long lastSeqNo) {\n+        if (this.lastRootPointer.getAndSet(new RootPointerInfo(newRootPointer, lastSeqNo)) == null) {\n+            // There was nothing else executing now.\n+            // Initiate an async loop that will execute as long as we have a new value.\n+            AtomicBoolean canContinue = new AtomicBoolean(this.lastRootPointer.get() != null);\n+            Futures.loop(\n+                    canContinue::get,\n+                    () -> {\n+                        RootPointerInfo rpi = this.lastRootPointer.get();\n+                        log.debug(\"{}: Updating Root Pointer info to {}.\", this.traceObjectId, rpi);\n+                        return this.dataSource.notifyAttributesPersisted(this.metadata.getId(), rpi.getRootPointer(), rpi.getLastSequenceNumber(), this.config.getFlushTimeout())\n+                                .whenCompleteAsync((r, ex) -> {\n+                                    if (ex != null) {\n+                                        log.error(\"{}: Unable to persist root pointer {}.\", this.traceObjectId, rpi, ex);\n+                                    } else {\n+                                        this.state.setLastPersistedSequenceNumber(rpi.getLastSequenceNumber());\n+                                    }\n+\n+                                    // Set the latest value to null ONLY if it hasn't changed in the meantime.\n+                                    if (this.lastRootPointer.compareAndSet(rpi, null)) {\n+                                        // No new value. Instruct the loop to stop processing.\n+                                        canContinue.set(false);\n+                                    }\n+                                }, this.executor);\n+\n+                    },\n+                    this.executor);\n+        }\n+    }\n+\n+    /**\n+     * Handles expected Attribute-related exceptions. Since the attribute index is a separate segment from the main one,\n+     * it is highly likely that it may get temporarily out of sync with the main one, thus causing spurious StreamSegmentSealedExceptions\n+     * or StreamSegmentNotExistsExceptions. If we get either of those, and they are consistent with our current state, the\n+     * we can safely ignore them; otherwise we should be rethrowing them.\n+     */\n+    private <T> CompletableFuture<T> handleAttributeException(CompletableFuture<T> future) {\n+        return Futures.exceptionallyExpecting(\n+                future,\n+                ex -> (ex instanceof StreamSegmentSealedException && this.metadata.isSealed())\n+                        || ((ex instanceof StreamSegmentNotExistsException || ex instanceof StreamSegmentMergedException)\n+                        && (this.metadata.isMerged() || this.metadata.isDeleted())),\n+                null);\n+    }\n+\n+    private boolean isSegmentDeleted() {\n+        return this.metadata.isDeleted() || this.metadata.isMerged();\n+    }\n+\n+    private Duration getElapsedSinceLastFlush() {\n+        return this.timer.getElapsed().minus(this.lastFlush.get());\n+    }\n+\n+    //endregion\n+\n+    //region RootPointer\n+\n+    @Data\n+    private static class RootPointerInfo {\n+        private final long rootPointer;\n+        private final long lastSequenceNumber;\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"RootPointer=%s, LastSeqNo=%s\", this.rootPointer, this.lastSequenceNumber);\n+        }\n+    }\n+\n+    //endregion\n+\n+    //region AggregatedAttributes\n+\n+    /**\n+     * Aggregates pending Attribute Updates.\n+     */\n+    private static class State {\n+        private final HashMap<UUID, Long> attributes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b3310d901a8a209c496900f4418f56b17138d90"}, "originalPosition": 317}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36a6cc843d05b38fa47f40440d8d9c1ae1d9a604", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/36a6cc843d05b38fa47f40440d8d9c1ae1d9a604", "committedDate": "2020-01-16T16:33:44Z", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MTM4NTM5", "url": "https://github.com/pravega/pravega/pull/4485#pullrequestreview-344138539", "createdAt": "2020-01-16T18:53:08Z", "commit": {"oid": "36a6cc843d05b38fa47f40440d8d9c1ae1d9a604"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ff33ebb928312d561e034dd1756845a11d3de76", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/1ff33ebb928312d561e034dd1756845a11d3de76", "committedDate": "2020-01-17T14:05:42Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a960ca12da9ebb37d3eb84b439f6e562185c4bb6", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/a960ca12da9ebb37d3eb84b439f6e562185c4bb6", "committedDate": "2020-01-17T21:29:43Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "702a15cb6e7b9ad2232b37e62c101bafb31ec16c", "author": {"user": {"login": "tkaitchuck", "name": "Tom Kaitchuck"}}, "url": "https://github.com/pravega/pravega/commit/702a15cb6e7b9ad2232b37e62c101bafb31ec16c", "committedDate": "2020-01-17T23:28:23Z", "message": "Merge branch 'master' into issue-4451-btree"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODkzMzMz", "url": "https://github.com/pravega/pravega/pull/4485#pullrequestreview-344893333", "createdAt": "2020-01-17T23:28:34Z", "commit": {"oid": "a960ca12da9ebb37d3eb84b439f6e562185c4bb6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3542, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}