{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyOTc2MjA2", "number": 4768, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyMTowNFrOD58Imw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMjowMDoxMFrOEBhzcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDgwNjY3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyMTowNFrOGRftew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo0OToyOVrOGSt_sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw==", "bodyText": "Using a member variable is error prone. (In fact there is a case this logic does not cover: if the segments change as a result of calling updateGroupStateIfNeeded, the next time through the above while loop it will pass in stale data resulting in an invalid state.)\nInstead it may be better to just use a local variables by computing the position on 128 an passing it into updateGroupStateIfNeeded, then modifying the offset for the segment read from before returning it.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r420998523", "createdAt": "2020-05-06T18:21:04Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +156,8 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        lastPosition = getPosition();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyNTAzMA==", "bodyText": "Maybe I'm mistaken, but your suggestion implies that we should be able to \"update\" the offsets of a PositionImpl object in some way, so we don't have to instantiate it twice anyway, right? I don't know if this is possible at the moment, as this object seems to be read-only and uses unmodifiable collections in its getters.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421125030", "createdAt": "2020-05-06T22:18:20Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +156,8 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        lastPosition = getPosition();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw=="}, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MTEzOQ==", "bodyText": "I think we can avoid this. See my comments below.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422281139", "createdAt": "2020-05-08T17:49:29Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +156,8 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        lastPosition = getPosition();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw=="}, "originalCommit": null, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDgyMDExOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyNDo0MlrOGRf17w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTo1NTozMVrOGRm2_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDY4Nw==", "bodyText": "I optimized this method, I don't think this reordering is needed anymore.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421000687", "createdAt": "2020-05-06T18:24:42Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -339,15 +348,15 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n             if (acquireTimer.hasRemaining()) {\n                 return false;\n             }\n-            if (state.getCheckpointForReader(readerId) != null) {\n-                return false;\n-            }\n             if (state.getNumberOfUnassignedSegments() == 0) {\n                 if (doesReaderOwnTooManySegments(state)) {\n                     acquireTimer.reset(calculateAcquireTime(readerId, state));\n                 }\n                 return false;\n             }\n+            if (state.getCheckpointForReader(readerId) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExNTY0NA==", "bodyText": "It does if acquireTimer.hasRemaining() is false quite often, which seems to be the case. By doing this, we are preventing the execution of getCheckpointForReader() thanks to the modification in the implementation of doesReaderOwnTooManySegments. If it finally turns out that there is a problem in the way acquireTimer is being set, then we can fix it and revert this change.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421115644", "createdAt": "2020-05-06T21:55:31Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -339,15 +348,15 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n             if (acquireTimer.hasRemaining()) {\n                 return false;\n             }\n-            if (state.getCheckpointForReader(readerId) != null) {\n-                return false;\n-            }\n             if (state.getNumberOfUnassignedSegments() == 0) {\n                 if (doesReaderOwnTooManySegments(state)) {\n                     acquireTimer.reset(calculateAcquireTime(readerId, state));\n                 }\n                 return false;\n             }\n+            if (state.getCheckpointForReader(readerId) != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDY4Nw=="}, "originalCommit": null, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDgzMTQwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyNzo1MFrOGRf9FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTo1MzozMFrOGRmzgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjUxNw==", "bodyText": "I am confused by this, because this method should only be invoked once per checkpoint interval. If that's set to say 20sec then this new time logic is totally redundant. Am I missing something?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421002517", "createdAt": "2020-05-06T18:27:50Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -213,13 +216,19 @@ Segment findSegmentToReleaseIfRequired() {\n      * the reader with the least assigned to it.\n      */\n     private boolean doesReaderOwnTooManySegments(ReaderGroupState state) {\n-        Map<String, Double> sizesOfAssignemnts = state.getRelativeSizes();\n+        // The previous calculation for this method is cached during TIME_UNIT to prevent excessive per-event computations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExNDc1NQ==", "bodyText": "You are right, this method is being invoked much more often than it should, as I understand its goal. This method is invoked in two different places, and the one that takes a lot of CPU cycles comes from shouldAcquireSegment(), which as you can see, it can be potentially invoked on every read event only if acquireTimer.hasRemaining() is false most of the time, which seems to be what is going on according to the flamegraphs. The acquireTimer should be generally in the order of seconds, right? So maybe I can spend some more time to see if this timer is incorrectly set at some point.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421114755", "createdAt": "2020-05-06T21:53:30Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -213,13 +216,19 @@ Segment findSegmentToReleaseIfRequired() {\n      * the reader with the least assigned to it.\n      */\n     private boolean doesReaderOwnTooManySegments(ReaderGroupState state) {\n-        Map<String, Double> sizesOfAssignemnts = state.getRelativeSizes();\n+        // The previous calculation for this method is cached during TIME_UNIT to prevent excessive per-event computations.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjUxNw=="}, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTAwNDk3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo0MTowN1rOGStviA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzozNzo0OVrOGUyAAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA==", "bodyText": "Replace this with a standard for loop. It will be faster.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422277000", "createdAt": "2020-05-08T17:41:07Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -97,12 +97,12 @@ void beginNewCheckpoint(String checkpointId, Set<String> currentReaders, Map<Seg\n     }\n     \n     String getCheckpointForReader(String readerName) {\n-        OptionalInt min = getCheckpointsForReader(readerName).stream().mapToInt(checkpoints::indexOf).min();\n-        if (min.isPresent()) {\n-            return checkpoints.get(min.getAsInt());\n-        } else {\n+        List<String> checkpointsForReader = getCheckpointsForReader(readerName);\n+        if (checkpointsForReader.isEmpty()) {\n             return null;\n         }\n+        OptionalInt min = checkpointsForReader.stream().mapToInt(checkpoints::indexOf).min();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NTgzOQ==", "bodyText": "Also if the checkpoints can be ordered, we can eliminate this loop all together and just take the first element from the list.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422285839", "createdAt": "2020-05-08T17:58:48Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -97,12 +97,12 @@ void beginNewCheckpoint(String checkpointId, Set<String> currentReaders, Map<Seg\n     }\n     \n     String getCheckpointForReader(String readerName) {\n-        OptionalInt min = getCheckpointsForReader(readerName).stream().mapToInt(checkpoints::indexOf).min();\n-        if (min.isPresent()) {\n-            return checkpoints.get(min.getAsInt());\n-        } else {\n+        List<String> checkpointsForReader = getCheckpointsForReader(readerName);\n+        if (checkpointsForReader.isEmpty()) {\n             return null;\n         }\n+        OptionalInt min = checkpointsForReader.stream().mapToInt(checkpoints::indexOf).min();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA=="}, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0MzkwNg==", "bodyText": "Fixed.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424443906", "createdAt": "2020-05-13T13:37:49Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -97,12 +97,12 @@ void beginNewCheckpoint(String checkpointId, Set<String> currentReaders, Map<Seg\n     }\n     \n     String getCheckpointForReader(String readerName) {\n-        OptionalInt min = getCheckpointsForReader(readerName).stream().mapToInt(checkpoints::indexOf).min();\n-        if (min.isPresent()) {\n-            return checkpoints.get(min.getAsInt());\n-        } else {\n+        List<String> checkpointsForReader = getCheckpointsForReader(readerName);\n+        if (checkpointsForReader.isEmpty()) {\n             return null;\n         }\n+        OptionalInt min = checkpointsForReader.stream().mapToInt(checkpoints::indexOf).min();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA=="}, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTAwNzgxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo0MjowNVrOGStxTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzozNzo1OFrOGUyAYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzQ1NQ==", "bodyText": "This does not need to be an atomic reference, it is guarded by the readers lock, so it can be re-assigned.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422277455", "createdAt": "2020-05-08T17:42:05Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -73,16 +74,19 @@\n     private boolean closed;\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n+    // Ranges map is heavily used to build Position objects that are returned to the client. While there is no change\n+    // in segment distribution, we reuse the same map instance for performance reasons. But this map should have a\n+    // copy-on-write behavior to do not impact all the Position objects referencing the previous version of it.\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private final AtomicReference<Map<Segment, Range>> ranges = new AtomicReference<>(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NDAwMg==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424444002", "createdAt": "2020-05-13T13:37:58Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -73,16 +74,19 @@\n     private boolean closed;\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n+    // Ranges map is heavily used to build Position objects that are returned to the client. While there is no change\n+    // in segment distribution, we reuse the same map instance for performance reasons. But this map should have a\n+    // copy-on-write behavior to do not impact all the Position objects referencing the previous version of it.\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private final AtomicReference<Map<Segment, Range>> ranges = new AtomicReference<>(new HashMap<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzQ1NQ=="}, "originalCommit": null, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTAxMjI1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo0MzozNFrOGSt0IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzo0MTo0OVrOGUyLow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3ODE3Nw==", "bodyText": "Let's make ownedSegments a List<Entry<Segment, Long>> and adapt positionImpl to store this. This will be much cheaper to construct.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422278177", "createdAt": "2020-05-08T17:43:34Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -172,11 +179,12 @@ private void blockFor(long timeoutMs) {\n     }\n \n     private PositionInternal getPosition() {\n-        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments);\n+        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments.size() + readers.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0Njg4Mw==", "bodyText": "I did that change but didn't show much improvement. Instead, I opted for another kind of optimization in which ownedSegments is re-used and we batch the changes of offsets for every read. A set of Position objects that reference the same ownedSegments object, will also have a reference to a list of  List<Entry<Segment, Long>> segmentOffsetUpdates. Each Position object will then lazily apply the updates to segment offsets up to the point the event was read. This has proved to make readers much faster reading small events, specially when multiple segments are involved.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424446883", "createdAt": "2020-05-13T13:41:49Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -172,11 +179,12 @@ private void blockFor(long timeoutMs) {\n     }\n \n     private PositionInternal getPosition() {\n-        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments);\n+        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments.size() + readers.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3ODE3Nw=="}, "originalCommit": null, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTA0ODc4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo1NTowOVrOGSuKnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzo0MjozMFrOGUyNtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MzkzMw==", "bodyText": "Rather than passing this in, we can probably avoid creating it all together. position is used in four places:\n\non line 209 where the reader is checkpointing. (This is rare and we can call getPosition() inside of this if without concern)\non line 218. This is the same situation as the above. It only occurs on checkpoint.\nwhen calling acquireSegmentsIfNeeded. However this method doesn't actually use the position passed in unless a timer has passed. So perhaps having this method call shouldAquireSegment first would avoid the need for position most of the time.\nupdateLagIfNeeded here the situation is the same as the above, it's based on a timer. So we could easily have a block that does:\n\nif (shouldAquireSegment() || shouldUpdateLag()) {\n    PositionImpl position = getPosition();\n    // The code currently in lines 231-235 here.\n}", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422283933", "createdAt": "2020-05-08T17:55:09Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -196,8 +204,7 @@ private PositionInternal getPosition() {\n      * have been persisted.\n      */\n     @GuardedBy(\"readers\")\n-    private String updateGroupStateIfNeeded() throws ReaderNotInReaderGroupException {\n-        PositionInternal position = (lastPosition == null) ? getPosition() : lastPosition;\n+    private String updateGroupStateIfNeeded(PositionInternal position) throws ReaderNotInReaderGroupException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NzQxMg==", "bodyText": "Thanks, I have applied this change (with some additions to that condition).", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424447412", "createdAt": "2020-05-13T13:42:30Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -196,8 +204,7 @@ private PositionInternal getPosition() {\n      * have been persisted.\n      */\n     @GuardedBy(\"readers\")\n-    private String updateGroupStateIfNeeded() throws ReaderNotInReaderGroupException {\n-        PositionInternal position = (lastPosition == null) ? getPosition() : lastPosition;\n+    private String updateGroupStateIfNeeded(PositionInternal position) throws ReaderNotInReaderGroupException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MzkzMw=="}, "originalCommit": null, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTA2NDQ0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzo1OTo1NFrOGSuUag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzo0MzowMVrOGUyPRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjQ0Mg==", "bodyText": "Let's just make this into a class of it's own. It muddies things to have it here.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422286442", "createdAt": "2020-05-08T17:59:54Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -377,14 +386,36 @@ public Type fetchEvent(EventPointer pointer) throws NoSuchEventException {\n             return ImmutableList.copyOf(readers);\n         }\n     }\n-    \n+\n+    // Ranges management region", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NzgxNA==", "bodyText": "Created a CopyOnWriteMapUtils class to contain all this functionality.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424447814", "createdAt": "2020-05-13T13:43:01Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -377,14 +386,36 @@ public Type fetchEvent(EventPointer pointer) throws NoSuchEventException {\n             return ImmutableList.copyOf(readers);\n         }\n     }\n-    \n+\n+    // Ranges management region", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjQ0Mg=="}, "originalCommit": null, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTA2NjY1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowMDo0NVrOGSuV2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowMDo0NVrOGSuV2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjgxMQ==", "bodyText": "HashMap already provides a constructor that does these two lines.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422286811", "createdAt": "2020-05-08T18:00:45Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -377,14 +386,36 @@ public Type fetchEvent(EventPointer pointer) throws NoSuchEventException {\n             return ImmutableList.copyOf(readers);\n         }\n     }\n-    \n+\n+    // Ranges management region\n+\n     @VisibleForTesting\n     Map<Segment, Range> getRanges() {\n         synchronized (readers) {\n-            return ImmutableMap.copyOf(ranges);\n+            return ImmutableMap.copyOf(ranges.get());\n         }\n     }\n \n+    private void copyOnPutSegmentRange(Segment segment, Range range) {\n+        Map<Segment, Range> newRanges = copyRanges();\n+        newRanges.put(segment, range);\n+        ranges.set(newRanges);\n+    }\n+\n+    private void copyOnRemoveSegmentRange(Segment segment) {\n+        Map<Segment, Range> newRanges = copyRanges();\n+        newRanges.remove(segment);\n+        ranges.set(newRanges);\n+    }\n+\n+    private Map<Segment, Range> copyRanges() {\n+        Map<Segment, Range> newRanges = new HashMap<>(2 * ranges.get().size());\n+        newRanges.putAll(ranges.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTA3MzA0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowMzowMVrOGSuZ8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzo0MzoyM1rOGUyQXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4Nzg1Ng==", "bodyText": "Shouldn't that be Preconditions.checkArgument(multiplier >= 1, ...", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422287856", "createdAt": "2020-05-08T18:03:01Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -405,7 +403,9 @@ private int calculateNumSegmentsToAcquire(ReaderGroupState state) {\n \n     @VisibleForTesting\n     static Duration calculateAcquireTime(String readerId, ReaderGroupState state) {\n-        return TIME_UNIT.multipliedBy(state.getNumberOfReaders() - state.getRanking(readerId));\n+        int multiplier = state.getNumberOfReaders() - state.getRanking(readerId);\n+        Preconditions.checkArgument(multiplier >= TIME_UNIT.getSeconds(), \"Invalid acquire timer multiplier\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0ODA5NQ==", "bodyText": "In this case is the same, but I changed it to what you suggest.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424448095", "createdAt": "2020-05-13T13:43:23Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -405,7 +403,9 @@ private int calculateNumSegmentsToAcquire(ReaderGroupState state) {\n \n     @VisibleForTesting\n     static Duration calculateAcquireTime(String readerId, ReaderGroupState state) {\n-        return TIME_UNIT.multipliedBy(state.getNumberOfReaders() - state.getRanking(readerId));\n+        int multiplier = state.getNumberOfReaders() - state.getRanking(readerId);\n+        Preconditions.checkArgument(multiplier >= TIME_UNIT.getSeconds(), \"Invalid acquire timer multiplier\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4Nzg1Ng=="}, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTIxMTI5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0Njo1MlrOGSvviQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzo0Mzo0NlrOGUyRfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwOTc2OQ==", "bodyText": "I think we can move the isReaderOnline check to below the acquireTimer.hasRemaining check.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422309769", "createdAt": "2020-05-08T18:46:52Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -343,9 +343,7 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n                 return false;\n             }\n             if (state.getNumberOfUnassignedSegments() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0ODM4Mg==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424448382", "createdAt": "2020-05-13T13:43:46Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -343,9 +343,7 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n                 return false;\n             }\n             if (state.getNumberOfUnassignedSegments() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwOTc2OQ=="}, "originalCommit": null, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTIyMzM4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo1MDo0MlrOGSv3BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo1MDo0MlrOGSv3BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxMTY4NA==", "bodyText": "Having a shouldAquireSegment() on groupstate would also make this method more efficient because the call to getLag() (above) could be avoided if we don't actually need to acquire a segment.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422311684", "createdAt": "2020-05-08T18:50:42Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -272,14 +281,14 @@ private boolean acquireSegmentsIfNeeded(PositionInternal position) throws Reader\n                 long endOffset = groupState.getEndOffsetForSegment(newSegment.getKey().getSegment());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTM5OTQ4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNDo0NDowOFrOGWnXmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowNTo1N1rOGWr0tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2Njg3NA==", "bodyText": "we can use the pattern checkpointIndex.compute(host, k -> { if k == null  } )", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426366874", "createdAt": "2020-05-18T04:44:08Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzOTg2MA==", "bodyText": "The code that this line is replacing was basically putting a new ArrayList object as an initialization value for a non-existing key. Just wanted to express the same logic in a more concise way.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426439860", "createdAt": "2020-05-18T08:05:57Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2Njg3NA=="}, "originalCommit": null, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTQ1OTk4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNToyNjowNFrOGWn7kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowMjowOVrOGWrsMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3NjA4MA==", "bodyText": "Given that ranges is guarded by readers   @GuardedBy(\"readers\") why do we need to create a copy? isn't it redundant ?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426376080", "createdAt": "2020-05-18T05:26:04Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -240,7 +277,7 @@ private void releaseSegmentsIfNeeded(PositionInternal position) throws ReaderNot\n             if (reader != null) {\n                 if (groupState.releaseSegment(segment, reader.getOffset(), getLag(), position)) {\n                     readers.remove(reader);\n-                    ranges.remove(reader.getSegmentId());\n+                    ranges = CopyOnWriteMapUtils.remove(ranges, reader.getSegmentId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNzY4Mw==", "bodyText": "The reason is that the ranges map is referenced by many PositionImpl objects (i.e, every time that readNextEvent() returns an event and there is no change in segments, the same ranges map is reused). This means that we cannot modify this map if there is a change in segments, as it would impact to all the previous PositionImpl objects and they would be in an inconsistent state. So, every time there is a change in the segments, we need the variable ranges to point to a new map object and apply the change in segments to the new map.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426437683", "createdAt": "2020-05-18T08:02:09Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -240,7 +277,7 @@ private void releaseSegmentsIfNeeded(PositionInternal position) throws ReaderNot\n             if (reader != null) {\n                 if (groupState.releaseSegment(segment, reader.getOffset(), getLag(), position)) {\n                     readers.remove(reader);\n-                    ranges.remove(reader.getSegmentId());\n+                    ranges = CopyOnWriteMapUtils.remove(ranges, reader.getSegmentId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3NjA4MA=="}, "originalCommit": null, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjM0OTkwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDoxMDozNFrOGWwg_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwOTozMjo0M1rOGYsc2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUxNjczMg==", "bodyText": "the maps need to be wrapped with java.util.Collections#unmodifiableMap and the updates should be wrapped with Collections.unmodifiableList().", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426516732", "createdAt": "2020-05-18T10:10:34Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +168,18 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        addSegmentOffsetUpdateIfNeeded(segment, offset + length);\n+        return new EventReadImpl<>(deserializer.deserialize(buffer),\n+                PositionImpl.builder().ownedSegments(ownedSegments).segmentRanges(ranges).updatesToSegmentOffsets(segmentOffsetUpdates).build(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NTY5MA==", "bodyText": "Thanks, I have done this change.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r427175690", "createdAt": "2020-05-19T09:52:05Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +168,18 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        addSegmentOffsetUpdateIfNeeded(segment, offset + length);\n+        return new EventReadImpl<>(deserializer.deserialize(buffer),\n+                PositionImpl.builder().ownedSegments(ownedSegments).segmentRanges(ranges).updatesToSegmentOffsets(segmentOffsetUpdates).build(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUxNjczMg=="}, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0NzI5MA==", "bodyText": "@shrids I just moved the immutability of these collections to the PositionImpl builder itself, so it takes effect to all the usages of such builder.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r428547290", "createdAt": "2020-05-21T09:32:43Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +168,18 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        addSegmentOffsetUpdateIfNeeded(segment, offset + length);\n+        return new EventReadImpl<>(deserializer.deserialize(buffer),\n+                PositionImpl.builder().ownedSegments(ownedSegments).segmentRanges(ranges).updatesToSegmentOffsets(segmentOffsetUpdates).build(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUxNjczMg=="}, "originalCommit": null, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjQzNTQ2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDozNjo0MlrOGWxXiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTo1MzowOFrOGXYxcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMDY5Nw==", "bodyText": "ownedSegments can be modified by the different thread while iterating here.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426530697", "createdAt": "2020-05-18T10:36:42Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -66,26 +75,29 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n \n     @Override\n     public Set<Segment> getOwnedSegments() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableSet(ownedSegments.keySet());\n     }\n \n     @Override\n     public Map<Segment, Long> getOwnedSegmentsWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableMap(ownedSegments);\n     }\n     \n     @Override\n     Map<SegmentWithRange, Long> getOwnedSegmentRangesWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         HashMap<SegmentWithRange, Long> result = new HashMap<>();\n         for (Entry<Segment, Long> entry : ownedSegments.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NjMwNg==", "bodyText": "Correct, good catch. Now, when applySegmentOffsetUpdatesIfNeeded() is executed, the PositionImpl object copies the ownedSegments map and only then sets the right offsets representing the point at which the event was read.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r427176306", "createdAt": "2020-05-19T09:53:08Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -66,26 +75,29 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n \n     @Override\n     public Set<Segment> getOwnedSegments() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableSet(ownedSegments.keySet());\n     }\n \n     @Override\n     public Map<Segment, Long> getOwnedSegmentsWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableMap(ownedSegments);\n     }\n     \n     @Override\n     Map<SegmentWithRange, Long> getOwnedSegmentRangesWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         HashMap<SegmentWithRange, Long> result = new HashMap<>();\n         for (Entry<Segment, Long> entry : ownedSegments.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMDY5Nw=="}, "originalCommit": null, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTA3OTgwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMDo1Mjo0NFrOGYGCPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMjowMDozOVrOGZUorg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxNzg4Nw==", "bodyText": "This isn't exactly threadsafe, right? updateToSegmentOffsets can be modified in the EventStreamReaderImpl thread. Yeah, the elements are added to segmentOffsetUpdates  under a lock and the code reads only until this.version. I always try to avoid this pattern.\n@tkaitchuck  @RaulGracia thoughts?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r427917887", "createdAt": "2020-05-20T10:52:44Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +230,20 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments.set(new HashMap<>(ownedSegments.get()));\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.get().put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNDE1OA==", "bodyText": "Thanks for the comment @shrids. I assume that your concern is about the possibility of getting a ConcurrentModificationException while looping over a list that could be subject to concurrent appends (totally valid concern). To test whether this is thread safe or not, I have tested the following:\n\nThread is continuously adding elements on a list.\nAnother thread is continuously iterating the same list.\n\nI have tried 2 variants for thread 2:\n\nLooping over the entire list:\n\nfor (Integer element: elements) { //do X on element }\n\n\nEmulating what we do in this PR (take a point in the list before the end and iterate up to that point):\n\nfor (int j = 0; j < elements.size(); j++) {//do X on element}\n\nFor case 1, I consistently get ConcurrentModificationException on every execution. However, after many executions of this experiment, I have not seen any occurrence of this problem for case 2. I accept that this may not be a usual pattern, but is the most efficient approach I could come up so far and it seems to be thread safe.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r428524158", "createdAt": "2020-05-21T08:43:26Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +230,20 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments.set(new HashMap<>(ownedSegments.get()));\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.get().put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxNzg4Nw=="}, "originalCommit": null, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNTY3OA==", "bodyText": "With the current implementation of ArrayList i do not see the possibility of an errror, given that we guarantee only one thread is performing the add. The resize impl of the ArrayList would not cause an error here too. It is just that the pattern is unconventional and I have always avoided it.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429205678", "createdAt": "2020-05-22T12:00:39Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +230,20 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments.set(new HashMap<>(ownedSegments.get()));\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.get().put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxNzg4Nw=="}, "originalCommit": null, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDY4NjAxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTo0NjowMFrOGZkcWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwODo0MTo0NlrOGaUYgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDY2NA==", "bodyText": "These names are just uuids for the most part, this sort of sorting is meaningless. The time order is the order they are in the checkpoints list. If the list for each host can be maintained in this order (Should be easy as it is the natural order in which they are added) then there is no need to sort, and we can just get the first element every time.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429464664", "createdAt": "2020-05-22T21:46:00Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());\n                 checkpointsForHost.add(checkpointId);\n             }\n         }\n+        // Sort checkpoints per reader so we have fast access based on time ordering.\n+        for (List<String> checkpointsForHost: checkpointIndex.values()) {\n+            checkpointsForHost.sort(String::compareTo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MDExMg==", "bodyText": "Done.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430250112", "createdAt": "2020-05-26T08:41:46Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());\n                 checkpointsForHost.add(checkpointId);\n             }\n         }\n+        // Sort checkpoints per reader so we have fast access based on time ordering.\n+        for (List<String> checkpointsForHost: checkpointIndex.values()) {\n+            checkpointsForHost.sort(String::compareTo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDY2NA=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDczMDQwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowMDowNFrOGZk4nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDozNzo0NFrOGavebQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw==", "bodyText": "Given the constants you selected this is going to add ~30MB of memory overhead per reader in a user's application. I don't consider this tradeoff worthwhile. See above for how we can avoid this.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429471903", "createdAt": "2020-05-22T22:00:04Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -22,23 +22,28 @@\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n import lombok.Builder;\n-import lombok.EqualsAndHashCode;\n import lombok.SneakyThrows;\n \n import static io.pravega.common.io.serialization.RevisionDataOutput.COMPACT_LONG_MAX;\n \n-@EqualsAndHashCode(callSuper = false)\n public class PositionImpl extends PositionInternal {\n \n     private static final PositionSerializer SERIALIZER = new PositionSerializer();\n-    private final Map<Segment, Long> ownedSegments;\n+    private Map<Segment, Long> ownedSegments;\n     private final Map<Segment, Range> segmentRanges;\n \n+    // If this field is set, it means that we will need to apply the updates on the ownedSegments.\n+    private transient List<Entry<Segment, Long>> updatesToSegmentOffsets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MDAzOQ==", "bodyText": "You are right in the case that the copy of the list is necessary, but I think that the current approach of referencing it may be feasible and is the one that provides the actual read throughput speedup.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430250039", "createdAt": "2020-05-26T08:41:39Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -22,23 +22,28 @@\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n import lombok.Builder;\n-import lombok.EqualsAndHashCode;\n import lombok.SneakyThrows;\n \n import static io.pravega.common.io.serialization.RevisionDataOutput.COMPACT_LONG_MAX;\n \n-@EqualsAndHashCode(callSuper = false)\n public class PositionImpl extends PositionInternal {\n \n     private static final PositionSerializer SERIALIZER = new PositionSerializer();\n-    private final Map<Segment, Long> ownedSegments;\n+    private Map<Segment, Long> ownedSegments;\n     private final Map<Segment, Range> segmentRanges;\n \n+    // If this field is set, it means that we will need to apply the updates on the ownedSegments.\n+    private transient List<Entry<Segment, Long>> updatesToSegmentOffsets;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5Mzk5Nw==", "bodyText": "No. That map will be ~30mb and there is one per EventStreamReader.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430693997", "createdAt": "2020-05-26T20:37:44Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -22,23 +22,28 @@\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n import lombok.Builder;\n-import lombok.EqualsAndHashCode;\n import lombok.SneakyThrows;\n \n import static io.pravega.common.io.serialization.RevisionDataOutput.COMPACT_LONG_MAX;\n \n-@EqualsAndHashCode(callSuper = false)\n public class PositionImpl extends PositionInternal {\n \n     private static final PositionSerializer SERIALIZER = new PositionSerializer();\n-    private final Map<Segment, Long> ownedSegments;\n+    private Map<Segment, Long> ownedSegments;\n     private final Map<Segment, Range> segmentRanges;\n \n+    // If this field is set, it means that we will need to apply the updates on the ownedSegments.\n+    private transient List<Entry<Segment, Long>> updatesToSegmentOffsets;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDczODU1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowMjoxN1rOGZk-TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDowMDo1OFrOGcEs8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng==", "bodyText": "This computation is wrong. The updatesToSegmentOffsets list is passed in without copying it. This means that if a caller holds onto one position object, and then calls readNext the first position object will be updated and have the wrong value. Please add a test for this.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429473356", "createdAt": "2020-05-22T22:02:17Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {\n+        this.ownedSegments = Collections.unmodifiableMap(ownedSegments);\n+        this.updatesToSegmentOffsets = Collections.unmodifiableList((updatesToSegmentOffsets == null) ? Collections.emptyList() : updatesToSegmentOffsets);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI0OTUzMQ==", "bodyText": "I have added an integration test to verify that the concurrent access and appends to updatesToSegmentOffsets. It shows that the optimization is safe and the offsets are correctly calculated.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430249531", "createdAt": "2020-05-26T08:40:47Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {\n+        this.ownedSegments = Collections.unmodifiableMap(ownedSegments);\n+        this.updatesToSegmentOffsets = Collections.unmodifiableList((updatesToSegmentOffsets == null) ? Collections.emptyList() : updatesToSegmentOffsets);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5NjYzMQ==", "bodyText": "Perhaps I am missing something, but I don't see any actual concurrency in the test.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430696631", "createdAt": "2020-05-26T20:43:30Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {\n+        this.ownedSegments = Collections.unmodifiableMap(ownedSegments);\n+        this.updatesToSegmentOffsets = Collections.unmodifiableList((updatesToSegmentOffsets == null) ? Collections.emptyList() : updatesToSegmentOffsets);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDM1Mg==", "bodyText": "Now the new test (integration/ReadTest.java) involves different threads for writing events, reading events and checking positions objects, so all this activity should happen concurrently. If there is any issue in PositionImpl when reading the segmentOffsetUpdates list is also being used by EventStreamReaderImpl, the test should fail.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090352", "createdAt": "2020-05-28T20:00:58Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {\n+        this.ownedSegments = Collections.unmodifiableMap(ownedSegments);\n+        this.updatesToSegmentOffsets = Collections.unmodifiableList((updatesToSegmentOffsets == null) ? Collections.emptyList() : updatesToSegmentOffsets);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDc0MDM1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowMzoyNVrOGZk_bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwODo0MTo1NVrOGaUY0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzY0Ng==", "bodyText": "How?! This is all static methods?", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429473646", "createdAt": "2020-05-22T22:03:25Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+@NotThreadSafe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MDE5NA==", "bodyText": "Removed.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430250194", "createdAt": "2020-05-26T08:41:55Z", "author": {"login": "RaulGracia"}, "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+@NotThreadSafe", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzY0Ng=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDc0NTU0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowNzowOVrOGZlCmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDowMDo1NFrOGcEssA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDQ1Nw==", "bodyText": "The semantics of which of these collections are copied or not should be spelled out in a javadoc. It would avoid the bug below.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429474457", "createdAt": "2020-05-22T22:07:09Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MTMyMw==", "bodyText": "Yes, I definitely can add javadoc explaining the main purpose of this builder and the way it is currently used. But I prefer to defer this task until we agree the final way to do this (whether passing updatesToSegmentOffsets is valid or not).", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430251323", "createdAt": "2020-05-26T08:43:45Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDQ1Nw=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDI4OA==", "bodyText": "I have added javadoc to clarify the goal of the builder method.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090288", "createdAt": "2020-05-28T20:00:54Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDQ1Nw=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDc0ODgxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowOTozN1rOGZlEiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDowMDo0OVrOGcEsdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDk1Mw==", "bodyText": "Because a copy is needed anyway (see comments below) this is actually going to make things slower. It would be better to simply in the getPosition() method iterate over the readers and construct the List<Entry<Segment, Long>> with only one entry per-segment. This is faster, avoids both of the need collections here, and the need to try to cache the position object.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429474953", "createdAt": "2020-05-22T22:09:37Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +62,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to do not generate Position objects on every event read, we define a base map of segments and\n+    // then a batch of updates to the offsets of these segments, one per event read. Internally, the Position object can\n+    // derive the right offsets at which the event was read by lazily replying such updates up to the point it was read.\n+    private static final long MAX_BUFFERED_SEGMENT_OFFSET_UPDATES = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDIyOA==", "bodyText": "I have added a performance comparison comparing your suggestion with this PR. For 1 segment, your approach is at par with this PR in terms of speed. But as more segments are handled by the reader, the performance decreases, given that the list to copy is larger.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090228", "createdAt": "2020-05-28T20:00:49Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +62,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to do not generate Position objects on every event read, we define a base map of segments and\n+    // then a batch of updates to the offsets of these segments, one per event read. Internally, the Position object can\n+    // derive the right offsets at which the event was read by lazily replying such updates up to the point it was read.\n+    private static final long MAX_BUFFERED_SEGMENT_OFFSET_UPDATES = 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDk1Mw=="}, "originalCommit": {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjYxNjI1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDoyMTo0NVrOGau8Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDowMDo0NlrOGcEsSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY4NTI0Ng==", "bodyText": "This lock is not guarding updatesToSegmentOffsets because it is shared by many objects.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430685246", "createdAt": "2020-05-26T20:21:45Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDE4NA==", "bodyText": "Correct, at this point we want to ensure that multiple threads invoking methods on a PositionImpl object execute this method under a lock, so building the internal state of the object is executed only once.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090184", "createdAt": "2020-05-28T20:00:46Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY4NTI0Ng=="}, "originalCommit": null, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjY2MDg2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDozNTowMFrOGavYow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDowMDo0NFrOGcEsIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MjUxNQ==", "bodyText": "@shrids 's intuition was correct. This call to updatesToSegmentOffsets.get(i) is not thread safe. The list may not be synchronized in any way between the thread calling readNextEvent and the thread calling this method. As such this could endup reading garbage data.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430692515", "createdAt": "2020-05-26T20:35:00Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null || this.updatesToSegmentOffsets.isEmpty()) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments = new HashMap<>(ownedSegments);\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDE0NA==", "bodyText": "You are right. In the case of using an ArrayList in that way, an internal resize can be triggered by one thread adding new elements, which might lead another thread to read garbage when executing this method in PositionImpl that reads that list. A solution to this is to use an \"structurally immutable\" list, wrapped by a List for convenience. This is currently achieved by using ArrayList.asList() for initializing updatesToSegmentOffsets. Any attempt to add or delete elements from the list will result in UnsupportedOperationException, while set and get methods are allowed (similar to an array).", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090144", "createdAt": "2020-05-28T20:00:44Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null || this.updatesToSegmentOffsets.isEmpty()) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments = new HashMap<>(ownedSegments);\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MjUxNQ=="}, "originalCommit": null, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDMxMzAyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMTozMzo1OFrOGda6Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo0MDo0MFrOGfJUmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjc0Mg==", "bodyText": "This optimization may burn us for users which serialize the position objects. (This is recommended behaviour and required for exactly once delivery). Please verify this solution actually improves performance in that case, and not just the no-op processing case. If it makes things significantly worse, then I don't think we should pursue it to improve performance for some users at the expense of others.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433502742", "createdAt": "2020-06-01T21:33:58Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +63,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to avoid creating a new ownedSegments map per event read, we define a base map of segments and", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxMTc3MA==", "bodyText": "As I have reported, we have performed a benchmark in which we have serialized each and every PositionImpl event. While this is not a realistic case, it was just for benchmarking purposes. In this case, the current state of the PR is 1.5x-2x better than master. While this is not the goal of this optimization, we just verified that this scenario is also improved.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435311770", "createdAt": "2020-06-04T14:40:40Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +63,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to avoid creating a new ownedSegments map per event read, we define a base map of segments and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjc0Mg=="}, "originalCommit": null, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDMxODI0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMTozNjowM1rOGda9eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNDozMToyNlrOGfw_Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzYxMA==", "bodyText": "This annotation does not actually hold anymore. There are paths to read from this not guarded by the 'readers' lock. If you want to keep this approach please make a threadsafe datastructure in common which follows this model. Then this class will simply have a final member and no annotation will be required.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433503610", "createdAt": "2020-06-01T21:36:03Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -74,12 +81,18 @@\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private Map<Segment, Range> ranges = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private final Map<Segment, Long> sealedSegments = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private Sequence lastRead;\n     @GuardedBy(\"readers\")\n+    private Map<Segment, Long> ownedSegments = new HashMap<>();\n+    @GuardedBy(\"readers\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxOTIwNg==", "bodyText": "One of the approaches taken by this PR is to use as input for building PositionImpl objects references to the collections they need to build their state instead of copies (specially map copies are a main performance bottleneck and a source of GC activity). While we do not make unsafe accesses or manipulations from PositionImpl objects to these shared collections, multiple PositionImpl object may point to ownedSegments, ranges and segmentOffsetUpdates. Shall I remove @GuardedBy(\"readers\") from these three collections?\n(Note that start adding locks here would impact on performance, so I prefer not to use additional synchronization. In my view, the current code has been reviewed and intensively benchmarked to be sure that is thread safe).", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435319206", "createdAt": "2020-06-04T14:50:24Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -74,12 +81,18 @@\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private Map<Segment, Range> ranges = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private final Map<Segment, Long> sealedSegments = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private Sequence lastRead;\n     @GuardedBy(\"readers\")\n+    private Map<Segment, Long> ownedSegments = new HashMap<>();\n+    @GuardedBy(\"readers\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzYxMA=="}, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk2MTYwNg==", "bodyText": "I have removed the annotation from the collections that are passed as references to the PositionImpl builder.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435961606", "createdAt": "2020-06-05T14:31:26Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -74,12 +81,18 @@\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private Map<Segment, Range> ranges = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private final Map<Segment, Long> sealedSegments = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private Sequence lastRead;\n     @GuardedBy(\"readers\")\n+    private Map<Segment, Long> ownedSegments = new HashMap<>();\n+    @GuardedBy(\"readers\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzYxMA=="}, "originalCommit": null, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDM3ODczOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMjowMDoxMFrOGdbjoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNDozMTo1NlrOGfxASA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzM3Ng==", "bodyText": "Rather than externalizing the logic, I would rather have it internalized to a single class. For example can we Make a CopyOnWriteHashMap which internally does the copies? Because this would allow callers to not need to understand the details of the implementation.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433513376", "createdAt": "2020-06-01T22:00:10Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+public final class CopyOnWriteMapUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3NDkyMQ==", "bodyText": "This was my first attempt, but then I changed my mind because I'm not fully convinced that it is the most clear way to do this. While I understand that having a CopyOnWriteHashMap makes the logic implicit, the problem is that it may lead to mistakes in this specific use case. That is, if we assume to have a CopyOnWriteHashMap for ranges, for instance, like:\nprivate Map<Segment, Range> ranges = new CopyOnWriteHashMap<>();\nThen someone could easily make the mistake of building the PositionImpl object in the way we are doing right now:\nPositionImpl.builder().ownedSegments(ownedSegments)\n                                     .segmentRanges(ranges)\n                                     .updatesToSegmentOffsets(segmentOffsetUpdates.subList(0, segmentOffsetUpdatesIndex))\n                                     .build();\n\nBut this is wrong, because we are using ranges in PositionImpl which would be a CopyOnWriteHashMap whose internal state would be changing on every put/remove. Therefore, we would need to build the PositionImpl object by using something like ranges.getInnerMap() that returns the actual HashMap inside CopyOnWriteHashMap (which is not in the contract of Map). This was my concern, but if you still want me to use a CopyOnWriteHashMap instead of the current utility class, then fine.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435374921", "createdAt": "2020-06-04T16:04:47Z", "author": {"login": "RaulGracia"}, "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+public final class CopyOnWriteMapUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzM3Ng=="}, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk2MTkyOA==", "bodyText": "Added CopyOnWriteHashMap according to your comment.", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435961928", "createdAt": "2020-06-05T14:31:56Z", "author": {"login": "RaulGracia"}, "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+public final class CopyOnWriteMapUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzM3Ng=="}, "originalCommit": null, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4312, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}