{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzOTkxNjM0", "number": 5406, "title": "Issue 5403: (SegmentStore) Reducing number of Storage reads from SegmentAttributeBTreeIndex", "bodyText": "Change log description\nPiggybacking onto existing Storage reads for the same BTree page.\nPurpose of the change\nFixes #5403.\nWhat the code does\n\nIn SegmentAttributeBTreeIndex, any BTreePage cache misses results in a direct read from Storage. If this is case, concurrent requests for the same key (or keys that require the same page(s)) would likely end up issuing identical, concurrent Storage read requests.\nThis change:\n\nRecords all (new) read requests and indexes them by offset (which is the BTreePage unique identifier).\nIf another request comes in for the same page (offset) while the first one is running, the second one will not issue a Storage read; instead it will return the completion from the first one (i.e., piggyback onto that one).\nIf the original request fails, so will any that have been piggybacked.\nWhen the original request completes (successfully or not), it is unregistered from the pending read collection so any subsequent read may go back to read from Storage (if not a cache hit).\n\n\n\nHow to verify it\nBuild must pass.", "createdAt": "2020-12-07T22:36:00Z", "url": "https://github.com/pravega/pravega/pull/5406", "merged": true, "mergeCommit": {"oid": "9a5eaa7cc82e72d17691407df43958c23f800ba1"}, "closed": true, "closedAt": "2020-12-08T15:21:56Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdjBQdWAH2gAyNTMzOTkxNjM0OmM4NzM5NWIyMDE2MjcyY2RiYTVkNjc1YjdkYWE5NTIyYzM2MTFhYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkCzW-gH2gAyNTMzOTkxNjM0OmYwMGYyMWI2ZGJlMDg3NTVjYjNlMWYyNzE1YTI0MjM2OGEyMDk3YTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c87395b2016272cdba5d675b7daa9522c3611ac2", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/c87395b2016272cdba5d675b7daa9522c3611ac2", "committedDate": "2020-12-05T00:32:28Z", "message": "Piggybacking.\n\nNeed to fix unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f19536a5e2341b0e8d8b69cba1a374c7a235afde", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/f19536a5e2341b0e8d8b69cba1a374c7a235afde", "committedDate": "2020-12-07T22:21:25Z", "message": "Merge remote-tracking branch 'origin/master' into issue-5401-piggybacks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/6f34f5abe8a5f7270e71864b03a648760a46df74", "committedDate": "2020-12-07T22:30:42Z", "message": "Reducing the number of Storage reads for SegmentAttributeBTreeIndex.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjMwMzUx", "url": "https://github.com/pravega/pravega/pull/5406#pullrequestreview-546630351", "createdAt": "2020-12-07T23:35:40Z", "commit": {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzozNTo0MVrOIA_18Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDowMjo0N1rOIBAjNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNjkxMw==", "bodyText": "Let's add a debug/warn log here so we can keep track of such cases.", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537916913", "createdAt": "2020-12-07T23:35:41Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -502,15 +515,63 @@ private long deserializeValue(ByteArraySegment value) {\n                         \"Attribute Index Segment has not been created yet. Cannot read %d byte(s) from offset (%d).\",\n                         length, offset)));\n             }\n-        } else {\n-            byte[] buffer = new byte[length];\n-            return this.storage.read(handle, offset, buffer, 0, length, timeout)\n-                               .thenApplyAsync(bytesRead -> {\n-                                   Preconditions.checkArgument(length == bytesRead, \"Unexpected number of bytes read.\");\n-                                   storeInCache(offset, buffer);\n-                                   return new ByteArraySegment(buffer);\n-                               }, this.executor);\n         }\n+\n+        return readPageFromStorage(handle, offset, length, timeout);\n+    }\n+\n+    /**\n+     * Reads a BTreeIndex page from Storage and inserts its into the cache (no cache lookups are performed).\n+     * Handles read concurrency on the same page by piggybacking on existing running reads on that page (identified by\n+     * page offset). If more than one concurrent request is issued for the same page, only one will be sent to Storage,\n+     * and subsequent ones will be attached to the original one.\n+     *\n+     * @param handle  {@link SegmentHandle} to read from.\n+     * @param offset  Page offset.\n+     * @param length  Page length.\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that will contain the result.\n+     */\n+    @VisibleForTesting\n+    CompletableFuture<ByteArraySegment> readPageFromStorage(SegmentHandle handle, long offset, int length, Duration timeout) {\n+        PendingRead pr;\n+        synchronized (this.pendingReads) {\n+            pr = this.pendingReads.get(offset);\n+            if (pr == null) {\n+                // Nobody else waiting for this offset. Register ourselves.\n+                pr = new PendingRead(offset, length);\n+                pr.completion.whenComplete((r, ex) -> {\n+                    // Cleanup.\n+                    synchronized (this.pendingReads) {\n+                        this.pendingReads.remove(offset);\n+                    }\n+                });\n+                this.pendingReads.put(offset, pr);\n+            } else if (pr.length < length) {\n+                // Somehow the previous request wanted to read less than us. This shouldn't be the case, yet it is\n+                // a situation we should handle. In his case, we will not be recording the PendingRead.\n+                pr = new PendingRead(offset, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyODUwMQ==", "bodyText": "What happens when page is evicted ?\nI think here when page is evicted from cache we need to remove that offset from pendingReads , otherwise next time we need to reload the page again we'll have a stale completed future from the last time and we won't really read anything - leaving cache with missing data.", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537928501", "createdAt": "2020-12-08T00:02:47Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -502,15 +515,63 @@ private long deserializeValue(ByteArraySegment value) {\n                         \"Attribute Index Segment has not been created yet. Cannot read %d byte(s) from offset (%d).\",\n                         length, offset)));\n             }\n-        } else {\n-            byte[] buffer = new byte[length];\n-            return this.storage.read(handle, offset, buffer, 0, length, timeout)\n-                               .thenApplyAsync(bytesRead -> {\n-                                   Preconditions.checkArgument(length == bytesRead, \"Unexpected number of bytes read.\");\n-                                   storeInCache(offset, buffer);\n-                                   return new ByteArraySegment(buffer);\n-                               }, this.executor);\n         }\n+\n+        return readPageFromStorage(handle, offset, length, timeout);\n+    }\n+\n+    /**\n+     * Reads a BTreeIndex page from Storage and inserts its into the cache (no cache lookups are performed).\n+     * Handles read concurrency on the same page by piggybacking on existing running reads on that page (identified by\n+     * page offset). If more than one concurrent request is issued for the same page, only one will be sent to Storage,\n+     * and subsequent ones will be attached to the original one.\n+     *\n+     * @param handle  {@link SegmentHandle} to read from.\n+     * @param offset  Page offset.\n+     * @param length  Page length.\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that will contain the result.\n+     */\n+    @VisibleForTesting\n+    CompletableFuture<ByteArraySegment> readPageFromStorage(SegmentHandle handle, long offset, int length, Duration timeout) {\n+        PendingRead pr;\n+        synchronized (this.pendingReads) {\n+            pr = this.pendingReads.get(offset);\n+            if (pr == null) {\n+                // Nobody else waiting for this offset. Register ourselves.\n+                pr = new PendingRead(offset, length);\n+                pr.completion.whenComplete((r, ex) -> {\n+                    // Cleanup.\n+                    synchronized (this.pendingReads) {\n+                        this.pendingReads.remove(offset);\n+                    }\n+                });\n+                this.pendingReads.put(offset, pr);\n+            } else if (pr.length < length) {\n+                // Somehow the previous request wanted to read less than us. This shouldn't be the case, yet it is\n+                // a situation we should handle. In his case, we will not be recording the PendingRead.\n+                pr = new PendingRead(offset, length);\n+            } else {\n+                // Piggyback on the existing read.\n+                return pr.completion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d53925c8e8bf63870147115e2c23b038c2dcf69", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/1d53925c8e8bf63870147115e2c23b038c2dcf69", "committedDate": "2020-12-08T02:36:16Z", "message": "Log messages.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzA4ODYz", "url": "https://github.com/pravega/pravega/pull/5406#pullrequestreview-546708863", "createdAt": "2020-12-08T03:00:06Z", "commit": {"oid": "1d53925c8e8bf63870147115e2c23b038c2dcf69"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f00f21b6dbe08755cb3e1f2715a242368a2097a3", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/f00f21b6dbe08755cb3e1f2715a242368a2097a3", "committedDate": "2020-12-08T04:54:25Z", "message": "Merge branch 'master' into issue-5401-piggybacks"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3784, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}