{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDQ0Nzc2", "number": 4567, "title": "Issue 4565: (SegmentStore) Improving Data Frames memory allocation", "bodyText": "Change log description\nChanged the underlying buffer for DataFrame from a ByteArraySegment backed by a single byte array to a memory efficient composite array that only allocates memory when needed.\nPurpose of the change\nFixes #4565.\nBackground\nWe format the BK/Tier1 writes using a class called DataFrame. When creating instances of this class we have no way of knowing how much data we'd end up writing (since we don't know how much of the existing queued data is valid and how much it will serialize to, and since we don't know if any other operations will arrive as we are constructing it). As such, we had two options for this class. We could either allocate a full 1MB buffer every time we create it (and fill as much as we need), or begin with a small buffer and then resize it as needed. The second approach ends up doing a lot of allocations and memory copies and the first one is less CPU intensive, but at the cost of over-allocating memory.\nIt turns out that in some cases we could be over-allocating memory by a lot. For example, a recent perf test indicated that even though we had about 420MB of data \"in-flight\" to BK, we were actually holding up about 2GB of heap, with the difference going to overallocation.\nWhat the code does\nCreated a CompositeByteArraySegment (and parent interface CompositeByteArrayView)\n\nThese extend from BufferView so they're interchangeable with other uses of existing ByteArraySegment classes.\nThis class creates a \"virtual\" index-based data structure mimicking an array, but it doesn't allocate all the bytes at once.\nIt breaks down the \"virtual array\" into smaller blocks (configurable). Each such block represents a contiguous range within the larger array and is only allocated when the first byte within that range is set.\n\nIf not allocated, upon reading all bytes within a block range will be read as 0 (same as a freshly initialized array).\n\n\nThe goal of this class is to reduce the amount of memory used by DataFrames by allocating memory in small increments as we populate it.\n\nIntegration with the rest of the code:\n\nChanged DataFrame to wrap a CompositeByteArraySegment instead of ByteArraySegment.\nChanged DurableDataLog interface to use CompositeArrayView instead of ArrayView for writes.\nChanged BookKeeperLog & bookkeeper.Write to convert a CompositeArrayView into a Netty CompositeByteBuf which is eventually passed on to BK's asyncAddEntry.\n\nThis is needed since the CompositeArrayView organizes data as individual arrays and there is no point in allocating a new byte array and copy them there just for this purpose.\n\n\n\nHow to verify it\nAll tests must pass.", "createdAt": "2020-02-21T00:26:22Z", "url": "https://github.com/pravega/pravega/pull/4567", "merged": true, "mergeCommit": {"oid": "aee4d6c45c485493ab5c8a3932a57ad452b95015"}, "closed": true, "closedAt": "2020-02-28T13:53:57Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGUSORAH2gAyMzc4MDQ0Nzc2OjFhNThhNDhhOTRkYjM4NTA5YWFlZTkyMjBlNjgwNzZjNDQ3MzQxMTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIrpCUgH2gAyMzc4MDQ0Nzc2OmI0MDFiOWVmZGE0NTgxM2JkNGI0MjdlNDVmMjkzOTEzYzhmYmJhMzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1a58a48a94db38509aaee9220e68076c44734113", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/1a58a48a94db38509aaee9220e68076c44734113", "committedDate": "2020-02-21T00:07:38Z", "message": "CompositeArrayView, CompositeByteArraySegment.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77a07529a4194ab9f17be27c6d94bd650ac414eb", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/77a07529a4194ab9f17be27c6d94bd650ac414eb", "committedDate": "2020-02-22T16:22:13Z", "message": "Javadoc for CompositeArrayView.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDUwNDY4", "url": "https://github.com/pravega/pravega/pull/4567#pullrequestreview-363050468", "createdAt": "2020-02-22T20:55:44Z", "commit": {"oid": "77a07529a4194ab9f17be27c6d94bd650ac414eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDo1NTo0NFrOFtM22A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDo1NTo0NFrOFtM22A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MDg4OA==", "bodyText": "Why aren't we using Netty ByteBufs ? There is already lot of support for composition and they support direct memory?", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r382940888", "createdAt": "2020-02-22T20:55:44Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.common.Exceptions;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * A composite, index-based array-like structure that is made up of one or more individual arrays of equal size. Each\n+ * component array maps to a contiguous offset range and is only allocated when the first index within its range needs\n+ * to be set (if unallocated, any index within its range will have a value of 0).\n+ */\n+public class CompositeByteArraySegment implements CompositeArrayView {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77a07529a4194ab9f17be27c6d94bd650ac414eb"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/22664531816c7a5805f3fd1ded5040c6f4cdf429", "committedDate": "2020-02-23T18:39:48Z", "message": "Unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjAxMjA1", "url": "https://github.com/pravega/pravega/pull/4567#pullrequestreview-363601205", "createdAt": "2020-02-24T18:23:18Z", "commit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzQ4Nzgy", "url": "https://github.com/pravega/pravega/pull/4567#pullrequestreview-365348782", "createdAt": "2020-02-27T00:51:53Z", "commit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo1MTo1M1rOFvBuYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo1NzowOVrOFvB0Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTY0OQ==", "bodyText": "byte[] result = new byte[this.length];\ncopyTo(ByteBuffer.wrap(result));\nreturn result;", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384855649", "createdAt": "2020-02-27T00:51:53Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.common.Exceptions;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * A composite, index-based array-like structure that is made up of one or more individual arrays of equal size. Each\n+ * component array maps to a contiguous offset range and is only allocated when the first index within its range needs\n+ * to be set (if unallocated, any index within its range will have a value of 0).\n+ */\n+public class CompositeByteArraySegment implements CompositeArrayView {\n+    //region Members\n+    /**\n+     * Default component array size. 4KB maps to the kernel's page size.\n+     */\n+    private static final int DEFAULT_ARRAY_SIZE = 4 * 1024;\n+    /**\n+     * The offset at which the {@link CompositeByteArraySegment} begins, counted from the first block. This is helpful\n+     * for slicing a {@link CompositeByteArraySegment}. See {@link #slice}.\n+     */\n+    private final int startOffset;\n+    /**\n+     * Size of each component array.\n+     */\n+    private final int arraySize;\n+    private final Object[] arrays;\n+    @Getter\n+    private final int length;\n+    //endregion\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with a default component array size.\n+     *\n+     * @param length The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *               to use, but doesn't allocate any of them yet.\n+     */\n+    public CompositeByteArraySegment(int length) {\n+        this(length, DEFAULT_ARRAY_SIZE);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with the given component array size.\n+     *\n+     * @param length    The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *                  to use, but doesn't allocate any of them yet.\n+     * @param arraySize The component array size.\n+     */\n+    public CompositeByteArraySegment(int length, int arraySize) {\n+        Preconditions.checkArgument(length >= 0, \"length must be a non-negative number.\");\n+        Preconditions.checkArgument(arraySize > 0, \"arraySize must be a positive number.\");\n+\n+        this.length = length;\n+        this.arraySize = Math.min(length, arraySize); // No point in allocating more memory if total length is smaller than arraySize.\n+        this.startOffset = 0;\n+        int count = length / arraySize + (length % arraySize == 0 ? 0 : 1);\n+        this.arrays = new Object[count];\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class that wraps the given array. This instance\n+     * will have a single component array.\n+     *\n+     * @param source The byte array to wrap. Any changes made to this array will be reflected in this\n+     *               {@link CompositeByteArraySegment} instance and vice-versa.\n+     */\n+    @VisibleForTesting\n+    public CompositeByteArraySegment(@NonNull byte[] source) {\n+        this(new Object[]{source}, source.length, 0, source.length);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} that uses the given arguments. Useful for slicing.\n+     *\n+     * @param arrays      The array components to use.\n+     * @param arraySize   Size of each individual component.\n+     * @param startOffset Start offset.\n+     * @param length      Length of {@link CompositeByteArraySegment}.\n+     */\n+    private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffset, int length) {\n+        this.arrays = arrays;\n+        this.arraySize = arraySize;\n+        this.startOffset = startOffset;\n+        this.length = length;\n+    }\n+\n+    //region CompositeArrayView Implementation\n+\n+    @Override\n+    public byte get(int offset) {\n+        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n+        return array == null ? 0 : array[getArrayOffset(offset)];\n+    }\n+\n+    @Override\n+    public void set(int offset, byte value) {\n+        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n+        array[getArrayOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public InputStream getReader() {\n+        // Use the collector to create a list of ByteArrayInputStreams and then return them as combined.\n+        ArrayList<ByteArrayInputStream> streams = new ArrayList<>();\n+        collect((array, offset, length) -> streams.add(new ByteArrayInputStream(array, offset, length)));\n+        return new SequenceInputStream(Iterators.asEnumeration(streams.iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public CompositeArrayView slice(int offset, int length) {\n+        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n+        if (offset == 0 && length == this.length) {\n+            // Nothing to slice.\n+            return this;\n+        }\n+\n+        return new CompositeByteArraySegment(this.arrays, this.arraySize, this.startOffset + offset, length);\n+    }\n+\n+    @Override\n+    public <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray) throws ExceptionT {\n+        collect(collectArray, this.length);\n+    }\n+\n+    private <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray, int length) throws ExceptionT {\n+        if (length == 0) {\n+            // Nothing to collect.\n+            return;\n+        }\n+\n+        // We only need to process a subset of our arrays (since we may be sliced from the original array list).\n+        int startId = getArrayId(0);\n+        int endId = getArrayId(length - 1);\n+\n+        int arrayOffset = getArrayOffset(0); // The first array may need an offset, if this.startOffset > 0.\n+        for (int arrayId = startId; arrayId <= endId; arrayId++) {\n+            int arrayLength = Math.min(length, this.arraySize - arrayOffset);\n+            byte[] array = getArray(arrayId, false); // Don't allocate array if not allocated yet.\n+            if (array == null) {\n+                // Providing a dummy, empty array of the correct size is the easiest way to handle unallocated components\n+                // for all the cases this method is used for.\n+                collectArray.accept(new byte[arrayLength], 0, arrayLength);\n+            } else {\n+                collectArray.accept(array, arrayOffset, arrayLength);\n+            }\n+\n+            length -= arrayLength;\n+            arrayOffset = 0; // After processing the first array (handling this.startOffset), all other array offsets are 0.\n+        }\n+\n+        assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzE3NA==", "bodyText": "Is this the best place for this method?", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384857174", "createdAt": "2020-02-27T00:57:09Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/Write.java", "diffHunk": "@@ -60,12 +68,19 @@\n         this.beginAttemptTimer = new AtomicReference<>();\n     }\n \n+    private ByteBuf convertData(CompositeArrayView data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dea2fc49e7fc15737d80e4b34995cdb7f724c1f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/7dea2fc49e7fc15737d80e4b34995cdb7f724c1f", "committedDate": "2020-02-27T01:40:31Z", "message": "Merge branch 'master' into issue-4565-data-frame"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ebd3fb51133da338f99086ba017995bfe33c9e7", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/7ebd3fb51133da338f99086ba017995bfe33c9e7", "committedDate": "2020-02-27T01:44:53Z", "message": "Simplified getCopy().\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90dfa65e9b365ad9bba148d08599d34ed1430856", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/90dfa65e9b365ad9bba148d08599d34ed1430856", "committedDate": "2020-02-27T01:45:25Z", "message": "Merge remote-tracking branch 'ap/issue-4565-data-frame' into issue-4565-data-frame"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzkxNTE2", "url": "https://github.com/pravega/pravega/pull/4567#pullrequestreview-365391516", "createdAt": "2020-02-27T03:18:00Z", "commit": {"oid": "90dfa65e9b365ad9bba148d08599d34ed1430856"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a86956692007a42e4739f3638acf02ec93bee97", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/8a86956692007a42e4739f3638acf02ec93bee97", "committedDate": "2020-02-27T22:04:34Z", "message": "Merge branch 'master' into issue-4565-data-frame"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b401b9efda45813bd4b427e45f293913c8fbba31", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/b401b9efda45813bd4b427e45f293913c8fbba31", "committedDate": "2020-02-28T08:28:13Z", "message": "Merge branch 'master' into issue-4565-data-frame"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3595, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}