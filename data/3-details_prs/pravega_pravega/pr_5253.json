{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMTk5MzQ4", "number": 5253, "title": "Issue 5169: Data Recovery - Copy the core attributes from old segment metadata to new segment metadata", "bodyText": "Change log description\nInstead of directly deleting the container metadata and its attribute segments, we now keep a back up copy of them and then delete them. This back up copy is used to update the attributes of the recovered segments.\nPurpose of the change\nFixes #5169\nWhat the code does\nThe code has got methods:\nbackUpMetadataAndAttributeSegments to make copies of metadata and its attribute segment. This is performed for all containers.\nand updateCoreAttributes, in which we iterate through the segments in the back up copy of the metadata segment and update the attributes of it in the newly created container metadata segment.\nHow to verify it\nBuild shall pass.", "createdAt": "2020-10-14T08:21:10Z", "url": "https://github.com/pravega/pravega/pull/5253", "merged": true, "mergeCommit": {"oid": "75c9f3ec7e10709878a94f306ad27dd6c81b6bf2"}, "closed": true, "closedAt": "2020-10-30T21:18:21Z", "author": {"login": "ManishKumarKeshri"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSYpX1gH2gAyNTAzMTk5MzQ4OmQyYzE5YmQxZGRiNjNlOWQ5MDUzMTQ1NzJlNTFlY2I0YmJiZTc3YjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXZlE2gFqTUyMDEyMjQ1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d2c19bd1ddb63e9d905314572e51ecb4bbbe77b4", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/d2c19bd1ddb63e9d905314572e51ecb4bbbe77b4", "committedDate": "2020-10-14T08:10:47Z", "message": "Updating with updating core attributes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cb6df4a5c6cd216f3688f5ce5f1c681cd31d600", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/7cb6df4a5c6cd216f3688f5ce5f1c681cd31d600", "committedDate": "2020-10-14T18:55:29Z", "message": "Adding update core attributes to testSegmentRestoration.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da612b4f62c2306a9a1b203033659b96e5be5756", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/da612b4f62c2306a9a1b203033659b96e5be5756", "committedDate": "2020-10-14T19:02:04Z", "message": "Minor changes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a8378406fc84c792cf136ad73f5b6d6c797e8bf", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/5a8378406fc84c792cf136ad73f5b6d6c797e8bf", "committedDate": "2020-10-14T21:45:05Z", "message": "Checkstyle.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f1c564bb6ff9602a8f83445268e4e6171c62f1a", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/9f1c564bb6ff9602a8f83445268e4e6171c62f1a", "committedDate": "2020-10-14T22:46:36Z", "message": "Adding a test.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ca25133d888004621da0959d3d7d3350ac7bab0", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/1ca25133d888004621da0959d3d7d3350ac7bab0", "committedDate": "2020-10-14T22:48:50Z", "message": "Merge branch 'issue-5169-Data-Recovery-Copy-the-core-attributes' of https://github.com/ManishKumarKeshri/pravega into issue-5169-Data-Recovery-Copy-the-core-attributes\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b482c67feb3106e1e80c19cea1cf66b9caebae1d", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/b482c67feb3106e1e80c19cea1cf66b9caebae1d", "committedDate": "2020-10-14T23:08:16Z", "message": "Removing some changes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/3195edce20715210274aa328b00ddd354f9b8820", "committedDate": "2020-10-14T23:31:24Z", "message": "Updating comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzODAyMzIw", "url": "https://github.com/pravega/pravega/pull/5253#pullrequestreview-513802320", "createdAt": "2020-10-21T15:14:54Z", "commit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNToxNDo1NFrOHlxzKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNToyODowOFrOHlyceA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NTI3Mg==", "bodyText": "\"the new names of the segments\"", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509375272", "createdAt": "2020-10-21T15:14:54Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NTQ3NA==", "bodyText": "\"Name of the ...\"\nbelow too", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509375474", "createdAt": "2020-10-21T15:15:09Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NTc5Mg==", "bodyText": "\"will indicate the operation has completed\"\n(the future itself won't have anything in it)", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509375792", "createdAt": "2020-10-21T15:15:31Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3ODIxNQ==", "bodyText": "Rephrase as:\nUpdates Core Attributes for all Segments for the given Containers.\nThis method iterates through all the Container Metadata Segments for the given Containers, interprets all entries as Segment-SegmentInfo mappings and extracts the Core Attributes for each. These Core Attributes are then applied to the same segments in the new Containers.", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509378215", "createdAt": "2020-10-21T15:18:29Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Given the back up of metadata segments, this method iterates through all segments in it and gets their attributes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3OTAwMg==", "bodyText": "Why not @throws TimeoutException and @throws IOException? That is the standard Javadoc we should use.\nThe format you used was our convention for async methods that return CompletableFuture.", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509379002", "createdAt": "2020-10-21T15:19:29Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Given the back up of metadata segments, this method iterates through all segments in it and gets their attributes\n+     * and updates it in the container metadata segment of the given {@link DebugStreamSegmentContainer} instance.\n+     * @param metadataSegments  A map of back of metadata segments along with their container Ids.\n+     * @param containersMap     A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService   A thread pool for execution.\n+     * @throws Exception        If an exception occurred. This could be one of the following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MTYyNw==", "bodyText": "You assume that your input is correct. Can you please do the following validations:\n\nmetadataSegments.size == containersMap.size\nAll container ids are accounted for", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509381627", "createdAt": "2020-10-21T15:22:50Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Given the back up of metadata segments, this method iterates through all segments in it and gets their attributes\n+     * and updates it in the container metadata segment of the given {@link DebugStreamSegmentContainer} instance.\n+     * @param metadataSegments  A map of back of metadata segments along with their container Ids.\n+     * @param containersMap     A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService   A thread pool for execution.\n+     * @throws Exception        If an exception occurred. This could be one of the following:\n+     *                              * TimeoutException:     If the calls for computation(used in the method)\n+     *                                                      didn't complete in time.\n+     *                              * IOException     :     If a general IO exception occurred.\n+     */\n+    public static void updateCoreAttributes(Map<Integer, String> metadataSegments,\n+                                            Map<Integer, DebugStreamSegmentContainer> containersMap,\n+                                            ExecutorService executorService) throws Exception {\n+        val args = IteratorArgs.builder().fetchTimeout(TIMEOUT).build();\n+        SegmentToContainerMapper segToConMapper = new SegmentToContainerMapper(containersMap.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MjE4OA==", "bodyText": "\"Container id: {}, Segment Name: {}\" (capitalization)", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509382188", "createdAt": "2020-10-21T15:23:34Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Given the back up of metadata segments, this method iterates through all segments in it and gets their attributes\n+     * and updates it in the container metadata segment of the given {@link DebugStreamSegmentContainer} instance.\n+     * @param metadataSegments  A map of back of metadata segments along with their container Ids.\n+     * @param containersMap     A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService   A thread pool for execution.\n+     * @throws Exception        If an exception occurred. This could be one of the following:\n+     *                              * TimeoutException:     If the calls for computation(used in the method)\n+     *                                                      didn't complete in time.\n+     *                              * IOException     :     If a general IO exception occurred.\n+     */\n+    public static void updateCoreAttributes(Map<Integer, String> metadataSegments,\n+                                            Map<Integer, DebugStreamSegmentContainer> containersMap,\n+                                            ExecutorService executorService) throws Exception {\n+        val args = IteratorArgs.builder().fetchTimeout(TIMEOUT).build();\n+        SegmentToContainerMapper segToConMapper = new SegmentToContainerMapper(containersMap.size());\n+\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (val metadataEntry : metadataSegments.entrySet()) {\n+            val containerForSegmentsContained = containersMap.get(metadataEntry.getKey());\n+            val containerForBackUpMetadataSegment = containersMap.get(segToConMapper.getContainerId(metadataEntry.getValue()));\n+            log.info(\"container id: {}, segment Name: {}\", containerForBackUpMetadataSegment.getId(), metadataEntry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MzI3Mw==", "bodyText": "\"Segment Name: {}, Attribute Updates: {}`\n(put attribute updates second since it's going to be a long list)", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509383273", "createdAt": "2020-10-21T15:24:54Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Given the back up of metadata segments, this method iterates through all segments in it and gets their attributes\n+     * and updates it in the container metadata segment of the given {@link DebugStreamSegmentContainer} instance.\n+     * @param metadataSegments  A map of back of metadata segments along with their container Ids.\n+     * @param containersMap     A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService   A thread pool for execution.\n+     * @throws Exception        If an exception occurred. This could be one of the following:\n+     *                              * TimeoutException:     If the calls for computation(used in the method)\n+     *                                                      didn't complete in time.\n+     *                              * IOException     :     If a general IO exception occurred.\n+     */\n+    public static void updateCoreAttributes(Map<Integer, String> metadataSegments,\n+                                            Map<Integer, DebugStreamSegmentContainer> containersMap,\n+                                            ExecutorService executorService) throws Exception {\n+        val args = IteratorArgs.builder().fetchTimeout(TIMEOUT).build();\n+        SegmentToContainerMapper segToConMapper = new SegmentToContainerMapper(containersMap.size());\n+\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (val metadataEntry : metadataSegments.entrySet()) {\n+            val containerForSegmentsContained = containersMap.get(metadataEntry.getKey());\n+            val containerForBackUpMetadataSegment = containersMap.get(segToConMapper.getContainerId(metadataEntry.getValue()));\n+            log.info(\"container id: {}, segment Name: {}\", containerForBackUpMetadataSegment.getId(), metadataEntry.getValue());\n+            val tableExtension = containerForBackUpMetadataSegment.getExtension(ContainerTableExtension.class);\n+            val entryIterator = tableExtension.entryIterator(metadataEntry.getValue(), args)\n+                    .get(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+\n+            val metadataSegmentName = NameUtils.getMetadataSegmentName(containerForSegmentsContained.getId());\n+            // Store the segments in a set\n+            entryIterator.forEachRemaining(item -> {\n+                for (val entry : item.getEntries()) {\n+                    val segmentInfo = MetadataStore.SegmentInfo.deserialize(entry.getValue());\n+                    val properties = segmentInfo.getProperties();\n+\n+                    // skip, if this is a metadata segment\n+                    if (metadataSegmentName.equals(properties.getName())) {\n+                        continue;\n+                    }\n+\n+                    List<AttributeUpdate> attributeUpdates = properties.getAttributes().entrySet().stream()\n+                            .map(e -> new AttributeUpdate(e.getKey(), AttributeUpdateType.Replace, e.getValue()))\n+                            .collect(Collectors.toList());\n+                    log.info(\"Updating attributes = {} for segment '{}'\", attributeUpdates, properties.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NDE1OA==", "bodyText": "To make your life easier, I suggest you create the futures and wait for them for each container. That way if one of your containers fails to migrate, at least you know where you left off and what finished executing.", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509384158", "createdAt": "2020-10-21T15:26:00Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Given the back up of metadata segments, this method iterates through all segments in it and gets their attributes\n+     * and updates it in the container metadata segment of the given {@link DebugStreamSegmentContainer} instance.\n+     * @param metadataSegments  A map of back of metadata segments along with their container Ids.\n+     * @param containersMap     A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService   A thread pool for execution.\n+     * @throws Exception        If an exception occurred. This could be one of the following:\n+     *                              * TimeoutException:     If the calls for computation(used in the method)\n+     *                                                      didn't complete in time.\n+     *                              * IOException     :     If a general IO exception occurred.\n+     */\n+    public static void updateCoreAttributes(Map<Integer, String> metadataSegments,\n+                                            Map<Integer, DebugStreamSegmentContainer> containersMap,\n+                                            ExecutorService executorService) throws Exception {\n+        val args = IteratorArgs.builder().fetchTimeout(TIMEOUT).build();\n+        SegmentToContainerMapper segToConMapper = new SegmentToContainerMapper(containersMap.size());\n+\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NDY3MQ==", "bodyText": "Add more info. What container id?", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509384671", "createdAt": "2020-10-21T15:26:39Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -265,6 +342,7 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                     return Futures.loop(\n                             () -> bytesToRead.get() > 0,\n                             () -> {\n+                                log.info(\"Reading\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NTg0OA==", "bodyText": "Why do you need this? I don't see where you use this or why you need a RefCountByteArraySegment. That class is meant to track append leaks, which you do not need to do.\nAll you need to do in your tests is generate a basic ByteArraySegment, so you don't need these changes here.", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r509385848", "createdAt": "2020-10-21T15:28:08Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/StreamSegmentContainerTests.java", "diffHunk": "@@ -2158,7 +2158,7 @@ private void mergeTransactions(HashMap<String, ArrayList<String>> transactionsBy\n         Futures.allOf(mergeFutures).get(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n     }\n \n-    private RefCountByteArraySegment getAppendData(String segmentName, int appendId) {\n+    public static RefCountByteArraySegment getAppendData(String segmentName, int appendId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e3fefaba65e886d65e5b347831858996a0dd574", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/6e3fefaba65e886d65e5b347831858996a0dd574", "committedDate": "2020-10-23T20:31:04Z", "message": "Fixing comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "811dc682acbe9d18f7eeedc1ec7a7dd6563d39f5", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/811dc682acbe9d18f7eeedc1ec7a7dd6563d39f5", "committedDate": "2020-10-23T20:33:06Z", "message": "Removing method isMetadataSegment.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5329c997004cd7f0dcbca56fab426dc0e9c09a1e", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/5329c997004cd7f0dcbca56fab426dc0e9c09a1e", "committedDate": "2020-10-26T04:40:42Z", "message": "Minor javadoc changes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "5329c997004cd7f0dcbca56fab426dc0e9c09a1e", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/5329c997004cd7f0dcbca56fab426dc0e9c09a1e", "committedDate": "2020-10-26T04:40:42Z", "message": "Minor javadoc changes.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODc2OTYw", "url": "https://github.com/pravega/pravega/pull/5253#pullrequestreview-516876960", "createdAt": "2020-10-26T15:08:58Z", "commit": {"oid": "5329c997004cd7f0dcbca56fab426dc0e9c09a1e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowODo1OFrOHoUIsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNTo0OFrOHoUeDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNDk5NQ==", "bodyText": "No we cannot have that. We do not currently support changing the number of Segment Containers in a cluster (we may do this - #1644).", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r512034995", "createdAt": "2020-10-26T15:08:58Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +249,80 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names to the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name to the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name to the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           CompletableFuture which when completed will have the segments' contents copied to another segments.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Given the back up of metadata segments, this method iterates through all segments in it and gets their attributes\n+     * and updates it in the container metadata segment of the given {@link DebugStreamSegmentContainer} instance.\n+     * @param metadataSegments  A map of back of metadata segments along with their container Ids.\n+     * @param containersMap     A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService   A thread pool for execution.\n+     * @throws Exception        If an exception occurred. This could be one of the following:\n+     *                              * TimeoutException:     If the calls for computation(used in the method)\n+     *                                                      didn't complete in time.\n+     *                              * IOException     :     If a general IO exception occurred.\n+     */\n+    public static void updateCoreAttributes(Map<Integer, String> metadataSegments,\n+                                            Map<Integer, DebugStreamSegmentContainer> containersMap,\n+                                            ExecutorService executorService) throws Exception {\n+        val args = IteratorArgs.builder().fetchTimeout(TIMEOUT).build();\n+        SegmentToContainerMapper segToConMapper = new SegmentToContainerMapper(containersMap.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MTYyNw=="}, "originalCommit": {"oid": "3195edce20715210274aa328b00ddd354f9b8820"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNjg5NQ==", "bodyText": "What I meant is to add this outside of the entryIterator.forEachRemaining but still withinin the outer for loop.\nAnd when you wait on it, use .get(with timeout) so we don't end up waiting forever.\nIn that case we also need to make sure the Timeout is something reasonable. If we set it to 5s, then that may not be sufficient to restore all the segments in a container (there could be millions of them).", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r512036895", "createdAt": "2020-10-26T15:11:19Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +254,112 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names of the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name of the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name of the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           A CompletableFuture which when completed will indicate the operation has completed.\n+     *                                   If the operation failed, the future will be failed with the causing exception.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Updates Core Attributes for all Segments for the given Containers.\n+     * This method iterates through all the back copies of Container Metadata Segments, interprets all entries as\n+     * Segment-SegmentInfo mappings and extracts the Core Attributes for each. These Core Attributes are then applied\n+     * to the same segments in the given Containers.\n+     * @param backUpMetadataSegments    A map of back copies of metadata segments along with their container Ids.\n+     * @param containersMap             A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService           A thread pool for execution.\n+     * @throws InterruptedException     If the operation was interrupted while waiting.\n+     * @throws TimeoutException         If the timeout expired prior to being able to complete update attributes for all segments.\n+     * @throws ExecutionException       When execution of update attributes to all segments encountered an error.\n+     */\n+    public static void updateCoreAttributes(Map<Integer, String> backUpMetadataSegments,\n+                                            Map<Integer, DebugStreamSegmentContainer> containersMap,\n+                                            ExecutorService executorService) throws InterruptedException, ExecutionException,\n+            TimeoutException {\n+        // If there are no back up metadata segments, no updating will be done.\n+        if (backUpMetadataSegments.size() == 0) {\n+            return;\n+        }\n+\n+        // If there are metadata segments, then at least one container should be present.\n+        Preconditions.checkState(containersMap.size() > 0, \"There should be at least one container.\");\n+\n+        val args = IteratorArgs.builder().fetchTimeout(TIMEOUT).build();\n+        SegmentToContainerMapper segToConMapper = new SegmentToContainerMapper(containersMap.size());\n+\n+        // Iterate through all back up metadata segments\n+        for (val backUpMetadataSegmentEntry : backUpMetadataSegments.entrySet()) {\n+            // Get the name of original metadata segment\n+            val metadataSegment = NameUtils.getMetadataSegmentName(backUpMetadataSegmentEntry.getKey());\n+\n+            // Get the name of back up metadata segment\n+            val backUpMetadataSegment = backUpMetadataSegmentEntry.getValue();\n+\n+            // Get the new container assignment for back up metadata segment\n+            val containerForBackUpMetadataSegment = containersMap.get(segToConMapper.getContainerId(\n+                    backUpMetadataSegment));\n+            log.info(\"Back up container metadata segment name: {} and its container id: {}\", backUpMetadataSegment,\n+                    containerForBackUpMetadataSegment.getId());\n+\n+            // Get the iterator to iterate through all segments in the back up metadata segment\n+            val tableExtension = containerForBackUpMetadataSegment.getExtension(ContainerTableExtension.class);\n+            val entryIterator = tableExtension.entryIterator(backUpMetadataSegment, args)\n+                    .get(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+\n+            ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+\n+            // Iterating through all segments in the back up metadata segment\n+            entryIterator.forEachRemaining(item -> {\n+                for (val entry : item.getEntries()) {\n+\n+                    val segmentInfo = MetadataStore.SegmentInfo.deserialize(entry.getValue());\n+                    val properties = segmentInfo.getProperties();\n+\n+                    // skip, if this is original metadata segment\n+                    if (properties.getName().equals(metadataSegment)) {\n+                        continue;\n+                    }\n+\n+                    // Get the attributes for the current segment\n+                    List<AttributeUpdate> attributeUpdates = properties.getAttributes().entrySet().stream()\n+                            .map(e -> new AttributeUpdate(e.getKey(), AttributeUpdateType.Replace, e.getValue()))\n+                            .collect(Collectors.toList());\n+                    log.info(\"Segment Name: {} Attributes Updates: {}\", properties.getName(), attributeUpdates);\n+\n+                    // Get the container for the current segment\n+                    val container = containersMap.get(segToConMapper.getContainerId(\n+                            properties.getName()));\n+\n+                    // Update attributes for the current segment\n+                    futures.add(Futures.exceptionallyExpecting(\n+                            container.updateAttributes(properties.getName(), attributeUpdates, TIMEOUT),\n+                            ex -> ex instanceof StreamSegmentNotExistsException, null));\n+                }\n+\n+                // Waiting for update attributes for all segments in each back up metadata segment.\n+                Futures.allOf(futures).join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5329c997004cd7f0dcbca56fab426dc0e9c09a1e"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNzgxMg==", "bodyText": "Your Javadoc says \"creates a backup\" yet this method is named get. Consider renaming to createBackupMetadataSegments", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r512037812", "createdAt": "2020-10-26T15:12:34Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -278,4 +392,42 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n             }, executor);\n         }, executor);\n     }\n+\n+    /**\n+     * This method creates a back up segment of container metadata segment and its attribute segment for each\n+     * container Id. The original metadata segments and its attribute segments are deleted and the back up copy\n+     * of original metadata segments are stored in a map and returned.\n+     *\n+     * @param storage                   A {@link Storage} instance to get the segments from.\n+     * @param containerCount            The number of containers for which renaming of container metadata segment and its\n+     *                                  attributes segment has to be performed.\n+     * @param executorService           A thread pool for execution.\n+     * @return                          A Map of Container Ids to new container metadata segment names.\n+     * @throws InterruptedException     If the operation was interrupted while waiting.\n+     * @throws TimeoutException         If the timeout expired prior to being able to complete the operation.\n+     * @throws ExecutionException       When execution of the opreations encountered an error.\n+     */\n+    public static Map<Integer, String> getBackUpMetadataSegments(Storage storage, int containerCount, ExecutorService executorService)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5329c997004cd7f0dcbca56fab426dc0e9c09a1e"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MDQ2MQ==", "bodyText": "why do you pass null for timeout here?", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r512040461", "createdAt": "2020-10-26T15:15:48Z", "author": {"login": "andreipaduroiu"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/DebugStreamSegmentContainerTests.java", "diffHunk": "@@ -250,6 +258,149 @@ public void testEndToEnd() throws Exception {\n         }\n     }\n \n+    /**\n+     * The test create a dummy metadata segment and its attribute segment using a storage instance. The method under the\n+     * test creates copies of the segments. After that, it is verified if the new segments exist.\n+     */\n+    @Test\n+    public void testBackUpMetadataAndAttributeSegments() {\n+        // Create a storage.\n+        StorageFactory storageFactory = new InMemoryStorageFactory(executorService());\n+        @Cleanup\n+        Storage s = storageFactory.createStorageAdapter();\n+        s.initialize(1);\n+        log.info(\"Created a storage instance\");\n+\n+        String metadataSegment = NameUtils.getMetadataSegmentName(CONTAINER_ID);\n+        String attributeSegment = NameUtils.getAttributeSegmentName(metadataSegment);\n+        String backUpMetadataSegment = \"segment-\" + RANDOM.nextInt();\n+        String backUpAttributeSegment = \"segment-\" + RANDOM.nextInt();\n+\n+        s.create(metadataSegment, TIMEOUT).join();\n+        s.create(attributeSegment, TIMEOUT).join();\n+\n+        ContainerRecoveryUtils.backUpMetadataAndAttributeSegments(s, CONTAINER_ID, backUpMetadataSegment, backUpAttributeSegment,\n+                executorService()).join();\n+\n+        // back up metadata segment should exist\n+        Assert.assertTrue(\"Unexpected result for existing segment (no files).\", s.exists(backUpMetadataSegment, null).join());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5329c997004cd7f0dcbca56fab426dc0e9c09a1e"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5e3fd5dce3e36c51cc567f33978764e90af4996", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/a5e3fd5dce3e36c51cc567f33978764e90af4996", "committedDate": "2020-10-26T19:17:08Z", "message": "Fixing comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f02af9c7e0b1470595444650fa711adbc607608", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/2f02af9c7e0b1470595444650fa711adbc607608", "committedDate": "2020-10-26T19:22:38Z", "message": "Minor change.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTA5MTQ4", "url": "https://github.com/pravega/pravega/pull/5253#pullrequestreview-517109148", "createdAt": "2020-10-26T19:30:30Z", "commit": {"oid": "2f02af9c7e0b1470595444650fa711adbc607608"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "030bcd63424505f1b3063de2da0b0bd7d3ed714a", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/030bcd63424505f1b3063de2da0b0bd7d3ed714a", "committedDate": "2020-10-27T06:46:55Z", "message": "Fixing build fail. BackUp metadata segment get assigned to different container.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MzUwMzI5", "url": "https://github.com/pravega/pravega/pull/5253#pullrequestreview-519350329", "createdAt": "2020-10-29T05:54:19Z", "commit": {"oid": "030bcd63424505f1b3063de2da0b0bd7d3ed714a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNTo1NDoxOVrOHqL7BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNTo1OTozM1rOHqMFyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk5NzU3Mw==", "bodyText": "val ?", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r513997573", "createdAt": "2020-10-29T05:54:19Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -278,4 +388,44 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n             }, executor);\n         }, executor);\n     }\n+\n+    /**\n+     * This method creates a back up segment of container metadata segment and its attribute segment for each\n+     * container Id. The original metadata segments and its attribute segments are deleted and the back up copy\n+     * of original metadata segments are stored in a map and returned.\n+     *\n+     * @param storage                   A {@link Storage} instance to get the segments from.\n+     * @param containerCount            The number of containers for which renaming of container metadata segment and its\n+     *                                  attributes segment has to be performed.\n+     * @param executorService           A thread pool for execution.\n+     * @param timeout                   Timeout for the operation.\n+     * @return                          A Map of Container Ids to new container metadata segment names.\n+     * @throws InterruptedException     If the operation was interrupted while waiting.\n+     * @throws TimeoutException         If the timeout expired prior to being able to complete the operation.\n+     * @throws ExecutionException       When execution of the opreations encountered an error.\n+     */\n+    public static Map<Integer, String> createBackUpMetadataSegments(Storage storage, int containerCount, ExecutorService executorService,\n+                                                                 Duration timeout)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        String fileSuffix = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n+        Map<Integer, String> backUpMetadataSegments = new HashMap<>();\n+\n+        val futures = new ArrayList<CompletableFuture<Void>>();\n+\n+        for (int containerId = 0; containerId < containerCount; containerId++) {\n+            String backUpMetadataSegment = NameUtils.getMetadataSegmentName(containerId) + fileSuffix;\n+            String backUpAttributeSegment = NameUtils.getAttributeSegmentName(backUpMetadataSegment);\n+            log.debug(\"Created '{}' as a back of metadata segment of container Id '{}'\", backUpAttributeSegment, containerId);\n+\n+            int finalContainerId = containerId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "030bcd63424505f1b3063de2da0b0bd7d3ed714a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwMDMzMA==", "bodyText": "val ? It is accessed on line 348. in another thread.\nin general try to use final or volatile.", "url": "https://github.com/pravega/pravega/pull/5253#discussion_r514000330", "createdAt": "2020-10-29T05:59:33Z", "author": {"login": "sachin-j-joshi"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/ContainerRecoveryUtils.java", "diffHunk": "@@ -246,6 +254,108 @@ private static void validateContainerIds(Map<Integer, DebugStreamSegmentContaine\n                 ex -> ex instanceof StreamSegmentNotExistsException, null);\n     }\n \n+\n+    /**\n+     * Copies the contents of container metadata segment and its attribute segment to new segments. The new names of the segments\n+     * are passed as parameters.\n+     * @param storage                    A {@link Storage} instance where segments are stored.\n+     * @param containerId                A Container Id to get the name of the metadata segment.\n+     * @param backUpMetadataSegmentName  A name of the back up metadata segment.\n+     * @param backUpAttributeSegmentName A name of the back attribute segment.\n+     * @param executorService            A thread pool for execution.\n+     * @return                           A CompletableFuture which when completed will indicate the operation has completed.\n+     *                                   If the operation failed, the future will be failed with the causing exception.\n+     */\n+    public static CompletableFuture<Void> backUpMetadataAndAttributeSegments(Storage storage, int containerId,\n+                                                                             String backUpMetadataSegmentName,\n+                                                                             String backUpAttributeSegmentName,\n+                                                                             ExecutorService executorService) {\n+        Preconditions.checkNotNull(storage);\n+        String metadataSegmentName = NameUtils.getMetadataSegmentName(containerId);\n+        String attributeSegmentName = NameUtils.getAttributeSegmentName(metadataSegmentName);\n+        return copySegment(storage, metadataSegmentName, backUpMetadataSegmentName, executorService)\n+                        .thenAcceptAsync(x -> copySegment(storage, attributeSegmentName, backUpAttributeSegmentName,\n+                                executorService));\n+    }\n+\n+    /**\n+     * Updates Core Attributes for all Segments for the given Containers.\n+     * This method iterates through all the back copies of Container Metadata Segments, interprets all entries as\n+     * Segment-SegmentInfo mappings and extracts the Core Attributes for each. These Core Attributes are then applied\n+     * to the same segments in the given Containers.\n+     * @param backUpMetadataSegments    A map of back copies of metadata segments along with their container Ids.\n+     * @param containersMap             A map of {@link DebugStreamSegmentContainer} instances with their container Ids.\n+     * @param executorService           A thread pool for execution.\n+     * @param timeout                   Timeout for the operation.\n+     * @throws InterruptedException     If the operation was interrupted while waiting.\n+     * @throws TimeoutException         If the timeout expired prior to being able to complete update attributes for all segments.\n+     * @throws ExecutionException       When execution of update attributes to all segments encountered an error.\n+     */\n+    public static void updateCoreAttributes(Map<Integer, String> backUpMetadataSegments,\n+                                            Map<Integer, DebugStreamSegmentContainer> containersMap,\n+                                            ExecutorService executorService,\n+                                            Duration timeout) throws InterruptedException, ExecutionException,\n+            TimeoutException {\n+        Preconditions.checkState(backUpMetadataSegments.size() == containersMap.size(), \"The number of \" +\n+                \"back-up metadata segments and containers should match.\");\n+\n+        val args = IteratorArgs.builder().fetchTimeout(timeout).build();\n+        SegmentToContainerMapper segToConMapper = new SegmentToContainerMapper(containersMap.size());\n+\n+        // Iterate through all back up metadata segments\n+        for (val backUpMetadataSegmentEntry : backUpMetadataSegments.entrySet()) {\n+            // Get the name of original metadata segment\n+            val metadataSegment = NameUtils.getMetadataSegmentName(backUpMetadataSegmentEntry.getKey());\n+\n+            // Get the name of back up metadata segment\n+            val backUpMetadataSegment = backUpMetadataSegmentEntry.getValue();\n+\n+            // Get the container for back up metadata segment\n+            val containerForBackUpMetadataSegment = containersMap.get(segToConMapper.getContainerId(\n+                    backUpMetadataSegment));\n+            log.info(\"Back up container metadata segment name: {} and its container id: {}\", backUpMetadataSegment,\n+                    containerForBackUpMetadataSegment.getId());\n+\n+            // Get the container for segments inside back up metadata segment\n+            val container = containersMap.get(backUpMetadataSegmentEntry.getKey());\n+\n+            // Get the iterator to iterate through all segments in the back up metadata segment\n+            val tableExtension = containerForBackUpMetadataSegment.getExtension(ContainerTableExtension.class);\n+            val entryIterator = tableExtension.entryIterator(backUpMetadataSegment, args)\n+                    .get(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+\n+            ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "030bcd63424505f1b3063de2da0b0bd7d3ed714a"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d67d13329746bb1bcb5571b5afd4a33b5d840b97", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/d67d13329746bb1bcb5571b5afd4a33b5d840b97", "committedDate": "2020-10-29T18:30:39Z", "message": "Fixing comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "d67d13329746bb1bcb5571b5afd4a33b5d840b97", "author": {"user": null}, "url": "https://github.com/pravega/pravega/commit/d67d13329746bb1bcb5571b5afd4a33b5d840b97", "committedDate": "2020-10-29T18:30:39Z", "message": "Fixing comments.\n\nSigned-off-by: ManishKumarKeshri <manish.keshri562@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTIyNDUy", "url": "https://github.com/pravega/pravega/pull/5253#pullrequestreview-520122452", "createdAt": "2020-10-29T22:05:37Z", "commit": {"oid": "d67d13329746bb1bcb5571b5afd4a33b5d840b97"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3908, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}